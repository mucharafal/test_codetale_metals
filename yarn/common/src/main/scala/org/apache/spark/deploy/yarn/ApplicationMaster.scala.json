[{
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "nit - of should be or (failing or succeeding)\n",
    "commit": "21f2502947eb2a242168cc5a50225df5c36c9161",
    "createdAt": "2014-11-28T16:46:32Z",
    "diffHunk": "@@ -106,10 +106,14 @@ private[spark] class ApplicationMaster(args: ApplicationMasterArguments,\n           val isLastAttempt = client.getAttemptId().getAttemptId() >= maxAppAttempts\n \n           if (!finished) {\n-            // this shouldn't ever happen, but if it does assume weird failure\n-            finish(FinalApplicationStatus.FAILED,\n+            // This happens when the user application calls System.exit(). We have the choice\n+            // of either failing of succeeding at this point. We report success to avoid",
    "line": 16
  }],
  "prId": 3484
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "might be nice to update this comment \n",
    "commit": "21f2502947eb2a242168cc5a50225df5c36c9161",
    "createdAt": "2014-11-28T16:53:46Z",
    "diffHunk": "@@ -403,42 +407,6 @@ private[spark] class ApplicationMaster(args: ApplicationMasterArguments,\n   }\n \n   /**\n-   * This system security manager applies to the entire process.\n-   * It's main purpose is to handle the case if the user code does a System.exit.\n-   * This allows us to catch that and properly set the YARN application status and\n-   * cleanup if needed.\n-   */\n-  private def setupSystemSecurityManager(): Unit = {\n-    try {\n-      var stopped = false\n-      System.setSecurityManager(new java.lang.SecurityManager() {\n-        override def checkExit(paramInt: Int) {\n-          if (!stopped) {\n-            logInfo(\"In securityManager checkExit, exit code: \" + paramInt)\n-            if (paramInt == 0) {\n-              finish(FinalApplicationStatus.SUCCEEDED, ApplicationMaster.EXIT_SUCCESS)\n-            } else {\n-              finish(FinalApplicationStatus.FAILED,\n-                paramInt,\n-                \"User class exited with non-zero exit code\")\n-            }\n-            stopped = true\n-          }\n-        }\n-        // required for the checkExit to work properly\n-        override def checkPermission(perm: java.security.Permission): Unit = {}\n-      })\n-    }\n-    catch {\n-      case e: SecurityException =>\n-        finish(FinalApplicationStatus.FAILED,\n-          ApplicationMaster.EXIT_SECURITY,\n-          \"Error in setSecurityManager\")\n-        logError(\"Error in setSecurityManager:\", e)\n-    }\n-  }\n-\n-  /**\n    * Start the user class, which contains the spark driver, in a separate Thread.\n    * If the main routine exits cleanly or exits with System.exit(0) we\n    * assume it was successful, for all other cases we assume failure.",
    "line": 98
  }],
  "prId": 3484
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "since this is no longer an unexpected failure and could be success we should change the exit code. On success should be ApplicationMaster.EXIT_SUCCESS.\n",
    "commit": "21f2502947eb2a242168cc5a50225df5c36c9161",
    "createdAt": "2014-11-28T16:59:15Z",
    "diffHunk": "@@ -106,10 +106,14 @@ private[spark] class ApplicationMaster(args: ApplicationMasterArguments,\n           val isLastAttempt = client.getAttemptId().getAttemptId() >= maxAppAttempts\n \n           if (!finished) {\n-            // this shouldn't ever happen, but if it does assume weird failure\n-            finish(FinalApplicationStatus.FAILED,\n+            // This happens when the user application calls System.exit(). We have the choice\n+            // of either failing of succeeding at this point. We report success to avoid\n+            // retrying applications that have succeeded (System.exit(0)), which means that\n+            // applications that explicitly exit with a non-zero status will also show up as\n+            // succeeded in the RM UI.\n+            finish(finalStatus,\n               ApplicationMaster.EXIT_UNCAUGHT_EXCEPTION,",
    "line": 21
  }],
  "prId": 3484
}]