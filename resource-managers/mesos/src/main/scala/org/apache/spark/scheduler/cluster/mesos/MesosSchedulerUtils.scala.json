[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why is it necessary to read the principal from a file? It's not a really sensitive parameter, and can be provided with `--conf` with no issues.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-11T21:04:09Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")"
  }, {
    "author": {
      "login": "ArtRand"
    },
    "body": "I agree. I don't think it's necessary to put the principal in a file, just the secret. ",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-14T00:57:13Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")"
  }, {
    "author": {
      "login": "rvesse"
    },
    "body": "We have customers who operate secure multi-tenant environments who consider even leaking principals of users from other tenants to be a security issue i.e. they want to minimise what users from one tenant can learn about users from another",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-15T10:49:51Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why not provide the secret directly in the environment, instead of indirectly through a file?\r\n\r\nThat is more secure than files in certain situations, so it would be nice to at least have that option.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-11T21:05:19Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\"))\n+      .foreach { principalFile =>\n+        val file = io.Source.fromFile(principalFile)\n+        val principal = file.getLines.next()\n+        file.close\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+      }\n     conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n       fwInfoBuilder.setPrincipal(principal)\n       credBuilder.setPrincipal(principal)\n     }\n+    conf.getOption(\"spark.mesos.secret.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\"))"
  }, {
    "author": {
      "login": "ArtRand"
    },
    "body": "Environment-variable secrets (even using the `secrets` primitive up to Mesos 1.4) will be available at `/proc/<pid>/environ` so file-based secret passing is more secure. I'm tempted to say having an insecure _option_ is worse than having less flexibility. I believe that this will be changed in a future release of Mesos (the variable will be removed once \"used\"), but we can add the envvar option then. ",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-14T01:01:33Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\"))\n+      .foreach { principalFile =>\n+        val file = io.Source.fromFile(principalFile)\n+        val principal = file.getLines.next()\n+        file.close\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+      }\n     conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n       fwInfoBuilder.setPrincipal(principal)\n       credBuilder.setPrincipal(principal)\n     }\n+    conf.getOption(\"spark.mesos.secret.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\"))"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You can't read `/proc/<pid>/environ` from other users' processes.\r\n\r\n```\r\n$ cat /proc/1/environ\r\ncat: /proc/1/environ: Permission denied\r\n```",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-16T19:21:19Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\"))\n+      .foreach { principalFile =>\n+        val file = io.Source.fromFile(principalFile)\n+        val principal = file.getLines.next()\n+        file.close\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+      }\n     conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n       fwInfoBuilder.setPrincipal(principal)\n       credBuilder.setPrincipal(principal)\n     }\n+    conf.getOption(\"spark.mesos.secret.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\"))"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This should be merged with `getOption(\"spark.mesos.secret\")` below.\r\n\r\n```\r\nconf.getOption(\"spark.mesos.secret\")\r\n  .orElse(/* Read optional file-based config into string */)\r\n```\r\n  ",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-11T21:06:35Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\"))\n+      .foreach { principalFile =>\n+        val file = io.Source.fromFile(principalFile)\n+        val principal = file.getLines.next()\n+        file.close\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+      }\n     conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n       fwInfoBuilder.setPrincipal(principal)\n       credBuilder.setPrincipal(principal)\n     }\n+    conf.getOption(\"spark.mesos.secret.file\")"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "You should use `Files.toString()` (from Guava) here (simpler and also handles errors properly).\r\n\r\nThe whole block is also indented incorrectly.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-11T21:07:09Z",
    "diffHunk": "@@ -80,10 +80,27 @@ trait MesosSchedulerUtils extends Logging {\n     }\n     fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n       conf.get(DRIVER_HOST_ADDRESS)))\n+    conf.getOption(\"spark.mesos.principal.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\"))\n+      .foreach { principalFile =>\n+        val file = io.Source.fromFile(principalFile)\n+        val principal = file.getLines.next()\n+        file.close\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+      }\n     conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n       fwInfoBuilder.setPrincipal(principal)\n       credBuilder.setPrincipal(principal)\n     }\n+    conf.getOption(\"spark.mesos.secret.file\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\"))\n+      .foreach { secretFile =>\n+       val file = io.Source.fromFile(secretFile)"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: indent extra level",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-18T20:43:12Z",
    "diffHunk": "@@ -71,40 +74,62 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+            Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))\n+          }\n+      ).foreach { principal =>\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+    }"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: indendation is wrong",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-18T20:45:39Z",
    "diffHunk": "@@ -71,40 +74,62 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+            Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))\n+          }\n+      ).foreach { principal =>\n+        fwInfoBuilder.setPrincipal(principal)\n+        credBuilder.setPrincipal(principal)\n+    }\n+    conf.getOption(\"spark.mesos.secret\")\n+      .orElse(\n+        conf.getOption(\"spark.mesos.secret.file\")\n+         .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\")))\n+         .map { secretFile =>\n+           Files.toString(new File(secretFile), Charset.forName(\"UTF-8\"))\n+         }\n+      ).foreach { secret =>\n+      credBuilder.setSecret(secret)"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "ArtRand"
    },
    "body": "If you use this environment variable then won't these always be set when using the [Rest client](https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/deploy/rest/RestSubmissionClient.scala#L407)? Is this the desired behavior? ",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-22T17:03:24Z",
    "diffHunk": "@@ -71,40 +74,64 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))"
  }, {
    "author": {
      "login": "rvesse"
    },
    "body": "I am not sure I understand enough of spark internals to answer your question.\r\n\r\nThese variables are only necessary for Mesos and only on the driver which registers the framework with Mesos. Is it actually possible to submit jobs via REST into a Mesos cluster? Even if it is the Spark framework must exist at that point thereby rendering credentials unnecessary in that scenario.\r\n\r\nOr am I missing something here?\r\n\r\n",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-26T14:24:03Z",
    "diffHunk": "@@ -71,40 +74,64 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))"
  }, {
    "author": {
      "login": "ArtRand"
    },
    "body": "Sorry for the delay. I have a use case where I start the Dispatcher in the Mesos cluster and then execute `spark-submit` cluster calls from within the container. Unfortunately this requires me to unset a few environment variables (`MESOS_EXECUTOR_ID MESOS_FRAMEWORK_ID MESOS_SLAVE_ID MESOS_SLAVE_PID MESOS_TASK_ID`) because they interfere with `spark-submit` due to this function in the rest client. \r\n\r\nIf the Dispatcher is started in a mode where it needs these Mesos authentication credentials, can we assume that we'll want to always forward them this same way? I realize I might be getting into the weeds here and this might me a _me_ problem. But I thought I'd bring it up. ",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-01-30T17:51:56Z",
    "diffHunk": "@@ -71,40 +74,64 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "So have you guys reached a conclusion here? I'm not familiar with mesos deployments so I don't really know whether there's a problem here.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-01T21:45:29Z",
    "diffHunk": "@@ -71,40 +74,64 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))"
  }, {
    "author": {
      "login": "ArtRand"
    },
    "body": "I would want to make sure that @susanxhuynh and/or @skonto agree, but I think this is probably fine. ",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-05T14:55:52Z",
    "diffHunk": "@@ -71,40 +74,64 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))"
  }, {
    "author": {
      "login": "susanxhuynh"
    },
    "body": "I think it's fine to set that env var, SPARK_MESOS_PRINCIPAL.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-05T19:30:28Z",
    "diffHunk": "@@ -71,40 +74,64 @@ trait MesosSchedulerUtils extends Logging {\n       failoverTimeout: Option[Double] = None,\n       frameworkId: Option[String] = None): SchedulerDriver = {\n     val fwInfoBuilder = FrameworkInfo.newBuilder().setUser(sparkUser).setName(appName)\n-    val credBuilder = Credential.newBuilder()\n+    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n+      conf.get(DRIVER_HOST_ADDRESS)))\n     webuiUrl.foreach { url => fwInfoBuilder.setWebuiUrl(url) }\n     checkpoint.foreach { checkpoint => fwInfoBuilder.setCheckpoint(checkpoint) }\n     failoverTimeout.foreach { timeout => fwInfoBuilder.setFailoverTimeout(timeout) }\n     frameworkId.foreach { id =>\n       fwInfoBuilder.setId(FrameworkID.newBuilder().setValue(id).build())\n     }\n-    fwInfoBuilder.setHostname(Option(conf.getenv(\"SPARK_PUBLIC_DNS\")).getOrElse(\n-      conf.get(DRIVER_HOST_ADDRESS)))\n-    conf.getOption(\"spark.mesos.principal\").foreach { principal =>\n-      fwInfoBuilder.setPrincipal(principal)\n-      credBuilder.setPrincipal(principal)\n-    }\n-    conf.getOption(\"spark.mesos.secret\").foreach { secret =>\n-      credBuilder.setSecret(secret)\n-    }\n-    if (credBuilder.hasSecret && !fwInfoBuilder.hasPrincipal) {\n-      throw new SparkException(\n-        \"spark.mesos.principal must be configured when spark.mesos.secret is set\")\n-    }\n+\n     conf.getOption(\"spark.mesos.role\").foreach { role =>\n       fwInfoBuilder.setRole(role)\n     }\n     val maxGpus = conf.getInt(\"spark.mesos.gpus.max\", 0)\n     if (maxGpus > 0) {\n       fwInfoBuilder.addCapabilities(Capability.newBuilder().setType(Capability.Type.GPU_RESOURCES))\n     }\n+    val credBuilder = buildCredentials(conf, fwInfoBuilder)\n     if (credBuilder.hasPrincipal) {\n       new MesosSchedulerDriver(\n         scheduler, fwInfoBuilder.build(), masterUrl, credBuilder.build())\n     } else {\n       new MesosSchedulerDriver(scheduler, fwInfoBuilder.build(), masterUrl)\n     }\n   }\n+  \n+  def buildCredentials(\n+      conf: SparkConf, \n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: indented too far. Also, we generally use `StandardCharsets.UTF_8`.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-08T20:44:29Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+              Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: indent a little more",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-08T20:45:11Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+              Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))\n+          }\n+      ).foreach { principal =>\n+         fwInfoBuilder.setPrincipal(principal)\n+         credBuilder.setPrincipal(principal)\n+    }"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Same re: `StandardCharsets`.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-08T20:45:32Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+              Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))\n+          }\n+      ).foreach { principal =>\n+         fwInfoBuilder.setPrincipal(principal)\n+         credBuilder.setPrincipal(principal)\n+    }\n+    conf.getOption(\"spark.mesos.secret\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.secret.file\")\n+         .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\")))\n+         .map { secretFile =>\n+           Files.toString(new File(secretFile), Charset.forName(\"UTF-8\"))"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: add indent",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-08T20:45:42Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+              Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))\n+          }\n+      ).foreach { principal =>\n+         fwInfoBuilder.setPrincipal(principal)\n+         credBuilder.setPrincipal(principal)\n+    }\n+    conf.getOption(\"spark.mesos.secret\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.secret.file\")\n+         .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\")))\n+         .map { secretFile =>\n+           Files.toString(new File(secretFile), Charset.forName(\"UTF-8\"))\n+         }\n+      ).foreach { secret =>\n+         credBuilder.setSecret(secret)\n+    }"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: this is indented 3 spaces, not 2.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-08T20:46:12Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+              Files.toString(new File(principalFile), Charset.forName(\"UTF-8\"))\n+          }\n+      ).foreach { principal =>\n+         fwInfoBuilder.setPrincipal(principal)\n+         credBuilder.setPrincipal(principal)\n+    }\n+    conf.getOption(\"spark.mesos.secret\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.secret.file\")\n+         .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\")))\n+         .map { secretFile =>\n+           Files.toString(new File(secretFile), Charset.forName(\"UTF-8\"))\n+         }\n+      ).foreach { secret =>\n+         credBuilder.setSecret(secret)"
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: this block is indented 4 spaces not 2.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-09T19:19:29Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+            Files.toString(new File(principalFile), StandardCharsets.UTF_8)\n+          }\n+      ).foreach { principal =>\n+          fwInfoBuilder.setPrincipal(principal)",
    "line": 72
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: this needs to be indented further",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-09T19:19:39Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+            Files.toString(new File(principalFile), StandardCharsets.UTF_8)\n+          }\n+      ).foreach { principal =>\n+          fwInfoBuilder.setPrincipal(principal)\n+          credBuilder.setPrincipal(principal)\n+    }",
    "line": 74
  }],
  "prId": 20167
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "same indentation problem here.",
    "commit": "30e1cbd89ca801e0c6d0ac28b5d10554921b72d9",
    "createdAt": "2018-02-09T19:19:51Z",
    "diffHunk": "@@ -106,6 +99,40 @@ trait MesosSchedulerUtils extends Logging {\n     }\n   }\n \n+  def buildCredentials(\n+      conf: SparkConf,\n+      fwInfoBuilder: Protos.FrameworkInfo.Builder): Protos.Credential.Builder = {\n+    val credBuilder = Credential.newBuilder()\n+    conf.getOption(\"spark.mesos.principal\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.principal.file\")\n+          .orElse(Option(conf.getenv(\"SPARK_MESOS_PRINCIPAL_FILE\")))\n+          .map { principalFile =>\n+            Files.toString(new File(principalFile), StandardCharsets.UTF_8)\n+          }\n+      ).foreach { principal =>\n+          fwInfoBuilder.setPrincipal(principal)\n+          credBuilder.setPrincipal(principal)\n+    }\n+    conf.getOption(\"spark.mesos.secret\")\n+      .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET\")))\n+      .orElse(\n+        conf.getOption(\"spark.mesos.secret.file\")\n+         .orElse(Option(conf.getenv(\"SPARK_MESOS_SECRET_FILE\")))\n+         .map { secretFile =>\n+           Files.toString(new File(secretFile), StandardCharsets.UTF_8)\n+         }\n+      ).foreach { secret =>\n+          credBuilder.setSecret(secret)",
    "line": 84
  }],
  "prId": 20167
}]