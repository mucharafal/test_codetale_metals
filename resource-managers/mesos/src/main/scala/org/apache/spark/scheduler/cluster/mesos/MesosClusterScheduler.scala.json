[{
  "comments": [{
    "author": {
      "login": "susanxhuynh"
    },
    "body": "typo: \"Submission\"",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-08T02:20:18Z",
    "diffHunk": "@@ -374,6 +375,15 @@ private[spark] class MesosClusterScheduler(\n     s\"${frameworkId}-${desc.submissionId}${retries}\"\n   }\n \n+  private def getDriverTaskId(desc: MesosDriverDescription): String = {\n+    val sId = desc.submissionId\n+    desc.retryState.map(state => sId + s\"-retry-${state.retries.toString}\").getOrElse(sId)\n+  }\n+\n+  private def getSumbmissionIdFromTaskId(taskId: String): String = {"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Will fix.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-11T10:23:28Z",
    "diffHunk": "@@ -374,6 +375,15 @@ private[spark] class MesosClusterScheduler(\n     s\"${frameworkId}-${desc.submissionId}${retries}\"\n   }\n \n+  private def getDriverTaskId(desc: MesosDriverDescription): String = {\n+    val sId = desc.submissionId\n+    desc.retryState.map(state => sId + s\"-retry-${state.retries.toString}\").getOrElse(sId)\n+  }\n+\n+  private def getSumbmissionIdFromTaskId(taskId: String): String = {"
  }],
  "prId": 19374
}, {
  "comments": [{
    "author": {
      "login": "susanxhuynh"
    },
    "body": "Why did this change? I think the original `getValue` is the standard way to get the value of this TaskID proto. http://mesos.apache.org/api/latest/java/org/apache/mesos/Protos.TaskID.html",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-08T18:02:44Z",
    "diffHunk": "@@ -276,8 +276,8 @@ private[spark] class MesosClusterScheduler(\n   private def recoverState(): Unit = {\n     stateLock.synchronized {\n       launchedDriversState.fetchAll[MesosClusterSubmissionState]().foreach { state =>\n-        launchedDrivers(state.taskId.getValue) = state\n-        pendingRecover(state.taskId.getValue) = state.slaveId\n+        launchedDrivers(state.driverDescription.submissionId) = state\n+        pendingRecover(state.taskId.toString) = state.slaveId"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "I will check, probably missed the getValue call here it.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-11T10:23:17Z",
    "diffHunk": "@@ -276,8 +276,8 @@ private[spark] class MesosClusterScheduler(\n   private def recoverState(): Unit = {\n     stateLock.synchronized {\n       launchedDriversState.fetchAll[MesosClusterSubmissionState]().foreach { state =>\n-        launchedDrivers(state.taskId.getValue) = state\n-        pendingRecover(state.taskId.getValue) = state.slaveId\n+        launchedDrivers(state.driverDescription.submissionId) = state\n+        pendingRecover(state.taskId.toString) = state.slaveId"
  }],
  "prId": 19374
}, {
  "comments": [{
    "author": {
      "login": "susanxhuynh"
    },
    "body": "This parameter, `status`, is not used.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-09T14:32:20Z",
    "diffHunk": "@@ -804,45 +814,52 @@ private[spark] class MesosClusterScheduler(\n     logInfo(s\"Received status update: taskId=${taskId}\" +\n       s\" state=${status.getState}\" +\n       s\" message=${status.getMessage}\" +\n-      s\" reason=${status.getReason}\");\n+      s\" reason=${status.getReason}\")\n \n     stateLock.synchronized {\n-      if (launchedDrivers.contains(taskId)) {\n+      val subId = getSumbmissionIdFromTaskId(taskId)\n+      if (launchedDrivers.contains(subId)) {\n         if (status.getReason == Reason.REASON_RECONCILIATION &&\n           !pendingRecover.contains(taskId)) {\n           // Task has already received update and no longer requires reconciliation.\n           return\n         }\n-        val state = launchedDrivers(taskId)\n+        val state = launchedDrivers(subId)\n         // Check if the driver is supervise enabled and can be relaunched.\n         if (state.driverDescription.supervise && shouldRelaunch(status.getState)) {\n-          removeFromLaunchedDrivers(taskId)\n+          removeFromLaunchedDrivers(subId)\n           state.finishDate = Some(new Date())\n           val retryState: Option[MesosClusterRetryState] = state.driverDescription.retryState\n           val (retries, waitTimeSec) = retryState\n             .map { rs => (rs.retries + 1, Math.min(maxRetryWaitTime, rs.waitTime * 2)) }\n             .getOrElse{ (1, 1) }\n           val nextRetry = new Date(new Date().getTime + waitTimeSec * 1000L)\n-\n           val newDriverDescription = state.driverDescription.copy(\n             retryState = Some(new MesosClusterRetryState(status, retries, nextRetry, waitTimeSec)))\n-          addDriverToPending(newDriverDescription, taskId);\n+          addDriverToPending(newDriverDescription, newDriverDescription.submissionId)\n         } else if (TaskState.isFinished(mesosToTaskState(status.getState))) {\n-          removeFromLaunchedDrivers(taskId)\n-          state.finishDate = Some(new Date())\n-          if (finishedDrivers.size >= retainedDrivers) {\n-            val toRemove = math.max(retainedDrivers / 10, 1)\n-            finishedDrivers.trimStart(toRemove)\n-          }\n-          finishedDrivers += state\n+          retireDriver(subId, state, status)\n         }\n         state.mesosTaskStatus = Option(status)\n       } else {\n-        logError(s\"Unable to find driver $taskId in status update\")\n+        logError(s\"Unable to find driver with $taskId in status update\")\n       }\n     }\n   }\n \n+  private def retireDriver(\n+      submissionId: String,\n+      state: MesosClusterSubmissionState,\n+      status: TaskStatus) = {"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Will fix thanx.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-11T10:23:51Z",
    "diffHunk": "@@ -804,45 +814,52 @@ private[spark] class MesosClusterScheduler(\n     logInfo(s\"Received status update: taskId=${taskId}\" +\n       s\" state=${status.getState}\" +\n       s\" message=${status.getMessage}\" +\n-      s\" reason=${status.getReason}\");\n+      s\" reason=${status.getReason}\")\n \n     stateLock.synchronized {\n-      if (launchedDrivers.contains(taskId)) {\n+      val subId = getSumbmissionIdFromTaskId(taskId)\n+      if (launchedDrivers.contains(subId)) {\n         if (status.getReason == Reason.REASON_RECONCILIATION &&\n           !pendingRecover.contains(taskId)) {\n           // Task has already received update and no longer requires reconciliation.\n           return\n         }\n-        val state = launchedDrivers(taskId)\n+        val state = launchedDrivers(subId)\n         // Check if the driver is supervise enabled and can be relaunched.\n         if (state.driverDescription.supervise && shouldRelaunch(status.getState)) {\n-          removeFromLaunchedDrivers(taskId)\n+          removeFromLaunchedDrivers(subId)\n           state.finishDate = Some(new Date())\n           val retryState: Option[MesosClusterRetryState] = state.driverDescription.retryState\n           val (retries, waitTimeSec) = retryState\n             .map { rs => (rs.retries + 1, Math.min(maxRetryWaitTime, rs.waitTime * 2)) }\n             .getOrElse{ (1, 1) }\n           val nextRetry = new Date(new Date().getTime + waitTimeSec * 1000L)\n-\n           val newDriverDescription = state.driverDescription.copy(\n             retryState = Some(new MesosClusterRetryState(status, retries, nextRetry, waitTimeSec)))\n-          addDriverToPending(newDriverDescription, taskId);\n+          addDriverToPending(newDriverDescription, newDriverDescription.submissionId)\n         } else if (TaskState.isFinished(mesosToTaskState(status.getState))) {\n-          removeFromLaunchedDrivers(taskId)\n-          state.finishDate = Some(new Date())\n-          if (finishedDrivers.size >= retainedDrivers) {\n-            val toRemove = math.max(retainedDrivers / 10, 1)\n-            finishedDrivers.trimStart(toRemove)\n-          }\n-          finishedDrivers += state\n+          retireDriver(subId, state, status)\n         }\n         state.mesosTaskStatus = Option(status)\n       } else {\n-        logError(s\"Unable to find driver $taskId in status update\")\n+        logError(s\"Unable to find driver with $taskId in status update\")\n       }\n     }\n   }\n \n+  private def retireDriver(\n+      submissionId: String,\n+      state: MesosClusterSubmissionState,\n+      status: TaskStatus) = {"
  }],
  "prId": 19374
}, {
  "comments": [{
    "author": {
      "login": "susanxhuynh"
    },
    "body": "Maybe modify the comments up in L.138-150 ^^ to clarify which data structures are keyed by submission ID vs. task ID:\r\n- Keyed by submission ID: `launchedDrivers`, `queuedDrivers`, `pendingRetryDrivers`, `finishedDrivers`\r\n- Keyed by task ID: `pendingRecover`",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-09T14:43:01Z",
    "diffHunk": "@@ -276,8 +276,8 @@ private[spark] class MesosClusterScheduler(\n   private def recoverState(): Unit = {\n     stateLock.synchronized {\n       launchedDriversState.fetchAll[MesosClusterSubmissionState]().foreach { state =>\n-        launchedDrivers(state.taskId.getValue) = state\n-        pendingRecover(state.taskId.getValue) = state.slaveId\n+        launchedDrivers(state.driverDescription.submissionId) = state"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "ok",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-17T08:52:40Z",
    "diffHunk": "@@ -276,8 +276,8 @@ private[spark] class MesosClusterScheduler(\n   private def recoverState(): Unit = {\n     stateLock.synchronized {\n       launchedDriversState.fetchAll[MesosClusterSubmissionState]().foreach { state =>\n-        launchedDrivers(state.taskId.getValue) = state\n-        pendingRecover(state.taskId.getValue) = state.slaveId\n+        launchedDrivers(state.driverDescription.submissionId) = state"
  }],
  "prId": 19374
}, {
  "comments": [{
    "author": {
      "login": "ArtRand"
    },
    "body": "Maybe make this a constant? ",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-14T01:31:45Z",
    "diffHunk": "@@ -374,6 +375,15 @@ private[spark] class MesosClusterScheduler(\n     s\"${frameworkId}-${desc.submissionId}${retries}\"\n   }\n \n+  private def getDriverTaskId(desc: MesosDriverDescription): String = {\n+    val sId = desc.submissionId\n+    desc.retryState.map(state => sId + s\"-retry-${state.retries.toString}\").getOrElse(sId)\n+  }\n+\n+  private def getSumbmissionIdFromTaskId(taskId: String): String = {\n+    taskId.split(\"-retry-\").head"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "sure.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-16T19:41:02Z",
    "diffHunk": "@@ -374,6 +375,15 @@ private[spark] class MesosClusterScheduler(\n     s\"${frameworkId}-${desc.submissionId}${retries}\"\n   }\n \n+  private def getDriverTaskId(desc: MesosDriverDescription): String = {\n+    val sId = desc.submissionId\n+    desc.retryState.map(state => sId + s\"-retry-${state.retries.toString}\").getOrElse(sId)\n+  }\n+\n+  private def getSumbmissionIdFromTaskId(taskId: String): String = {\n+    taskId.split(\"-retry-\").head"
  }],
  "prId": 19374
}, {
  "comments": [{
    "author": {
      "login": "ArtRand"
    },
    "body": "Maybe keep the name as `subId` because it could be confusing otherwise.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-14T01:35:36Z",
    "diffHunk": "@@ -896,8 +913,8 @@ private[spark] class MesosClusterScheduler(\n     revive()\n   }\n \n-  private def addDriverToPending(desc: MesosDriverDescription, taskId: String) = {\n-    pendingRetryDriversState.persist(taskId, desc)\n+  private def addDriverToPending(desc: MesosDriverDescription, id: String) = {\n+    pendingRetryDriversState.persist(id, desc)"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "ok.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-16T19:41:25Z",
    "diffHunk": "@@ -896,8 +913,8 @@ private[spark] class MesosClusterScheduler(\n     revive()\n   }\n \n-  private def addDriverToPending(desc: MesosDriverDescription, taskId: String) = {\n-    pendingRetryDriversState.persist(taskId, desc)\n+  private def addDriverToPending(desc: MesosDriverDescription, id: String) = {\n+    pendingRetryDriversState.persist(id, desc)"
  }],
  "prId": 19374
}, {
  "comments": [{
    "author": {
      "login": "ArtRand"
    },
    "body": "Sorry, super nit, maybe `RETRY_SEP`. Feel free to ignore. ",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-18T00:37:23Z",
    "diffHunk": "@@ -135,22 +135,24 @@ private[spark] class MesosClusterScheduler(\n   private val useFetchCache = conf.getBoolean(\"spark.mesos.fetchCache.enable\", false)\n   private val schedulerState = engineFactory.createEngine(\"scheduler\")\n   private val stateLock = new Object()\n+  // Keyed by submission id\n   private val finishedDrivers =\n     new mutable.ArrayBuffer[MesosClusterSubmissionState](retainedDrivers)\n   private var frameworkId: String = null\n-  // Holds all the launched drivers and current launch state, keyed by driver id.\n+  // Holds all the launched drivers and current launch state, keyed by submission id.\n   private val launchedDrivers = new mutable.HashMap[String, MesosClusterSubmissionState]()\n   // Holds a map of driver id to expected slave id that is passed to Mesos for reconciliation.\n   // All drivers that are loaded after failover are added here, as we need get the latest\n-  // state of the tasks from Mesos.\n+  // state of the tasks from Mesos. Keyed by task Id.\n   private val pendingRecover = new mutable.HashMap[String, SlaveID]()\n-  // Stores all the submitted drivers that hasn't been launched.\n+  // Stores all the submitted drivers that hasn't been launched, keyed by submission id\n   private val queuedDrivers = new ArrayBuffer[MesosDriverDescription]()\n-  // All supervised drivers that are waiting to retry after termination.\n+  // All supervised drivers that are waiting to retry after termination, keyed by submission id\n   private val pendingRetryDrivers = new ArrayBuffer[MesosDriverDescription]()\n   private val queuedDriversState = engineFactory.createEngine(\"driverQueue\")\n   private val launchedDriversState = engineFactory.createEngine(\"launchedDrivers\")\n   private val pendingRetryDriversState = engineFactory.createEngine(\"retryList\")\n+  private final val RETRY_ID = \"-retry-\""
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "np will update.",
    "commit": "06999177331b7323813eca3c06d6a9a55e054f7d",
    "createdAt": "2017-10-18T11:58:15Z",
    "diffHunk": "@@ -135,22 +135,24 @@ private[spark] class MesosClusterScheduler(\n   private val useFetchCache = conf.getBoolean(\"spark.mesos.fetchCache.enable\", false)\n   private val schedulerState = engineFactory.createEngine(\"scheduler\")\n   private val stateLock = new Object()\n+  // Keyed by submission id\n   private val finishedDrivers =\n     new mutable.ArrayBuffer[MesosClusterSubmissionState](retainedDrivers)\n   private var frameworkId: String = null\n-  // Holds all the launched drivers and current launch state, keyed by driver id.\n+  // Holds all the launched drivers and current launch state, keyed by submission id.\n   private val launchedDrivers = new mutable.HashMap[String, MesosClusterSubmissionState]()\n   // Holds a map of driver id to expected slave id that is passed to Mesos for reconciliation.\n   // All drivers that are loaded after failover are added here, as we need get the latest\n-  // state of the tasks from Mesos.\n+  // state of the tasks from Mesos. Keyed by task Id.\n   private val pendingRecover = new mutable.HashMap[String, SlaveID]()\n-  // Stores all the submitted drivers that hasn't been launched.\n+  // Stores all the submitted drivers that hasn't been launched, keyed by submission id\n   private val queuedDrivers = new ArrayBuffer[MesosDriverDescription]()\n-  // All supervised drivers that are waiting to retry after termination.\n+  // All supervised drivers that are waiting to retry after termination, keyed by submission id\n   private val pendingRetryDrivers = new ArrayBuffer[MesosDriverDescription]()\n   private val queuedDriversState = engineFactory.createEngine(\"driverQueue\")\n   private val launchedDriversState = engineFactory.createEngine(\"launchedDrivers\")\n   private val pendingRetryDriversState = engineFactory.createEngine(\"retryList\")\n+  private final val RETRY_ID = \"-retry-\""
  }],
  "prId": 19374
}]