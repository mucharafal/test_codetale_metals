[{
  "comments": [{
    "author": {
      "login": "galv"
    },
    "body": "This line fails for me. It should be `customResource1.units should be (\"M\")`, right?",
    "commit": "dc2e382ff1e468f7e54e14a12fdfcf983b70ea0f",
    "createdAt": "2018-05-20T02:07:00Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.yarn\n+\n+import org.apache.hadoop.yarn.api.records.Resource\n+import org.apache.hadoop.yarn.util.Records\n+import org.scalatest.{BeforeAndAfterAll, Matchers}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.deploy.yarn.TestYarnResourceTypeHelper.ResourceInformation\n+\n+class ResourceTypeHelperSuite extends SparkFunSuite with Matchers with BeforeAndAfterAll {\n+\n+  private val CUSTOM_RES_1 = \"custom-resource-type-1\"\n+  private val CUSTOM_RES_2 = \"custom-resource-type-2\"\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+  }\n+\n+  private def getExpectedUnmatchedErrorMessage(value: String) = {\n+    \"Value of resource type should match pattern \" +\n+      s\"([0-9]+)([A-Za-z]*), unmatched value: $value\"\n+  }\n+\n+  test(\"resource type value does not match pattern\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"**@#\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(\"**@#\"))\n+  }\n+\n+  test(\"resource type just unit defined\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"m\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(\"m\"))\n+  }\n+\n+  test(\"resource type with null value should not be allowed\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, null)\n+    }\n+    thrown.getMessage should equal (\"Resource parameter should not be null!\")\n+  }\n+\n+  test(\"resource type with valid value and invalid unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123ppp\")\n+    val resource = createAResource\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    }\n+    thrown.getMessage should fullyMatch regex\n+      \"\"\"Unknown unit 'ppp'\\. Known units are \\[.*\\]\"\"\"\n+  }\n+\n+  test(\"resource type with valid value and without unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (123)\n+    customResource.units should be (\"\")\n+  }\n+\n+  test(\"resource type with valid value and unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"2g\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (2)\n+    customResource.units should be (\"G\")\n+  }\n+\n+  test(\"two resource types with valid values and units\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1, CUSTOM_RES_2))\n+\n+    val resourceTypes = Map(\n+      CUSTOM_RES_1 -> \"123m\",\n+      CUSTOM_RES_2 -> \"10G\"\n+    )\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource1: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource1.name should equal (CUSTOM_RES_1)\n+    customResource1.value should be (123)\n+    customResource1.units should be (\"m\")"
  }, {
    "author": {
      "login": "szilard-nemeth"
    },
    "body": "good catch, fixed",
    "commit": "dc2e382ff1e468f7e54e14a12fdfcf983b70ea0f",
    "createdAt": "2018-05-22T12:26:42Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.yarn\n+\n+import org.apache.hadoop.yarn.api.records.Resource\n+import org.apache.hadoop.yarn.util.Records\n+import org.scalatest.{BeforeAndAfterAll, Matchers}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.deploy.yarn.TestYarnResourceTypeHelper.ResourceInformation\n+\n+class ResourceTypeHelperSuite extends SparkFunSuite with Matchers with BeforeAndAfterAll {\n+\n+  private val CUSTOM_RES_1 = \"custom-resource-type-1\"\n+  private val CUSTOM_RES_2 = \"custom-resource-type-2\"\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+  }\n+\n+  private def getExpectedUnmatchedErrorMessage(value: String) = {\n+    \"Value of resource type should match pattern \" +\n+      s\"([0-9]+)([A-Za-z]*), unmatched value: $value\"\n+  }\n+\n+  test(\"resource type value does not match pattern\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"**@#\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(\"**@#\"))\n+  }\n+\n+  test(\"resource type just unit defined\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"m\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(\"m\"))\n+  }\n+\n+  test(\"resource type with null value should not be allowed\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, null)\n+    }\n+    thrown.getMessage should equal (\"Resource parameter should not be null!\")\n+  }\n+\n+  test(\"resource type with valid value and invalid unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123ppp\")\n+    val resource = createAResource\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    }\n+    thrown.getMessage should fullyMatch regex\n+      \"\"\"Unknown unit 'ppp'\\. Known units are \\[.*\\]\"\"\"\n+  }\n+\n+  test(\"resource type with valid value and without unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (123)\n+    customResource.units should be (\"\")\n+  }\n+\n+  test(\"resource type with valid value and unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"2g\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (2)\n+    customResource.units should be (\"G\")\n+  }\n+\n+  test(\"two resource types with valid values and units\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1, CUSTOM_RES_2))\n+\n+    val resourceTypes = Map(\n+      CUSTOM_RES_1 -> \"123m\",\n+      CUSTOM_RES_2 -> \"10G\"\n+    )\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource1: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource1.name should equal (CUSTOM_RES_1)\n+    customResource1.value should be (123)\n+    customResource1.units should be (\"m\")"
  }],
  "prId": 20761
}, {
  "comments": [{
    "author": {
      "login": "galv"
    },
    "body": "You're taking advantage of the implementation detail that the value is matched against the regex before it is checked that the yarn resource type `CUSTOM_RES_1` is available. Therefore, to make this unit test more complete, I would do `TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))`. Same for the test case \"resource type just unit defined\".",
    "commit": "dc2e382ff1e468f7e54e14a12fdfcf983b70ea0f",
    "createdAt": "2018-05-20T02:40:20Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.yarn\n+\n+import org.apache.hadoop.yarn.api.records.Resource\n+import org.apache.hadoop.yarn.util.Records\n+import org.scalatest.{BeforeAndAfterAll, Matchers}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.deploy.yarn.TestYarnResourceTypeHelper.ResourceInformation\n+\n+class ResourceTypeHelperSuite extends SparkFunSuite with Matchers with BeforeAndAfterAll {\n+\n+  private val CUSTOM_RES_1 = \"custom-resource-type-1\"\n+  private val CUSTOM_RES_2 = \"custom-resource-type-2\"\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+  }\n+\n+  private def getExpectedUnmatchedErrorMessage(value: String) = {\n+    \"Value of resource type should match pattern \" +\n+      s\"([0-9]+)([A-Za-z]*), unmatched value: $value\"\n+  }\n+\n+  test(\"resource type value does not match pattern\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())"
  }, {
    "author": {
      "login": "szilard-nemeth"
    },
    "body": "good point, fixed",
    "commit": "dc2e382ff1e468f7e54e14a12fdfcf983b70ea0f",
    "createdAt": "2018-05-22T12:25:11Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.yarn\n+\n+import org.apache.hadoop.yarn.api.records.Resource\n+import org.apache.hadoop.yarn.util.Records\n+import org.scalatest.{BeforeAndAfterAll, Matchers}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.deploy.yarn.TestYarnResourceTypeHelper.ResourceInformation\n+\n+class ResourceTypeHelperSuite extends SparkFunSuite with Matchers with BeforeAndAfterAll {\n+\n+  private val CUSTOM_RES_1 = \"custom-resource-type-1\"\n+  private val CUSTOM_RES_2 = \"custom-resource-type-2\"\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+  }\n+\n+  private def getExpectedUnmatchedErrorMessage(value: String) = {\n+    \"Value of resource type should match pattern \" +\n+      s\"([0-9]+)([A-Za-z]*), unmatched value: $value\"\n+  }\n+\n+  test(\"resource type value does not match pattern\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())"
  }],
  "prId": 20761
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "While we've (unfortunately) not used this standard Scala test syntax in almost all the tests, I'm OK with using it here, in preference to `assert(... === \"G\")` Don't know if others feel strongly about it.",
    "commit": "dc2e382ff1e468f7e54e14a12fdfcf983b70ea0f",
    "createdAt": "2018-09-18T15:21:25Z",
    "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.yarn\n+\n+import org.apache.hadoop.yarn.api.records.Resource\n+import org.apache.hadoop.yarn.util.Records\n+import org.scalatest.{BeforeAndAfterAll, Matchers}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.deploy.yarn.TestYarnResourceTypeHelper.ResourceInformation\n+\n+class ResourceTypeHelperSuite extends SparkFunSuite with Matchers with BeforeAndAfterAll {\n+\n+  private val CUSTOM_RES_1 = \"custom-resource-type-1\"\n+  private val CUSTOM_RES_2 = \"custom-resource-type-2\"\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+  }\n+\n+  private def getExpectedUnmatchedErrorMessage(name: String, value: String): String = {\n+    s\"Resource request for '$name' ('$value') does not match pattern ([0-9]+)([A-Za-z]*).\"\n+  }\n+\n+  test(\"resource type value does not match pattern\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"**@#\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(CUSTOM_RES_1, \"**@#\"))\n+  }\n+\n+  test(\"resource type just unit defined\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"m\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(CUSTOM_RES_1, \"m\"))\n+  }\n+\n+  test(\"resource type with null value should not be allowed\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, null)\n+    }\n+    thrown.getMessage should equal (\"requirement failed: Resource parameter should not be null!\")\n+  }\n+\n+  test(\"resource type with valid value and invalid unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123ppp\")\n+    val resource = createAResource\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    }\n+    thrown.getMessage should fullyMatch regex\n+      \"\"\"Unknown unit 'ppp'\\. Known units are \\[.*\\]\"\"\"\n+  }\n+\n+  test(\"resource type with valid value and without unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (123)\n+    customResource.units should be (\"\")\n+  }\n+\n+  test(\"resource type with valid value and unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"2g\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (2)\n+    customResource.units should be (\"G\")"
  }, {
    "author": {
      "login": "szilard-nemeth"
    },
    "body": "I hope others won't bothered wit this. If anyone is, please tell me and I will fix it real quick.",
    "commit": "dc2e382ff1e468f7e54e14a12fdfcf983b70ea0f",
    "createdAt": "2018-09-19T11:17:01Z",
    "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.yarn\n+\n+import org.apache.hadoop.yarn.api.records.Resource\n+import org.apache.hadoop.yarn.util.Records\n+import org.scalatest.{BeforeAndAfterAll, Matchers}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.deploy.yarn.TestYarnResourceTypeHelper.ResourceInformation\n+\n+class ResourceTypeHelperSuite extends SparkFunSuite with Matchers with BeforeAndAfterAll {\n+\n+  private val CUSTOM_RES_1 = \"custom-resource-type-1\"\n+  private val CUSTOM_RES_2 = \"custom-resource-type-2\"\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+  }\n+\n+  private def getExpectedUnmatchedErrorMessage(name: String, value: String): String = {\n+    s\"Resource request for '$name' ('$value') does not match pattern ([0-9]+)([A-Za-z]*).\"\n+  }\n+\n+  test(\"resource type value does not match pattern\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"**@#\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(CUSTOM_RES_1, \"**@#\"))\n+  }\n+\n+  test(\"resource type just unit defined\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"m\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, createAResource)\n+    }\n+    thrown.getMessage should equal (getExpectedUnmatchedErrorMessage(CUSTOM_RES_1, \"m\"))\n+  }\n+\n+  test(\"resource type with null value should not be allowed\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List())\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, null)\n+    }\n+    thrown.getMessage should equal (\"requirement failed: Resource parameter should not be null!\")\n+  }\n+\n+  test(\"resource type with valid value and invalid unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123ppp\")\n+    val resource = createAResource\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    }\n+    thrown.getMessage should fullyMatch regex\n+      \"\"\"Unknown unit 'ppp'\\. Known units are \\[.*\\]\"\"\"\n+  }\n+\n+  test(\"resource type with valid value and without unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"123\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (123)\n+    customResource.units should be (\"\")\n+  }\n+\n+  test(\"resource type with valid value and unit\") {\n+    assume(ResourceTypeHelper.isYarnResourceTypesAvailable())\n+    TestYarnResourceTypeHelper.initializeResourceTypes(List(CUSTOM_RES_1))\n+\n+    val resourceTypes = Map(CUSTOM_RES_1 -> \"2g\")\n+    val resource = createAResource\n+\n+    ResourceTypeHelper.setResourceInfoFromResourceTypes(resourceTypes, resource)\n+    val customResource: ResourceInformation = TestYarnResourceTypeHelper\n+      .getResourceInformationByName(resource, CUSTOM_RES_1)\n+    customResource.name should equal (CUSTOM_RES_1)\n+    customResource.value should be (2)\n+    customResource.units should be (\"G\")"
  }],
  "prId": 20761
}]