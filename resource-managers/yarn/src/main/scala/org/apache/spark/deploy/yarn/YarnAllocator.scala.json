[{
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "should it capture all exception/error when it is fatal (if possible)\r\nI can see how the error can be \"lost\" on this new thread instead of getting propagate to re-throw from the original (the one calling thread.join())",
    "commit": "24fb01ce5f45206f749360f18f8172d1ebd52370",
    "createdAt": "2019-03-16T04:10:28Z",
    "diffHunk": "@@ -417,12 +424,40 @@ private[yarn] class YarnAllocator(\n         containersToUse, remainingAfterHostMatches)\n     }\n \n-    // Match remaining by rack\n+    // Match remaining by rack. Because YARN's RackResolver swallows thread interrupts\n+    // (see SPARK-27094), which can cause this code to miss interrupts from the AM, use\n+    // a separate thread to perform the operation.\n     val remainingAfterRackMatches = new ArrayBuffer[Container]\n-    for (allocatedContainer <- remainingAfterHostMatches) {\n-      val rack = resolver.resolve(conf, allocatedContainer.getNodeId.getHost)\n-      matchContainerToRequest(allocatedContainer, rack, containersToUse,\n-        remainingAfterRackMatches)\n+    if (remainingAfterHostMatches.nonEmpty) {\n+      var exception: Option[Throwable] = None\n+      val thread = new Thread(\"spark-rack-resolver\") {\n+        override def run(): Unit = {\n+          try {\n+            for (allocatedContainer <- remainingAfterHostMatches) {\n+              val rack = resolver.resolve(conf, allocatedContainer.getNodeId.getHost)\n+              matchContainerToRequest(allocatedContainer, rack, containersToUse,\n+                remainingAfterRackMatches)\n+            }\n+          } catch {\n+            case NonFatal(e) =>\n+              exception = Some(e)",
    "line": 39
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "sure",
    "commit": "24fb01ce5f45206f749360f18f8172d1ebd52370",
    "createdAt": "2019-03-18T16:10:46Z",
    "diffHunk": "@@ -417,12 +424,40 @@ private[yarn] class YarnAllocator(\n         containersToUse, remainingAfterHostMatches)\n     }\n \n-    // Match remaining by rack\n+    // Match remaining by rack. Because YARN's RackResolver swallows thread interrupts\n+    // (see SPARK-27094), which can cause this code to miss interrupts from the AM, use\n+    // a separate thread to perform the operation.\n     val remainingAfterRackMatches = new ArrayBuffer[Container]\n-    for (allocatedContainer <- remainingAfterHostMatches) {\n-      val rack = resolver.resolve(conf, allocatedContainer.getNodeId.getHost)\n-      matchContainerToRequest(allocatedContainer, rack, containersToUse,\n-        remainingAfterRackMatches)\n+    if (remainingAfterHostMatches.nonEmpty) {\n+      var exception: Option[Throwable] = None\n+      val thread = new Thread(\"spark-rack-resolver\") {\n+        override def run(): Unit = {\n+          try {\n+            for (allocatedContainer <- remainingAfterHostMatches) {\n+              val rack = resolver.resolve(conf, allocatedContainer.getNodeId.getHost)\n+              matchContainerToRequest(allocatedContainer, rack, containersToUse,\n+                remainingAfterRackMatches)\n+            }\n+          } catch {\n+            case NonFatal(e) =>\n+              exception = Some(e)",
    "line": 39
  }],
  "prId": 24017
}]