[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "During the recent discussion in the sig meeting I was thinking about this guy. I think it may not be necessary to mount this secret in executors, and let the driver propagate the tokens to executors through its normal means.\r\n\r\ne.g. later if/when adding code to monitor delegation tokens for updates, that would mean only the driver has to do it.\r\n\r\nI'll git this a try; if it works, it might be feasible to re-merge this code with the kerberos step.",
    "commit": "ccb39560298a5e54f144b8ba2a43d950289ccf34",
    "createdAt": "2018-11-14T19:01:35Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.features\n+\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.hadoop.security.UserGroupInformation\n+\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.deploy.k8s.{KubernetesConf, KubernetesUtils, SparkPod}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.security.HadoopDelegationTokenManager\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * Delegation token support for Spark apps on kubernetes.\n+ *\n+ * When preparing driver resources, this step will generate delegation tokens for the app if\n+ * they're needed.\n+ *\n+ * When preparing pods, this step will mount the delegation token secret (either pre-defined,\n+ * or generated by this step when preparing the driver).\n+ */\n+private[spark] class DelegationTokenFeatureStep(conf: KubernetesConf[_], isDriver: Boolean)"
  }, {
    "author": {
      "login": "ifilonenko"
    },
    "body": "This is what I meant above when I said that the `HadoopKerberosLogin` logic could be deleted. The assumption here is that the secret should not be created as the keytab will use the HadoopDelegationTokenManager logic. The only secret that should be _created_ would be the keytab. However, I personally thought that we should point to a secretName that is either the delegationToken or the keytab. Hence why I suggested that the secretName and secretItemKey remain. ",
    "commit": "ccb39560298a5e54f144b8ba2a43d950289ccf34",
    "createdAt": "2018-11-14T19:30:45Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.features\n+\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.hadoop.security.UserGroupInformation\n+\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.deploy.k8s.{KubernetesConf, KubernetesUtils, SparkPod}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.security.HadoopDelegationTokenManager\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * Delegation token support for Spark apps on kubernetes.\n+ *\n+ * When preparing driver resources, this step will generate delegation tokens for the app if\n+ * they're needed.\n+ *\n+ * When preparing pods, this step will mount the delegation token secret (either pre-defined,\n+ * or generated by this step when preparing the driver).\n+ */\n+private[spark] class DelegationTokenFeatureStep(conf: KubernetesConf[_], isDriver: Boolean)"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I think you're missing one use case there. There are 3 use cases:\r\n\r\n- keytab: keytab is provided to driver, driver handles kerberos login, creates tokens, distributes tokens to executors\r\n- pre-defined token secret: secret is mounted in the driver, env variable is set, driver loads them and distributes to executors\r\n- default kerberos case: submission client generates delegation tokens, creates a secret for them, then this behaves like the bullet above\r\n\r\nThe third use case is actually the most common. In your reply above you're only covering the other two. My code covers all three.\r\n\r\nI'm just saying that this code actually doesn't need to do anything on the executor side, because the driver takes care of everything when the credentials are provided.",
    "commit": "ccb39560298a5e54f144b8ba2a43d950289ccf34",
    "createdAt": "2018-11-14T19:38:56Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.features\n+\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.hadoop.security.UserGroupInformation\n+\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.deploy.k8s.{KubernetesConf, KubernetesUtils, SparkPod}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.security.HadoopDelegationTokenManager\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * Delegation token support for Spark apps on kubernetes.\n+ *\n+ * When preparing driver resources, this step will generate delegation tokens for the app if\n+ * they're needed.\n+ *\n+ * When preparing pods, this step will mount the delegation token secret (either pre-defined,\n+ * or generated by this step when preparing the driver).\n+ */\n+private[spark] class DelegationTokenFeatureStep(conf: KubernetesConf[_], isDriver: Boolean)"
  }],
  "prId": 22911
}]