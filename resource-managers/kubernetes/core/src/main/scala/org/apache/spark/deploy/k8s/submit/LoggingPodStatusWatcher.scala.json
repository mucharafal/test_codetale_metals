[{
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "No need for `hasCompleted` ? Are all error's non-recoverable ?",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-27T08:09:41Z",
    "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+      appId: String, maybeLoggingInterval: Option[Long])\n+    extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")\n+      scheduler.scheduleAtFixedRate(logRunnable, 0, interval, TimeUnit.MILLISECONDS)\n+    }\n+  }\n+\n+  override def eventReceived(action: Action, pod: Pod): Unit = {\n+    this.pod = Option(pod)\n+    action match {\n+      case Action.DELETED =>\n+        closeWatch()\n+\n+      case Action.ERROR =>\n+        closeWatch()"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "`hasCompleted` is checked below. Refactored the cases.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-28T00:46:07Z",
    "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+      appId: String, maybeLoggingInterval: Option[Long])\n+    extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")\n+      scheduler.scheduleAtFixedRate(logRunnable, 0, interval, TimeUnit.MILLISECONDS)\n+    }\n+  }\n+\n+  override def eventReceived(action: Action, pod: Pod): Unit = {\n+    this.pod = Option(pod)\n+    action match {\n+      case Action.DELETED =>\n+        closeWatch()\n+\n+      case Action.ERROR =>\n+        closeWatch()"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "It is checked only for case of `action != DELETED` and `action != ERROR` right ?",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-28T01:51:44Z",
    "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+      appId: String, maybeLoggingInterval: Option[Long])\n+    extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")\n+      scheduler.scheduleAtFixedRate(logRunnable, 0, interval, TimeUnit.MILLISECONDS)\n+    }\n+  }\n+\n+  override def eventReceived(action: Action, pod: Pod): Unit = {\n+    this.pod = Option(pod)\n+    action match {\n+      case Action.DELETED =>\n+        closeWatch()\n+\n+      case Action.ERROR =>\n+        closeWatch()"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "It's because in both `DELETE` and `ERROR` cases, the application is considered being terminated. In other cases, we need to check the phase of the driver pod to determine if the application terminated. ",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-30T17:57:53Z",
    "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+      appId: String, maybeLoggingInterval: Option[Long])\n+    extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")\n+      scheduler.scheduleAtFixedRate(logRunnable, 0, interval, TimeUnit.MILLISECONDS)\n+    }\n+  }\n+\n+  override def eventReceived(action: Action, pod: Pod): Unit = {\n+    this.pod = Option(pod)\n+    action match {\n+      case Action.DELETED =>\n+        closeWatch()\n+\n+      case Action.ERROR =>\n+        closeWatch()"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "jiangxb1987"
    },
    "body": "nit: each param for a single line.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-27T15:10:13Z",
    "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+      appId: String, maybeLoggingInterval: Option[Long])"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-28T00:46:53Z",
    "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+      appId: String, maybeLoggingInterval: Option[Long])"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "should this be tracked with a JIRA?",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-02T18:38:24Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+    appId: String,\n+    maybeLoggingInterval: Option[Long])\n+  extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")\n+      scheduler.scheduleAtFixedRate(logRunnable, 0, interval, TimeUnit.MILLISECONDS)\n+    }\n+  }\n+\n+  override def eventReceived(action: Action, pod: Pod): Unit = {\n+    this.pod = Option(pod)\n+    action match {\n+      case Action.DELETED | Action.ERROR =>\n+        closeWatch()\n+\n+      case _ =>\n+        logLongStatus()\n+        if (hasCompleted()) {\n+          closeWatch()\n+        }\n+    }\n+  }\n+\n+  override def onClose(e: KubernetesClientException): Unit = {\n+    logDebug(s\"Stopping watching application $appId with last-observed phase $phase\")\n+    closeWatch()\n+  }\n+\n+  private def logShortStatus() = {\n+    logInfo(s\"Application status for $appId (phase: $phase)\")\n+  }\n+\n+  private def logLongStatus() = {\n+    logInfo(\"State changed, new state: \" + pod.map(formatPodState).getOrElse(\"unknown\"))\n+  }\n+\n+  private def hasCompleted(): Boolean = {\n+    phase == \"Succeeded\" || phase == \"Failed\"\n+  }\n+\n+  private def closeWatch(): Unit = {\n+    podCompletedFuture.countDown()\n+    scheduler.shutdown()\n+  }\n+\n+  private def formatPodState(pod: Pod): String = {\n+    // TODO include specific container state"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Actually it already includes the `containerStatuses`. Removed this TODO.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T17:42:53Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+    appId: String,\n+    maybeLoggingInterval: Option[Long])\n+  extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")\n+      scheduler.scheduleAtFixedRate(logRunnable, 0, interval, TimeUnit.MILLISECONDS)\n+    }\n+  }\n+\n+  override def eventReceived(action: Action, pod: Pod): Unit = {\n+    this.pod = Option(pod)\n+    action match {\n+      case Action.DELETED | Action.ERROR =>\n+        closeWatch()\n+\n+      case _ =>\n+        logLongStatus()\n+        if (hasCompleted()) {\n+          closeWatch()\n+        }\n+    }\n+  }\n+\n+  override def onClose(e: KubernetesClientException): Unit = {\n+    logDebug(s\"Stopping watching application $appId with last-observed phase $phase\")\n+    closeWatch()\n+  }\n+\n+  private def logShortStatus() = {\n+    logInfo(s\"Application status for $appId (phase: $phase)\")\n+  }\n+\n+  private def logLongStatus() = {\n+    logInfo(\"State changed, new state: \" + pod.map(formatPodState).getOrElse(\"unknown\"))\n+  }\n+\n+  private def hasCompleted(): Boolean = {\n+    phase == \"Succeeded\" || phase == \"Failed\"\n+  }\n+\n+  private def closeWatch(): Unit = {\n+    podCompletedFuture.countDown()\n+    scheduler.shutdown()\n+  }\n+\n+  private def formatPodState(pod: Pod): String = {\n+    // TODO include specific container state"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "You could use `.checkValue` in the constant declaration instead.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T19:53:43Z",
    "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+    appId: String,\n+    maybeLoggingInterval: Option[Long])\n+  extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T21:38:59Z",
    "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit\n+\n+import java.util.concurrent.{CountDownLatch, TimeUnit}\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{ContainerStateRunning, ContainerStateTerminated, ContainerStateWaiting, ContainerStatus, Pod, Time}\n+import io.fabric8.kubernetes.client.{KubernetesClientException, Watcher}\n+import io.fabric8.kubernetes.client.Watcher.Action\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.util.ThreadUtils\n+\n+private[k8s] trait LoggingPodStatusWatcher extends Watcher[Pod] {\n+  def awaitCompletion(): Unit\n+}\n+\n+/**\n+ * A monitor for the running Kubernetes pod of a Spark application. Status logging occurs on\n+ * every state change and also at an interval for liveness.\n+ *\n+ * @param appId application ID.\n+ * @param maybeLoggingInterval ms between each state request. If provided, must be a positive\n+ *                             number.\n+ */\n+private[k8s] class LoggingPodStatusWatcherImpl(\n+    appId: String,\n+    maybeLoggingInterval: Option[Long])\n+  extends LoggingPodStatusWatcher with Logging {\n+\n+  private val podCompletedFuture = new CountDownLatch(1)\n+  // start timer for periodic logging\n+  private val scheduler =\n+    ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"logging-pod-status-watcher\")\n+  private val logRunnable: Runnable = new Runnable {\n+    override def run() = logShortStatus()\n+  }\n+\n+  private var pod = Option.empty[Pod]\n+\n+  private def phase: String = pod.map(_.getStatus.getPhase).getOrElse(\"unknown\")\n+\n+  def start(): Unit = {\n+    maybeLoggingInterval.foreach { interval =>\n+      require(interval > 0, s\"Logging interval must be a positive time value, got: $interval ms.\")"
  }],
  "prId": 19717
}]