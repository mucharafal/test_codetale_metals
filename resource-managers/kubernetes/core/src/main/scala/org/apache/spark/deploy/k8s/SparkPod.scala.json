[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I added this because I started to get tired of code like the following:\r\n\r\n```\r\nval someIntermediateName = someOption.map { blah =>\r\n   // create the updated pod\r\n}.getOrElse(previousPodName)\r\n\r\n// lather, rinse, repeat\r\n```\r\n\r\nTo me that's hard to follow and brittle, and this pattern makes things clearer IMO.",
    "commit": "ccb39560298a5e54f144b8ba2a43d950289ccf34",
    "createdAt": "2018-11-14T17:17:49Z",
    "diffHunk": "@@ -18,7 +18,30 @@ package org.apache.spark.deploy.k8s\n \n import io.fabric8.kubernetes.api.model.{Container, ContainerBuilder, Pod, PodBuilder}\n \n-private[spark] case class SparkPod(pod: Pod, container: Container)\n+private[spark] case class SparkPod(pod: Pod, container: Container) {\n+\n+  /**\n+   * Convenience method to apply a series of chained transformations to a pod.\n+   *\n+   * Use it like:\n+   *\n+   *     original.modify { case pod =>\n+   *       // update pod and return new one\n+   *     }.modify { case pod =>\n+   *       // more changes that create a new pod\n+   *     }.modify {\n+   *       case pod if someCondition => // new pod\n+   *     }\n+   *\n+   * This makes it cleaner to apply multiple transformations, avoiding having to create\n+   * a bunch of awkwardly-named local variables. Since the argument is a partial function,\n+   * it can do matching without needing to exhaust all the possibilities. If the function\n+   * is not applied, then the original pod will be kept.\n+   */\n+  def transform(fn: PartialFunction[SparkPod, SparkPod]): SparkPod = fn.lift(this).getOrElse(this)",
    "line": 25
  }, {
    "author": {
      "login": "ifilonenko"
    },
    "body": "I would think that this change is out of the scope of this PR, but I do love the use of a PartialFunction here. Thanks for this! ",
    "commit": "ccb39560298a5e54f144b8ba2a43d950289ccf34",
    "createdAt": "2018-11-14T17:20:20Z",
    "diffHunk": "@@ -18,7 +18,30 @@ package org.apache.spark.deploy.k8s\n \n import io.fabric8.kubernetes.api.model.{Container, ContainerBuilder, Pod, PodBuilder}\n \n-private[spark] case class SparkPod(pod: Pod, container: Container)\n+private[spark] case class SparkPod(pod: Pod, container: Container) {\n+\n+  /**\n+   * Convenience method to apply a series of chained transformations to a pod.\n+   *\n+   * Use it like:\n+   *\n+   *     original.modify { case pod =>\n+   *       // update pod and return new one\n+   *     }.modify { case pod =>\n+   *       // more changes that create a new pod\n+   *     }.modify {\n+   *       case pod if someCondition => // new pod\n+   *     }\n+   *\n+   * This makes it cleaner to apply multiple transformations, avoiding having to create\n+   * a bunch of awkwardly-named local variables. Since the argument is a partial function,\n+   * it can do matching without needing to exhaust all the possibilities. If the function\n+   * is not applied, then the original pod will be kept.\n+   */\n+  def transform(fn: PartialFunction[SparkPod, SparkPod]): SparkPod = fn.lift(this).getOrElse(this)",
    "line": 25
  }],
  "prId": 22911
}]