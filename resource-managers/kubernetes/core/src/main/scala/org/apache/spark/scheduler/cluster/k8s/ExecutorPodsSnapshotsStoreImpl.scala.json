[{
  "comments": [{
    "author": {
      "login": "mccheah"
    },
    "body": "So the watch only creates new snapshots by applying some \"diff\" according to the next event to the previous snapshot. One downside of this data model is that we end up buffering multiple collections of pods in the observable stream which can all perhaps only differ by a single pod per update. Thus we end up temporarily storing redundant information in the snapshots. But the observable buffers are ephemeral and will be periodically processed by the periodic iterations of the subscribers. I wouldn't mind thinking about a more optimal representation here.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-08T01:49:35Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(\n+    bufferSnapshotsExecutor: ScheduledExecutorService,\n+    executeSubscriptionsExecutor: ExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val snapshotsObservable = PublishSubject.create[ExecutorPodsSnapshot]()\n+  private val observedDisposables = mutable.Buffer.empty[Disposable]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (subscriber: ExecutorPodsSnapshot => Unit): Unit = {\n+    observedDisposables += snapshotsObservable\n+      // Group events in the time window given by the caller. These buffers are then sent\n+      // to the caller's lambda at the given interval, with the pod updates that occurred\n+      // in that given interval.\n+      .buffer(\n+        processBatchIntervalMillis,\n+        TimeUnit.MILLISECONDS,\n+        // For testing - specifically use the given scheduled executor service to trigger\n+        // buffer boundaries. Allows us to inject a deterministic scheduler here.\n+        Schedulers.from(bufferSnapshotsExecutor))\n+      // Trigger an event cycle immediately. Not strictly required to be fully correct, but\n+      // in particular the pod allocator should try to request executors immediately instead\n+      // of waiting for one pod allocation delay.\n+      .startWith(Lists.newArrayList(ExecutorPodsSnapshot()))\n+      // Force all triggered events - both the initial event above and the buffered ones in\n+      // the following time windows - to execute asynchronously to this call's thread.\n+      .observeOn(Schedulers.from(executeSubscriptionsExecutor))\n+      .subscribe(toReactivexConsumer { snapshots: java.util.List[ExecutorPodsSnapshot] =>\n+        Utils.tryLogNonFatalError {\n+          snapshots.asScala.foreach(subscriber)\n+        }\n+      })\n+  }\n+\n+  override def stop(): Unit = {\n+    observedDisposables.foreach(_.dispose())\n+    snapshotsObservable.onComplete()\n+    ThreadUtils.shutdown(bufferSnapshotsExecutor)\n+    ThreadUtils.shutdown(executeSubscriptionsExecutor)\n+  }\n+\n+  override def updatePod(updatedPod: Pod): Unit = SNAPSHOT_LOCK.synchronized {\n+    currentSnapshot = currentSnapshot.withUpdate(updatedPod)"
  }, {
    "author": {
      "login": "dvogelbacher"
    },
    "body": "we only ever need to send the latest snapshot update with this new approach, so having the `snapshotsObservable buffer` doesn't make sense anymore? I.e., we don't need to send the subscriber all the Snapshots that happened during a given interval. Only the last one.\r\nSo we can just have a periodic task that takes the latest snapshot and sends it to all subscribers.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-08T20:58:38Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(\n+    bufferSnapshotsExecutor: ScheduledExecutorService,\n+    executeSubscriptionsExecutor: ExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val snapshotsObservable = PublishSubject.create[ExecutorPodsSnapshot]()\n+  private val observedDisposables = mutable.Buffer.empty[Disposable]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (subscriber: ExecutorPodsSnapshot => Unit): Unit = {\n+    observedDisposables += snapshotsObservable\n+      // Group events in the time window given by the caller. These buffers are then sent\n+      // to the caller's lambda at the given interval, with the pod updates that occurred\n+      // in that given interval.\n+      .buffer(\n+        processBatchIntervalMillis,\n+        TimeUnit.MILLISECONDS,\n+        // For testing - specifically use the given scheduled executor service to trigger\n+        // buffer boundaries. Allows us to inject a deterministic scheduler here.\n+        Schedulers.from(bufferSnapshotsExecutor))\n+      // Trigger an event cycle immediately. Not strictly required to be fully correct, but\n+      // in particular the pod allocator should try to request executors immediately instead\n+      // of waiting for one pod allocation delay.\n+      .startWith(Lists.newArrayList(ExecutorPodsSnapshot()))\n+      // Force all triggered events - both the initial event above and the buffered ones in\n+      // the following time windows - to execute asynchronously to this call's thread.\n+      .observeOn(Schedulers.from(executeSubscriptionsExecutor))\n+      .subscribe(toReactivexConsumer { snapshots: java.util.List[ExecutorPodsSnapshot] =>\n+        Utils.tryLogNonFatalError {\n+          snapshots.asScala.foreach(subscriber)\n+        }\n+      })\n+  }\n+\n+  override def stop(): Unit = {\n+    observedDisposables.foreach(_.dispose())\n+    snapshotsObservable.onComplete()\n+    ThreadUtils.shutdown(bufferSnapshotsExecutor)\n+    ThreadUtils.shutdown(executeSubscriptionsExecutor)\n+  }\n+\n+  override def updatePod(updatedPod: Pod): Unit = SNAPSHOT_LOCK.synchronized {\n+    currentSnapshot = currentSnapshot.withUpdate(updatedPod)"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "I'm pretty sure we want all snapshots. The reason is to get a more accurate response in the lifecycle handler. If a pod enters an error state and then someone marks it for deletion, you want to at least have the chance to capture the error state when sending the executor removal request to the Spark scheduler.\r\n\r\nFor the pods allocator we can do either the latest or all.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-08T21:07:46Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(\n+    bufferSnapshotsExecutor: ScheduledExecutorService,\n+    executeSubscriptionsExecutor: ExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val snapshotsObservable = PublishSubject.create[ExecutorPodsSnapshot]()\n+  private val observedDisposables = mutable.Buffer.empty[Disposable]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (subscriber: ExecutorPodsSnapshot => Unit): Unit = {\n+    observedDisposables += snapshotsObservable\n+      // Group events in the time window given by the caller. These buffers are then sent\n+      // to the caller's lambda at the given interval, with the pod updates that occurred\n+      // in that given interval.\n+      .buffer(\n+        processBatchIntervalMillis,\n+        TimeUnit.MILLISECONDS,\n+        // For testing - specifically use the given scheduled executor service to trigger\n+        // buffer boundaries. Allows us to inject a deterministic scheduler here.\n+        Schedulers.from(bufferSnapshotsExecutor))\n+      // Trigger an event cycle immediately. Not strictly required to be fully correct, but\n+      // in particular the pod allocator should try to request executors immediately instead\n+      // of waiting for one pod allocation delay.\n+      .startWith(Lists.newArrayList(ExecutorPodsSnapshot()))\n+      // Force all triggered events - both the initial event above and the buffered ones in\n+      // the following time windows - to execute asynchronously to this call's thread.\n+      .observeOn(Schedulers.from(executeSubscriptionsExecutor))\n+      .subscribe(toReactivexConsumer { snapshots: java.util.List[ExecutorPodsSnapshot] =>\n+        Utils.tryLogNonFatalError {\n+          snapshots.asScala.foreach(subscriber)\n+        }\n+      })\n+  }\n+\n+  override def stop(): Unit = {\n+    observedDisposables.foreach(_.dispose())\n+    snapshotsObservable.onComplete()\n+    ThreadUtils.shutdown(bufferSnapshotsExecutor)\n+    ThreadUtils.shutdown(executeSubscriptionsExecutor)\n+  }\n+\n+  override def updatePod(updatedPod: Pod): Unit = SNAPSHOT_LOCK.synchronized {\n+    currentSnapshot = currentSnapshot.withUpdate(updatedPod)"
  }, {
    "author": {
      "login": "dvogelbacher"
    },
    "body": "gotcha, that makes sense",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-08T21:13:51Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(\n+    bufferSnapshotsExecutor: ScheduledExecutorService,\n+    executeSubscriptionsExecutor: ExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val snapshotsObservable = PublishSubject.create[ExecutorPodsSnapshot]()\n+  private val observedDisposables = mutable.Buffer.empty[Disposable]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (subscriber: ExecutorPodsSnapshot => Unit): Unit = {\n+    observedDisposables += snapshotsObservable\n+      // Group events in the time window given by the caller. These buffers are then sent\n+      // to the caller's lambda at the given interval, with the pod updates that occurred\n+      // in that given interval.\n+      .buffer(\n+        processBatchIntervalMillis,\n+        TimeUnit.MILLISECONDS,\n+        // For testing - specifically use the given scheduled executor service to trigger\n+        // buffer boundaries. Allows us to inject a deterministic scheduler here.\n+        Schedulers.from(bufferSnapshotsExecutor))\n+      // Trigger an event cycle immediately. Not strictly required to be fully correct, but\n+      // in particular the pod allocator should try to request executors immediately instead\n+      // of waiting for one pod allocation delay.\n+      .startWith(Lists.newArrayList(ExecutorPodsSnapshot()))\n+      // Force all triggered events - both the initial event above and the buffered ones in\n+      // the following time windows - to execute asynchronously to this call's thread.\n+      .observeOn(Schedulers.from(executeSubscriptionsExecutor))\n+      .subscribe(toReactivexConsumer { snapshots: java.util.List[ExecutorPodsSnapshot] =>\n+        Utils.tryLogNonFatalError {\n+          snapshots.asScala.foreach(subscriber)\n+        }\n+      })\n+  }\n+\n+  override def stop(): Unit = {\n+    observedDisposables.foreach(_.dispose())\n+    snapshotsObservable.onComplete()\n+    ThreadUtils.shutdown(bufferSnapshotsExecutor)\n+    ThreadUtils.shutdown(executeSubscriptionsExecutor)\n+  }\n+\n+  override def updatePod(updatedPod: Pod): Unit = SNAPSHOT_LOCK.synchronized {\n+    currentSnapshot = currentSnapshot.withUpdate(updatedPod)"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "A brief remark that one still might not be 100% accurate because of failures in the information flow (missing events etc) - but for all the events we do get we should be trying to handle them all as best we can.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-08T21:21:02Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(\n+    bufferSnapshotsExecutor: ScheduledExecutorService,\n+    executeSubscriptionsExecutor: ExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val snapshotsObservable = PublishSubject.create[ExecutorPodsSnapshot]()\n+  private val observedDisposables = mutable.Buffer.empty[Disposable]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (subscriber: ExecutorPodsSnapshot => Unit): Unit = {\n+    observedDisposables += snapshotsObservable\n+      // Group events in the time window given by the caller. These buffers are then sent\n+      // to the caller's lambda at the given interval, with the pod updates that occurred\n+      // in that given interval.\n+      .buffer(\n+        processBatchIntervalMillis,\n+        TimeUnit.MILLISECONDS,\n+        // For testing - specifically use the given scheduled executor service to trigger\n+        // buffer boundaries. Allows us to inject a deterministic scheduler here.\n+        Schedulers.from(bufferSnapshotsExecutor))\n+      // Trigger an event cycle immediately. Not strictly required to be fully correct, but\n+      // in particular the pod allocator should try to request executors immediately instead\n+      // of waiting for one pod allocation delay.\n+      .startWith(Lists.newArrayList(ExecutorPodsSnapshot()))\n+      // Force all triggered events - both the initial event above and the buffered ones in\n+      // the following time windows - to execute asynchronously to this call's thread.\n+      .observeOn(Schedulers.from(executeSubscriptionsExecutor))\n+      .subscribe(toReactivexConsumer { snapshots: java.util.List[ExecutorPodsSnapshot] =>\n+        Utils.tryLogNonFatalError {\n+          snapshots.asScala.foreach(subscriber)\n+        }\n+      })\n+  }\n+\n+  override def stop(): Unit = {\n+    observedDisposables.foreach(_.dispose())\n+    snapshotsObservable.onComplete()\n+    ThreadUtils.shutdown(bufferSnapshotsExecutor)\n+    ThreadUtils.shutdown(executeSubscriptionsExecutor)\n+  }\n+\n+  override def updatePod(updatedPod: Pod): Unit = SNAPSHOT_LOCK.synchronized {\n+    currentSnapshot = currentSnapshot.withUpdate(updatedPod)"
  }],
  "prId": 21366
}, {
  "comments": [{
    "author": {
      "login": "skonto"
    },
    "body": "Picky: Having an Impl class is more Java like.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-11T20:19:06Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl("
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "Prefer an impl class here because we also implement a test-only version in https://github.com/apache/spark/pull/21366/files#diff-ac93ac5a7a34f600bb942c7feb092924",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-11T20:23:08Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl("
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "And the internal implementation is pretty different between the test and the real versions - the real version uses ReactiveX observables while the fake one just uses an in-memory buffer, etc. - it doesn't entirely make sense to have the test implementation extend the real implementation. Mocks are too verbose because of the complexity of the test implementation.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-11T20:25:32Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent.{ExecutorService, ScheduledExecutorService, TimeUnit}\n+\n+import com.google.common.collect.Lists\n+import io.fabric8.kubernetes.api.model.Pod\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.functions.Consumer\n+import io.reactivex.schedulers.Schedulers\n+import io.reactivex.subjects.PublishSubject\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl("
  }],
  "prId": 21366
}, {
  "comments": [{
    "author": {
      "login": "skonto"
    },
    "body": "Could you add a description of the class here.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-14T09:12:45Z",
    "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent._\n+\n+import io.fabric8.kubernetes.api.model.Pod\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(subscribersExecutor: ScheduledExecutorService)"
  }],
  "prId": 21366
}, {
  "comments": [{
    "author": {
      "login": "skonto"
    },
    "body": "toRunnable is not needed with lambdas in Java 8. Just pass there: () => callSubscriber(newSubscriber)",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-14T11:06:18Z",
    "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent._\n+\n+import io.fabric8.kubernetes.api.model.Pod\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(subscribersExecutor: ScheduledExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val subscribers = mutable.Buffer.empty[SnapshotsSubscriber]\n+  private val pollingTasks = mutable.Buffer.empty[Future[_]]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (onNewSnapshots: Seq[ExecutorPodsSnapshot] => Unit): Unit = {\n+    val newSubscriber = SnapshotsSubscriber(\n+        new LinkedBlockingQueue[ExecutorPodsSnapshot](), onNewSnapshots)\n+    subscribers += newSubscriber\n+    pollingTasks += subscribersExecutor.scheduleWithFixedDelay(\n+      toRunnable(() => callSubscriber(newSubscriber)),"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "Just tried that and it doesn't work - I think that requires the scala-java8-compat module which I don't think is worth pulling in for just this case.",
    "commit": "1a99dceeb9dfbfc58e26885c290461cbf37a5428",
    "createdAt": "2018-06-14T20:48:46Z",
    "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.scheduler.cluster.k8s\n+\n+import java.util.concurrent._\n+\n+import io.fabric8.kubernetes.api.model.Pod\n+import javax.annotation.concurrent.GuardedBy\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.spark.util.{ThreadUtils, Utils}\n+\n+private[spark] class ExecutorPodsSnapshotsStoreImpl(subscribersExecutor: ScheduledExecutorService)\n+  extends ExecutorPodsSnapshotsStore {\n+\n+  private val SNAPSHOT_LOCK = new Object()\n+\n+  private val subscribers = mutable.Buffer.empty[SnapshotsSubscriber]\n+  private val pollingTasks = mutable.Buffer.empty[Future[_]]\n+\n+  @GuardedBy(\"SNAPSHOT_LOCK\")\n+  private var currentSnapshot = ExecutorPodsSnapshot()\n+\n+  override def addSubscriber(\n+      processBatchIntervalMillis: Long)\n+      (onNewSnapshots: Seq[ExecutorPodsSnapshot] => Unit): Unit = {\n+    val newSubscriber = SnapshotsSubscriber(\n+        new LinkedBlockingQueue[ExecutorPodsSnapshot](), onNewSnapshots)\n+    subscribers += newSubscriber\n+    pollingTasks += subscribersExecutor.scheduleWithFixedDelay(\n+      toRunnable(() => callSubscriber(newSubscriber)),"
  }],
  "prId": 21366
}]