[{
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "I will need to read up on how k8s does security before I can comment more here ... would be great if @vanzin and @tgravescs took a look.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-27T08:42:08Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "jiangxb1987"
    },
    "body": "nit:\r\n```\r\noption.map { opt =>\r\n  sparkConf.set(configEntry, opt)\r\n}.getOrElse(sparkConf)\r\n```",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-27T15:25:28Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ => {\n+      mountedCanonicalLocation\n+    }))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String]}\n+      .getOrElse {\n+        valueMountedFromSubmitter.map { valueBase64 =>\n+          Map(secretName -> valueBase64)\n+        }.getOrElse(Map.empty[String, String])\n+      }\n+  }\n+\n+  private implicit def augmentSparkConf(sparkConf: SparkConf): OptionSettableSparkConf = {\n+    new OptionSettableSparkConf(sparkConf)\n+  }\n+}\n+\n+private class OptionSettableSparkConf(sparkConf: SparkConf) {\n+  def setOption(configEntry: String, option: Option[String]): SparkConf = {\n+    option.map( opt => {"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-28T00:47:01Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ => {\n+      mountedCanonicalLocation\n+    }))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String]}\n+      .getOrElse {\n+        valueMountedFromSubmitter.map { valueBase64 =>\n+          Map(secretName -> valueBase64)\n+        }.getOrElse(Map.empty[String, String])\n+      }\n+  }\n+\n+  private implicit def augmentSparkConf(sparkConf: SparkConf): OptionSettableSparkConf = {\n+    new OptionSettableSparkConf(sparkConf)\n+  }\n+}\n+\n+private class OptionSettableSparkConf(sparkConf: SparkConf) {\n+  def setOption(configEntry: String, option: Option[String]): SparkConf = {\n+    option.map( opt => {"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "nit: we can remove `{` and corresponding `}`.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-30T09:57:34Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ => {"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-30T16:48:32Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ => {"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "nit: add a space before `}`.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-30T09:58:16Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ => {\n+      mountedCanonicalLocation\n+    }))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String]}"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-11-30T16:48:52Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ => {\n+      mountedCanonicalLocation\n+    }))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String]}"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Instead of passing the format string as an argument, I'd pass the file type instead and inject that into a hardcoded format string here. (Mostly paranoia from C, where it's fishy to use parameters as format strings.)",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T20:45:36Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T23:05:47Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.map { _ =>`",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T20:46:25Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ =>"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T22:56:52Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ =>"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Kinda hard to see what's going on here. Adding a scaladoc would help, especially explaining the arguments.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T20:49:50Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ =>\n+      mountedCanonicalLocation\n+    ))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String] }"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T23:24:03Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ =>\n+      mountedCanonicalLocation\n+    ))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String] }"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.map { opt => `\r\n\r\nUsing `option.foreach` here would also be cleaner.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T20:50:11Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ =>\n+      mountedCanonicalLocation\n+    ))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String] }\n+      .getOrElse {\n+        valueMountedFromSubmitter.map { valueBase64 =>\n+          Map(secretName -> valueBase64)\n+        }.getOrElse(Map.empty[String, String])\n+      }\n+  }\n+\n+  private implicit def augmentSparkConf(sparkConf: SparkConf): OptionSettableSparkConf = {\n+    new OptionSettableSparkConf(sparkConf)\n+  }\n+}\n+\n+private class OptionSettableSparkConf(sparkConf: SparkConf) {\n+  def setOption(configEntry: String, option: Option[String]): SparkConf = {\n+    option.map( opt =>"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "Done.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T22:56:55Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver client cert file provided at %s does not exist or is not a file.\")\n+\n+    val driverSparkConfWithCredentialsLocations = setDriverPodKubernetesCredentialLocations(\n+        driverSparkConf,\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val kubernetesCredentialsSecret = createCredentialsSecret(\n+        oauthTokenBase64,\n+        caCertDataBase64,\n+        clientKeyDataBase64,\n+        clientCertDataBase64)\n+\n+    val driverPodWithMountedKubernetesCredentials = kubernetesCredentialsSecret.map { secret =>\n+      new PodBuilder(driverSpec.driverPod)\n+        .editOrNewSpec()\n+          .addNewVolume()\n+            .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+            .withNewSecret().withSecretName(secret.getMetadata.getName).endSecret()\n+            .endVolume()\n+          .endSpec()\n+        .build()\n+    }.getOrElse(\n+      driverServiceAccount.map { account =>\n+        new PodBuilder(driverSpec.driverPod)\n+          .editOrNewSpec()\n+          .withServiceAccount(account)\n+          .withServiceAccountName(account)\n+          .endSpec()\n+          .build()\n+      }.getOrElse(driverSpec.driverPod)\n+    )\n+\n+    val driverContainerWithMountedSecretVolume = kubernetesCredentialsSecret.map { secret =>\n+      new ContainerBuilder(driverSpec.driverContainer)\n+        .addNewVolumeMount()\n+          .withName(DRIVER_CREDENTIALS_SECRET_VOLUME_NAME)\n+          .withMountPath(DRIVER_CREDENTIALS_SECRETS_BASE_DIR)\n+          .endVolumeMount()\n+        .build()\n+    }.getOrElse(driverSpec.driverContainer)\n+\n+    driverSpec.copy(\n+      driverPod = driverPodWithMountedKubernetesCredentials,\n+      otherKubernetesResources =\n+        driverSpec.otherKubernetesResources ++ kubernetesCredentialsSecret.toSeq,\n+      driverSparkConf = driverSparkConfWithCredentialsLocations,\n+      driverContainer = driverContainerWithMountedSecretVolume)\n+  }\n+\n+  private def createCredentialsSecret(\n+      driverOAuthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): Option[Secret] = {\n+    val allSecretData =\n+      resolveSecretData(\n+        maybeMountedClientKeyFile,\n+        driverClientKeyDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_KEY_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedClientCertFile,\n+        driverClientCertDataBase64,\n+        DRIVER_CREDENTIALS_CLIENT_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedCaCertFile,\n+        driverCaCertDataBase64,\n+        DRIVER_CREDENTIALS_CA_CERT_SECRET_NAME) ++\n+      resolveSecretData(\n+        maybeMountedOAuthTokenFile,\n+        driverOAuthTokenBase64,\n+        DRIVER_CREDENTIALS_OAUTH_TOKEN_SECRET_NAME)\n+\n+    if (allSecretData.isEmpty) {\n+      None\n+    } else {\n+      Some(new SecretBuilder()\n+        .withNewMetadata()\n+          .withName(s\"$kubernetesResourceNamePrefix-kubernetes-credentials\")\n+          .endMetadata()\n+        .withData(allSecretData.asJava)\n+        .build())\n+    }\n+  }\n+\n+  private def setDriverPodKubernetesCredentialLocations(\n+      driverSparkConf: SparkConf,\n+      driverOauthTokenBase64: Option[String],\n+      driverCaCertDataBase64: Option[String],\n+      driverClientKeyDataBase64: Option[String],\n+      driverClientCertDataBase64: Option[String]): SparkConf = {\n+    val resolvedMountedOAuthTokenFile = resolveSecretLocation(\n+      maybeMountedOAuthTokenFile,\n+      driverOauthTokenBase64,\n+      DRIVER_CREDENTIALS_OAUTH_TOKEN_PATH)\n+    val resolvedMountedClientKeyFile = resolveSecretLocation(\n+      maybeMountedClientKeyFile,\n+      driverClientKeyDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_KEY_PATH)\n+    val resolvedMountedClientCertFile = resolveSecretLocation(\n+      maybeMountedClientCertFile,\n+      driverClientCertDataBase64,\n+      DRIVER_CREDENTIALS_CLIENT_CERT_PATH)\n+    val resolvedMountedCaCertFile = resolveSecretLocation(\n+      maybeMountedCaCertFile,\n+      driverCaCertDataBase64,\n+      DRIVER_CREDENTIALS_CA_CERT_PATH)\n+\n+    val sparkConfWithCredentialLocations = driverSparkConf\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedCaCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientKeyFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\",\n+        resolvedMountedClientCertFile)\n+      .setOption(\n+        s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\",\n+        resolvedMountedOAuthTokenFile)\n+\n+    // Redact all OAuth token values\n+    sparkConfWithCredentialLocations\n+      .getAll\n+      .filter(_._1.endsWith(OAUTH_TOKEN_CONF_SUFFIX)).map(_._1)\n+      .foreach {\n+        sparkConfWithCredentialLocations.set(_, \"<present_but_redacted>\")\n+      }\n+    sparkConfWithCredentialLocations\n+  }\n+\n+  private def safeFileConfToBase64(\n+      conf: String,\n+      fileNotFoundFormatString: String): Option[String] = {\n+    submissionSparkConf.getOption(conf)\n+      .map(new File(_))\n+      .map { file =>\n+        require(file.isFile, String.format(fileNotFoundFormatString, file.getAbsolutePath))\n+        BaseEncoding.base64().encode(Files.toByteArray(file))\n+      }\n+  }\n+\n+  private def resolveSecretLocation(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      mountedCanonicalLocation: String): Option[String] = {\n+    mountedUserSpecified.orElse(valueMountedFromSubmitter.map( _ =>\n+      mountedCanonicalLocation\n+    ))\n+  }\n+\n+  private def resolveSecretData(\n+      mountedUserSpecified: Option[String],\n+      valueMountedFromSubmitter: Option[String],\n+      secretName: String): Map[String, String] = {\n+    mountedUserSpecified.map { _ => Map.empty[String, String] }\n+      .getOrElse {\n+        valueMountedFromSubmitter.map { valueBase64 =>\n+          Map(secretName -> valueBase64)\n+        }.getOrElse(Map.empty[String, String])\n+      }\n+  }\n+\n+  private implicit def augmentSparkConf(sparkConf: SparkConf): OptionSettableSparkConf = {\n+    new OptionSettableSparkConf(sparkConf)\n+  }\n+}\n+\n+private class OptionSettableSparkConf(sparkConf: SparkConf) {\n+  def setOption(configEntry: String, option: Option[String]): SparkConf = {\n+    option.map( opt =>"
  }],
  "prId": 19717
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Not really familiar with how these things are used  by k8s, but don't these certs generally have passwords? I can't seem to find anything related to passwords for these things.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T20:52:47Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64("
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "/cc @mccheah.",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-04T22:59:20Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64("
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "These types of files are typically not password protected. Java KeyStores are. (Which reminds me that we should eventually support JKS files for these Kubernetes clients).",
    "commit": "cbcd30ea0a5eb75ed831f50707bc97035c0a3371",
    "createdAt": "2017-12-05T00:22:38Z",
    "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.File\n+import java.nio.charset.StandardCharsets\n+\n+import scala.collection.JavaConverters._\n+import scala.language.implicitConversions\n+\n+import com.google.common.io.{BaseEncoding, Files}\n+import io.fabric8.kubernetes.api.model.{ContainerBuilder, PodBuilder, Secret, SecretBuilder}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.Constants._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+\n+/**\n+ * Mounts Kubernetes credentials into the driver pod. The driver will use such mounted credentials\n+ * to request executors.\n+ */\n+private[spark] class DriverKubernetesCredentialsStep(\n+    submissionSparkConf: SparkConf,\n+    kubernetesResourceNamePrefix: String) extends DriverConfigurationStep {\n+\n+  private val maybeMountedOAuthTokenFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$OAUTH_TOKEN_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientKeyFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\")\n+  private val maybeMountedClientCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CLIENT_CERT_FILE_CONF_SUFFIX\")\n+  private val maybeMountedCaCertFile = submissionSparkConf.getOption(\n+      s\"$KUBERNETES_AUTH_DRIVER_MOUNTED_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\")\n+  private val driverServiceAccount = submissionSparkConf.get(KUBERNETES_SERVICE_ACCOUNT_NAME)\n+\n+  override def configureDriver(driverSpec: KubernetesDriverSpec): KubernetesDriverSpec = {\n+    val driverSparkConf = driverSpec.driverSparkConf.clone()\n+\n+    val oauthTokenBase64 = submissionSparkConf\n+        .getOption(s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$OAUTH_TOKEN_CONF_SUFFIX\")\n+        .map { token =>\n+          BaseEncoding.base64().encode(token.getBytes(StandardCharsets.UTF_8))\n+        }\n+    val caCertDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CA_CERT_FILE_CONF_SUFFIX\",\n+        \"Driver CA cert file provided at %s does not exist or is not a file.\")\n+    val clientKeyDataBase64 = safeFileConfToBase64(\n+        s\"$KUBERNETES_AUTH_DRIVER_CONF_PREFIX.$CLIENT_KEY_FILE_CONF_SUFFIX\",\n+        \"Driver client key file provided at %s does not exist or is not a file.\")\n+    val clientCertDataBase64 = safeFileConfToBase64("
  }],
  "prId": 19717
}]