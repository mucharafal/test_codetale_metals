[{
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "Do we need `$` at the end of the object name?",
    "commit": "28343fb50310826bc9962e785f25d1af9b3c3f4a",
    "createdAt": "2017-12-18T10:09:40Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.StringReader\n+import java.util.Properties\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.collect.Maps\n+import io.fabric8.kubernetes.api.model.{ConfigMap, ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+import org.apache.spark.deploy.k8s.submit.steps.initcontainer.{InitContainerConfigurationStep, InitContainerSpec}\n+import org.apache.spark.util.Utils\n+\n+class DriverInitContainerBootstrapStepSuite extends SparkFunSuite {\n+\n+  private val CONFIG_MAP_NAME = \"spark-init-config-map\"\n+  private val CONFIG_MAP_KEY = \"spark-init-config-map-key\"\n+\n+  test(\"The init container bootstrap step should use all of the init container steps\") {\n+    val baseDriverSpec = KubernetesDriverSpec(\n+      driverPod = new PodBuilder().build(),\n+      driverContainer = new ContainerBuilder().build(),\n+      driverSparkConf = new SparkConf(false),\n+      otherKubernetesResources = Seq.empty[HasMetadata])\n+    val initContainerSteps = Seq(\n+      FirstTestInitContainerConfigurationStep$,\n+      SecondTestInitContainerConfigurationStep$)\n+    val bootstrapStep = new DriverInitContainerBootstrapStep(\n+      initContainerSteps,\n+      CONFIG_MAP_NAME,\n+      CONFIG_MAP_KEY)\n+\n+    val preparedDriverSpec = bootstrapStep.configureDriver(baseDriverSpec)\n+\n+    assert(preparedDriverSpec.driverPod.getMetadata.getLabels.asScala ===\n+      FirstTestInitContainerConfigurationStep$.additionalLabels)\n+    val additionalDriverEnv = preparedDriverSpec.driverContainer.getEnv.asScala\n+    assert(additionalDriverEnv.size === 1)\n+    assert(additionalDriverEnv.head.getName ===\n+      FirstTestInitContainerConfigurationStep$.additionalMainContainerEnvKey)\n+    assert(additionalDriverEnv.head.getValue ===\n+      FirstTestInitContainerConfigurationStep$.additionalMainContainerEnvValue)\n+\n+    assert(preparedDriverSpec.otherKubernetesResources.size === 2)\n+    assert(preparedDriverSpec.otherKubernetesResources.contains(\n+      FirstTestInitContainerConfigurationStep$.additionalKubernetesResource))\n+    assert(preparedDriverSpec.otherKubernetesResources.exists {\n+      case configMap: ConfigMap =>\n+        val hasMatchingName = configMap.getMetadata.getName == CONFIG_MAP_NAME\n+        val configMapData = configMap.getData.asScala\n+        val hasCorrectNumberOfEntries = configMapData.size == 1\n+        val initContainerPropertiesRaw = configMapData(CONFIG_MAP_KEY)\n+        val initContainerProperties = new Properties()\n+        Utils.tryWithResource(new StringReader(initContainerPropertiesRaw)) {\n+          initContainerProperties.load(_)\n+        }\n+        val initContainerPropertiesMap = Maps.fromProperties(initContainerProperties).asScala\n+        val expectedInitContainerProperties = Map(\n+          SecondTestInitContainerConfigurationStep$.additionalInitContainerPropertyKey ->\n+            SecondTestInitContainerConfigurationStep$.additionalInitContainerPropertyValue)\n+        val hasMatchingProperties = initContainerPropertiesMap == expectedInitContainerProperties\n+        hasMatchingName && hasCorrectNumberOfEntries && hasMatchingProperties\n+      case _ => false\n+    })\n+\n+    val initContainers = preparedDriverSpec.driverPod.getSpec.getInitContainers\n+    assert(initContainers.size() === 1)\n+    val initContainerEnv = initContainers.get(0).getEnv.asScala\n+    assert(initContainerEnv.size === 1)\n+    assert(initContainerEnv.head.getName ===\n+      SecondTestInitContainerConfigurationStep$.additionalInitContainerEnvKey)\n+    assert(initContainerEnv.head.getValue ===\n+      SecondTestInitContainerConfigurationStep$.additionalInitContainerEnvValue)\n+\n+    val expectedSparkConf = Map(\n+      INIT_CONTAINER_CONFIG_MAP_NAME.key -> CONFIG_MAP_NAME,\n+      INIT_CONTAINER_CONFIG_MAP_KEY_CONF.key -> CONFIG_MAP_KEY,\n+      SecondTestInitContainerConfigurationStep$.additionalDriverSparkConfKey ->\n+        SecondTestInitContainerConfigurationStep$.additionalDriverSparkConfValue)\n+    assert(preparedDriverSpec.driverSparkConf.getAll.toMap === expectedSparkConf)\n+  }\n+}\n+\n+private object FirstTestInitContainerConfigurationStep$ extends InitContainerConfigurationStep {"
  }, {
    "author": {
      "login": "liyinan926"
    },
    "body": "No, it shouldn't be there. Removed.",
    "commit": "28343fb50310826bc9962e785f25d1af9b3c3f4a",
    "createdAt": "2017-12-18T16:22:48Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.StringReader\n+import java.util.Properties\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.collect.Maps\n+import io.fabric8.kubernetes.api.model.{ConfigMap, ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+import org.apache.spark.deploy.k8s.submit.steps.initcontainer.{InitContainerConfigurationStep, InitContainerSpec}\n+import org.apache.spark.util.Utils\n+\n+class DriverInitContainerBootstrapStepSuite extends SparkFunSuite {\n+\n+  private val CONFIG_MAP_NAME = \"spark-init-config-map\"\n+  private val CONFIG_MAP_KEY = \"spark-init-config-map-key\"\n+\n+  test(\"The init container bootstrap step should use all of the init container steps\") {\n+    val baseDriverSpec = KubernetesDriverSpec(\n+      driverPod = new PodBuilder().build(),\n+      driverContainer = new ContainerBuilder().build(),\n+      driverSparkConf = new SparkConf(false),\n+      otherKubernetesResources = Seq.empty[HasMetadata])\n+    val initContainerSteps = Seq(\n+      FirstTestInitContainerConfigurationStep$,\n+      SecondTestInitContainerConfigurationStep$)\n+    val bootstrapStep = new DriverInitContainerBootstrapStep(\n+      initContainerSteps,\n+      CONFIG_MAP_NAME,\n+      CONFIG_MAP_KEY)\n+\n+    val preparedDriverSpec = bootstrapStep.configureDriver(baseDriverSpec)\n+\n+    assert(preparedDriverSpec.driverPod.getMetadata.getLabels.asScala ===\n+      FirstTestInitContainerConfigurationStep$.additionalLabels)\n+    val additionalDriverEnv = preparedDriverSpec.driverContainer.getEnv.asScala\n+    assert(additionalDriverEnv.size === 1)\n+    assert(additionalDriverEnv.head.getName ===\n+      FirstTestInitContainerConfigurationStep$.additionalMainContainerEnvKey)\n+    assert(additionalDriverEnv.head.getValue ===\n+      FirstTestInitContainerConfigurationStep$.additionalMainContainerEnvValue)\n+\n+    assert(preparedDriverSpec.otherKubernetesResources.size === 2)\n+    assert(preparedDriverSpec.otherKubernetesResources.contains(\n+      FirstTestInitContainerConfigurationStep$.additionalKubernetesResource))\n+    assert(preparedDriverSpec.otherKubernetesResources.exists {\n+      case configMap: ConfigMap =>\n+        val hasMatchingName = configMap.getMetadata.getName == CONFIG_MAP_NAME\n+        val configMapData = configMap.getData.asScala\n+        val hasCorrectNumberOfEntries = configMapData.size == 1\n+        val initContainerPropertiesRaw = configMapData(CONFIG_MAP_KEY)\n+        val initContainerProperties = new Properties()\n+        Utils.tryWithResource(new StringReader(initContainerPropertiesRaw)) {\n+          initContainerProperties.load(_)\n+        }\n+        val initContainerPropertiesMap = Maps.fromProperties(initContainerProperties).asScala\n+        val expectedInitContainerProperties = Map(\n+          SecondTestInitContainerConfigurationStep$.additionalInitContainerPropertyKey ->\n+            SecondTestInitContainerConfigurationStep$.additionalInitContainerPropertyValue)\n+        val hasMatchingProperties = initContainerPropertiesMap == expectedInitContainerProperties\n+        hasMatchingName && hasCorrectNumberOfEntries && hasMatchingProperties\n+      case _ => false\n+    })\n+\n+    val initContainers = preparedDriverSpec.driverPod.getSpec.getInitContainers\n+    assert(initContainers.size() === 1)\n+    val initContainerEnv = initContainers.get(0).getEnv.asScala\n+    assert(initContainerEnv.size === 1)\n+    assert(initContainerEnv.head.getName ===\n+      SecondTestInitContainerConfigurationStep$.additionalInitContainerEnvKey)\n+    assert(initContainerEnv.head.getValue ===\n+      SecondTestInitContainerConfigurationStep$.additionalInitContainerEnvValue)\n+\n+    val expectedSparkConf = Map(\n+      INIT_CONTAINER_CONFIG_MAP_NAME.key -> CONFIG_MAP_NAME,\n+      INIT_CONTAINER_CONFIG_MAP_KEY_CONF.key -> CONFIG_MAP_KEY,\n+      SecondTestInitContainerConfigurationStep$.additionalDriverSparkConfKey ->\n+        SecondTestInitContainerConfigurationStep$.additionalDriverSparkConfValue)\n+    assert(preparedDriverSpec.driverSparkConf.getAll.toMap === expectedSparkConf)\n+  }\n+}\n+\n+private object FirstTestInitContainerConfigurationStep$ extends InitContainerConfigurationStep {"
  }],
  "prId": 19954
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "ditto.",
    "commit": "28343fb50310826bc9962e785f25d1af9b3c3f4a",
    "createdAt": "2017-12-18T10:09:57Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.StringReader\n+import java.util.Properties\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.collect.Maps\n+import io.fabric8.kubernetes.api.model.{ConfigMap, ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+import org.apache.spark.deploy.k8s.submit.steps.initcontainer.{InitContainerConfigurationStep, InitContainerSpec}\n+import org.apache.spark.util.Utils\n+\n+class DriverInitContainerBootstrapStepSuite extends SparkFunSuite {\n+\n+  private val CONFIG_MAP_NAME = \"spark-init-config-map\"\n+  private val CONFIG_MAP_KEY = \"spark-init-config-map-key\"\n+\n+  test(\"The init container bootstrap step should use all of the init container steps\") {\n+    val baseDriverSpec = KubernetesDriverSpec(\n+      driverPod = new PodBuilder().build(),\n+      driverContainer = new ContainerBuilder().build(),\n+      driverSparkConf = new SparkConf(false),\n+      otherKubernetesResources = Seq.empty[HasMetadata])\n+    val initContainerSteps = Seq(\n+      FirstTestInitContainerConfigurationStep$,\n+      SecondTestInitContainerConfigurationStep$)\n+    val bootstrapStep = new DriverInitContainerBootstrapStep(\n+      initContainerSteps,\n+      CONFIG_MAP_NAME,\n+      CONFIG_MAP_KEY)\n+\n+    val preparedDriverSpec = bootstrapStep.configureDriver(baseDriverSpec)\n+\n+    assert(preparedDriverSpec.driverPod.getMetadata.getLabels.asScala ===\n+      FirstTestInitContainerConfigurationStep$.additionalLabels)\n+    val additionalDriverEnv = preparedDriverSpec.driverContainer.getEnv.asScala\n+    assert(additionalDriverEnv.size === 1)\n+    assert(additionalDriverEnv.head.getName ===\n+      FirstTestInitContainerConfigurationStep$.additionalMainContainerEnvKey)\n+    assert(additionalDriverEnv.head.getValue ===\n+      FirstTestInitContainerConfigurationStep$.additionalMainContainerEnvValue)\n+\n+    assert(preparedDriverSpec.otherKubernetesResources.size === 2)\n+    assert(preparedDriverSpec.otherKubernetesResources.contains(\n+      FirstTestInitContainerConfigurationStep$.additionalKubernetesResource))\n+    assert(preparedDriverSpec.otherKubernetesResources.exists {\n+      case configMap: ConfigMap =>\n+        val hasMatchingName = configMap.getMetadata.getName == CONFIG_MAP_NAME\n+        val configMapData = configMap.getData.asScala\n+        val hasCorrectNumberOfEntries = configMapData.size == 1\n+        val initContainerPropertiesRaw = configMapData(CONFIG_MAP_KEY)\n+        val initContainerProperties = new Properties()\n+        Utils.tryWithResource(new StringReader(initContainerPropertiesRaw)) {\n+          initContainerProperties.load(_)\n+        }\n+        val initContainerPropertiesMap = Maps.fromProperties(initContainerProperties).asScala\n+        val expectedInitContainerProperties = Map(\n+          SecondTestInitContainerConfigurationStep$.additionalInitContainerPropertyKey ->\n+            SecondTestInitContainerConfigurationStep$.additionalInitContainerPropertyValue)\n+        val hasMatchingProperties = initContainerPropertiesMap == expectedInitContainerProperties\n+        hasMatchingName && hasCorrectNumberOfEntries && hasMatchingProperties\n+      case _ => false\n+    })\n+\n+    val initContainers = preparedDriverSpec.driverPod.getSpec.getInitContainers\n+    assert(initContainers.size() === 1)\n+    val initContainerEnv = initContainers.get(0).getEnv.asScala\n+    assert(initContainerEnv.size === 1)\n+    assert(initContainerEnv.head.getName ===\n+      SecondTestInitContainerConfigurationStep$.additionalInitContainerEnvKey)\n+    assert(initContainerEnv.head.getValue ===\n+      SecondTestInitContainerConfigurationStep$.additionalInitContainerEnvValue)\n+\n+    val expectedSparkConf = Map(\n+      INIT_CONTAINER_CONFIG_MAP_NAME.key -> CONFIG_MAP_NAME,\n+      INIT_CONTAINER_CONFIG_MAP_KEY_CONF.key -> CONFIG_MAP_KEY,\n+      SecondTestInitContainerConfigurationStep$.additionalDriverSparkConfKey ->\n+        SecondTestInitContainerConfigurationStep$.additionalDriverSparkConfValue)\n+    assert(preparedDriverSpec.driverSparkConf.getAll.toMap === expectedSparkConf)\n+  }\n+}\n+\n+private object FirstTestInitContainerConfigurationStep$ extends InitContainerConfigurationStep {\n+\n+  val additionalLabels = Map(\"additionalLabelkey\" -> \"additionalLabelValue\")\n+  val additionalMainContainerEnvKey = \"TEST_ENV_MAIN_KEY\"\n+  val additionalMainContainerEnvValue = \"TEST_ENV_MAIN_VALUE\"\n+  val additionalKubernetesResource = new SecretBuilder()\n+    .withNewMetadata()\n+    .withName(\"test-secret\")\n+    .endMetadata()\n+    .addToData(\"secret-key\", \"secret-value\")\n+    .build()\n+\n+  override def configureInitContainer(initContainerSpec: InitContainerSpec): InitContainerSpec = {\n+    val driverPod = new PodBuilder(initContainerSpec.driverPod)\n+      .editOrNewMetadata()\n+      .addToLabels(additionalLabels.asJava)\n+      .endMetadata()\n+      .build()\n+    val mainContainer = new ContainerBuilder(initContainerSpec.driverContainer)\n+      .addNewEnv()\n+      .withName(additionalMainContainerEnvKey)\n+      .withValue(additionalMainContainerEnvValue)\n+      .endEnv()\n+      .build()\n+    initContainerSpec.copy(\n+      driverPod = driverPod,\n+      driverContainer = mainContainer,\n+      initContainerDependentResources = initContainerSpec.initContainerDependentResources ++\n+        Seq(additionalKubernetesResource))\n+  }\n+}\n+\n+private object SecondTestInitContainerConfigurationStep$ extends InitContainerConfigurationStep {"
  }],
  "prId": 19954
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Add empty line before this.",
    "commit": "28343fb50310826bc9962e785f25d1af9b3c3f4a",
    "createdAt": "2017-12-21T00:00:08Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.submit.steps\n+\n+import java.io.StringReader\n+import java.util.Properties\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.collect.Maps\n+import io.fabric8.kubernetes.api.model.{ConfigMap, ContainerBuilder, HasMetadata, PodBuilder, SecretBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.deploy.k8s.Config._\n+import org.apache.spark.deploy.k8s.submit.KubernetesDriverSpec\n+import org.apache.spark.deploy.k8s.submit.steps.initcontainer.{InitContainerConfigurationStep, InitContainerSpec}\n+import org.apache.spark.util.Utils\n+\n+class DriverInitContainerBootstrapStepSuite extends SparkFunSuite {\n+\n+  private val CONFIG_MAP_NAME = \"spark-init-config-map\"\n+  private val CONFIG_MAP_KEY = \"spark-init-config-map-key\"\n+\n+  test(\"The init container bootstrap step should use all of the init container steps\") {\n+    val baseDriverSpec = KubernetesDriverSpec(\n+      driverPod = new PodBuilder().build(),\n+      driverContainer = new ContainerBuilder().build(),\n+      driverSparkConf = new SparkConf(false),\n+      otherKubernetesResources = Seq.empty[HasMetadata])\n+    val initContainerSteps = Seq(\n+      FirstTestInitContainerConfigurationStep,\n+      SecondTestInitContainerConfigurationStep)\n+    val bootstrapStep = new DriverInitContainerBootstrapStep(\n+      initContainerSteps,\n+      CONFIG_MAP_NAME,\n+      CONFIG_MAP_KEY)\n+\n+    val preparedDriverSpec = bootstrapStep.configureDriver(baseDriverSpec)\n+\n+    assert(preparedDriverSpec.driverPod.getMetadata.getLabels.asScala ===\n+      FirstTestInitContainerConfigurationStep.additionalLabels)\n+    val additionalDriverEnv = preparedDriverSpec.driverContainer.getEnv.asScala\n+    assert(additionalDriverEnv.size === 1)\n+    assert(additionalDriverEnv.head.getName ===\n+      FirstTestInitContainerConfigurationStep.additionalMainContainerEnvKey)\n+    assert(additionalDriverEnv.head.getValue ===\n+      FirstTestInitContainerConfigurationStep.additionalMainContainerEnvValue)\n+\n+    assert(preparedDriverSpec.otherKubernetesResources.size === 2)\n+    assert(preparedDriverSpec.otherKubernetesResources.contains(\n+      FirstTestInitContainerConfigurationStep.additionalKubernetesResource))\n+    assert(preparedDriverSpec.otherKubernetesResources.exists {\n+      case configMap: ConfigMap =>\n+        val hasMatchingName = configMap.getMetadata.getName == CONFIG_MAP_NAME\n+        val configMapData = configMap.getData.asScala\n+        val hasCorrectNumberOfEntries = configMapData.size == 1\n+        val initContainerPropertiesRaw = configMapData(CONFIG_MAP_KEY)\n+        val initContainerProperties = new Properties()\n+        Utils.tryWithResource(new StringReader(initContainerPropertiesRaw)) {\n+          initContainerProperties.load(_)\n+        }\n+        val initContainerPropertiesMap = Maps.fromProperties(initContainerProperties).asScala\n+        val expectedInitContainerProperties = Map(\n+          SecondTestInitContainerConfigurationStep.additionalInitContainerPropertyKey ->\n+            SecondTestInitContainerConfigurationStep.additionalInitContainerPropertyValue)\n+        val hasMatchingProperties = initContainerPropertiesMap == expectedInitContainerProperties\n+        hasMatchingName && hasCorrectNumberOfEntries && hasMatchingProperties\n+      case _ => false"
  }],
  "prId": 19954
}]