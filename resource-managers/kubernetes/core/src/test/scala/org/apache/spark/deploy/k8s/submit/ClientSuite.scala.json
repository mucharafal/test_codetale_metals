[{
  "comments": [{
    "author": {
      "login": "mccheah"
    },
    "body": "Think for this test, it'll be more streamlined if you\r\n- check for the existence of a secret,\r\n- extract the secret and check its contents,\r\n- check for the existence of a config map,\r\n- extract the config map and check its contents.",
    "commit": "f8f42f063ba23d417750bc1eaa3b26b59907535d",
    "createdAt": "2018-03-14T01:09:45Z",
    "diffHunk": "@@ -108,62 +111,42 @@ class ClientSuite extends SparkFunSuite with BeforeAndAfter {\n       SecondTestConfigurationStep.containerName)\n   }\n \n-  test(\"The client should create the secondary Kubernetes resources.\") {\n+  test(\"The client should create Kubernetes resources\") {\n     val submissionClient = new Client(\n       submissionSteps,\n       new SparkConf(false),\n       kubernetesClient,\n       false,\n       \"spark\",\n-      loggingPodStatusWatcher)\n+      loggingPodStatusWatcher,\n+      KUBERNETES_RESOURCE_PREFIX)\n     submissionClient.run()\n     val createdPod = createdPodArgumentCaptor.getValue\n     val otherCreatedResources = createdResourcesArgumentCaptor.getAllValues\n-    assert(otherCreatedResources.size === 1)\n-    val createdResource = Iterables.getOnlyElement(otherCreatedResources).asInstanceOf[Secret]\n-    assert(createdResource.getMetadata.getName === FirstTestConfigurationStep.secretName)\n-    assert(createdResource.getData.asScala ===\n-      Map(FirstTestConfigurationStep.secretKey -> FirstTestConfigurationStep.secretData))\n-    val ownerReference = Iterables.getOnlyElement(createdResource.getMetadata.getOwnerReferences)\n-    assert(ownerReference.getName === createdPod.getMetadata.getName)\n-    assert(ownerReference.getKind === DRIVER_POD_KIND)\n-    assert(ownerReference.getUid === DRIVER_POD_UID)\n-    assert(ownerReference.getApiVersion === DRIVER_POD_API_VERSION)\n-  }\n-\n-  test(\"The client should attach the driver container with the appropriate JVM options.\") {\n-    val sparkConf = new SparkConf(false)\n-      .set(\"spark.logConf\", \"true\")\n-      .set(\n-        org.apache.spark.internal.config.DRIVER_JAVA_OPTIONS,\n-          \"-XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails\")\n-    val submissionClient = new Client(\n-      submissionSteps,\n-      sparkConf,\n-      kubernetesClient,\n-      false,\n-      \"spark\",\n-      loggingPodStatusWatcher)\n-    submissionClient.run()\n-    val createdPod = createdPodArgumentCaptor.getValue\n+    assert(otherCreatedResources.size === 2)\n+    otherCreatedResources.toArray.foreach{"
  }, {
    "author": {
      "login": "ifilonenko"
    },
    "body": "I thought it would be easier to just go through all the resources in a single loop, but I see your point. I can modify to that setup",
    "commit": "f8f42f063ba23d417750bc1eaa3b26b59907535d",
    "createdAt": "2018-03-14T04:06:10Z",
    "diffHunk": "@@ -108,62 +111,42 @@ class ClientSuite extends SparkFunSuite with BeforeAndAfter {\n       SecondTestConfigurationStep.containerName)\n   }\n \n-  test(\"The client should create the secondary Kubernetes resources.\") {\n+  test(\"The client should create Kubernetes resources\") {\n     val submissionClient = new Client(\n       submissionSteps,\n       new SparkConf(false),\n       kubernetesClient,\n       false,\n       \"spark\",\n-      loggingPodStatusWatcher)\n+      loggingPodStatusWatcher,\n+      KUBERNETES_RESOURCE_PREFIX)\n     submissionClient.run()\n     val createdPod = createdPodArgumentCaptor.getValue\n     val otherCreatedResources = createdResourcesArgumentCaptor.getAllValues\n-    assert(otherCreatedResources.size === 1)\n-    val createdResource = Iterables.getOnlyElement(otherCreatedResources).asInstanceOf[Secret]\n-    assert(createdResource.getMetadata.getName === FirstTestConfigurationStep.secretName)\n-    assert(createdResource.getData.asScala ===\n-      Map(FirstTestConfigurationStep.secretKey -> FirstTestConfigurationStep.secretData))\n-    val ownerReference = Iterables.getOnlyElement(createdResource.getMetadata.getOwnerReferences)\n-    assert(ownerReference.getName === createdPod.getMetadata.getName)\n-    assert(ownerReference.getKind === DRIVER_POD_KIND)\n-    assert(ownerReference.getUid === DRIVER_POD_UID)\n-    assert(ownerReference.getApiVersion === DRIVER_POD_API_VERSION)\n-  }\n-\n-  test(\"The client should attach the driver container with the appropriate JVM options.\") {\n-    val sparkConf = new SparkConf(false)\n-      .set(\"spark.logConf\", \"true\")\n-      .set(\n-        org.apache.spark.internal.config.DRIVER_JAVA_OPTIONS,\n-          \"-XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails\")\n-    val submissionClient = new Client(\n-      submissionSteps,\n-      sparkConf,\n-      kubernetesClient,\n-      false,\n-      \"spark\",\n-      loggingPodStatusWatcher)\n-    submissionClient.run()\n-    val createdPod = createdPodArgumentCaptor.getValue\n+    assert(otherCreatedResources.size === 2)\n+    otherCreatedResources.toArray.foreach{"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "This test wouldn't catch if we returned 2 secrets or 2 config maps, instead of one of each, for example.",
    "commit": "f8f42f063ba23d417750bc1eaa3b26b59907535d",
    "createdAt": "2018-03-14T20:18:43Z",
    "diffHunk": "@@ -108,62 +111,42 @@ class ClientSuite extends SparkFunSuite with BeforeAndAfter {\n       SecondTestConfigurationStep.containerName)\n   }\n \n-  test(\"The client should create the secondary Kubernetes resources.\") {\n+  test(\"The client should create Kubernetes resources\") {\n     val submissionClient = new Client(\n       submissionSteps,\n       new SparkConf(false),\n       kubernetesClient,\n       false,\n       \"spark\",\n-      loggingPodStatusWatcher)\n+      loggingPodStatusWatcher,\n+      KUBERNETES_RESOURCE_PREFIX)\n     submissionClient.run()\n     val createdPod = createdPodArgumentCaptor.getValue\n     val otherCreatedResources = createdResourcesArgumentCaptor.getAllValues\n-    assert(otherCreatedResources.size === 1)\n-    val createdResource = Iterables.getOnlyElement(otherCreatedResources).asInstanceOf[Secret]\n-    assert(createdResource.getMetadata.getName === FirstTestConfigurationStep.secretName)\n-    assert(createdResource.getData.asScala ===\n-      Map(FirstTestConfigurationStep.secretKey -> FirstTestConfigurationStep.secretData))\n-    val ownerReference = Iterables.getOnlyElement(createdResource.getMetadata.getOwnerReferences)\n-    assert(ownerReference.getName === createdPod.getMetadata.getName)\n-    assert(ownerReference.getKind === DRIVER_POD_KIND)\n-    assert(ownerReference.getUid === DRIVER_POD_UID)\n-    assert(ownerReference.getApiVersion === DRIVER_POD_API_VERSION)\n-  }\n-\n-  test(\"The client should attach the driver container with the appropriate JVM options.\") {\n-    val sparkConf = new SparkConf(false)\n-      .set(\"spark.logConf\", \"true\")\n-      .set(\n-        org.apache.spark.internal.config.DRIVER_JAVA_OPTIONS,\n-          \"-XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails\")\n-    val submissionClient = new Client(\n-      submissionSteps,\n-      sparkConf,\n-      kubernetesClient,\n-      false,\n-      \"spark\",\n-      loggingPodStatusWatcher)\n-    submissionClient.run()\n-    val createdPod = createdPodArgumentCaptor.getValue\n+    assert(otherCreatedResources.size === 2)\n+    otherCreatedResources.toArray.foreach{"
  }],
  "prId": 20669
}]