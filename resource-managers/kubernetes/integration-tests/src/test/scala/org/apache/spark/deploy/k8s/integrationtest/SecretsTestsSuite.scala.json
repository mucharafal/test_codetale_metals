[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`sec` is redundant?",
    "commit": "67df340d943d38afd1ea4c12c02b417b5434970f",
    "createdAt": "2018-07-05T23:25:00Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.integrationtest\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{Pod, Secret, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.commons.io.output.ByteArrayOutputStream\n+import org.scalatest.concurrent.Eventually\n+\n+import org.apache.spark.deploy.k8s.integrationtest.KubernetesSuite._\n+\n+private[spark] trait SecretsTestsSuite { k8sSuite: KubernetesSuite =>\n+\n+  import SecretsTestsSuite._\n+\n+  private def createTestSecret(): Secret = {\n+    val sb = new SecretBuilder()\n+    sb.withNewMetadata()\n+      .withName(ENV_SECRET_NAME)\n+      .endMetadata()\n+    val secUsername = Base64.encodeBase64String(ENV_SECRET_VALUE_1.getBytes())\n+    val secPassword = Base64.encodeBase64String(ENV_SECRET_VALUE_2.getBytes())\n+    val envSecretData = Map(ENV_SECRET_KEY_1 -> secUsername, ENV_SECRET_KEY_2 -> secPassword)\n+    sb.addToData(envSecretData.asJava)\n+    val envSecret = sb.build()\n+    val sec = kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .createOrReplace(envSecret)\n+    sec"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "yeah will fix.",
    "commit": "67df340d943d38afd1ea4c12c02b417b5434970f",
    "createdAt": "2018-07-10T14:17:39Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.integrationtest\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{Pod, Secret, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.commons.io.output.ByteArrayOutputStream\n+import org.scalatest.concurrent.Eventually\n+\n+import org.apache.spark.deploy.k8s.integrationtest.KubernetesSuite._\n+\n+private[spark] trait SecretsTestsSuite { k8sSuite: KubernetesSuite =>\n+\n+  import SecretsTestsSuite._\n+\n+  private def createTestSecret(): Secret = {\n+    val sb = new SecretBuilder()\n+    sb.withNewMetadata()\n+      .withName(ENV_SECRET_NAME)\n+      .endMetadata()\n+    val secUsername = Base64.encodeBase64String(ENV_SECRET_VALUE_1.getBytes())\n+    val secPassword = Base64.encodeBase64String(ENV_SECRET_VALUE_2.getBytes())\n+    val envSecretData = Map(ENV_SECRET_KEY_1 -> secUsername, ENV_SECRET_KEY_2 -> secPassword)\n+    sb.addToData(envSecretData.asJava)\n+    val envSecret = sb.build()\n+    val sec = kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .createOrReplace(envSecret)\n+    sec"
  }],
  "prId": 21652
}, {
  "comments": [{
    "author": {
      "login": "liyinan926"
    },
    "body": "Do you really need to call this?",
    "commit": "67df340d943d38afd1ea4c12c02b417b5434970f",
    "createdAt": "2018-07-06T06:00:26Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.integrationtest\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{Pod, Secret, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.commons.io.output.ByteArrayOutputStream\n+import org.scalatest.concurrent.Eventually\n+\n+import org.apache.spark.deploy.k8s.integrationtest.KubernetesSuite._\n+\n+private[spark] trait SecretsTestsSuite { k8sSuite: KubernetesSuite =>\n+\n+  import SecretsTestsSuite._\n+\n+  private def createTestSecret(): Secret = {\n+    val sb = new SecretBuilder()\n+    sb.withNewMetadata()\n+      .withName(ENV_SECRET_NAME)\n+      .endMetadata()\n+    val secUsername = Base64.encodeBase64String(ENV_SECRET_VALUE_1.getBytes())\n+    val secPassword = Base64.encodeBase64String(ENV_SECRET_VALUE_2.getBytes())\n+    val envSecretData = Map(ENV_SECRET_KEY_1 -> secUsername, ENV_SECRET_KEY_2 -> secPassword)\n+    sb.addToData(envSecretData.asJava)\n+    val envSecret = sb.build()\n+    val sec = kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .createOrReplace(envSecret)\n+    sec\n+  }\n+\n+  private def deleteTestSecret(): Unit = {\n+    kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .withName(ENV_SECRET_NAME)\n+      .delete()\n+  }\n+\n+  test(\"Run SparkPi with env and mount secrets.\") {\n+    createTestSecret()\n+    sparkAppConf\n+      .set(s\"spark.kubernetes.driver.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+      .set(s\"spark.kubernetes.executor.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+    try {\n+      runSparkPiAndVerifyCompletion(\n+        driverPodChecker = (driverPod: Pod) => {\n+          doBasicDriverPodCheck(driverPod)\n+          checkSecrets(driverPod)\n+        },\n+        executorPodChecker = (executorPod: Pod) => {\n+          doBasicExecutorPodCheck(executorPod)\n+          checkSecrets(executorPod)\n+        },\n+        appArgs = Array(\"1000\") // give it enough time for all execs to be visible\n+      )\n+    } finally {\n+      // make sure this always run\n+      deleteTestSecret()\n+    }\n+  }\n+\n+  private def checkSecrets(pod: Pod): Unit = {\n+    Eventually.eventually(TIMEOUT, INTERVAL) {\n+      implicit val podName: String = pod.getMetadata.getName\n+      val env = executeCommand(\"env\")\n+      assert(env.toString.contains(ENV_SECRET_VALUE_1))\n+      assert(env.toString.contains(ENV_SECRET_VALUE_2))\n+      val fileUsernameContents = executeCommand(s\"cat\", s\"$SECRET_MOUNT_PATH/$ENV_SECRET_KEY_1\")\n+      val filePasswordContents = executeCommand(s\"cat\", s\"$SECRET_MOUNT_PATH/$ENV_SECRET_KEY_2\")\n+      assert(fileUsernameContents.toString.trim.equals(ENV_SECRET_VALUE_1))\n+      assert(filePasswordContents.toString.trim.equals(ENV_SECRET_VALUE_2))\n+    }\n+  }\n+\n+  private def executeCommand(cmd: String*)(implicit podName: String): String = {\n+    val out = new ByteArrayOutputStream()\n+    val watch = kubernetesTestComponents\n+      .kubernetesClient\n+      .pods()\n+      .withName(podName)\n+      .readingInput(System.in)\n+      .writingOutput(out)\n+      .writingError(System.err)\n+      .withTTY()\n+      .exec(cmd.toArray: _*)\n+    // wait to get some result back\n+    Thread.sleep(1000)",
    "line": 108
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Yes check the above comments about the delay. Most examples in the fabric8io use a delay to read the result: https://github.com/apache/spark/pull/21652#discussion_r200135218\r\nAlso it didnt work for me when run locally without a delay, it requires a mechanism to get the stream output of the command otherwise.",
    "commit": "67df340d943d38afd1ea4c12c02b417b5434970f",
    "createdAt": "2018-07-10T14:12:09Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.integrationtest\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{Pod, Secret, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.commons.io.output.ByteArrayOutputStream\n+import org.scalatest.concurrent.Eventually\n+\n+import org.apache.spark.deploy.k8s.integrationtest.KubernetesSuite._\n+\n+private[spark] trait SecretsTestsSuite { k8sSuite: KubernetesSuite =>\n+\n+  import SecretsTestsSuite._\n+\n+  private def createTestSecret(): Secret = {\n+    val sb = new SecretBuilder()\n+    sb.withNewMetadata()\n+      .withName(ENV_SECRET_NAME)\n+      .endMetadata()\n+    val secUsername = Base64.encodeBase64String(ENV_SECRET_VALUE_1.getBytes())\n+    val secPassword = Base64.encodeBase64String(ENV_SECRET_VALUE_2.getBytes())\n+    val envSecretData = Map(ENV_SECRET_KEY_1 -> secUsername, ENV_SECRET_KEY_2 -> secPassword)\n+    sb.addToData(envSecretData.asJava)\n+    val envSecret = sb.build()\n+    val sec = kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .createOrReplace(envSecret)\n+    sec\n+  }\n+\n+  private def deleteTestSecret(): Unit = {\n+    kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .withName(ENV_SECRET_NAME)\n+      .delete()\n+  }\n+\n+  test(\"Run SparkPi with env and mount secrets.\") {\n+    createTestSecret()\n+    sparkAppConf\n+      .set(s\"spark.kubernetes.driver.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+      .set(s\"spark.kubernetes.executor.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+    try {\n+      runSparkPiAndVerifyCompletion(\n+        driverPodChecker = (driverPod: Pod) => {\n+          doBasicDriverPodCheck(driverPod)\n+          checkSecrets(driverPod)\n+        },\n+        executorPodChecker = (executorPod: Pod) => {\n+          doBasicExecutorPodCheck(executorPod)\n+          checkSecrets(executorPod)\n+        },\n+        appArgs = Array(\"1000\") // give it enough time for all execs to be visible\n+      )\n+    } finally {\n+      // make sure this always run\n+      deleteTestSecret()\n+    }\n+  }\n+\n+  private def checkSecrets(pod: Pod): Unit = {\n+    Eventually.eventually(TIMEOUT, INTERVAL) {\n+      implicit val podName: String = pod.getMetadata.getName\n+      val env = executeCommand(\"env\")\n+      assert(env.toString.contains(ENV_SECRET_VALUE_1))\n+      assert(env.toString.contains(ENV_SECRET_VALUE_2))\n+      val fileUsernameContents = executeCommand(s\"cat\", s\"$SECRET_MOUNT_PATH/$ENV_SECRET_KEY_1\")\n+      val filePasswordContents = executeCommand(s\"cat\", s\"$SECRET_MOUNT_PATH/$ENV_SECRET_KEY_2\")\n+      assert(fileUsernameContents.toString.trim.equals(ENV_SECRET_VALUE_1))\n+      assert(filePasswordContents.toString.trim.equals(ENV_SECRET_VALUE_2))\n+    }\n+  }\n+\n+  private def executeCommand(cmd: String*)(implicit podName: String): String = {\n+    val out = new ByteArrayOutputStream()\n+    val watch = kubernetesTestComponents\n+      .kubernetesClient\n+      .pods()\n+      .withName(podName)\n+      .readingInput(System.in)\n+      .writingOutput(out)\n+      .writingError(System.err)\n+      .withTTY()\n+      .exec(cmd.toArray: _*)\n+    // wait to get some result back\n+    Thread.sleep(1000)",
    "line": 108
  }],
  "prId": 21652
}, {
  "comments": [{
    "author": {
      "login": "liyinan926"
    },
    "body": "Unnecessary `s` before `\"cat\"`.",
    "commit": "67df340d943d38afd1ea4c12c02b417b5434970f",
    "createdAt": "2018-07-06T06:02:08Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.integrationtest\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{Pod, Secret, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.commons.io.output.ByteArrayOutputStream\n+import org.scalatest.concurrent.Eventually\n+\n+import org.apache.spark.deploy.k8s.integrationtest.KubernetesSuite._\n+\n+private[spark] trait SecretsTestsSuite { k8sSuite: KubernetesSuite =>\n+\n+  import SecretsTestsSuite._\n+\n+  private def createTestSecret(): Secret = {\n+    val sb = new SecretBuilder()\n+    sb.withNewMetadata()\n+      .withName(ENV_SECRET_NAME)\n+      .endMetadata()\n+    val secUsername = Base64.encodeBase64String(ENV_SECRET_VALUE_1.getBytes())\n+    val secPassword = Base64.encodeBase64String(ENV_SECRET_VALUE_2.getBytes())\n+    val envSecretData = Map(ENV_SECRET_KEY_1 -> secUsername, ENV_SECRET_KEY_2 -> secPassword)\n+    sb.addToData(envSecretData.asJava)\n+    val envSecret = sb.build()\n+    val sec = kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .createOrReplace(envSecret)\n+    sec\n+  }\n+\n+  private def deleteTestSecret(): Unit = {\n+    kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .withName(ENV_SECRET_NAME)\n+      .delete()\n+  }\n+\n+  test(\"Run SparkPi with env and mount secrets.\") {\n+    createTestSecret()\n+    sparkAppConf\n+      .set(s\"spark.kubernetes.driver.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+      .set(s\"spark.kubernetes.executor.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+    try {\n+      runSparkPiAndVerifyCompletion(\n+        driverPodChecker = (driverPod: Pod) => {\n+          doBasicDriverPodCheck(driverPod)\n+          checkSecrets(driverPod)\n+        },\n+        executorPodChecker = (executorPod: Pod) => {\n+          doBasicExecutorPodCheck(executorPod)\n+          checkSecrets(executorPod)\n+        },\n+        appArgs = Array(\"1000\") // give it enough time for all execs to be visible\n+      )\n+    } finally {\n+      // make sure this always run\n+      deleteTestSecret()\n+    }\n+  }\n+\n+  private def checkSecrets(pod: Pod): Unit = {\n+    Eventually.eventually(TIMEOUT, INTERVAL) {\n+      implicit val podName: String = pod.getMetadata.getName\n+      val env = executeCommand(\"env\")\n+      assert(env.toString.contains(ENV_SECRET_VALUE_1))\n+      assert(env.toString.contains(ENV_SECRET_VALUE_2))\n+      val fileUsernameContents = executeCommand(s\"cat\", s\"$SECRET_MOUNT_PATH/$ENV_SECRET_KEY_1\")"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": ":+1: ",
    "commit": "67df340d943d38afd1ea4c12c02b417b5434970f",
    "createdAt": "2018-07-10T14:14:15Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.k8s.integrationtest\n+\n+import scala.collection.JavaConverters._\n+\n+import io.fabric8.kubernetes.api.model.{Pod, Secret, SecretBuilder}\n+import org.apache.commons.codec.binary.Base64\n+import org.apache.commons.io.output.ByteArrayOutputStream\n+import org.scalatest.concurrent.Eventually\n+\n+import org.apache.spark.deploy.k8s.integrationtest.KubernetesSuite._\n+\n+private[spark] trait SecretsTestsSuite { k8sSuite: KubernetesSuite =>\n+\n+  import SecretsTestsSuite._\n+\n+  private def createTestSecret(): Secret = {\n+    val sb = new SecretBuilder()\n+    sb.withNewMetadata()\n+      .withName(ENV_SECRET_NAME)\n+      .endMetadata()\n+    val secUsername = Base64.encodeBase64String(ENV_SECRET_VALUE_1.getBytes())\n+    val secPassword = Base64.encodeBase64String(ENV_SECRET_VALUE_2.getBytes())\n+    val envSecretData = Map(ENV_SECRET_KEY_1 -> secUsername, ENV_SECRET_KEY_2 -> secPassword)\n+    sb.addToData(envSecretData.asJava)\n+    val envSecret = sb.build()\n+    val sec = kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .createOrReplace(envSecret)\n+    sec\n+  }\n+\n+  private def deleteTestSecret(): Unit = {\n+    kubernetesTestComponents\n+      .kubernetesClient\n+      .secrets()\n+      .withName(ENV_SECRET_NAME)\n+      .delete()\n+  }\n+\n+  test(\"Run SparkPi with env and mount secrets.\") {\n+    createTestSecret()\n+    sparkAppConf\n+      .set(s\"spark.kubernetes.driver.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.driver.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+      .set(s\"spark.kubernetes.executor.secrets.$ENV_SECRET_NAME\", SECRET_MOUNT_PATH)\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.USERNAME\", s\"$ENV_SECRET_NAME:username\")\n+      .set(s\"spark.kubernetes.executor.secretKeyRef.PASSWORD\", s\"$ENV_SECRET_NAME:password\")\n+    try {\n+      runSparkPiAndVerifyCompletion(\n+        driverPodChecker = (driverPod: Pod) => {\n+          doBasicDriverPodCheck(driverPod)\n+          checkSecrets(driverPod)\n+        },\n+        executorPodChecker = (executorPod: Pod) => {\n+          doBasicExecutorPodCheck(executorPod)\n+          checkSecrets(executorPod)\n+        },\n+        appArgs = Array(\"1000\") // give it enough time for all execs to be visible\n+      )\n+    } finally {\n+      // make sure this always run\n+      deleteTestSecret()\n+    }\n+  }\n+\n+  private def checkSecrets(pod: Pod): Unit = {\n+    Eventually.eventually(TIMEOUT, INTERVAL) {\n+      implicit val podName: String = pod.getMetadata.getName\n+      val env = executeCommand(\"env\")\n+      assert(env.toString.contains(ENV_SECRET_VALUE_1))\n+      assert(env.toString.contains(ENV_SECRET_VALUE_2))\n+      val fileUsernameContents = executeCommand(s\"cat\", s\"$SECRET_MOUNT_PATH/$ENV_SECRET_KEY_1\")"
  }],
  "prId": 21652
}]