[{
  "comments": [{
    "author": {
      "login": "erikerlandson"
    },
    "body": "nit - use of `return` in scala is usually considered not good style",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-11T17:28:01Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {\n+        return MinikubeStatus.NONE"
  }],
  "prId": 23520
}, {
  "comments": [{
    "author": {
      "login": "erikerlandson"
    },
    "body": "would this be more readable as `case MinikubeStatus(...)`",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-11T17:31:32Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {\n+        return MinikubeStatus.NONE\n+      }\n+\n+      val hostString = statusString.find(_.contains(\"host: \"))\n+      val kubeletString = statusString.find(_.contains(\"kubelet: \"))\n+      val apiserverString = statusString.find(_.contains(\"apiserver: \"))\n+      val kubectlString = statusString.find(_.contains(\"kubectl: \"))\n+\n+      if (hostString.isEmpty || kubeletString.isEmpty\n+        || apiserverString.isEmpty || kubectlString.isEmpty) {\n+        MinikubeStatus.NONE\n+      } else {\n+        val status1 = hostString.get.replaceFirst(\"host: \", \"\")\n+        val status2 = kubeletString.get.replaceFirst(\"kubelet: \", \"\")\n+        val status3 = apiserverString.get.replaceFirst(\"apiserver: \", \"\")\n+        val status4 = kubectlString.get.replaceFirst(\"kubectl: \", \"\")\n+        if (!status4.contains(\"Correctly Configured:\")) {\n+          MinikubeStatus.NONE\n+        } else {\n+          val stats = List(status1, status2, status3)\n+            .map(MinikubeStatus.unapply)"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Here I am mapping the status string to an enum Value and then parse all values and fail if any of them is not `running`. Scala has a `withName` method to do the mapping to an enum value but in MinikubeStatus there is a custom one named `unapply` that does that. Reason is to better format the exception if mapping cannot be done. Don't see how case MinikubeStatus will help here, could you elaborate more?",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-28T21:37:59Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {\n+        return MinikubeStatus.NONE\n+      }\n+\n+      val hostString = statusString.find(_.contains(\"host: \"))\n+      val kubeletString = statusString.find(_.contains(\"kubelet: \"))\n+      val apiserverString = statusString.find(_.contains(\"apiserver: \"))\n+      val kubectlString = statusString.find(_.contains(\"kubectl: \"))\n+\n+      if (hostString.isEmpty || kubeletString.isEmpty\n+        || apiserverString.isEmpty || kubectlString.isEmpty) {\n+        MinikubeStatus.NONE\n+      } else {\n+        val status1 = hostString.get.replaceFirst(\"host: \", \"\")\n+        val status2 = kubeletString.get.replaceFirst(\"kubelet: \", \"\")\n+        val status3 = apiserverString.get.replaceFirst(\"apiserver: \", \"\")\n+        val status4 = kubectlString.get.replaceFirst(\"kubectl: \", \"\")\n+        if (!status4.contains(\"Correctly Configured:\")) {\n+          MinikubeStatus.NONE\n+        } else {\n+          val stats = List(status1, status2, status3)\n+            .map(MinikubeStatus.unapply)"
  }],
  "prId": 23520
}, {
  "comments": [{
    "author": {
      "login": "erikerlandson"
    },
    "body": "match/case here?",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-11T17:32:08Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {\n+        return MinikubeStatus.NONE\n+      }\n+\n+      val hostString = statusString.find(_.contains(\"host: \"))\n+      val kubeletString = statusString.find(_.contains(\"kubelet: \"))\n+      val apiserverString = statusString.find(_.contains(\"apiserver: \"))\n+      val kubectlString = statusString.find(_.contains(\"kubectl: \"))\n+\n+      if (hostString.isEmpty || kubeletString.isEmpty\n+        || apiserverString.isEmpty || kubectlString.isEmpty) {\n+        MinikubeStatus.NONE\n+      } else {\n+        val status1 = hostString.get.replaceFirst(\"host: \", \"\")\n+        val status2 = kubeletString.get.replaceFirst(\"kubelet: \", \"\")\n+        val status3 = apiserverString.get.replaceFirst(\"apiserver: \", \"\")\n+        val status4 = kubectlString.get.replaceFirst(\"kubectl: \", \"\")\n+        if (!status4.contains(\"Correctly Configured:\")) {\n+          MinikubeStatus.NONE\n+        } else {\n+          val stats = List(status1, status2, status3)\n+            .map(MinikubeStatus.unapply)\n+            .map(_.getOrElse(throw new IllegalStateException(s\"Unknown status $statusString\")))\n+          if (stats.exists(_ != MinikubeStatus.RUNNING)) {\n+            MinikubeStatus.NONE\n+          } else {\n+            MinikubeStatus.RUNNING\n+          }\n+        }\n+      }\n+    } else {\n+      val finalStatusString = oldMinikube\n+        .head\n+        .replaceFirst(\"minikubeVM: \", \"\")\n+        .replaceFirst(\"minikube: \", \"\")\n+      MinikubeStatus.unapply(finalStatusString)",
    "line": 45
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "This code pre-existed I just followed the same style but I can refactor.",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-11T21:46:54Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {\n+        return MinikubeStatus.NONE\n+      }\n+\n+      val hostString = statusString.find(_.contains(\"host: \"))\n+      val kubeletString = statusString.find(_.contains(\"kubelet: \"))\n+      val apiserverString = statusString.find(_.contains(\"apiserver: \"))\n+      val kubectlString = statusString.find(_.contains(\"kubectl: \"))\n+\n+      if (hostString.isEmpty || kubeletString.isEmpty\n+        || apiserverString.isEmpty || kubectlString.isEmpty) {\n+        MinikubeStatus.NONE\n+      } else {\n+        val status1 = hostString.get.replaceFirst(\"host: \", \"\")\n+        val status2 = kubeletString.get.replaceFirst(\"kubelet: \", \"\")\n+        val status3 = apiserverString.get.replaceFirst(\"apiserver: \", \"\")\n+        val status4 = kubectlString.get.replaceFirst(\"kubectl: \", \"\")\n+        if (!status4.contains(\"Correctly Configured:\")) {\n+          MinikubeStatus.NONE\n+        } else {\n+          val stats = List(status1, status2, status3)\n+            .map(MinikubeStatus.unapply)\n+            .map(_.getOrElse(throw new IllegalStateException(s\"Unknown status $statusString\")))\n+          if (stats.exists(_ != MinikubeStatus.RUNNING)) {\n+            MinikubeStatus.NONE\n+          } else {\n+            MinikubeStatus.RUNNING\n+          }\n+        }\n+      }\n+    } else {\n+      val finalStatusString = oldMinikube\n+        .head\n+        .replaceFirst(\"minikubeVM: \", \"\")\n+        .replaceFirst(\"minikube: \", \"\")\n+      MinikubeStatus.unapply(finalStatusString)",
    "line": 45
  }],
  "prId": 23520
}, {
  "comments": [{
    "author": {
      "login": "liyinan926"
    },
    "body": "You might want to add some comment here why to have this check and why number 4.",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-16T20:08:29Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {"
  }],
  "prId": 23520
}, {
  "comments": [{
    "author": {
      "login": "liyinan926"
    },
    "body": "Looks like you can define constants for the various string literals here as they are used more than once.",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-16T20:12:41Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {\n+      if (statusString.length != 4) {\n+        return MinikubeStatus.NONE\n+      }\n+\n+      val hostString = statusString.find(_.contains(\"host: \"))"
  }],
  "prId": 23520
}, {
  "comments": [{
    "author": {
      "login": "liyinan926"
    },
    "body": "This code is a bit hard to read due to the multiple levels of nesting with `if-else` blocks. Can you put the code for the newer versions of Minikube into a separate method?",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-16T20:15:40Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {",
    "line": 38
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "sure",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-28T08:47:24Z",
    "diffHunk": "@@ -38,12 +38,50 @@ private[spark] object Minikube extends Logging {\n \n   def getMinikubeStatus: MinikubeStatus.Value = {\n     val statusString = executeMinikube(\"status\")\n+    logInfo(s\"Minikube status command output:\\n$statusString\")\n+    // up to minikube version 0.30 use this to check for minikube status\n+    val oldMinikube = statusString\n       .filter(line => line.contains(\"minikubeVM: \") || line.contains(\"minikube:\"))\n-      .head\n-      .replaceFirst(\"minikubeVM: \", \"\")\n-      .replaceFirst(\"minikube: \", \"\")\n-    MinikubeStatus.unapply(statusString)\n+\n+    if (oldMinikube.isEmpty) {",
    "line": 38
  }],
  "prId": 23520
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "is searching this specific word a bit fragile?",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-31T06:54:22Z",
    "diffHunk": "@@ -52,13 +66,43 @@ private[spark] object Minikube extends Logging {\n     val kubernetesConf = new ConfigBuilder()\n       .withApiVersion(\"v1\")\n       .withMasterUrl(kubernetesMaster)\n-      .withCaCertFile(Paths.get(userHome, \".minikube\", \"ca.crt\").toFile.getAbsolutePath)\n-      .withClientCertFile(Paths.get(userHome, \".minikube\", \"apiserver.crt\").toFile.getAbsolutePath)\n-      .withClientKeyFile(Paths.get(userHome, \".minikube\", \"apiserver.key\").toFile.getAbsolutePath)\n+      .withCaCertFile(Paths.get(userHome, MINIKUBE_PATH, \"ca.crt\").toFile.getAbsolutePath)\n+      .withClientCertFile(Paths.get(userHome, MINIKUBE_PATH, \"apiserver.crt\").toFile.getAbsolutePath)\n+      .withClientKeyFile(Paths.get(userHome, MINIKUBE_PATH, \"apiserver.key\").toFile.getAbsolutePath)\n       .build()\n     new DefaultKubernetesClient(kubernetesConf)\n   }\n \n+  // Covers minikube status output after Minikube V0.30.\n+  private def getIfNewMinikubeStatus(statusString: Seq[String]): MinikubeStatus.Value = {\n+    val hostString = statusString.find(_.contains(s\"$HOST_PREFIX \"))\n+    val kubeletString = statusString.find(_.contains(s\"$KUBELET_PREFIX \"))\n+    val apiserverString = statusString.find(_.contains(s\"$APISERVER_PREFIX \"))\n+    val kubectlString = statusString.find(_.contains(s\"$KUBECTL_PREFIX \"))\n+\n+    if (hostString.isEmpty || kubeletString.isEmpty\n+      || apiserverString.isEmpty || kubectlString.isEmpty) {\n+      MinikubeStatus.NONE\n+    } else {\n+      val status1 = hostString.get.replaceFirst(s\"$HOST_PREFIX \", \"\")\n+      val status2 = kubeletString.get.replaceFirst(s\"$KUBELET_PREFIX \", \"\")\n+      val status3 = apiserverString.get.replaceFirst(s\"$APISERVER_PREFIX \", \"\")\n+      val status4 = kubectlString.get.replaceFirst(s\"$KUBECTL_PREFIX \", \"\")\n+      if (!status4.contains(\"Correctly Configured:\")) {",
    "line": 80
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Maybe, I dont know. It matters I guess to be correctly configured but of course the message could change in the future. Hard to say... but on the other hand they have changed recently the format why should they change that message again. Btw If we see any issues we can always update the logic. If there are no other issues could you merge it?",
    "commit": "97eff33376925fb7f67df2fe6a32710aa06d1d22",
    "createdAt": "2019-01-31T10:21:13Z",
    "diffHunk": "@@ -52,13 +66,43 @@ private[spark] object Minikube extends Logging {\n     val kubernetesConf = new ConfigBuilder()\n       .withApiVersion(\"v1\")\n       .withMasterUrl(kubernetesMaster)\n-      .withCaCertFile(Paths.get(userHome, \".minikube\", \"ca.crt\").toFile.getAbsolutePath)\n-      .withClientCertFile(Paths.get(userHome, \".minikube\", \"apiserver.crt\").toFile.getAbsolutePath)\n-      .withClientKeyFile(Paths.get(userHome, \".minikube\", \"apiserver.key\").toFile.getAbsolutePath)\n+      .withCaCertFile(Paths.get(userHome, MINIKUBE_PATH, \"ca.crt\").toFile.getAbsolutePath)\n+      .withClientCertFile(Paths.get(userHome, MINIKUBE_PATH, \"apiserver.crt\").toFile.getAbsolutePath)\n+      .withClientKeyFile(Paths.get(userHome, MINIKUBE_PATH, \"apiserver.key\").toFile.getAbsolutePath)\n       .build()\n     new DefaultKubernetesClient(kubernetesConf)\n   }\n \n+  // Covers minikube status output after Minikube V0.30.\n+  private def getIfNewMinikubeStatus(statusString: Seq[String]): MinikubeStatus.Value = {\n+    val hostString = statusString.find(_.contains(s\"$HOST_PREFIX \"))\n+    val kubeletString = statusString.find(_.contains(s\"$KUBELET_PREFIX \"))\n+    val apiserverString = statusString.find(_.contains(s\"$APISERVER_PREFIX \"))\n+    val kubectlString = statusString.find(_.contains(s\"$KUBECTL_PREFIX \"))\n+\n+    if (hostString.isEmpty || kubeletString.isEmpty\n+      || apiserverString.isEmpty || kubectlString.isEmpty) {\n+      MinikubeStatus.NONE\n+    } else {\n+      val status1 = hostString.get.replaceFirst(s\"$HOST_PREFIX \", \"\")\n+      val status2 = kubeletString.get.replaceFirst(s\"$KUBELET_PREFIX \", \"\")\n+      val status3 = apiserverString.get.replaceFirst(s\"$APISERVER_PREFIX \", \"\")\n+      val status4 = kubectlString.get.replaceFirst(s\"$KUBECTL_PREFIX \", \"\")\n+      if (!status4.contains(\"Correctly Configured:\")) {",
    "line": 80
  }],
  "prId": 23520
}]