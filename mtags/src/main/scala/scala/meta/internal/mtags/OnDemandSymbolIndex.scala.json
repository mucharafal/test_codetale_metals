[
  {
    "id" : "a11c68df-754b-448f-9ce8-d15be5504a82",
    "prId" : 332,
    "comments" : [
      {
        "id" : "7b32b53c-eb6b-4978-9ee2-3755f1265ce5",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I would add a reference to the note from above, where you list the limitations of this approach.",
        "createdAt" : "2018-10-14T20:23:47Z",
        "updatedAt" : "2018-10-17T09:17:09Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "889b282a30a7ddd72b09da4b9328f7779b1cfae9",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,190 @@\n+package scala.meta.internal.mtags\n+\n+import java.nio.CharBuffer\n+import java.nio.charset.StandardCharsets\n+import scala.collection.mutable\n+import scala.meta.inputs.Input\n+import scala.meta.internal.io.PathIO\n+import scala.meta.internal.{semanticdb => s}\n+import scala.meta.io.AbsolutePath\n+import scala.meta.io.Classpath\n+import scala.meta.internal.mtags.Enrichments._\n+import scala.meta.internal.io._\n+import scala.meta.internal.semanticdb.Scala._\n+\n+/**\n+ * An implementation of GlobalSymbolIndex with fast indexing and low memory usage.\n+ *\n+ * Fast indexing is enabled by ScalaToplevelMtags, a custom parser that extracts\n+ * only toplevel symbols from a Scala source file. Java source files don't need indexing\n+ * because their file location can be inferred from the symbol itself."
  },
  {
    "id" : "3c85d9c1-e3d1-4477-99ac-981074f879d0",
    "prId" : 332,
    "comments" : [
      {
        "id" : "3a5484d0-dfd5-4467-903c-6c294dde356d",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Can this be accessed concurrently? Maybe using an `AtomicInteger` would be safer.",
        "createdAt" : "2018-10-14T20:26:39Z",
        "updatedAt" : "2018-10-17T09:17:09Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "889b282a30a7ddd72b09da4b9328f7779b1cfae9",
    "line" : 41,
    "diffHunk" : "@@ -0,0 +1,190 @@\n+package scala.meta.internal.mtags\n+\n+import java.nio.CharBuffer\n+import java.nio.charset.StandardCharsets\n+import scala.collection.mutable\n+import scala.meta.inputs.Input\n+import scala.meta.internal.io.PathIO\n+import scala.meta.internal.{semanticdb => s}\n+import scala.meta.io.AbsolutePath\n+import scala.meta.io.Classpath\n+import scala.meta.internal.mtags.Enrichments._\n+import scala.meta.internal.io._\n+import scala.meta.internal.semanticdb.Scala._\n+\n+/**\n+ * An implementation of GlobalSymbolIndex with fast indexing and low memory usage.\n+ *\n+ * Fast indexing is enabled by ScalaToplevelMtags, a custom parser that extracts\n+ * only toplevel symbols from a Scala source file. Java source files don't need indexing\n+ * because their file location can be inferred from the symbol itself.\n+ *\n+ * Low memory usage is enabled by only storing \"non-trivial toplevel\" symbols.\n+ * A symbol is \"toplevel\" when its owner is a package. A symbol is \"non-trivial\"\n+ * when it doesn't match the path of the file it's defined in, for example `Some#`\n+ * in Option.scala is non-trivial while `Option#` in Option.scala is trivial.\n+ *\n+ * @param toplevels keys are non-trivial toplevel symbols and values are the file\n+ *                  the symbols are defined in.\n+ * @param definitions keys are global symbols and the values are the files the symbols\n+ *                    are defined in. Difference between toplevels and definitions\n+ *                    is that toplevels contains only symbols generated by ScalaToplevelMtags\n+ *                    while definitions contains only symbols generated by ScalaMtags.\n+ */\n+final case class OnDemandSymbolIndex(\n+    toplevels: mutable.Map[String, AbsolutePath] = mutable.Map.empty,\n+    definitions: mutable.Map[String, AbsolutePath] = mutable.Map.empty\n+) extends GlobalSymbolIndex {\n+  val mtags = new Mtags\n+  private val sourceJars = new ClasspathLoader(Classpath(Nil))\n+  var indexedSources = 0L"
  },
  {
    "id" : "3f60f441-7b38-496a-8eaa-267ebff01ddc",
    "prId" : 763,
    "comments" : [
      {
        "id" : "29bca0f4-12f5-4ca1-8c35-3fb51a4f3cc8",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I'm not sure what was happening here, but it seemed that this `ListFiles` was being shadowed by `scala.meta.internal.io.ListFiles`",
        "createdAt" : "2019-06-13T11:18:46Z",
        "updatedAt" : "2019-06-18T18:13:44Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8b8f8c663ffe7481455869fe747514f96e7e658b",
    "line" : null,
    "diffHunk" : "@@ -11,6 +11,7 @@ import scala.meta.internal.semanticdb.Scala._\n import scala.meta.internal.{semanticdb => s}\n import scala.meta.io.AbsolutePath\n import scala.util.control.NonFatal\n+import scala.meta.internal.mtags.ListFiles"
  },
  {
    "id" : "0bcf753e-d389-4eb3-adb1-a8b00d013a2b",
    "prId" : 763,
    "comments" : [
      {
        "id" : "e2d27c63-9318-403e-b631-4d690ddb2dec",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Why do we do `ListFiles => _` here? I don't see any change conencted to that.",
        "createdAt" : "2019-06-18T19:03:50Z",
        "updatedAt" : "2019-06-18T19:09:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "495ead39-4686-48ea-89b0-1c7fab0dcb76",
        "parentId" : "e2d27c63-9318-403e-b631-4d690ddb2dec",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Great question, I don't know ðŸ˜…\r\nOn Scala 2.13 the `ListFiles` from `scala.meta.internal.io` takes precedence over our `ListFiles` so it doesn't compile.",
        "createdAt" : "2019-06-18T19:18:55Z",
        "updatedAt" : "2019-06-18T19:18:56Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "44e4e028-277d-477d-8a2f-cd7bc2b93e67",
        "parentId" : "e2d27c63-9318-403e-b631-4d690ddb2dec",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Ach alright, I didn't know we had multiples of that. Thanks!",
        "createdAt" : "2019-06-18T19:22:29Z",
        "updatedAt" : "2019-06-18T19:22:29Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8b8f8c663ffe7481455869fe747514f96e7e658b",
    "line" : 5,
    "diffHunk" : "@@ -5,7 +5,7 @@ import java.nio.charset.StandardCharsets\n import scala.collection.concurrent.TrieMap\n import scala.meta.inputs.Input\n import scala.meta.internal.io.PathIO\n-import scala.meta.internal.io._\n+import scala.meta.internal.io.{ListFiles => _, _}"
  },
  {
    "id" : "301718c7-cfe8-44d9-8249-7143c0d606c5",
    "prId" : 954,
    "comments" : [
      {
        "id" : "c851f83f-0927-498f-a1c1-35d3a4fa4fc7",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "I think it can be further simplified. This exception is already handled in the `tryRun`, so it seems that there is no need to wrap the `root.listRecursive` in try statement:\r\nWe can just leave it at:\r\n```scala\r\nroot.listRecursive.foreach {\r\n  case source if source.isScala =>\r\n    try addSourceFile(source, None)\r\n    catch {\r\n      case NonFatal(e) => onError.lift(IndexError(source, e))\r\n    }\r\n  case _ =>\r\n}\r\n```",
        "createdAt" : "2019-10-03T07:11:44Z",
        "updatedAt" : "2019-10-03T11:05:56Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b613d4d00d446042c5af74801473c4c8388a1acf",
    "line" : null,
    "diffHunk" : "@@ -53,15 +54,18 @@ final case class OnDemandSymbolIndex(\n   override def addSourceJar(jar: AbsolutePath): Unit = tryRun {\n     if (sourceJars.addEntry(jar)) {\n       FileIO.withJarFileSystem(jar, create = false) { root =>\n-        root.listRecursive.foreach {\n-          case source if source.isScala =>\n-            try {\n-              addSourceFile(source, None)\n-            } catch {\n-              case NonFatal(e) =>\n-                onError.lift(IndexError(source, e))\n-            }\n-          case _ =>\n+        try {\n+          root.listRecursive.foreach {\n+            case source if source.isScala =>\n+              try addSourceFile(source, None)\n+              catch {\n+                case NonFatal(e) => onError.lift(IndexError(source, e))\n+              }\n+            case _ =>\n+          }\n+        } catch {\n+          case e: NoSuchFileException =>\n+            onError(e)"
  },
  {
    "id" : "690b5602-7276-40fd-a5eb-faa6375a776e",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "16acd0fe-4d17-4a18-8ea2-df477e88c05f",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Not 100% sure, but we use Scalameta parser here to create TextDocument on the fly. Shouldn't it also work with `sc` files, but a proper syntax? Or does Scalameta parser not support `.sc` files? Or are the changes so radical that we would need to have a custom one? \r\n\r\nI am worried there can be a race condition between when the file is indexed and senabticDB files is created.",
        "createdAt" : "2020-03-31T17:27:48Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "69db76f0-f1e4-4f9b-9fbb-c28e9a3b1f3f",
        "parentId" : "16acd0fe-4d17-4a18-8ea2-df477e88c05f",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Just fixed that.",
        "createdAt" : "2020-04-05T22:14:41Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -145,6 +146,9 @@ final case class OnDemandSymbolIndex(\n         val input = file.toInput\n         val document = mtags.index(language, input)\n         s.TextDocuments(List(document))\n+      case \"sc\" =>\n+        val res = semanticdb(file)"
  }
]