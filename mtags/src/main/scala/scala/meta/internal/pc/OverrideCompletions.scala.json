[
  {
    "id" : "8a03c66b-4632-4aa2-95ad-b9e03c314032",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "e79cdbd3-c43f-407d-95f4-01fd1d462053",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "The followings code comes from `Completions.scala`",
        "createdAt" : "2020-02-03T07:06:25Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 14,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember("
  },
  {
    "id" : "05daa547-b325-4b3f-b95b-74f7f9a59cd8",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "4e1098db-8ccb-45ac-a949-9bda716674aa",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Extracted the logic to calculate the list of `OverrideDefMember` so that this method can be used from both\r\n- `case class Override`\r\n- `implementAll()`",
        "createdAt" : "2020-02-03T07:08:29Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 106,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers("
  },
  {
    "id" : "1ab40e4c-ce4a-4dbd-bd3a-e6796a222bcf",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "47d07c89-59a5-4d78-a113-bc1662cb0d80",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "The following codes are new ones.",
        "createdAt" : "2020-02-03T07:09:09Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 294,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+"
  },
  {
    "id" : "627d10e2-77b7-4523-a389-81ddc9eafbfc",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "4c5c03a2-efd6-41c6-a193-4900264647fe",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Find the position of the opening brace for the Template. Since `Template` always has both the opening and closing braces, it's safe, I guess.\r\n\r\nDoes anybody have a better idea to find a good position to insert implements? 🤔 ",
        "createdAt" : "2020-02-03T07:13:13Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      // if the both opening/closing braces located in a line:\n+      //\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      //\n+      // add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val end =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end)) \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            s\"\\n${indent}\",\n+            s\"\\n${indent}\",\n+            s\"$end\"\n+          )\n+      )\n+      implementAll :: allAbstractImports.toList\n+    } else {\n+      Nil\n+    }\n+  }\n+\n+  /**\n+   * Get the position of the opening brace of given Template.\n+   * insert implementations onto the top of the body.\n+   *\n+   * @param text the text of the original source code.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   */\n+  private def inferEditPosition(text: String, t: Template): Position = {\n+    val start = t.pos.start\n+    val end = t.pos.end\n+    val offset = text.indexOf('{', start) + 1\n+    t.pos.withStart(offset).withEnd(offset)"
  },
  {
    "id" : "78ca6d86-1b09-4c02-9e27-2959f9a9c28a",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "6856d68b-8c3c-461e-a67d-7dce0fe69f4e",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "For the class/object that has defined in one line like this:\r\n\r\n```scala\r\nclass Foo extends Bar {}\r\n```\r\n\r\nWe have to add a newline and proper indent at the end of implements for the sake of pretty result like:\r\n\r\n```scala\r\nobject X {\r\n  class Foo extends Bar {\r\n    override def foo(x: Int): Int = ??? \r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\nOtherwise, the result looks something like \r\n\r\n```scala\r\nobject X {\r\n  class Foo extends Bar {\r\n    override def foo(x: Int): Int = ???}\r\n}\r\n\r\n// or \r\n\r\nobject X {\r\n  class Foo extends Bar {\r\n    override def foo(x: Int): Int = ???\r\n}\r\n}\r\n```",
        "createdAt" : "2020-02-03T07:18:07Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      // if the both opening/closing braces located in a line:\n+      //\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      //\n+      // add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val end =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end)) \"\\n\" + \" \" * necessaryIndent"
  },
  {
    "id" : "af1b4b44-45a3-44aa-ae23-25821ff9d5e8",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "efe68866-b17b-484d-8c83-44c952d03382",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Find the explicit declaration in the class/object so that we can infer the indent from them.\r\n\r\n```scala\r\nobject X {\r\n  trait Foo {\r\n    def foo(x: Int): Int\r\n  }\r\n  class Bar extends Foo {\r\n               val x = 1\r\n  }\r\n}\r\n```\r\n\r\nto \r\n\r\n```scala\r\nobject X {\r\n  // ...\r\n  class Bar extends Foo {\r\n          override def foo(x: Int): Int = ???\r\n          val x = 1\r\n  }\r\n}\r\n```\r\n\r\ninstead of \r\n\r\n```scala\r\nobject X {\r\n  // ...\r\n  class Bar extends Foo {\r\n    override def foo(x: Int): Int = ???\r\n          val x = 1\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n**Removing primary constructor** by `sym.pos.line != t.pos.line`, because if it remains and infers the indent from that, the result will be\r\n\r\n```scala\r\nobject X {\r\n  // ...\r\n  class Bar(init: Int) extends Foo {\r\n  override def foo(x: Int): Int = ???\r\n          val x = 1\r\n  }\r\n}\r\n```\r\n\r\nI thought it could be filtered out using `!sym.isPrimaryConstructor` but it remains 🤔 ",
        "createdAt" : "2020-02-03T07:26:01Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 398,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )"
  },
  {
    "id" : "251dd5ef-1542-430d-9a72-810601869e9f",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "1093b170-acd4-4804-ab96-6ef9fac67cf9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "What about:\r\n```\r\nobject Foo extends Bar {}\r\n```\r\n?",
        "createdAt" : "2020-02-03T15:55:14Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e07c4279-435e-4896-ba94-ff74339cdce6",
        "parentId" : "1093b170-acd4-4804-ab96-6ef9fac67cf9",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Oops, I missed that situation, we have to add the following case:\r\n\r\n```scala\r\ncase (m: ModuleDef) :: _ =>\r\n  // ...\r\n```\r\n\r\nto capture object's definition. ",
        "createdAt" : "2020-02-08T06:11:48Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b4b23422-7500-4dde-baa7-753c534ca7fd",
        "parentId" : "1093b170-acd4-4804-ab96-6ef9fac67cf9",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done in https://github.com/scalameta/metals/pull/1379/commits/0bd0092ecb6890e62d2b137b085fed55d4db5473 :)",
        "createdAt" : "2020-02-08T07:56:16Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 318,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>"
  },
  {
    "id" : "e914e74e-dbf4-4bb1-a2d8-6663779704a3",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "34f39e18-d1ab-47ce-a568-9ab3e1d46769",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "What if we don't have {} and it's just `class Foo extends Bar` ?",
        "createdAt" : "2020-02-03T16:44:05Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a1f8093e-54d3-425c-9da5-3c01aeffc64d",
        "parentId" : "34f39e18-d1ab-47ce-a568-9ab3e1d46769",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "I missed dealing with that case. Now, in that case, we don't add any implements on the class/object.\r\n\r\nProbably, we should add necessary braces and complete it to\r\n\r\n```scala\r\ntrait Bar {\r\n  def bar(x: Int): Int\r\n}\r\n\r\nclass Foo extends Bar\r\n\r\n// to\r\n\r\nclass Foo extends Bar {\r\n  override def  bar(x: Int): Int\r\n}\r\n```",
        "createdAt" : "2020-02-08T06:30:59Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c514671-4f4d-4790-975a-2ac0a120b8fe",
        "parentId" : "34f39e18-d1ab-47ce-a568-9ab3e1d46769",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done https://github.com/scalameta/metals/pull/1379/commits/4edcdc60dbfd90b00b1d3eafca9de07e598fa353 :)\r\nFor the object creation: `val foo = new Foo`, the diagnostic message is `trait Foo is abstract; cannot be instantiated`. It doesn't match \"missing implementation\" kind of error message, and so there's no quickfix available for that situation.",
        "createdAt" : "2020-02-08T07:55:45Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      // if the both opening/closing braces located in a line:\n+      //\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      //\n+      // add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val end =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end)) \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            s\"\\n${indent}\",\n+            s\"\\n${indent}\",\n+            s\"$end\"\n+          )\n+      )\n+      implementAll :: allAbstractImports.toList\n+    } else {\n+      Nil\n+    }\n+  }\n+\n+  /**\n+   * Get the position of the opening brace of given Template.\n+   * insert implementations onto the top of the body.\n+   *\n+   * @param text the text of the original source code.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   */\n+  private def inferEditPosition(text: String, t: Template): Position = {\n+    val start = t.pos.start\n+    val end = t.pos.end\n+    val offset = text.indexOf('{', start) + 1"
  },
  {
    "id" : "64947af0-f025-406e-bcd3-e41a57ae3dbe",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "3c604ea2-2b9f-4ed4-9357-9eead8d747ba",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "all the cases are nearly identical in their implementation, the only difference is how they extract a tree. Can we maybe extract it to a utility method taking a Tree as input?",
        "createdAt" : "2020-02-09T21:36:49Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9c52e1de-9c61-460d-9784-4507b2dc21c0",
        "parentId" : "3c604ea2-2b9f-4ed4-9357-9eead8d747ba",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done in https://github.com/scalameta/metals/pull/1379/commits/761a52952d7d9138cba683bbbd1c638723889903\r\nThank you for your advice, it's much clear :)",
        "createdAt" : "2020-02-10T15:40:48Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 324,
    "diffHunk" : "@@ -0,0 +1,506 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // object Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (m: ModuleDef) :: _ =>"
  },
  {
    "id" : "daab25b3-7530-4ca2-878c-7e18565406c6",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "0b1f9158-831f-4f44-8cba-65dd42cfc5e6",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "defaultIndent (lowercase D)?",
        "createdAt" : "2020-02-09T21:41:04Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5a87860d-d1f1-4d32-96a6-f4c9eddb006b",
        "parentId" : "0b1f9158-831f-4f44-8cba-65dd42cfc5e6",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Personally, I usually use upper camel case for constants https://docs.scala-lang.org/style/naming-conventions.html#constants-values-variable-and-methods, and [metals seem that it also follow this naming convention](https://github.com/scalameta/metals/blob/60e3d151dd80f0def1a122ff54e5c2f9e805e6cb/metals/src/main/scala/scala/meta/internal/metals/ClientExperimentalCapabilities.scala#L12).\r\n\r\nI don't have a strong opinion around a naming convention, but what do you think about this? :)",
        "createdAt" : "2020-02-10T07:01:12Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "83226296-4d85-4882-9767-41344905bd60",
        "parentId" : "0b1f9158-831f-4f44-8cba-65dd42cfc5e6",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I don't mind either, let's leave it like this 👍 ",
        "createdAt" : "2020-02-10T15:34:34Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 12,
    "diffHunk" : "@@ -0,0 +1,506 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2"
  },
  {
    "id" : "9d53ecbb-8b27-40bd-87d7-6cf37db89788",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "ac348e9f-b9bf-4783-a8a8-103189c0855b",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n    if (hasBody(text,t))\r\n```\r\nWe could reuse logic from `hasBody`",
        "createdAt" : "2020-02-10T16:01:33Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "73faac61-14d8-4e86-85bb-406ebc33e6d6",
        "parentId" : "ac348e9f-b9bf-4783-a8a8-103189c0855b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done https://github.com/scalameta/metals/pull/1379/commits/15d8e1feba9aed6cce18d9f6b74382f464b8be1e :)\r\n\r\nModified the `hasBody`'s return type to `Option[Int]` so that we can reuse `hasBody` from `inferEditPosition`.",
        "createdAt" : "2020-02-11T07:14:21Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,489 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+\n+    def implementAllFor(\n+        t: Template\n+    ): List[l.TextEdit] = {\n+      val typed = typedTreeAt(t.pos)\n+      implementAll(\n+        typed,\n+        inferEditPosition(text, t).toLSP,\n+        t,\n+        text,\n+        true,\n+        _ => true\n+      )\n+    }\n+\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        implementAllFor(t)\n+\n+      // object Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (m: ModuleDef) :: _ =>\n+        val t = m.impl\n+        implementAllFor(t)\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      val shouldCompleteBraces = !hasBody(text, t)\n+\n+      // if the both opening/closing braces located in a line:\n+      // ```\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      // ```\n+      // or there's no body like this `class Foo extends Bar`.\n+      // Add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val lastIndent =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end) || shouldCompleteBraces)\n+          \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      // Add opening/closing braces\n+      // `object Foo extends Bar` to\n+      // ```\n+      // object Foo extends Bar {\n+      //   override def method: Int = ???\n+      // }\n+      // ```\n+      val start = if (shouldCompleteBraces) s\" {\\n${indent}\" else s\"\\n${indent}\"\n+      val end = if (shouldCompleteBraces) s\"${lastIndent}}\" else lastIndent\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            start,\n+            s\"\\n${indent}\",\n+            end\n+          )\n+      )\n+      implementAll :: allAbstractImports.toList\n+    } else {\n+      Nil\n+    }\n+  }\n+\n+  /**\n+   * Get the position to insert implements for the given Template.\n+   * `class Foo extends Bar {}` => retuning position would be right after the opening brace.\n+   * `class Foo extends Bar` => retuning position would be right after `Bar`.\n+   *\n+   * @param text the text of the original source code.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   */\n+  private def inferEditPosition(text: String, t: Template): Position = {\n+    val start = t.pos.start\n+    val end = t.pos.end\n+    val offset = text.indexOf('{', start)\n+    if (offset > 0 && offset < t.pos.end)"
  },
  {
    "id" : "7d4569ae-e794-4c91-bd5d-d6935092c094",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Let's maybe add another newline between members?\r\n\r\nIt's usually what people would want I think.\r\n\r\nSo instead of:\r\n```\r\nclass A {\r\n  def a = ???\r\n  def b = ???\r\n}\r\n```\r\nwe would have:\r\n```\r\nclass A {\r\n\r\n  def a = ???\r\n  \r\n  def b = ???\r\n\r\n}\r\n```\r\n\r\nI would also consider maybe newline at the start or end.",
        "createdAt" : "2020-02-10T16:26:48Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9157eb71-3feb-44ca-98d2-98ac172376ed",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Personally, I prefer the dense result (without empty lines), but meanwhile, the intellij-scala-plugin seems to add empty lines between methods, and it's probably better to add empty lines as you suggested 👍 so that users from IntelliJ can easily get used to Metals.\r\n\r\ndone  https://github.com/scalameta/metals/pull/1379/commits/505297812bb80adea74f10428bc226678b6af8c2",
        "createdAt" : "2020-02-11T06:59:24Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3141c9df-fa97-4e03-8f40-2b2dc961632a",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "So one thing to think about with this is now we have the \"completion\" version giving you the condensed version with no spaces and the \"code action\" version giving extra spaces. I sort of think we should be consistent.",
        "createdAt" : "2020-02-11T07:52:18Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "52d1c4e4-0be0-4f0e-b543-53691e9f3c24",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "> I sort of think we should be consistent.\r\n\r\nAh, that's correct, I'm still leaning toward add spaces for both codeaction and completions.\r\nWhat do you think about this ?",
        "createdAt" : "2020-02-11T10:52:47Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74137c2a-a23b-44cb-8785-f80193bb5b4b",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "For reference, added spaces between abstract members for completion-version https://github.com/scalameta/metals/pull/1379/commits/e100253dce0a50a1201510f9bec11fbe8f298bbb :)\r\nWe can revert it if we don't need it.",
        "createdAt" : "2020-02-11T11:12:28Z",
        "updatedAt" : "2020-02-11T11:12:29Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b33d72dc-632c-4231-bc55-7b43cd95d16b",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "I don't have a strong preference on it. I just thing whichever one we choose we should do it the same in both. I'd say leave them they way you have them 👍 ",
        "createdAt" : "2020-02-11T12:11:56Z",
        "updatedAt" : "2020-02-11T12:11:56Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,489 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"🔼 \"\n+          else \"⏫ \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+\n+    def implementAllFor(\n+        t: Template\n+    ): List[l.TextEdit] = {\n+      val typed = typedTreeAt(t.pos)\n+      implementAll(\n+        typed,\n+        inferEditPosition(text, t).toLSP,\n+        t,\n+        text,\n+        true,\n+        _ => true\n+      )\n+    }\n+\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        implementAllFor(t)\n+\n+      // object Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (m: ModuleDef) :: _ =>\n+        val t = m.impl\n+        implementAllFor(t)\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      val shouldCompleteBraces = !hasBody(text, t)\n+\n+      // if the both opening/closing braces located in a line:\n+      // ```\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      // ```\n+      // or there's no body like this `class Foo extends Bar`.\n+      // Add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val lastIndent =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end) || shouldCompleteBraces)\n+          \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      // Add opening/closing braces\n+      // `object Foo extends Bar` to\n+      // ```\n+      // object Foo extends Bar {\n+      //   override def method: Int = ???\n+      // }\n+      // ```\n+      val start = if (shouldCompleteBraces) s\" {\\n${indent}\" else s\"\\n${indent}\"\n+      val end = if (shouldCompleteBraces) s\"${lastIndent}}\" else lastIndent\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            start,\n+            s\"\\n${indent}\","
  }
]