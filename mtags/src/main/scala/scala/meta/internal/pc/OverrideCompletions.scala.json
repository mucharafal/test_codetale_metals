[
  {
    "id" : "8a03c66b-4632-4aa2-95ad-b9e03c314032",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "e79cdbd3-c43f-407d-95f4-01fd1d462053",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "The followings code comes from `Completions.scala`",
        "createdAt" : "2020-02-03T07:06:25Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 14,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember("
  },
  {
    "id" : "05daa547-b325-4b3f-b95b-74f7f9a59cd8",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "4e1098db-8ccb-45ac-a949-9bda716674aa",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Extracted the logic to calculate the list of `OverrideDefMember` so that this method can be used from both\r\n- `case class Override`\r\n- `implementAll()`",
        "createdAt" : "2020-02-03T07:08:29Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 106,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers("
  },
  {
    "id" : "1ab40e4c-ce4a-4dbd-bd3a-e6796a222bcf",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "47d07c89-59a5-4d78-a113-bc1662cb0d80",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "The following codes are new ones.",
        "createdAt" : "2020-02-03T07:09:09Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 294,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+"
  },
  {
    "id" : "627d10e2-77b7-4523-a389-81ddc9eafbfc",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "4c5c03a2-efd6-41c6-a193-4900264647fe",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Find the position of the opening brace for the Template. Since `Template` always has both the opening and closing braces, it's safe, I guess.\r\n\r\nDoes anybody have a better idea to find a good position to insert implements? ðŸ¤” ",
        "createdAt" : "2020-02-03T07:13:13Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      // if the both opening/closing braces located in a line:\n+      //\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      //\n+      // add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val end =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end)) \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            s\"\\n${indent}\",\n+            s\"\\n${indent}\",\n+            s\"$end\"\n+          )\n+      )\n+      implementAll :: allAbstractImports.toList\n+    } else {\n+      Nil\n+    }\n+  }\n+\n+  /**\n+   * Get the position of the opening brace of given Template.\n+   * insert implementations onto the top of the body.\n+   *\n+   * @param text the text of the original source code.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   */\n+  private def inferEditPosition(text: String, t: Template): Position = {\n+    val start = t.pos.start\n+    val end = t.pos.end\n+    val offset = text.indexOf('{', start) + 1\n+    t.pos.withStart(offset).withEnd(offset)"
  },
  {
    "id" : "78ca6d86-1b09-4c02-9e27-2959f9a9c28a",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "6856d68b-8c3c-461e-a67d-7dce0fe69f4e",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "For the class/object that has defined in one line like this:\r\n\r\n```scala\r\nclass Foo extends Bar {}\r\n```\r\n\r\nWe have to add a newline and proper indent at the end of implements for the sake of pretty result like:\r\n\r\n```scala\r\nobject X {\r\n  class Foo extends Bar {\r\n    override def foo(x: Int): Int = ??? \r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\nOtherwise, the result looks something like \r\n\r\n```scala\r\nobject X {\r\n  class Foo extends Bar {\r\n    override def foo(x: Int): Int = ???}\r\n}\r\n\r\n// or \r\n\r\nobject X {\r\n  class Foo extends Bar {\r\n    override def foo(x: Int): Int = ???\r\n}\r\n}\r\n```",
        "createdAt" : "2020-02-03T07:18:07Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      // if the both opening/closing braces located in a line:\n+      //\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      //\n+      // add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val end =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end)) \"\\n\" + \" \" * necessaryIndent"
  },
  {
    "id" : "af1b4b44-45a3-44aa-ae23-25821ff9d5e8",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "efe68866-b17b-484d-8c83-44c952d03382",
        "parentId" : null,
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Find the explicit declaration in the class/object so that we can infer the indent from them.\r\n\r\n```scala\r\nobject X {\r\n  trait Foo {\r\n    def foo(x: Int): Int\r\n  }\r\n  class Bar extends Foo {\r\n               val x = 1\r\n  }\r\n}\r\n```\r\n\r\nto \r\n\r\n```scala\r\nobject X {\r\n  // ...\r\n  class Bar extends Foo {\r\n          override def foo(x: Int): Int = ???\r\n          val x = 1\r\n  }\r\n}\r\n```\r\n\r\ninstead of \r\n\r\n```scala\r\nobject X {\r\n  // ...\r\n  class Bar extends Foo {\r\n    override def foo(x: Int): Int = ???\r\n          val x = 1\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n**Removing primary constructor** by `sym.pos.line != t.pos.line`, because if it remains and infers the indent from that, the result will be\r\n\r\n```scala\r\nobject X {\r\n  // ...\r\n  class Bar(init: Int) extends Foo {\r\n  override def foo(x: Int): Int = ???\r\n          val x = 1\r\n  }\r\n}\r\n```\r\n\r\nI thought it could be filtered out using `!sym.isPrimaryConstructor` but it remains ðŸ¤” ",
        "createdAt" : "2020-02-03T07:26:01Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 398,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )"
  },
  {
    "id" : "251dd5ef-1542-430d-9a72-810601869e9f",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "1093b170-acd4-4804-ab96-6ef9fac67cf9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "What about:\r\n```\r\nobject Foo extends Bar {}\r\n```\r\n?",
        "createdAt" : "2020-02-03T15:55:14Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e07c4279-435e-4896-ba94-ff74339cdce6",
        "parentId" : "1093b170-acd4-4804-ab96-6ef9fac67cf9",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Oops, I missed that situation, we have to add the following case:\r\n\r\n```scala\r\ncase (m: ModuleDef) :: _ =>\r\n  // ...\r\n```\r\n\r\nto capture object's definition. ",
        "createdAt" : "2020-02-08T06:11:48Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b4b23422-7500-4dde-baa7-753c534ca7fd",
        "parentId" : "1093b170-acd4-4804-ab96-6ef9fac67cf9",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done in https://github.com/scalameta/metals/pull/1379/commits/0bd0092ecb6890e62d2b137b085fed55d4db5473 :)",
        "createdAt" : "2020-02-08T07:56:16Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 318,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>"
  },
  {
    "id" : "e914e74e-dbf4-4bb1-a2d8-6663779704a3",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "34f39e18-d1ab-47ce-a568-9ab3e1d46769",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "What if we don't have {} and it's just `class Foo extends Bar` ?",
        "createdAt" : "2020-02-03T16:44:05Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a1f8093e-54d3-425c-9da5-3c01aeffc64d",
        "parentId" : "34f39e18-d1ab-47ce-a568-9ab3e1d46769",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "I missed dealing with that case. Now, in that case, we don't add any implements on the class/object.\r\n\r\nProbably, we should add necessary braces and complete it to\r\n\r\n```scala\r\ntrait Bar {\r\n  def bar(x: Int): Int\r\n}\r\n\r\nclass Foo extends Bar\r\n\r\n// to\r\n\r\nclass Foo extends Bar {\r\n  override def  bar(x: Int): Int\r\n}\r\n```",
        "createdAt" : "2020-02-08T06:30:59Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c514671-4f4d-4790-975a-2ac0a120b8fe",
        "parentId" : "34f39e18-d1ab-47ce-a568-9ab3e1d46769",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done https://github.com/scalameta/metals/pull/1379/commits/4edcdc60dbfd90b00b1d3eafca9de07e598fa353 :)\r\nFor the object creation: `val foo = new Foo`, the diagnostic message is `trait Foo is abstract; cannot be instantiated`. It doesn't match \"missing implementation\" kind of error message, and so there's no quickfix available for that situation.",
        "createdAt" : "2020-02-08T07:55:45Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,461 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      // if the both opening/closing braces located in a line:\n+      //\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      //\n+      // add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val end =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end)) \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            s\"\\n${indent}\",\n+            s\"\\n${indent}\",\n+            s\"$end\"\n+          )\n+      )\n+      implementAll :: allAbstractImports.toList\n+    } else {\n+      Nil\n+    }\n+  }\n+\n+  /**\n+   * Get the position of the opening brace of given Template.\n+   * insert implementations onto the top of the body.\n+   *\n+   * @param text the text of the original source code.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   */\n+  private def inferEditPosition(text: String, t: Template): Position = {\n+    val start = t.pos.start\n+    val end = t.pos.end\n+    val offset = text.indexOf('{', start) + 1"
  },
  {
    "id" : "64947af0-f025-406e-bcd3-e41a57ae3dbe",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "3c604ea2-2b9f-4ed4-9357-9eead8d747ba",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "all the cases are nearly identical in their implementation, the only difference is how they extract a tree. Can we maybe extract it to a utility method taking a Tree as input?",
        "createdAt" : "2020-02-09T21:36:49Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9c52e1de-9c61-460d-9784-4507b2dc21c0",
        "parentId" : "3c604ea2-2b9f-4ed4-9357-9eead8d747ba",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done in https://github.com/scalameta/metals/pull/1379/commits/761a52952d7d9138cba683bbbd1c638723889903\r\nThank you for your advice, it's much clear :)",
        "createdAt" : "2020-02-10T15:40:48Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 324,
    "diffHunk" : "@@ -0,0 +1,506 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        val typed = typedTreeAt(t.pos)\n+        implementAll(\n+          typed,\n+          inferEditPosition(text, t).toLSP,\n+          t,\n+          text,\n+          true,\n+          _ => true\n+        )\n+\n+      // object Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (m: ModuleDef) :: _ =>"
  },
  {
    "id" : "daab25b3-7530-4ca2-878c-7e18565406c6",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "0b1f9158-831f-4f44-8cba-65dd42cfc5e6",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "defaultIndent (lowercase D)?",
        "createdAt" : "2020-02-09T21:41:04Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5a87860d-d1f1-4d32-96a6-f4c9eddb006b",
        "parentId" : "0b1f9158-831f-4f44-8cba-65dd42cfc5e6",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Personally, I usually use upper camel case for constants https://docs.scala-lang.org/style/naming-conventions.html#constants-values-variable-and-methods, and [metals seem that it also follow this naming convention](https://github.com/scalameta/metals/blob/60e3d151dd80f0def1a122ff54e5c2f9e805e6cb/metals/src/main/scala/scala/meta/internal/metals/ClientExperimentalCapabilities.scala#L12).\r\n\r\nI don't have a strong opinion around a naming convention, but what do you think about this? :)",
        "createdAt" : "2020-02-10T07:01:12Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "83226296-4d85-4882-9767-41344905bd60",
        "parentId" : "0b1f9158-831f-4f44-8cba-65dd42cfc5e6",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I don't mind either, let's leave it like this ðŸ‘ ",
        "createdAt" : "2020-02-10T15:34:34Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : 12,
    "diffHunk" : "@@ -0,0 +1,506 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2"
  },
  {
    "id" : "9d53ecbb-8b27-40bd-87d7-6cf37db89788",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "ac348e9f-b9bf-4783-a8a8-103189c0855b",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n    if (hasBody(text,t))\r\n```\r\nWe could reuse logic from `hasBody`",
        "createdAt" : "2020-02-10T16:01:33Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "73faac61-14d8-4e86-85bb-406ebc33e6d6",
        "parentId" : "ac348e9f-b9bf-4783-a8a8-103189c0855b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "done https://github.com/scalameta/metals/pull/1379/commits/15d8e1feba9aed6cce18d9f6b74382f464b8be1e :)\r\n\r\nModified the `hasBody`'s return type to `Option[Int]` so that we can reuse `hasBody` from `inferEditPosition`.",
        "createdAt" : "2020-02-11T07:14:21Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,489 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+\n+    def implementAllFor(\n+        t: Template\n+    ): List[l.TextEdit] = {\n+      val typed = typedTreeAt(t.pos)\n+      implementAll(\n+        typed,\n+        inferEditPosition(text, t).toLSP,\n+        t,\n+        text,\n+        true,\n+        _ => true\n+      )\n+    }\n+\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        implementAllFor(t)\n+\n+      // object Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (m: ModuleDef) :: _ =>\n+        val t = m.impl\n+        implementAllFor(t)\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      val shouldCompleteBraces = !hasBody(text, t)\n+\n+      // if the both opening/closing braces located in a line:\n+      // ```\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      // ```\n+      // or there's no body like this `class Foo extends Bar`.\n+      // Add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val lastIndent =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end) || shouldCompleteBraces)\n+          \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      // Add opening/closing braces\n+      // `object Foo extends Bar` to\n+      // ```\n+      // object Foo extends Bar {\n+      //   override def method: Int = ???\n+      // }\n+      // ```\n+      val start = if (shouldCompleteBraces) s\" {\\n${indent}\" else s\"\\n${indent}\"\n+      val end = if (shouldCompleteBraces) s\"${lastIndent}}\" else lastIndent\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            start,\n+            s\"\\n${indent}\",\n+            end\n+          )\n+      )\n+      implementAll :: allAbstractImports.toList\n+    } else {\n+      Nil\n+    }\n+  }\n+\n+  /**\n+   * Get the position to insert implements for the given Template.\n+   * `class Foo extends Bar {}` => retuning position would be right after the opening brace.\n+   * `class Foo extends Bar` => retuning position would be right after `Bar`.\n+   *\n+   * @param text the text of the original source code.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   */\n+  private def inferEditPosition(text: String, t: Template): Position = {\n+    val start = t.pos.start\n+    val end = t.pos.end\n+    val offset = text.indexOf('{', start)\n+    if (offset > 0 && offset < t.pos.end)"
  },
  {
    "id" : "7d4569ae-e794-4c91-bd5d-d6935092c094",
    "prId" : 1379,
    "comments" : [
      {
        "id" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Let's maybe add another newline between members?\r\n\r\nIt's usually what people would want I think.\r\n\r\nSo instead of:\r\n```\r\nclass A {\r\n  def a = ???\r\n  def b = ???\r\n}\r\n```\r\nwe would have:\r\n```\r\nclass A {\r\n\r\n  def a = ???\r\n  \r\n  def b = ???\r\n\r\n}\r\n```\r\n\r\nI would also consider maybe newline at the start or end.",
        "createdAt" : "2020-02-10T16:26:48Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9157eb71-3feb-44ca-98d2-98ac172376ed",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "Personally, I prefer the dense result (without empty lines), but meanwhile, the intellij-scala-plugin seems to add empty lines between methods, and it's probably better to add empty lines as you suggested ðŸ‘ so that users from IntelliJ can easily get used to Metals.\r\n\r\ndone  https://github.com/scalameta/metals/pull/1379/commits/505297812bb80adea74f10428bc226678b6af8c2",
        "createdAt" : "2020-02-11T06:59:24Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3141c9df-fa97-4e03-8f40-2b2dc961632a",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "So one thing to think about with this is now we have the \"completion\" version giving you the condensed version with no spaces and the \"code action\" version giving extra spaces. I sort of think we should be consistent.",
        "createdAt" : "2020-02-11T07:52:18Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "52d1c4e4-0be0-4f0e-b543-53691e9f3c24",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "> I sort of think we should be consistent.\r\n\r\nAh, that's correct, I'm still leaning toward add spaces for both codeaction and completions.\r\nWhat do you think about this ?",
        "createdAt" : "2020-02-11T10:52:47Z",
        "updatedAt" : "2020-02-11T11:11:05Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74137c2a-a23b-44cb-8785-f80193bb5b4b",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "body" : "For reference, added spaces between abstract members for completion-version https://github.com/scalameta/metals/pull/1379/commits/e100253dce0a50a1201510f9bec11fbe8f298bbb :)\r\nWe can revert it if we don't need it.",
        "createdAt" : "2020-02-11T11:12:28Z",
        "updatedAt" : "2020-02-11T11:12:29Z",
        "lastEditedBy" : {
          "login" : "tanishiking",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/9353584?u=c3e5aba60a43901e7d2b7c0ea4caac06cde77049&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b33d72dc-632c-4231-bc55-7b43cd95d16b",
        "parentId" : "5a763e6e-2e65-4269-90bc-cf15d415aa5b",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "I don't have a strong preference on it. I just thing whichever one we choose we should do it the same in both. I'd say leave them they way you have them ðŸ‘ ",
        "createdAt" : "2020-02-11T12:11:56Z",
        "updatedAt" : "2020-02-11T12:11:56Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e100253dce0a50a1201510f9bec11fbe8f298bbb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,489 @@\n+package scala.meta.internal.pc\n+\n+import scala.meta.pc.PresentationCompilerConfig.OverrideDefFormat\n+\n+import org.eclipse.{lsp4j => l}\n+\n+import scala.collection.mutable\n+import scala.collection.immutable.Nil\n+\n+trait OverrideCompletions { this: MetalsGlobal =>\n+\n+  private val DefaultIndent = 2\n+\n+  class OverrideDefMember(\n+      val label: String,\n+      val edit: l.TextEdit,\n+      val filterText: String,\n+      sym: Symbol,\n+      val autoImports: List[l.TextEdit],\n+      val detail: String\n+  ) extends ScopeMember(sym, NoType, true, EmptyTree)\n+\n+  /**\n+   * An `override def` completion to implement methods from the supertype.\n+   *\n+   * @param name the name of the method being completed including the `_CURSOR_` suffix.\n+   * @param t the enclosing template for the class/object/trait we are implementing.\n+   * @param pos the position of the completion request, points to `_CURSOR_`.\n+   * @param text the text of the original source code without `_CURSOR_`.\n+   * @param start the position start of the completion.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   */\n+  case class Override(\n+      name: Name,\n+      t: Template,\n+      pos: Position,\n+      text: String,\n+      start: Int,\n+      isCandidate: Symbol => Boolean\n+  ) extends CompletionPosition {\n+    val prefix: String = name.toString.stripSuffix(CURSOR)\n+    val typed: Tree = typedTreeAt(t.pos)\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    val range: l.Range = pos.withStart(start).withEnd(pos.point).toLSP\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+\n+    override def contribute: List[Member] = {\n+      if (start < 0) {\n+        Nil\n+      } else {\n+        val overrideMembers = getMembers(\n+          typed,\n+          range,\n+          pos,\n+          text,\n+          text.startsWith(\"o\", start),\n+          true,\n+          isCandidate\n+        )\n+\n+        val overrideDefMembers: List[OverrideDefMember] =\n+          overrideMembers\n+            .filter { candidate =>\n+              CompletionFuzzy.matchesSubCharacters(\n+                prefix,\n+                candidate.filterText\n+              )\n+            }\n+\n+        val allAbstractMembers = overrideMembers\n+          .filter(_.sym.isAbstract)\n+\n+        val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+        if (allAbstractMembers.length > 1 && overrideDefMembers.length > 1) {\n+          val necessaryIndent = if (metalsConfig.snippetAutoIndent()) {\n+            \"\"\n+          } else {\n+            val amount =\n+              allAbstractEdits.head.getRange.getStart.getCharacter\n+            \" \" * amount\n+          }\n+\n+          val implementAll: TextEditMember = new TextEditMember(\n+            prefix,\n+            new l.TextEdit(\n+              range,\n+              allAbstractEdits\n+                .map(_.getNewText)\n+                .mkString(s\"\\n${necessaryIndent}\")\n+            ),\n+            completionsSymbol(\"implement\"),\n+            label = Some(\"Implement all members\"),\n+            detail = Some(s\" (${allAbstractEdits.length} total)\"),\n+            additionalTextEdits = allAbstractImports.toList\n+          )\n+\n+          implementAll :: overrideDefMembers\n+        } else {\n+          overrideDefMembers\n+        }\n+      }\n+    }\n+  }\n+\n+  private def getMembers(\n+      typed: Tree,\n+      range: l.Range,\n+      pos: Position,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      shouldMoveCursor: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[OverrideDefMember] = {\n+\n+    // Returns all the symbols of all transitive supertypes in the enclosing scope.\n+    // For example:\n+    // class Main extends Serializable {\n+    //   class Inner {\n+    //     // parentSymbols: List(Main, Serializable, Inner)\n+    //   }\n+    // }\n+    def parentSymbols(context: Context): collection.Set[Symbol] = {\n+      val isVisited = mutable.Set.empty[Symbol]\n+      var cx = context\n+\n+      def expandParent(parent: Symbol): Unit = {\n+        if (!isVisited(parent)) {\n+          isVisited.add(parent)\n+          parent.parentSymbols.foreach { parent =>\n+            expandParent(parent)\n+          }\n+        }\n+      }\n+\n+      while (cx != NoContext && !cx.owner.hasPackageFlag) {\n+        expandParent(cx.owner)\n+        cx = cx.outer\n+      }\n+      isVisited\n+    }\n+\n+    val lineStart: RunId = pos.source.lineToOffset(pos.line - 1)\n+    val context: Context = doLocateContext(pos)\n+    val baseAutoImport: Option[AutoImportPosition] =\n+      autoImportPosition(pos, text)\n+    val autoImport: AutoImportPosition = baseAutoImport.getOrElse(\n+      AutoImportPosition(\n+        lineStart,\n+        inferIndent(lineStart, text),\n+        padTop = false\n+      )\n+    )\n+    val importContext: Context =\n+      if (baseAutoImport.isDefined)\n+        doLocateImportContext(pos, baseAutoImport)\n+      else context\n+    val re: scala.collection.Map[Symbol, Name] = renamedSymbols(context)\n+    val owners: scala.collection.Set[Symbol] = parentSymbols(context)\n+\n+    val isDecl: Set[Symbol] = typed.tpe.decls.toSet\n+    def isOverridableMethod(sym: Symbol): Boolean = {\n+      sym.isMethod &&\n+      !isDecl(sym) &&\n+      !isNotOverridableName(sym.name) &&\n+      !sym.isPrivate &&\n+      !sym.isSynthetic &&\n+      !sym.isArtifact &&\n+      !sym.isEffectivelyFinal &&\n+      !sym.name.endsWith(CURSOR) &&\n+      !sym.isConstructor &&\n+      (!isVarSetter(sym) || (isVarSetter(sym) && sym.isAbstract)) &&\n+      !sym.isSetter &&\n+      isCandidate(sym)\n+    }\n+\n+    case class OverrideCandidate(sym: Symbol) {\n+      val memberType: Type = typed.tpe.memberType(sym)\n+      val info: Type =\n+        if (memberType.isErroneous) sym.info\n+        else {\n+          memberType match {\n+            case m: MethodType => m\n+            case m: NullaryMethodType => m\n+            case m @ PolyType(_, _: MethodType) => m\n+            case _ => sym.info\n+          }\n+        }\n+\n+      val history = new ShortenedNames(\n+        lookupSymbol = { name =>\n+          context.lookupSymbol(name, _ => true) :: Nil\n+        },\n+        config = renameConfig,\n+        renames = re,\n+        owners = owners\n+      )\n+\n+      val printer = new SignaturePrinter(\n+        sym,\n+        history,\n+        info,\n+        includeDocs = false,\n+        includeDefaultParam = false,\n+        printLongType = false\n+      )\n+\n+      val overrideKeyword: String =\n+        if (!sym.isAbstract || shouldAddOverrideKwd) \"override \"\n+        // Don't insert `override` keyword if the supermethod is abstract and the\n+        // user did not explicitly type starting with o . See:\n+        // https://github.com/scalameta/metals/issues/565#issuecomment-472761240\n+        else \"\"\n+\n+      val lzy: String =\n+        if (sym.isLazy) \"lazy \"\n+        else \"\"\n+\n+      val keyword: String =\n+        if (isVarSetter(sym)) \"var \"\n+        else if (sym.isStable) \"val \"\n+        else \"def \"\n+\n+      val asciOverrideDef: String = {\n+        if (sym.isAbstract) keyword\n+        else s\"${overrideKeyword}${keyword}\"\n+      }\n+\n+      val overrideDef: String = metalsConfig.overrideDefFormat() match {\n+        case OverrideDefFormat.Unicode =>\n+          if (sym.isAbstract) \"ðŸ”¼ \"\n+          else \"â« \"\n+        case _ => asciOverrideDef\n+      }\n+\n+      val name: String = Identifier(sym.name)\n+\n+      val filterText: String = s\"${overrideKeyword}${lzy}${keyword}${name}\"\n+\n+      // if we had no val or def then filter will be empty\n+      def toMember = new OverrideDefMember(\n+        label,\n+        edit,\n+        filterText,\n+        sym,\n+        history.autoImports(\n+          pos,\n+          importContext,\n+          autoImport.offset,\n+          autoImport.indent,\n+          autoImport.padTop\n+        ),\n+        details\n+      )\n+\n+      private def label = overrideDef + name + signature\n+      private def details = asciOverrideDef + name + signature\n+      private def signature = printer.defaultMethodSignature()\n+      private def edit = new l.TextEdit(\n+        range,\n+        if (clientSupportsSnippets && shouldMoveCursor) {\n+          s\"$filterText$signature = $${0:???}\"\n+        } else {\n+          s\"$filterText$signature = ???\"\n+        }\n+      )\n+    }\n+\n+    typed.tpe.members.iterator.toList\n+      .filter(isOverridableMethod)\n+      .map(OverrideCandidate.apply)\n+      .map(_.toMember)\n+  }\n+\n+  private def toEdits(\n+      allAbstractMembers: List[OverrideDefMember]\n+  ): (List[l.TextEdit], Set[l.TextEdit]) = {\n+    allAbstractMembers.foldLeft(\n+      (List.empty[l.TextEdit], Set.empty[l.TextEdit])\n+    ) { (editsAndImports, overrideDefMember) =>\n+      val edits = overrideDefMember.edit :: editsAndImports._1\n+      val imports = overrideDefMember.autoImports.toSet ++ editsAndImports\n+        ._2\n+      (edits, imports)\n+    }\n+  }\n+\n+  // NOTE(gabro): sym.isVar does not work consistently across Scala versions\n+  // Specifically, it behaves differently between 2.11 and 2.12/2.13\n+  // This check is borrowed from\n+  // https://github.com/scala/scala/blob/f389823ef0416612a0058a80c1fe85948ff5fc0a/src/reflect/scala/reflect/internal/Symbols.scala#L2645\n+  private def isVarSetter(sym: Symbol): Boolean =\n+    !sym.isStable && !sym.isLazy && sym.isAccessor\n+\n+  def implementAllAt(pos: Position, text: String): List[l.TextEdit] = {\n+\n+    def implementAllFor(\n+        t: Template\n+    ): List[l.TextEdit] = {\n+      val typed = typedTreeAt(t.pos)\n+      implementAll(\n+        typed,\n+        inferEditPosition(text, t).toLSP,\n+        t,\n+        text,\n+        true,\n+        _ => true\n+      )\n+    }\n+\n+    // make sure the compilation unit is loaded\n+    typedTreeAt(pos)\n+\n+    lastVisistedParentTrees match {\n+\n+      // class Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (c: ClassDef) :: _ =>\n+        val t = c.impl\n+        implementAllFor(t)\n+\n+      // object Foo extends Bar {}\n+      // ~~~~~~~~~~~~~~~~~~~~~~~~\n+      case (m: ModuleDef) :: _ =>\n+        val t = m.impl\n+        implementAllFor(t)\n+\n+      // new Foo {}\n+      //     ~~~~~~\n+      case (_: Ident) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      // new Foo[T] {}\n+      //     ~~~~~~~~~\n+      case (_: Ident) ::\n+            (_: AppliedTypeTree) ::\n+            (t: Template) :: _ =>\n+        implementAllFor(t)\n+\n+      case _ =>\n+        Nil\n+    }\n+  }\n+\n+  /**\n+   * Get text edits for an `override def` completion to implement methods from the supertype.\n+   *\n+   * @param typed the typed tree: template for the class/object we are implementing.\n+   * @param range the position to fill the completions.\n+   * @param t the enclosing template for the class/object we are implementing.\n+   * @param text the text of the original source code.\n+   * @param shouldAddOverrideKwd if it's true, completion add `override` for each methods.\n+   * @param isCandidate the determination of whether the symbol will be a possible completion item.\n+   * @return the list of TextEdit of both method implementations and auto imports.\n+   */\n+  private def implementAll(\n+      typed: Tree,\n+      range: l.Range,\n+      t: Template,\n+      text: String,\n+      shouldAddOverrideKwd: Boolean,\n+      isCandidate: Symbol => Boolean\n+  ): List[l.TextEdit] = {\n+    val overrideMembers = getMembers(\n+      typed,\n+      range,\n+      t.pos,\n+      text,\n+      true,\n+      false,\n+      isCandidate\n+    )\n+\n+    val allAbstractMembers = overrideMembers\n+      .filter(_.sym.isAbstract)\n+\n+    val (allAbstractEdits, allAbstractImports) = toEdits(allAbstractMembers)\n+\n+    if (allAbstractEdits.length > 0) {\n+\n+      // infer necessary indent\n+      //\n+      // |object Test {\n+      // |    class Foo extends Bar {} // inferred to 4\n+      // |}\n+      val lineStart = t.pos.source.lineToOffset(t.pos.line - 1)\n+      val necessaryIndent = inferIndent(lineStart, text)\n+\n+      // infer indent for implementations\n+      // if there's declaration in the class/object, follow its indent.\n+      // otherwise the indent default to 2\n+      val indent = typed.tpe.decls\n+        .filter(sym =>\n+          !sym.isSynthetic &&\n+            !sym.isPrimaryConstructor &&\n+            sym.pos.line != t.pos.line // filter out explicit primary constructor `class Foo(x: Int) ...`\n+        )\n+        .headOption\n+        .map(existing => {\n+          \" \" * inferIndent(\n+            t.pos.source.lineToOffset(existing.pos.line - 1),\n+            text\n+          )\n+        })\n+        .getOrElse {\n+          \" \" * (necessaryIndent + DefaultIndent)\n+        }\n+\n+      val shouldCompleteBraces = !hasBody(text, t)\n+\n+      // if the both opening/closing braces located in a line:\n+      // ```\n+      // object {\n+      //   class Foo extends Bar {}\n+      // }\n+      // ```\n+      // or there's no body like this `class Foo extends Bar`.\n+      // Add an newline and indent in the end of implementations, so that\n+      // the closing brace is indented.\n+      //\n+      // object {\n+      //   class Foo extends Bar {\n+      //     override def foo = ???\n+      //   }\n+      // }\n+      val lastIndent =\n+        if (t.pos.source.offsetToLine(t.pos.start) ==\n+            t.pos.source.offsetToLine(t.pos.end) || shouldCompleteBraces)\n+          \"\\n\" + \" \" * necessaryIndent\n+        else \"\"\n+\n+      // Add opening/closing braces\n+      // `object Foo extends Bar` to\n+      // ```\n+      // object Foo extends Bar {\n+      //   override def method: Int = ???\n+      // }\n+      // ```\n+      val start = if (shouldCompleteBraces) s\" {\\n${indent}\" else s\"\\n${indent}\"\n+      val end = if (shouldCompleteBraces) s\"${lastIndent}}\" else lastIndent\n+      val implementAll = new l.TextEdit(\n+        range,\n+        allAbstractEdits\n+          .map(_.getNewText)\n+          .mkString(\n+            start,\n+            s\"\\n${indent}\","
  }
]