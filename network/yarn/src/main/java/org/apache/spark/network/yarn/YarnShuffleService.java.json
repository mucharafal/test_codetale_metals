[{
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "yarn supports giving you a recoveryPath.  Did you not want to use that to support older versions that don't have nm recovery?\n",
    "commit": "0d285d3fac15afc77313255799a3392dcf74518f",
    "createdAt": "2015-08-05T15:42:25Z",
    "diffHunk": "@@ -100,11 +127,34 @@ private boolean isAuthenticationEnabled() {\n    */\n   @Override\n   protected void serviceInit(Configuration conf) {\n+\n+    // In case this NM was killed while there were running spark applications, we need to restore\n+    // lost state for the existing executors.  We look for an existing file in the NM's local dirs.\n+    // If we don't find one, then we choose a file to use to save the state next time.  However, we\n+    // do *not* immediately register all the executors in that file, just in case the application\n+    // was terminated while the NM was restarting.  We wait until yarn tells the service about the\n+    // app again via #initializeApplication, so we know its still running.  That is important\n+    // for preventing a leak where the app data would stick around *forever*.  This does leave\n+    // a small race -- if the NM restarts *again*, after only some of the existing apps have been\n+    // re-registered, the info of the remaining apps is lost.\n+    registeredExecutorFile =\n+      findRegisteredExecutorFile(conf.getStrings(\"yarn.nodemanager.local-dirs\"));"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "yes, precisely.  I suppose I could use reflection to see if `getRecoveryPath` is available, and if not, then fall back on this mechanism.  But since I want this to work w/out `getRecoveryPath` in any case, is there any advantage to using it when its available?  maybe its a little safer when its around?\n",
    "commit": "0d285d3fac15afc77313255799a3392dcf74518f",
    "createdAt": "2015-08-05T16:10:40Z",
    "diffHunk": "@@ -100,11 +127,34 @@ private boolean isAuthenticationEnabled() {\n    */\n   @Override\n   protected void serviceInit(Configuration conf) {\n+\n+    // In case this NM was killed while there were running spark applications, we need to restore\n+    // lost state for the existing executors.  We look for an existing file in the NM's local dirs.\n+    // If we don't find one, then we choose a file to use to save the state next time.  However, we\n+    // do *not* immediately register all the executors in that file, just in case the application\n+    // was terminated while the NM was restarting.  We wait until yarn tells the service about the\n+    // app again via #initializeApplication, so we know its still running.  That is important\n+    // for preventing a leak where the app data would stick around *forever*.  This does leave\n+    // a small race -- if the NM restarts *again*, after only some of the existing apps have been\n+    // re-registered, the info of the remaining apps is lost.\n+    registeredExecutorFile =\n+      findRegisteredExecutorFile(conf.getStrings(\"yarn.nodemanager.local-dirs\"));"
  }],
  "prId": 7943
}]