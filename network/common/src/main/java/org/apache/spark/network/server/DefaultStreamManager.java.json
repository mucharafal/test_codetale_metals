[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can u explain what curChunk is\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T22:17:15Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.server;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+\n+/**\n+ * StreamManager which allows registration of an Iterator<ManagedBuffer>, which are individually\n+ * fetched as chunks by the client.\n+ */\n+public class DefaultStreamManager extends StreamManager {\n+  private final Logger logger = LoggerFactory.getLogger(DefaultStreamManager.class);\n+\n+  private final AtomicLong nextStreamId;\n+  private final Map<Long, StreamState> streams;\n+\n+  /** State of a single stream. */\n+  private static class StreamState {\n+    final Iterator<ManagedBuffer> buffers;\n+\n+    int curChunk = 0;"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "e.g. it is used to track current chunk index and to prevent out of order blah blah\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T22:19:05Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.server;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+\n+/**\n+ * StreamManager which allows registration of an Iterator<ManagedBuffer>, which are individually\n+ * fetched as chunks by the client.\n+ */\n+public class DefaultStreamManager extends StreamManager {\n+  private final Logger logger = LoggerFactory.getLogger(DefaultStreamManager.class);\n+\n+  private final AtomicLong nextStreamId;\n+  private final Map<Long, StreamState> streams;\n+\n+  /** State of a single stream. */\n+  private static class StreamState {\n+    final Iterator<ManagedBuffer> buffers;\n+\n+    int curChunk = 0;"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "update the comment to explain this is only for debugging purposes and the system actually does not need the guarantee that stream id is unique\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T22:18:45Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.server;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+\n+/**\n+ * StreamManager which allows registration of an Iterator<ManagedBuffer>, which are individually\n+ * fetched as chunks by the client.\n+ */\n+public class DefaultStreamManager extends StreamManager {\n+  private final Logger logger = LoggerFactory.getLogger(DefaultStreamManager.class);\n+\n+  private final AtomicLong nextStreamId;\n+  private final Map<Long, StreamState> streams;\n+\n+  /** State of a single stream. */\n+  private static class StreamState {\n+    final Iterator<ManagedBuffer> buffers;\n+\n+    int curChunk = 0;\n+\n+    StreamState(Iterator<ManagedBuffer> buffers) {\n+      this.buffers = buffers;\n+    }\n+  }\n+\n+  public DefaultStreamManager() {\n+    // Start with a random stream id to help identifying different streams."
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can u add javadoc explaining this method and unregisterStream?\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T22:21:43Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.server;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+\n+/**\n+ * StreamManager which allows registration of an Iterator<ManagedBuffer>, which are individually\n+ * fetched as chunks by the client.\n+ */\n+public class DefaultStreamManager extends StreamManager {\n+  private final Logger logger = LoggerFactory.getLogger(DefaultStreamManager.class);\n+\n+  private final AtomicLong nextStreamId;\n+  private final Map<Long, StreamState> streams;\n+\n+  /** State of a single stream. */\n+  private static class StreamState {\n+    final Iterator<ManagedBuffer> buffers;\n+\n+    int curChunk = 0;\n+\n+    StreamState(Iterator<ManagedBuffer> buffers) {\n+      this.buffers = buffers;\n+    }\n+  }\n+\n+  public DefaultStreamManager() {\n+    // Start with a random stream id to help identifying different streams.\n+    nextStreamId = new AtomicLong((long) new Random().nextInt(Integer.MAX_VALUE) * 1000);\n+    streams = new ConcurrentHashMap<Long, StreamState>();\n+  }\n+\n+  @Override\n+  public ManagedBuffer getChunk(long streamId, int chunkIndex) {\n+    StreamState state = streams.get(streamId);\n+    if (chunkIndex != state.curChunk) {\n+      throw new IllegalStateException(String.format(\n+        \"Received out-of-order chunk index %s (expected %s)\", chunkIndex, state.curChunk));\n+    } else if (!state.buffers.hasNext()) {\n+      throw new IllegalStateException(String.format(\n+        \"Requested chunk index beyond end %s\", chunkIndex));\n+    }\n+    state.curChunk += 1;\n+    ManagedBuffer nextChunk = state.buffers.next();\n+\n+    if (!state.buffers.hasNext()) {\n+      logger.trace(\"Removing stream id {}\", streamId);\n+      streams.remove(streamId);\n+    }\n+\n+    return nextChunk;\n+  }\n+\n+  @Override\n+  public void connectionTerminated(long streamId) {\n+    // Release all remaining buffers.\n+    StreamState state = streams.remove(streamId);\n+    if (state != null && state.buffers != null) {\n+      while (state.buffers.hasNext()) {\n+        state.buffers.next().release();\n+      }\n+    }\n+  }\n+\n+  public long registerStream(Iterator<ManagedBuffer> buffers) {"
  }],
  "prId": 2753
}]