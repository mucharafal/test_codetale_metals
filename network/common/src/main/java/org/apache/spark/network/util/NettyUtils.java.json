[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nitpick: space after switch\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-14T06:58:39Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import java.util.concurrent.ThreadFactory;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.epoll.EpollServerSocketChannel;\n+import io.netty.channel.epoll.EpollSocketChannel;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.ByteToMessageDecoder;\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n+\n+/**\n+ * Utilities for creating various Netty constructs based on whether we're using EPOLL or NIO.\n+ */\n+public class NettyUtils {\n+  /** Creates a Netty EventLoopGroup based on the IOMode. */\n+  public static EventLoopGroup createEventLoop(IOMode mode, int numThreads, String threadPrefix) {\n+    if (mode == IOMode.AUTO) {\n+      mode = autoselectMode();\n+    }\n+\n+    ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+        .setDaemon(true)\n+        .setNameFormat(threadPrefix + \"-%d\")\n+        .build();\n+\n+    switch(mode) {"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nitpick: space after switch\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-14T06:58:42Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import java.util.concurrent.ThreadFactory;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.epoll.EpollServerSocketChannel;\n+import io.netty.channel.epoll.EpollSocketChannel;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.ByteToMessageDecoder;\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n+\n+/**\n+ * Utilities for creating various Netty constructs based on whether we're using EPOLL or NIO.\n+ */\n+public class NettyUtils {\n+  /** Creates a Netty EventLoopGroup based on the IOMode. */\n+  public static EventLoopGroup createEventLoop(IOMode mode, int numThreads, String threadPrefix) {\n+    if (mode == IOMode.AUTO) {\n+      mode = autoselectMode();\n+    }\n+\n+    ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+        .setDaemon(true)\n+        .setNameFormat(threadPrefix + \"-%d\")\n+        .build();\n+\n+    switch(mode) {\n+      case NIO:\n+        return new NioEventLoopGroup(numThreads, threadFactory);\n+      case EPOLL:\n+        return new EpollEventLoopGroup(numThreads, threadFactory);\n+      default:\n+        throw new IllegalArgumentException(\"Unknown io mode: \" + mode);\n+    }\n+  }\n+\n+  /** Returns the correct (client) SocketChannel class based on IOMode. */\n+  public static Class<? extends Channel> getClientChannelClass(IOMode mode) {\n+    if (mode == IOMode.AUTO) {\n+      mode = autoselectMode();\n+    }\n+    switch(mode) {"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nitpick: space after switch\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-14T06:58:45Z",
    "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import java.util.concurrent.ThreadFactory;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.epoll.EpollServerSocketChannel;\n+import io.netty.channel.epoll.EpollSocketChannel;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.ByteToMessageDecoder;\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n+\n+/**\n+ * Utilities for creating various Netty constructs based on whether we're using EPOLL or NIO.\n+ */\n+public class NettyUtils {\n+  /** Creates a Netty EventLoopGroup based on the IOMode. */\n+  public static EventLoopGroup createEventLoop(IOMode mode, int numThreads, String threadPrefix) {\n+    if (mode == IOMode.AUTO) {\n+      mode = autoselectMode();\n+    }\n+\n+    ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+        .setDaemon(true)\n+        .setNameFormat(threadPrefix + \"-%d\")\n+        .build();\n+\n+    switch(mode) {\n+      case NIO:\n+        return new NioEventLoopGroup(numThreads, threadFactory);\n+      case EPOLL:\n+        return new EpollEventLoopGroup(numThreads, threadFactory);\n+      default:\n+        throw new IllegalArgumentException(\"Unknown io mode: \" + mode);\n+    }\n+  }\n+\n+  /** Returns the correct (client) SocketChannel class based on IOMode. */\n+  public static Class<? extends Channel> getClientChannelClass(IOMode mode) {\n+    if (mode == IOMode.AUTO) {\n+      mode = autoselectMode();\n+    }\n+    switch(mode) {\n+      case NIO:\n+        return NioSocketChannel.class;\n+      case EPOLL:\n+        return EpollSocketChannel.class;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown io mode: \" + mode);\n+    }\n+  }\n+\n+  /** Returns the correct ServerSocketChannel class based on IOMode. */\n+  public static Class<? extends ServerChannel> getServerChannelClass(IOMode mode) {\n+    if (mode == IOMode.AUTO) {\n+      mode = autoselectMode();\n+    }\n+    switch(mode) {"
  }],
  "prId": 2753
}]