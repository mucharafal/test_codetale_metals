[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Looks `AbstractResponseMessage` is not necessary if we move `createFailureResponse` to `ResponseMessage`.\n",
    "commit": "31f52e0b5014bd1d14a812b032778b0bda21f5d3",
    "createdAt": "2015-11-30T18:46:12Z",
    "diffHunk": "@@ -17,23 +17,15 @@\n \n package org.apache.spark.network.protocol;\n \n-import com.google.common.base.Objects;\n-import io.netty.buffer.ByteBuf;\n-\n import org.apache.spark.network.buffer.ManagedBuffer;\n-import org.apache.spark.network.buffer.NettyManagedBuffer;\n \n /**\n- * Abstract class for response messages that contain a large data portion kept in a separate\n- * buffer. These messages are treated especially by MessageEncoder.\n+ * Abstract class for response messages.\n  */\n-public abstract class ResponseWithBody implements ResponseMessage {\n-  public final ManagedBuffer body;\n-  public final boolean isBodyInFrame;\n+public abstract class AbstractResponseMessage extends AbstractMessage implements ResponseMessage {",
    "line": 18
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "That would require dummy implementations in `ChunkFetchFailure`, `RpcFailure` and `StreamFailure`...\n\nI actually don't see a lot of value in having separate interfaces for `ResponseMessage` and `RequestMessage`; this is not Scala, so you can't have a `sealed trait` and have the compiler help you when you miss something in a match. So you could just have `Message` with no need for any of the other interfaces / abstract classes. But I didn't want to do that cleanup in this change.\n",
    "commit": "31f52e0b5014bd1d14a812b032778b0bda21f5d3",
    "createdAt": "2015-11-30T19:15:28Z",
    "diffHunk": "@@ -17,23 +17,15 @@\n \n package org.apache.spark.network.protocol;\n \n-import com.google.common.base.Objects;\n-import io.netty.buffer.ByteBuf;\n-\n import org.apache.spark.network.buffer.ManagedBuffer;\n-import org.apache.spark.network.buffer.NettyManagedBuffer;\n \n /**\n- * Abstract class for response messages that contain a large data portion kept in a separate\n- * buffer. These messages are treated especially by MessageEncoder.\n+ * Abstract class for response messages.\n  */\n-public abstract class ResponseWithBody implements ResponseMessage {\n-  public final ManagedBuffer body;\n-  public final boolean isBodyInFrame;\n+public abstract class AbstractResponseMessage extends AbstractMessage implements ResponseMessage {",
    "line": 18
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "okey, let's keep it.\n",
    "commit": "31f52e0b5014bd1d14a812b032778b0bda21f5d3",
    "createdAt": "2015-11-30T20:04:28Z",
    "diffHunk": "@@ -17,23 +17,15 @@\n \n package org.apache.spark.network.protocol;\n \n-import com.google.common.base.Objects;\n-import io.netty.buffer.ByteBuf;\n-\n import org.apache.spark.network.buffer.ManagedBuffer;\n-import org.apache.spark.network.buffer.NettyManagedBuffer;\n \n /**\n- * Abstract class for response messages that contain a large data portion kept in a separate\n- * buffer. These messages are treated especially by MessageEncoder.\n+ * Abstract class for response messages.\n  */\n-public abstract class ResponseWithBody implements ResponseMessage {\n-  public final ManagedBuffer body;\n-  public final boolean isBodyInFrame;\n+public abstract class AbstractResponseMessage extends AbstractMessage implements ResponseMessage {",
    "line": 18
  }],
  "prId": 9987
}]