[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Does `bytesRead` have to be `volatile`?\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T01:51:06Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.client;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.util.TransportFrameDecoder;\n+\n+/**\n+ * An interceptor that is registered with the frame decoder to feed stream data to a\n+ * callback.\n+ */\n+class StreamInterceptor implements TransportFrameDecoder.Interceptor {\n+\n+  private final String streamId;\n+  private final long byteCount;\n+  private final StreamCallback callback;\n+\n+  private volatile long bytesRead;",
    "line": 37
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "It's extremely unlikely that it would cause a problem without volatile. But it's used in `handle`, which technically can be called from different threads (just not at the same time), so it doesn't hurt.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T02:30:04Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.client;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.util.TransportFrameDecoder;\n+\n+/**\n+ * An interceptor that is registered with the frame decoder to feed stream data to a\n+ * callback.\n+ */\n+class StreamInterceptor implements TransportFrameDecoder.Interceptor {\n+\n+  private final String streamId;\n+  private final long byteCount;\n+  private final StreamCallback callback;\n+\n+  private volatile long bytesRead;",
    "line": 37
  }],
  "prId": 9206
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "When this could happen?\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T01:53:46Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.client;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.util.TransportFrameDecoder;\n+\n+/**\n+ * An interceptor that is registered with the frame decoder to feed stream data to a\n+ * callback.\n+ */\n+class StreamInterceptor implements TransportFrameDecoder.Interceptor {\n+\n+  private final String streamId;\n+  private final long byteCount;\n+  private final StreamCallback callback;\n+\n+  private volatile long bytesRead;\n+\n+  StreamInterceptor(String streamId, long byteCount, StreamCallback callback) {\n+    this.streamId = streamId;\n+    this.byteCount = byteCount;\n+    this.callback = callback;\n+    this.bytesRead = 0;\n+  }\n+\n+  @Override\n+  public void exceptionCaught(Throwable cause) throws Exception {\n+    callback.onFailure(streamId, cause);\n+  }\n+\n+  @Override\n+  public void channelInactive() throws Exception {\n+    callback.onFailure(streamId, new ClosedChannelException());\n+  }\n+\n+  @Override\n+  public boolean handle(ByteBuf buf) throws Exception {\n+    int toRead = (int) Math.min(buf.readableBytes(), byteCount - bytesRead);\n+    ByteBuffer nioBuffer = buf.readSlice(toRead).nioBuffer();\n+\n+    int available = nioBuffer.remaining();\n+    callback.onData(streamId, nioBuffer);\n+    bytesRead += available;\n+    if (bytesRead > byteCount) {\n+      RuntimeException re = new IllegalStateException(String.format(",
    "line": 65
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "More of a sanity check, just in case.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T02:30:26Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.client;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.util.TransportFrameDecoder;\n+\n+/**\n+ * An interceptor that is registered with the frame decoder to feed stream data to a\n+ * callback.\n+ */\n+class StreamInterceptor implements TransportFrameDecoder.Interceptor {\n+\n+  private final String streamId;\n+  private final long byteCount;\n+  private final StreamCallback callback;\n+\n+  private volatile long bytesRead;\n+\n+  StreamInterceptor(String streamId, long byteCount, StreamCallback callback) {\n+    this.streamId = streamId;\n+    this.byteCount = byteCount;\n+    this.callback = callback;\n+    this.bytesRead = 0;\n+  }\n+\n+  @Override\n+  public void exceptionCaught(Throwable cause) throws Exception {\n+    callback.onFailure(streamId, cause);\n+  }\n+\n+  @Override\n+  public void channelInactive() throws Exception {\n+    callback.onFailure(streamId, new ClosedChannelException());\n+  }\n+\n+  @Override\n+  public boolean handle(ByteBuf buf) throws Exception {\n+    int toRead = (int) Math.min(buf.readableBytes(), byteCount - bytesRead);\n+    ByteBuffer nioBuffer = buf.readSlice(toRead).nioBuffer();\n+\n+    int available = nioBuffer.remaining();\n+    callback.onData(streamId, nioBuffer);\n+    bytesRead += available;\n+    if (bytesRead > byteCount) {\n+      RuntimeException re = new IllegalStateException(String.format(",
    "line": 65
  }],
  "prId": 9206
}]