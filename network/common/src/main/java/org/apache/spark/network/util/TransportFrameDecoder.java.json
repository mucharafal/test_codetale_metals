[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "should this be `buffer.readLong(buffer.readerIndex())` so that you don't advance the buffer when you don't have enough data yet?\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-28T16:10:43Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p/>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p/>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p/>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;\n+\n+  private CompositeByteBuf buffer;\n+  private volatile Interceptor interceptor;\n+\n+  @Override\n+  public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+    ByteBuf in = (ByteBuf) data;\n+\n+    if (buffer == null) {\n+      buffer = in.alloc().compositeBuffer();\n+    }\n+\n+    buffer.writeBytes(in);\n+\n+    while (buffer.isReadable()) {\n+      feedInterceptor();\n+      if (interceptor != null) {\n+        continue;\n+      }\n+\n+      ByteBuf frame = decodeNext();\n+      if (frame != null) {\n+        ctx.fireChannelRead(frame);\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    // We can't discard read sub-buffers if there are other references to the buffer (e.g.\n+    // through slices used for framing). This assumes that code that retains references\n+    // will call retain() from the thread that called \"fireChannelRead()\" above, otherwise\n+    // ref counting will go awry.\n+    if (buffer != null && buffer.refCnt() == 1) {\n+      buffer.discardReadComponents();\n+    }\n+  }\n+\n+  protected ByteBuf decodeNext() throws Exception {\n+    if (buffer.readableBytes() < LENGTH_SIZE) {\n+      return null;\n+    }\n+\n+    int frameLen = (int) buffer.readLong() - LENGTH_SIZE;",
    "line": 89
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I fix the reader index two lines down in that case, but I can use your approach too.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-29T00:08:23Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p/>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p/>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p/>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;\n+\n+  private CompositeByteBuf buffer;\n+  private volatile Interceptor interceptor;\n+\n+  @Override\n+  public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+    ByteBuf in = (ByteBuf) data;\n+\n+    if (buffer == null) {\n+      buffer = in.alloc().compositeBuffer();\n+    }\n+\n+    buffer.writeBytes(in);\n+\n+    while (buffer.isReadable()) {\n+      feedInterceptor();\n+      if (interceptor != null) {\n+        continue;\n+      }\n+\n+      ByteBuf frame = decodeNext();\n+      if (frame != null) {\n+        ctx.fireChannelRead(frame);\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    // We can't discard read sub-buffers if there are other references to the buffer (e.g.\n+    // through slices used for framing). This assumes that code that retains references\n+    // will call retain() from the thread that called \"fireChannelRead()\" above, otherwise\n+    // ref counting will go awry.\n+    if (buffer != null && buffer.refCnt() == 1) {\n+      buffer.discardReadComponents();\n+    }\n+  }\n+\n+  protected ByteBuf decodeNext() throws Exception {\n+    if (buffer.readableBytes() < LENGTH_SIZE) {\n+      return null;\n+    }\n+\n+    int frameLen = (int) buffer.readLong() - LENGTH_SIZE;",
    "line": 89
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Actually I'll keep my approach because then I don't need to move the index forward in case there's enough data.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-29T07:59:52Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p/>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p/>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p/>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;\n+\n+  private CompositeByteBuf buffer;\n+  private volatile Interceptor interceptor;\n+\n+  @Override\n+  public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+    ByteBuf in = (ByteBuf) data;\n+\n+    if (buffer == null) {\n+      buffer = in.alloc().compositeBuffer();\n+    }\n+\n+    buffer.writeBytes(in);\n+\n+    while (buffer.isReadable()) {\n+      feedInterceptor();\n+      if (interceptor != null) {\n+        continue;\n+      }\n+\n+      ByteBuf frame = decodeNext();\n+      if (frame != null) {\n+        ctx.fireChannelRead(frame);\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    // We can't discard read sub-buffers if there are other references to the buffer (e.g.\n+    // through slices used for framing). This assumes that code that retains references\n+    // will call retain() from the thread that called \"fireChannelRead()\" above, otherwise\n+    // ref counting will go awry.\n+    if (buffer != null && buffer.refCnt() == 1) {\n+      buffer.discardReadComponents();\n+    }\n+  }\n+\n+  protected ByteBuf decodeNext() throws Exception {\n+    if (buffer.readableBytes() < LENGTH_SIZE) {\n+      return null;\n+    }\n+\n+    int frameLen = (int) buffer.readLong() - LENGTH_SIZE;",
    "line": 89
  }, {
    "author": {
      "login": "squito"
    },
    "body": "doh, sorry I totally missed that, this is fine.  I guess I have just seen it the other way in some examples.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-29T14:19:13Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p/>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p/>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p/>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;\n+\n+  private CompositeByteBuf buffer;\n+  private volatile Interceptor interceptor;\n+\n+  @Override\n+  public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+    ByteBuf in = (ByteBuf) data;\n+\n+    if (buffer == null) {\n+      buffer = in.alloc().compositeBuffer();\n+    }\n+\n+    buffer.writeBytes(in);\n+\n+    while (buffer.isReadable()) {\n+      feedInterceptor();\n+      if (interceptor != null) {\n+        continue;\n+      }\n+\n+      ByteBuf frame = decodeNext();\n+      if (frame != null) {\n+        ctx.fireChannelRead(frame);\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    // We can't discard read sub-buffers if there are other references to the buffer (e.g.\n+    // through slices used for framing). This assumes that code that retains references\n+    // will call retain() from the thread that called \"fireChannelRead()\" above, otherwise\n+    // ref counting will go awry.\n+    if (buffer != null && buffer.refCnt() == 1) {\n+      buffer.discardReadComponents();\n+    }\n+  }\n+\n+  protected ByteBuf decodeNext() throws Exception {\n+    if (buffer.readableBytes() < LENGTH_SIZE) {\n+      return null;\n+    }\n+\n+    int frameLen = (int) buffer.readLong() - LENGTH_SIZE;",
    "line": 89
  }],
  "prId": 9206
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "Just an idea, dunno if this is possible or not -- instead of doing the frame decoding itself, could this delegate to a `LengthFieldBasedFrameDecoder` when there is no interceptor?\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-28T17:03:28Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p/>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p/>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p/>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {",
    "line": 42
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I tried really hard to do that way first. But you have no control over how data arrives; the buffer may contain data from multiple frames, and as soon as the frame decoder receives that buffer, it will try to decode multiple frames, and throw exceptions if the \"new frame\" (which contains unframed data) doesn't look like a valid frame.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-28T23:58:48Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p/>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p/>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p/>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {",
    "line": 42
  }],
  "prId": 9206
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "It seems weird that using 8 bytes for an `int` frame size.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T19:18:16Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;",
    "line": 46
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "The network library uses a long for sizes, even though the max frame size fits in an int. Don't ask me, that's how it was before and can't be changed now.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T19:22:30Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;",
    "line": 46
  }],
  "prId": 9206
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: could you add doc for the meaning of the return value?\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-11-03T19:48:19Z",
    "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+\n+/**\n+ * A customized frame decoder that allows intercepting raw data.\n+ * <p>\n+ * This behaves like Netty's frame decoder (with harcoded parameters that match this library's\n+ * needs), except it allows an interceptor to be installed to read data directly before it's\n+ * framed.\n+ * <p>\n+ * Unlike Netty's frame decoder, each frame is dispatched to child handlers as soon as it's\n+ * decoded, instead of building as many frames as the current buffer allows and dispatching\n+ * all of them. This allows a child handler to install an interceptor if needed.\n+ * <p>\n+ * If an interceptor is installed, framing stops, and data is instead fed directly to the\n+ * interceptor. When the interceptor indicates that it doesn't need to read any more data,\n+ * framing resumes. Interceptors should not hold references to the data buffers provided\n+ * to their handle() method.\n+ */\n+public class TransportFrameDecoder extends ChannelInboundHandlerAdapter {\n+\n+  public static final String HANDLER_NAME = \"frameDecoder\";\n+  private static final int LENGTH_SIZE = 8;\n+  private static final int MAX_FRAME_SIZE = Integer.MAX_VALUE;\n+\n+  private CompositeByteBuf buffer;\n+  private volatile Interceptor interceptor;\n+\n+  @Override\n+  public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+    ByteBuf in = (ByteBuf) data;\n+\n+    if (buffer == null) {\n+      buffer = in.alloc().compositeBuffer();\n+    }\n+\n+    buffer.writeBytes(in);\n+\n+    while (buffer.isReadable()) {\n+      feedInterceptor();\n+      if (interceptor != null) {\n+        continue;\n+      }\n+\n+      ByteBuf frame = decodeNext();\n+      if (frame != null) {\n+        ctx.fireChannelRead(frame);\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    // We can't discard read sub-buffers if there are other references to the buffer (e.g.\n+    // through slices used for framing). This assumes that code that retains references\n+    // will call retain() from the thread that called \"fireChannelRead()\" above, otherwise\n+    // ref counting will go awry.\n+    if (buffer != null && buffer.refCnt() == 1) {\n+      buffer.discardReadComponents();\n+    }\n+  }\n+\n+  protected ByteBuf decodeNext() throws Exception {\n+    if (buffer.readableBytes() < LENGTH_SIZE) {\n+      return null;\n+    }\n+\n+    int frameLen = (int) buffer.readLong() - LENGTH_SIZE;\n+    if (buffer.readableBytes() < frameLen) {\n+      buffer.readerIndex(buffer.readerIndex() - LENGTH_SIZE);\n+      return null;\n+    }\n+\n+    Preconditions.checkArgument(frameLen < MAX_FRAME_SIZE, \"Too large frame: %s\", frameLen);\n+    Preconditions.checkArgument(frameLen > 0, \"Frame length should be positive: %s\", frameLen);\n+\n+    ByteBuf frame = buffer.readSlice(frameLen);\n+    frame.retain();\n+    return frame;\n+  }\n+\n+  @Override\n+  public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+    if (buffer != null) {\n+      if (buffer.isReadable()) {\n+        feedInterceptor();\n+      }\n+      buffer.release();\n+    }\n+    if (interceptor != null) {\n+      interceptor.channelInactive();\n+    }\n+    super.channelInactive(ctx);\n+  }\n+\n+  @Override\n+  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+    if (interceptor != null) {\n+      interceptor.exceptionCaught(cause);\n+    }\n+    super.exceptionCaught(ctx, cause);\n+  }\n+\n+  public void setInterceptor(Interceptor interceptor) {\n+    Preconditions.checkState(this.interceptor == null, \"Already have an interceptor.\");\n+    this.interceptor = interceptor;\n+  }\n+\n+  private void feedInterceptor() throws Exception {\n+    if (interceptor != null && !interceptor.handle(buffer)) {\n+      interceptor = null;\n+    }\n+  }\n+\n+  public static interface Interceptor {\n+\n+    boolean handle(ByteBuf data) throws Exception;"
  }],
  "prId": 9206
}]