[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: Writes\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-04-07T21:49:33Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+\n+public interface LargeByteBuffer {\n+    public byte get();\n+\n+    /**\n+     * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+     * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+     * @param dst\n+     * @param offset\n+     * @param length\n+     */\n+    public void get(byte[] dst,int offset, int length);\n+\n+    public LargeByteBuffer rewind();\n+\n+    /**\n+     * return a deep copy of this buffer.\n+     * The returned buffer will have position == 0.  The position\n+     * of this buffer will not change as a result of copying.\n+     *\n+     * @return a new buffer with a full copy of this buffer's data\n+     */\n+    public LargeByteBuffer deepCopy();\n+\n+    /**\n+     * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+     * positive or negative.  It will move the full <code>n</code> unless that moves\n+     * it past the end (or beginning) of the buffer, in which case it will move to the end\n+     * (or beginning).\n+     *\n+     * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+     */\n+    public long skip(long n);\n+\n+    public long position();\n+\n+    /**\n+     * Creates a new byte buffer that shares this buffer's content.\n+     *\n+     * <p> The content of the new buffer will be that of this buffer.  Changes\n+     * to this buffer's content will be visible in the new buffer, and vice\n+     * versa; the two buffers' positions will be independent.\n+     *\n+     * <p> The new buffer's position will be identical to those of this buffer\n+     * */\n+    public LargeByteBuffer duplicate();\n+\n+\n+    public long remaining();\n+\n+    /**\n+     * the total number of bytes in this buffer\n+     * @return\n+     */\n+    public long size();\n+\n+    /**\n+     * writes the data from the current <code>position()</code> to the end of this buffer"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: Get\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-04-07T21:49:38Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+\n+public interface LargeByteBuffer {\n+    public byte get();\n+\n+    /**\n+     * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+     * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+     * @param dst\n+     * @param offset\n+     * @param length\n+     */\n+    public void get(byte[] dst,int offset, int length);\n+\n+    public LargeByteBuffer rewind();\n+\n+    /**\n+     * return a deep copy of this buffer.\n+     * The returned buffer will have position == 0.  The position\n+     * of this buffer will not change as a result of copying.\n+     *\n+     * @return a new buffer with a full copy of this buffer's data\n+     */\n+    public LargeByteBuffer deepCopy();\n+\n+    /**\n+     * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+     * positive or negative.  It will move the full <code>n</code> unless that moves\n+     * it past the end (or beginning) of the buffer, in which case it will move to the end\n+     * (or beginning).\n+     *\n+     * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+     */\n+    public long skip(long n);\n+\n+    public long position();\n+\n+    /**\n+     * Creates a new byte buffer that shares this buffer's content.\n+     *\n+     * <p> The content of the new buffer will be that of this buffer.  Changes\n+     * to this buffer's content will be visible in the new buffer, and vice\n+     * versa; the two buffers' positions will be independent.\n+     *\n+     * <p> The new buffer's position will be identical to those of this buffer\n+     * */\n+    public LargeByteBuffer duplicate();\n+\n+\n+    public long remaining();\n+\n+    /**\n+     * the total number of bytes in this buffer\n+     * @return\n+     */\n+    public long size();\n+\n+    /**\n+     * writes the data from the current <code>position()</code> to the end of this buffer\n+     * to the given channel.  The <code>position()</code> will be moved to the end of\n+     * the buffer after this.\n+     *\n+     * Note that this method will continually attempt to push data to the given channel.  If the\n+     * channel cannot accept more data, this will continuously retry until the channel accepts\n+     * the data.\n+     *\n+     * @param channel\n+     * @return the number of bytes written to the channel\n+     * @throws IOException\n+     */\n+    public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+    /**\n+     * get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "super nit: you seem to be mixing styles (`<p/>` vs. `<p></p>`).\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-04-20T19:03:09Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * <p> The content of the new buffer will be that of this buffer.  Changes"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "It'd be nice to fill in these empty javadoc tags, or remove them.\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-04-20T19:03:32Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * <p> The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * <p> The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   *\n+   * @return"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Interfaces / classes should have Javadoc to explain them.  For this interface in particular, a casual reader of the code might wonder why we wouldn't just use Java's `Buffer` or `ByteBuffer` interfaces.  I think that the reason is that we need `position`, `size` / `limit`, etc. to return longs instead of integers in order to support larger buffer sizes.  It would be good to clarify this.\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-05-29T19:20:59Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+public interface LargeByteBuffer {"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Since we are going to replace the `ByteBuffer` because of its limitation, is there any case that we need to switch it back when people using the `LargeByteBuffer`?\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-03T14:05:26Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   */\n+  public long size();\n+\n+  /**\n+   * Writes the data from the current <code>position()</code> to the end of this buffer\n+   * to the given channel.  The <code>position()</code> will be moved to the end of\n+   * the buffer after this.\n+   * <p/>\n+   * Note that this method will continually attempt to push data to the given channel.  If the\n+   * channel cannot accept more data, this will continuously retry until the channel accepts\n+   * the data.\n+   *\n+   * @param channel\n+   * @return the number of bytes written to the channel\n+   * @throws IOException\n+   */\n+  public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+  /**\n+   * Get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer\n+   * will always have the position set to 0, and the limit set to the end of the data.  Each\n+   * call will return a new ByteBuffer, but will not require copying the data (eg., it will\n+   * use ByteBuffer#duplicate()).  The returned byte buffer will share data with this buffer.  The\n+   * returned buffers will never be larger than\n+   * {@link org.apache.spark.network.buffer.LargeByteBufferHelper#MAX_CHUNK_SIZE}\n+   *\n+   * @throws BufferTooLargeException if this buffer is too large to fit in one {@link ByteBuffer}\n+   */\n+  public ByteBuffer asByteBuffer() throws BufferTooLargeException;",
    "line": 137
  }, {
    "author": {
      "login": "squito"
    },
    "body": "Eventually we may no longer use `ByteBuffer` directly, but initially some parts of the code will still use it.  In particular, we'll start by only supporting caching for large blocks, we won't support replication or shuffling (because its more complicated w/ the network transfer).  So those parts of the code will still need this.  See this discussion on https://issues.apache.org/jira/browse/SPARK-1391\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-03T18:52:25Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   */\n+  public long size();\n+\n+  /**\n+   * Writes the data from the current <code>position()</code> to the end of this buffer\n+   * to the given channel.  The <code>position()</code> will be moved to the end of\n+   * the buffer after this.\n+   * <p/>\n+   * Note that this method will continually attempt to push data to the given channel.  If the\n+   * channel cannot accept more data, this will continuously retry until the channel accepts\n+   * the data.\n+   *\n+   * @param channel\n+   * @return the number of bytes written to the channel\n+   * @throws IOException\n+   */\n+  public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+  /**\n+   * Get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer\n+   * will always have the position set to 0, and the limit set to the end of the data.  Each\n+   * call will return a new ByteBuffer, but will not require copying the data (eg., it will\n+   * use ByteBuffer#duplicate()).  The returned byte buffer will share data with this buffer.  The\n+   * returned buffers will never be larger than\n+   * {@link org.apache.spark.network.buffer.LargeByteBufferHelper#MAX_CHUNK_SIZE}\n+   *\n+   * @throws BufferTooLargeException if this buffer is too large to fit in one {@link ByteBuffer}\n+   */\n+  public ByteBuffer asByteBuffer() throws BufferTooLargeException;",
    "line": 137
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "I mean if in that case, people probably prefer call the `public List<ByteBuffer> nioBuffers()` instead, if the file size is greater than 2 GB, right?\nAnd, can we just reuse the interface `java.nio.ByteBuffer`, instead of creating the interface `LargeByteBuffer`?\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-04T00:33:09Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   */\n+  public long size();\n+\n+  /**\n+   * Writes the data from the current <code>position()</code> to the end of this buffer\n+   * to the given channel.  The <code>position()</code> will be moved to the end of\n+   * the buffer after this.\n+   * <p/>\n+   * Note that this method will continually attempt to push data to the given channel.  If the\n+   * channel cannot accept more data, this will continuously retry until the channel accepts\n+   * the data.\n+   *\n+   * @param channel\n+   * @return the number of bytes written to the channel\n+   * @throws IOException\n+   */\n+  public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+  /**\n+   * Get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer\n+   * will always have the position set to 0, and the limit set to the end of the data.  Each\n+   * call will return a new ByteBuffer, but will not require copying the data (eg., it will\n+   * use ByteBuffer#duplicate()).  The returned byte buffer will share data with this buffer.  The\n+   * returned buffers will never be larger than\n+   * {@link org.apache.spark.network.buffer.LargeByteBufferHelper#MAX_CHUNK_SIZE}\n+   *\n+   * @throws BufferTooLargeException if this buffer is too large to fit in one {@link ByteBuffer}\n+   */\n+  public ByteBuffer asByteBuffer() throws BufferTooLargeException;",
    "line": 137
  }, {
    "author": {
      "login": "squito"
    },
    "body": "The idea is that `BlockManager` and all related code will use a `LargeByteBuffer` instead of `ByteBuffer` initially, when we just use caching.  But when we get to parts of the code that don't support > 2GB, eg. replication, it will call `asByteBuffer`, and continue to use the existing code.  This way, as long as the blocks are less than 2GB, the behavior is the same; and if blocks are bigger than 2GB, we can fail fast with a useful error message.  I have a pr which integrates `LargeByteBuffer` and allows caching large blocks, but its really old now.  I'll bring it up to date and share, hopefully that will help show how it fits together.\n\nIt would also be possible for the code that didn't support > 2GB to use `public List<ByteBuffer> nioBuffers()` -- but its not as simple as just putting a loop around each of the buffers.  Eg., on the receiving end, as you try to rebuild the original block, you've got to buffer all the pieces together.  And what if you never get the entire message?  How long do you wait before releasing the resources you've buffered?\n\nAn alternative would be for replication to just fail if `nioBuffers()` returned more than one buffer, but that is basically the same thing as what is happening here, I'm just pushing a little bit of the error handling into this method and also making the guarantees clear.\n\nI'm not entirely sure what you mean by:\n\n> And, can we just reuse the interface `java.nio.ByteBuffer`, instead of creating the interface\n> `LargeByteBuffer`?\n\n`java.nio.ByteBuffer` is limited to 2GB b/c the api uses `int`s (among other things).  Also its an abstract class, not an interface\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-04T14:56:06Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   */\n+  public long size();\n+\n+  /**\n+   * Writes the data from the current <code>position()</code> to the end of this buffer\n+   * to the given channel.  The <code>position()</code> will be moved to the end of\n+   * the buffer after this.\n+   * <p/>\n+   * Note that this method will continually attempt to push data to the given channel.  If the\n+   * channel cannot accept more data, this will continuously retry until the channel accepts\n+   * the data.\n+   *\n+   * @param channel\n+   * @return the number of bytes written to the channel\n+   * @throws IOException\n+   */\n+  public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+  /**\n+   * Get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer\n+   * will always have the position set to 0, and the limit set to the end of the data.  Each\n+   * call will return a new ByteBuffer, but will not require copying the data (eg., it will\n+   * use ByteBuffer#duplicate()).  The returned byte buffer will share data with this buffer.  The\n+   * returned buffers will never be larger than\n+   * {@link org.apache.spark.network.buffer.LargeByteBufferHelper#MAX_CHUNK_SIZE}\n+   *\n+   * @throws BufferTooLargeException if this buffer is too large to fit in one {@link ByteBuffer}\n+   */\n+  public ByteBuffer asByteBuffer() throws BufferTooLargeException;",
    "line": 137
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Thanks for the explanation! I was suggesting to make the interface definition like the `ByteBuffer`, but I forgot the `int`s stuff(Sorry about this). \n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-05T06:03:40Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   */\n+  public long size();\n+\n+  /**\n+   * Writes the data from the current <code>position()</code> to the end of this buffer\n+   * to the given channel.  The <code>position()</code> will be moved to the end of\n+   * the buffer after this.\n+   * <p/>\n+   * Note that this method will continually attempt to push data to the given channel.  If the\n+   * channel cannot accept more data, this will continuously retry until the channel accepts\n+   * the data.\n+   *\n+   * @param channel\n+   * @return the number of bytes written to the channel\n+   * @throws IOException\n+   */\n+  public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+  /**\n+   * Get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer\n+   * will always have the position set to 0, and the limit set to the end of the data.  Each\n+   * call will return a new ByteBuffer, but will not require copying the data (eg., it will\n+   * use ByteBuffer#duplicate()).  The returned byte buffer will share data with this buffer.  The\n+   * returned buffers will never be larger than\n+   * {@link org.apache.spark.network.buffer.LargeByteBufferHelper#MAX_CHUNK_SIZE}\n+   *\n+   * @throws BufferTooLargeException if this buffer is too large to fit in one {@link ByteBuffer}\n+   */\n+  public ByteBuffer asByteBuffer() throws BufferTooLargeException;",
    "line": 137
  }, {
    "author": {
      "login": "squito"
    },
    "body": "no problem @chenghao-intel , its good to talk, through this stuff, I have gone back and forth on the design myself a little.  your input is definitely helpful :)\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-05T20:37:56Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);\n+\n+  public LargeByteBuffer rewind();\n+\n+  /**\n+   * Return a deep copy of this buffer.\n+   * The returned buffer will have position == 0.  The position\n+   * of this buffer will not change as a result of copying.\n+   *\n+   * @return a new buffer with a full copy of this buffer's data\n+   */\n+  public LargeByteBuffer deepCopy();\n+\n+  /**\n+   * Advance the position in this buffer by up to <code>n</code> bytes.  <code>n</code> may be\n+   * positive or negative.  It will move the full <code>n</code> unless that moves\n+   * it past the end (or beginning) of the buffer, in which case it will move to the end\n+   * (or beginning).\n+   *\n+   * @return the number of bytes moved forward (can be negative if <code>n</code> is negative)\n+   */\n+  public long skip(long n);\n+\n+  public long position();\n+\n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   * <p/>\n+   * The content of the new buffer will be that of this buffer.  Changes\n+   * to this buffer's content will be visible in the new buffer, and vice\n+   * versa; the two buffers' positions will be independent.\n+   * <p/>\n+   * The new buffer's position will be identical to those of this buffer\n+   */\n+  public LargeByteBuffer duplicate();\n+\n+  public long remaining();\n+\n+  /**\n+   * Total number of bytes in this buffer\n+   */\n+  public long size();\n+\n+  /**\n+   * Writes the data from the current <code>position()</code> to the end of this buffer\n+   * to the given channel.  The <code>position()</code> will be moved to the end of\n+   * the buffer after this.\n+   * <p/>\n+   * Note that this method will continually attempt to push data to the given channel.  If the\n+   * channel cannot accept more data, this will continuously retry until the channel accepts\n+   * the data.\n+   *\n+   * @param channel\n+   * @return the number of bytes written to the channel\n+   * @throws IOException\n+   */\n+  public long writeTo(WritableByteChannel channel) throws IOException;\n+\n+  /**\n+   * Get the entire contents of this as one ByteBuffer, if possible.  The returned ByteBuffer\n+   * will always have the position set to 0, and the limit set to the end of the data.  Each\n+   * call will return a new ByteBuffer, but will not require copying the data (eg., it will\n+   * use ByteBuffer#duplicate()).  The returned byte buffer will share data with this buffer.  The\n+   * returned buffers will never be larger than\n+   * {@link org.apache.spark.network.buffer.LargeByteBufferHelper#MAX_CHUNK_SIZE}\n+   *\n+   * @throws BufferTooLargeException if this buffer is too large to fit in one {@link ByteBuffer}\n+   */\n+  public ByteBuffer asByteBuffer() throws BufferTooLargeException;",
    "line": 137
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "`ByteBuffer.get` actually will return `ByteBuffer`, follow the same pattern?\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-03T14:24:54Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "And also provide the API `public LargeByteBuffer get(byte[] dst);`?\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-03T14:25:42Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "good idea, thanks!\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-03T18:59:02Z",
    "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst\n+   * @param offset\n+   * @param length\n+   */\n+  public void get(byte[] dst, int offset, int length);"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: too many empty lines\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-11-02T20:01:23Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+",
    "line": 49
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: too many empty lines\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-11-02T20:01:43Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.spark.network.buffer;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+\n+/**\n+ * A byte buffer which can hold over 2GB.\n+ * <p/>\n+ * This is roughly similar {@link java.nio.ByteBuffer}, with a limited set of operations relevant\n+ * to use in Spark, and without the capacity restrictions of a ByteBuffer.\n+ * <p/>\n+ * Unlike ByteBuffers, this is read-only, and only supports reading bytes (with both single and bulk\n+ * <code>get</code> methods).  It supports random access via <code>skip</code> to move around the\n+ * buffer.\n+ * <p/>\n+ * In general, implementations are expected to support O(1) random access.  Furthermore,\n+ * neighboring locations in the buffer are likely to be neighboring in memory, so sequential access\n+ * will avoid cache-misses.  However, these are only rough guidelines which may differ in\n+ * implementations.\n+ * <p/>\n+ * Any code which expects a ByteBuffer can obtain one via {@link #asByteBuffer} when possible -- see\n+ * that method for a full description of its limitations.\n+ * <p/>\n+ * Instances of this class can be created with\n+ * {@link org.apache.spark.network.buffer.LargeByteBufferHelper},\n+ * with a LargeByteBufferOutputStream,\n+ * or directly from the implementation\n+ * {@link org.apache.spark.network.buffer.WrappedLargeByteBuffer}.\n+ */\n+public interface LargeByteBuffer {\n+  public byte get();\n+\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.  Behaves\n+   * in the exact same way as <code>get(dst, 0, dst.length)</code>\n+   *\n+   * @param dst the destination array\n+   * @return this buffer\n+   */\n+  public LargeByteBuffer get(byte[] dst);\n+\n+  /**\n+   * Bulk copy data from this buffer into the given array.  First checks there is sufficient\n+   * data in this buffer; if not, throws a {@link java.nio.BufferUnderflowException}.\n+   *\n+   * @param dst the destination array\n+   * @param offset the offset within the destination array to write to\n+   * @param length how many bytes to write\n+   * @return this buffer\n+   */\n+  public LargeByteBuffer get(byte[] dst, int offset, int length);\n+",
    "line": 70
  }],
  "prId": 5400
}]