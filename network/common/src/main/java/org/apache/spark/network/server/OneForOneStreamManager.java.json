[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "I think we can avoid the new field by doing\n\n``` java\nstreams.get(streamId).associatedChannel = channel;\n```\n\nhere and\n\n``` java\n// Close all streams which have been associated with the channel.\nIterator<Map.Entry<Long, StreamState>> streamIterator = streams.iterator()\nwhile (streamIterator.hasNext()) {\n  StreamState state = streamIterator.next().getValue()\n  if (state.associatedChannel == channel) {\n    streamIterator.remove();\n\n    // Release all remaining buffers.\n    while (state.buffers.hasNext()) {\n      state.buffers.next().release();\n    }\n  }\n}\n```\n\nAllowing the removal of the other connectionTerminated().\n",
    "commit": "cf2c086cd7dcdb0f047dd1eca73e1708d812f25a",
    "createdAt": "2015-04-30T18:01:22Z",
    "diffHunk": "@@ -56,6 +62,15 @@ public OneForOneStreamManager() {\n     // This does not need to be globally unique, only unique to this class.\n     nextStreamId = new AtomicLong((long) new Random().nextInt(Integer.MAX_VALUE) * 1000);\n     streams = new ConcurrentHashMap<Long, StreamState>();\n+    streamIds = new ConcurrentHashMap<Channel, Set<Long>>();\n+  }\n+\n+  @Override\n+  public void registerChannel(Channel channel, long streamId) {"
  }],
  "prId": 5743
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Also, if you wouldn't mind, add a Preconditions.checkNotNull(buffers) to line 56 (to ensure buffers is not null).\n",
    "commit": "cf2c086cd7dcdb0f047dd1eca73e1708d812f25a",
    "createdAt": "2015-04-30T18:02:45Z",
    "diffHunk": "@@ -56,6 +62,15 @@ public OneForOneStreamManager() {\n     // This does not need to be globally unique, only unique to this class.\n     nextStreamId = new AtomicLong((long) new Random().nextInt(Integer.MAX_VALUE) * 1000);\n     streams = new ConcurrentHashMap<Long, StreamState>();\n+    streamIds = new ConcurrentHashMap<Channel, Set<Long>>();"
  }],
  "prId": 5743
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Ah, good point, this is safe because our Map is a ConcurrentHashMap (or else you would need to use an iterator to remove it safely). Would you mind making the left-hand type of the declaration of `streams` a `ConcurrentHashMap`? This is not the first place where we rely on the semantics of a ConcurrentHashMap over a general Map, and we should use proper style therefore.\n",
    "commit": "cf2c086cd7dcdb0f047dd1eca73e1708d812f25a",
    "createdAt": "2015-05-01T15:53:47Z",
    "diffHunk": "@@ -80,12 +95,17 @@ public ManagedBuffer getChunk(long streamId, int chunkIndex) {\n   }\n \n   @Override\n-  public void connectionTerminated(long streamId) {\n-    // Release all remaining buffers.\n-    StreamState state = streams.remove(streamId);\n-    if (state != null && state.buffers != null) {\n-      while (state.buffers.hasNext()) {\n-        state.buffers.next().release();\n+  public void connectionTerminated(Channel channel) {\n+    // Close all streams which have been associated with the channel.\n+    for (Map.Entry<Long, StreamState> entry: streams.entrySet()) {\n+      StreamState state = entry.getValue();\n+      if (state.associatedChannel == channel) {\n+        streams.remove(entry.getKey());",
    "line": 72
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Making sense. Updated.\n",
    "commit": "cf2c086cd7dcdb0f047dd1eca73e1708d812f25a",
    "createdAt": "2015-05-01T17:04:26Z",
    "diffHunk": "@@ -80,12 +95,17 @@ public ManagedBuffer getChunk(long streamId, int chunkIndex) {\n   }\n \n   @Override\n-  public void connectionTerminated(long streamId) {\n-    // Release all remaining buffers.\n-    StreamState state = streams.remove(streamId);\n-    if (state != null && state.buffers != null) {\n-      while (state.buffers.hasNext()) {\n-        state.buffers.next().release();\n+  public void connectionTerminated(Channel channel) {\n+    // Close all streams which have been associated with the channel.\n+    for (Map.Entry<Long, StreamState> entry: streams.entrySet()) {\n+      StreamState state = entry.getValue();\n+      if (state.associatedChannel == channel) {\n+        streams.remove(entry.getKey());",
    "line": 72
  }],
  "prId": 5743
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "nit: `this.buffers = Preconditions.checkNotNull(buffers)`\n",
    "commit": "cf2c086cd7dcdb0f047dd1eca73e1708d812f25a",
    "createdAt": "2015-05-01T15:54:13Z",
    "diffHunk": "@@ -42,11 +46,15 @@\n   private static class StreamState {\n     final Iterator<ManagedBuffer> buffers;\n \n+    // The channel associated to the stream\n+    Channel associatedChannel = null;\n+\n     // Used to keep track of the index of the buffer that the user has retrieved, just to ensure\n     // that the caller only requests each chunk one at a time, in order.\n     int curChunk = 0;\n \n     StreamState(Iterator<ManagedBuffer> buffers) {\n+      Preconditions.checkNotNull(buffers);\n       this.buffers = buffers;"
  }],
  "prId": 5743
}]