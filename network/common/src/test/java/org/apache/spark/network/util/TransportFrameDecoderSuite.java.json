[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "check that the buffers passed to `ctx.fireChannelRead` are actually the right frames, ie. `data1` and `data2`, not `buf1` and `buf2`, since the number of calls would be the same either way.  In fact, the expectation really shouldn't be `times(buffers.size())`, b/c even if you split the data into 3 channelRead calls, you'd still expect `ctx.fireChannelRead` to get called twice, right?\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-29T15:21:55Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+public class TransportFrameDecoderSuite {\n+\n+  @Test\n+  public void testFrameDecoding() throws Exception {\n+    Random rnd = new Random();\n+    TransportFrameDecoder decoder = new TransportFrameDecoder();\n+    ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n+\n+    List<ByteBuf> buffers = new ArrayList<>();\n+    for (int i = 0; i < 100; i++) {\n+      // Create two buffers; the first one will be large enough to contain the first full\n+      // frame and maybe a few bytes of the second frame.\n+      byte[] data1 = new byte[1024 * (rnd.nextInt(31) + 1)];\n+      byte[] data2 = new byte[1024 * (rnd.nextInt(31) + 1)];\n+      int totalSize = 2 * 8 + data1.length + data2.length;\n+      int size1 = 8 + data1.length + 8 * (rnd.nextInt(data2.length / 2) / 8);\n+      int size2 = totalSize - size1;\n+\n+      assertTrue(size1 >= data1.length + 8);\n+      assertTrue(size2 > 8);\n+\n+      ByteBuf buf1 = Unpooled.buffer(size1);\n+      ByteBuf buf2 = Unpooled.buffer(size2);\n+\n+      buf1.writeLong(data1.length + 8);\n+      buf1.writeBytes(data1);\n+\n+      int remaining = size1 - data1.length - 8;\n+      assertTrue(remaining % 8 == 0);\n+      if (remaining >= 8) {\n+        buf1.writeLong(data2.length + 8);\n+        remaining -= 8;\n+      } else {\n+        buf2.writeLong(data2.length + 8);\n+      }\n+\n+      if (remaining > 0) {\n+        buf1.writeBytes(data2, 0, remaining);\n+      }\n+      buf2.writeBytes(data2, remaining, data2.length - remaining);\n+      buffers.add(buf1);\n+      buffers.add(buf2);\n+    }\n+\n+    try {\n+      for (ByteBuf buf : buffers) {\n+        decoder.channelRead(ctx, buf);\n+      }\n+\n+      verify(ctx, times(buffers.size())).fireChannelRead(any(ByteBuf.class));"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "yeah, I'll change it. it just happens that the number of buffers and number of frames matches, and it would be better if they didn't.\n",
    "commit": "4d0ff6768bd9d94e19bd842d13d5dc18b3eae6c6",
    "createdAt": "2015-10-30T07:41:35Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+public class TransportFrameDecoderSuite {\n+\n+  @Test\n+  public void testFrameDecoding() throws Exception {\n+    Random rnd = new Random();\n+    TransportFrameDecoder decoder = new TransportFrameDecoder();\n+    ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n+\n+    List<ByteBuf> buffers = new ArrayList<>();\n+    for (int i = 0; i < 100; i++) {\n+      // Create two buffers; the first one will be large enough to contain the first full\n+      // frame and maybe a few bytes of the second frame.\n+      byte[] data1 = new byte[1024 * (rnd.nextInt(31) + 1)];\n+      byte[] data2 = new byte[1024 * (rnd.nextInt(31) + 1)];\n+      int totalSize = 2 * 8 + data1.length + data2.length;\n+      int size1 = 8 + data1.length + 8 * (rnd.nextInt(data2.length / 2) / 8);\n+      int size2 = totalSize - size1;\n+\n+      assertTrue(size1 >= data1.length + 8);\n+      assertTrue(size2 > 8);\n+\n+      ByteBuf buf1 = Unpooled.buffer(size1);\n+      ByteBuf buf2 = Unpooled.buffer(size2);\n+\n+      buf1.writeLong(data1.length + 8);\n+      buf1.writeBytes(data1);\n+\n+      int remaining = size1 - data1.length - 8;\n+      assertTrue(remaining % 8 == 0);\n+      if (remaining >= 8) {\n+        buf1.writeLong(data2.length + 8);\n+        remaining -= 8;\n+      } else {\n+        buf2.writeLong(data2.length + 8);\n+      }\n+\n+      if (remaining > 0) {\n+        buf1.writeBytes(data2, 0, remaining);\n+      }\n+      buf2.writeBytes(data2, remaining, data2.length - remaining);\n+      buffers.add(buf1);\n+      buffers.add(buf2);\n+    }\n+\n+    try {\n+      for (ByteBuf buf : buffers) {\n+        decoder.channelRead(ctx, buf);\n+      }\n+\n+      verify(ctx, times(buffers.size())).fireChannelRead(any(ByteBuf.class));"
  }],
  "prId": 9206
}]