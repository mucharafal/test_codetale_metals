[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nit  - new line\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-24T21:05:06Z",
    "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network;\n+\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.spark.network.protocol.Message;\n+import org.apache.spark.network.protocol.StreamChunkId;\n+import org.apache.spark.network.protocol.request.ChunkFetchRequest;\n+import org.apache.spark.network.protocol.request.RpcRequest;\n+import org.apache.spark.network.protocol.response.ChunkFetchFailure;\n+import org.apache.spark.network.protocol.response.ChunkFetchSuccess;\n+import org.apache.spark.network.protocol.response.MessageDecoder;\n+import org.apache.spark.network.protocol.response.MessageEncoder;\n+import org.apache.spark.network.protocol.response.RpcFailure;\n+import org.apache.spark.network.protocol.response.RpcResponse;\n+import org.apache.spark.network.util.NettyUtils;\n+\n+public class ProtocolSuite {\n+  private void testServerToClient(Message msg) {\n+    EmbeddedChannel serverChannel = new EmbeddedChannel(new MessageEncoder());\n+    serverChannel.writeOutbound(msg);\n+\n+    EmbeddedChannel clientChannel = new EmbeddedChannel(\n+        NettyUtils.createFrameDecoder(), new MessageDecoder());\n+\n+    while (!serverChannel.outboundMessages().isEmpty()) {\n+      clientChannel.writeInbound(serverChannel.readOutbound());\n+    }\n+\n+    assertEquals(1, clientChannel.inboundMessages().size());\n+    assertEquals(msg, clientChannel.readInbound());\n+  }\n+\n+  private void testClientToServer(Message msg) {\n+    EmbeddedChannel clientChannel = new EmbeddedChannel(new MessageEncoder());\n+    clientChannel.writeOutbound(msg);\n+\n+    EmbeddedChannel serverChannel = new EmbeddedChannel(\n+        NettyUtils.createFrameDecoder(), new MessageDecoder());\n+\n+    while (!clientChannel.outboundMessages().isEmpty()) {\n+      serverChannel.writeInbound(clientChannel.readOutbound());\n+    }\n+\n+    assertEquals(1, serverChannel.inboundMessages().size());\n+    assertEquals(msg, serverChannel.readInbound());\n+  }\n+\n+  @Test\n+  public void requests() {\n+    testClientToServer(new ChunkFetchRequest(new StreamChunkId(1, 2)));\n+    testClientToServer(new RpcRequest(12345, new byte[0]));\n+    testClientToServer(new RpcRequest(12345, new byte[100]));\n+  }\n+\n+  @Test\n+  public void responses() {\n+    testServerToClient(new ChunkFetchSuccess(new StreamChunkId(1, 2), new TestManagedBuffer(10)));\n+    testServerToClient(new ChunkFetchSuccess(new StreamChunkId(1, 2), new TestManagedBuffer(0)));\n+    testServerToClient(new ChunkFetchFailure(new StreamChunkId(1, 2), \"this is an error\"));\n+    testServerToClient(new ChunkFetchFailure(new StreamChunkId(1, 2), \"\"));\n+    testServerToClient(new RpcResponse(12345, new byte[0]));\n+    testServerToClient(new RpcResponse(12345, new byte[1000]));\n+    testServerToClient(new RpcFailure(0, \"this is an error\"));\n+    testServerToClient(new RpcFailure(0, \"\"));\n+  }\n+}",
    "line": 86
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "github didn't notice this, but it's done\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T05:43:50Z",
    "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network;\n+\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.spark.network.protocol.Message;\n+import org.apache.spark.network.protocol.StreamChunkId;\n+import org.apache.spark.network.protocol.request.ChunkFetchRequest;\n+import org.apache.spark.network.protocol.request.RpcRequest;\n+import org.apache.spark.network.protocol.response.ChunkFetchFailure;\n+import org.apache.spark.network.protocol.response.ChunkFetchSuccess;\n+import org.apache.spark.network.protocol.response.MessageDecoder;\n+import org.apache.spark.network.protocol.response.MessageEncoder;\n+import org.apache.spark.network.protocol.response.RpcFailure;\n+import org.apache.spark.network.protocol.response.RpcResponse;\n+import org.apache.spark.network.util.NettyUtils;\n+\n+public class ProtocolSuite {\n+  private void testServerToClient(Message msg) {\n+    EmbeddedChannel serverChannel = new EmbeddedChannel(new MessageEncoder());\n+    serverChannel.writeOutbound(msg);\n+\n+    EmbeddedChannel clientChannel = new EmbeddedChannel(\n+        NettyUtils.createFrameDecoder(), new MessageDecoder());\n+\n+    while (!serverChannel.outboundMessages().isEmpty()) {\n+      clientChannel.writeInbound(serverChannel.readOutbound());\n+    }\n+\n+    assertEquals(1, clientChannel.inboundMessages().size());\n+    assertEquals(msg, clientChannel.readInbound());\n+  }\n+\n+  private void testClientToServer(Message msg) {\n+    EmbeddedChannel clientChannel = new EmbeddedChannel(new MessageEncoder());\n+    clientChannel.writeOutbound(msg);\n+\n+    EmbeddedChannel serverChannel = new EmbeddedChannel(\n+        NettyUtils.createFrameDecoder(), new MessageDecoder());\n+\n+    while (!clientChannel.outboundMessages().isEmpty()) {\n+      serverChannel.writeInbound(clientChannel.readOutbound());\n+    }\n+\n+    assertEquals(1, serverChannel.inboundMessages().size());\n+    assertEquals(msg, serverChannel.readInbound());\n+  }\n+\n+  @Test\n+  public void requests() {\n+    testClientToServer(new ChunkFetchRequest(new StreamChunkId(1, 2)));\n+    testClientToServer(new RpcRequest(12345, new byte[0]));\n+    testClientToServer(new RpcRequest(12345, new byte[100]));\n+  }\n+\n+  @Test\n+  public void responses() {\n+    testServerToClient(new ChunkFetchSuccess(new StreamChunkId(1, 2), new TestManagedBuffer(10)));\n+    testServerToClient(new ChunkFetchSuccess(new StreamChunkId(1, 2), new TestManagedBuffer(0)));\n+    testServerToClient(new ChunkFetchFailure(new StreamChunkId(1, 2), \"this is an error\"));\n+    testServerToClient(new ChunkFetchFailure(new StreamChunkId(1, 2), \"\"));\n+    testServerToClient(new RpcResponse(12345, new byte[0]));\n+    testServerToClient(new RpcResponse(12345, new byte[1000]));\n+    testServerToClient(new RpcFailure(0, \"this is an error\"));\n+    testServerToClient(new RpcFailure(0, \"\"));\n+  }\n+}",
    "line": 86
  }],
  "prId": 2753
}]