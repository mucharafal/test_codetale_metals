[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "This is a change from the prior version -- before, only the client did this transformation, now both the server and client do.\n",
    "commit": "3481718baf66f4c02568f08d7011af19a2c47f4b",
    "createdAt": "2014-11-04T07:49:09Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.BaseEncoding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A SASL Server for Spark which simply keeps track of the state of a single SASL session, from the\n+ * initial state to the \"authenticated\" state. (It is not a server in the sense of accepting\n+ * connections on some socket.)\n+ */\n+public class SparkSaslServer {\n+  private final Logger logger = LoggerFactory.getLogger(SparkSaslServer.class);\n+\n+  /**\n+   * This is passed as the server name when creating the sasl client/server.\n+   * This could be changed to be configurable in the future.\n+   */\n+  static final String DEFAULT_REALM = \"default\";\n+\n+  /**\n+   * The authentication mechanism used here is DIGEST-MD5. This could be changed to be\n+   * configurable in the future.\n+   */\n+  static final String DIGEST = \"DIGEST-MD5\";\n+\n+  /**\n+   * The quality of protection is just \"auth\". This means that we are doing\n+   * authentication only, we are not supporting integrity or privacy protection of the\n+   * communication channel after authentication. This could be changed to be configurable\n+   * in the future.\n+   */\n+  static final Map<String, String> SASL_PROPS = ImmutableMap.<String, String>builder()\n+    .put(Sasl.QOP, \"auth\")\n+    .put(Sasl.SERVER_AUTH, \"true\")\n+    .build();\n+\n+  /** Identifier for a certain secret key within the secretKeyHolder. */\n+  private final String secretKeyId;\n+  private final SecretKeyHolder secretKeyHolder;\n+  private SaslServer saslServer;\n+\n+  public SparkSaslServer(String secretKeyId, SecretKeyHolder secretKeyHolder) {\n+    this.secretKeyId = secretKeyId;\n+    this.secretKeyHolder = secretKeyHolder;\n+    try {\n+      this.saslServer = Sasl.createSaslServer(DIGEST, null, DEFAULT_REALM, SASL_PROPS,\n+        new DigestCallbackHandler());\n+    } catch (SaslException e) {\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * Determines whether the authentication exchange has completed successfully.\n+   */\n+  public synchronized boolean isComplete() {\n+    return saslServer != null && saslServer.isComplete();\n+  }\n+\n+  /**\n+   * Used to respond to server SASL tokens.\n+   * @param token Server's SASL token\n+   * @return response to send back to the server.\n+   */\n+  public synchronized byte[] response(byte[] token) {\n+    try {\n+      return saslServer != null ? saslServer.evaluateResponse(token) : new byte[0];\n+    } catch (SaslException e) {\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * Disposes of any system resources or security-sensitive information the\n+   * SaslServer might be using.\n+   */\n+  public synchronized void dispose() {\n+    if (saslServer != null) {\n+      try {\n+        saslServer.dispose();\n+      } catch (SaslException e) {\n+        // ignore\n+      } finally {\n+        saslServer = null;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Implementation of javax.security.auth.callback.CallbackHandler for SASL DIGEST-MD5 mechanism.\n+   */\n+  private class DigestCallbackHandler implements CallbackHandler {\n+    @Override\n+    public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n+      for (Callback callback : callbacks) {\n+        if (callback instanceof NameCallback) {\n+          logger.trace(\"SASL server callback: setting username\");\n+          NameCallback nc = (NameCallback) callback;\n+          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n+        } else if (callback instanceof PasswordCallback) {\n+          logger.trace(\"SASL server callback: setting password\");\n+          PasswordCallback pc = (PasswordCallback) callback;\n+          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n+        } else if (callback instanceof RealmCallback) {\n+          logger.trace(\"SASL server callback: setting realm\");\n+          RealmCallback rc = (RealmCallback) callback;\n+          rc.setText(rc.getDefaultText());\n+        } else if (callback instanceof AuthorizeCallback) {\n+          AuthorizeCallback ac = (AuthorizeCallback) callback;\n+          String authId = ac.getAuthenticationID();\n+          String authzId = ac.getAuthorizationID();\n+          ac.setAuthorized(authId.equals(authzId));\n+          if (ac.isAuthorized()) {\n+            ac.setAuthorizedID(authzId);\n+          }\n+          logger.debug(\"SASL Authorization complete, authorized set to {}\", ac.isAuthorized());\n+        } else {\n+          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /* Encode a byte[] identifier as a Base64-encoded string. */\n+  public static String encodeIdentifier(String identifier) {\n+    return BaseEncoding.base64().encode(identifier.getBytes(Charsets.UTF_8));\n+  }\n+\n+  /** Encode a password as a base64-encoded char[] array. */\n+  public static char[] encodePassword(String password) {\n+    if (password != null) {"
  }, {
    "author": {
      "login": "tgravescs"
    },
    "body": "I don't follow your comment? It used to encode it for both client and server before as well. \n\nIt seems bad if you are trying to do a sasl negotiation with a null password. \n",
    "commit": "3481718baf66f4c02568f08d7011af19a2c47f4b",
    "createdAt": "2014-11-04T14:20:48Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.BaseEncoding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A SASL Server for Spark which simply keeps track of the state of a single SASL session, from the\n+ * initial state to the \"authenticated\" state. (It is not a server in the sense of accepting\n+ * connections on some socket.)\n+ */\n+public class SparkSaslServer {\n+  private final Logger logger = LoggerFactory.getLogger(SparkSaslServer.class);\n+\n+  /**\n+   * This is passed as the server name when creating the sasl client/server.\n+   * This could be changed to be configurable in the future.\n+   */\n+  static final String DEFAULT_REALM = \"default\";\n+\n+  /**\n+   * The authentication mechanism used here is DIGEST-MD5. This could be changed to be\n+   * configurable in the future.\n+   */\n+  static final String DIGEST = \"DIGEST-MD5\";\n+\n+  /**\n+   * The quality of protection is just \"auth\". This means that we are doing\n+   * authentication only, we are not supporting integrity or privacy protection of the\n+   * communication channel after authentication. This could be changed to be configurable\n+   * in the future.\n+   */\n+  static final Map<String, String> SASL_PROPS = ImmutableMap.<String, String>builder()\n+    .put(Sasl.QOP, \"auth\")\n+    .put(Sasl.SERVER_AUTH, \"true\")\n+    .build();\n+\n+  /** Identifier for a certain secret key within the secretKeyHolder. */\n+  private final String secretKeyId;\n+  private final SecretKeyHolder secretKeyHolder;\n+  private SaslServer saslServer;\n+\n+  public SparkSaslServer(String secretKeyId, SecretKeyHolder secretKeyHolder) {\n+    this.secretKeyId = secretKeyId;\n+    this.secretKeyHolder = secretKeyHolder;\n+    try {\n+      this.saslServer = Sasl.createSaslServer(DIGEST, null, DEFAULT_REALM, SASL_PROPS,\n+        new DigestCallbackHandler());\n+    } catch (SaslException e) {\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * Determines whether the authentication exchange has completed successfully.\n+   */\n+  public synchronized boolean isComplete() {\n+    return saslServer != null && saslServer.isComplete();\n+  }\n+\n+  /**\n+   * Used to respond to server SASL tokens.\n+   * @param token Server's SASL token\n+   * @return response to send back to the server.\n+   */\n+  public synchronized byte[] response(byte[] token) {\n+    try {\n+      return saslServer != null ? saslServer.evaluateResponse(token) : new byte[0];\n+    } catch (SaslException e) {\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * Disposes of any system resources or security-sensitive information the\n+   * SaslServer might be using.\n+   */\n+  public synchronized void dispose() {\n+    if (saslServer != null) {\n+      try {\n+        saslServer.dispose();\n+      } catch (SaslException e) {\n+        // ignore\n+      } finally {\n+        saslServer = null;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Implementation of javax.security.auth.callback.CallbackHandler for SASL DIGEST-MD5 mechanism.\n+   */\n+  private class DigestCallbackHandler implements CallbackHandler {\n+    @Override\n+    public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n+      for (Callback callback : callbacks) {\n+        if (callback instanceof NameCallback) {\n+          logger.trace(\"SASL server callback: setting username\");\n+          NameCallback nc = (NameCallback) callback;\n+          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n+        } else if (callback instanceof PasswordCallback) {\n+          logger.trace(\"SASL server callback: setting password\");\n+          PasswordCallback pc = (PasswordCallback) callback;\n+          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n+        } else if (callback instanceof RealmCallback) {\n+          logger.trace(\"SASL server callback: setting realm\");\n+          RealmCallback rc = (RealmCallback) callback;\n+          rc.setText(rc.getDefaultText());\n+        } else if (callback instanceof AuthorizeCallback) {\n+          AuthorizeCallback ac = (AuthorizeCallback) callback;\n+          String authId = ac.getAuthenticationID();\n+          String authzId = ac.getAuthorizationID();\n+          ac.setAuthorized(authId.equals(authzId));\n+          if (ac.isAuthorized()) {\n+            ac.setAuthorizedID(authzId);\n+          }\n+          logger.debug(\"SASL Authorization complete, authorized set to {}\", ac.isAuthorized());\n+        } else {\n+          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /* Encode a byte[] identifier as a Base64-encoded string. */\n+  public static String encodeIdentifier(String identifier) {\n+    return BaseEncoding.base64().encode(identifier.getBytes(Charsets.UTF_8));\n+  }\n+\n+  /** Encode a password as a base64-encoded char[] array. */\n+  public static char[] encodePassword(String password) {\n+    if (password != null) {"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "I'm referring to this: https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/SparkSaslClient.scala#L118\n\nI'm not sure what should be done about the case where both sides have a null password. Could throw exceptions on both sides.\n",
    "commit": "3481718baf66f4c02568f08d7011af19a2c47f4b",
    "createdAt": "2014-11-04T16:58:49Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.BaseEncoding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A SASL Server for Spark which simply keeps track of the state of a single SASL session, from the\n+ * initial state to the \"authenticated\" state. (It is not a server in the sense of accepting\n+ * connections on some socket.)\n+ */\n+public class SparkSaslServer {\n+  private final Logger logger = LoggerFactory.getLogger(SparkSaslServer.class);\n+\n+  /**\n+   * This is passed as the server name when creating the sasl client/server.\n+   * This could be changed to be configurable in the future.\n+   */\n+  static final String DEFAULT_REALM = \"default\";\n+\n+  /**\n+   * The authentication mechanism used here is DIGEST-MD5. This could be changed to be\n+   * configurable in the future.\n+   */\n+  static final String DIGEST = \"DIGEST-MD5\";\n+\n+  /**\n+   * The quality of protection is just \"auth\". This means that we are doing\n+   * authentication only, we are not supporting integrity or privacy protection of the\n+   * communication channel after authentication. This could be changed to be configurable\n+   * in the future.\n+   */\n+  static final Map<String, String> SASL_PROPS = ImmutableMap.<String, String>builder()\n+    .put(Sasl.QOP, \"auth\")\n+    .put(Sasl.SERVER_AUTH, \"true\")\n+    .build();\n+\n+  /** Identifier for a certain secret key within the secretKeyHolder. */\n+  private final String secretKeyId;\n+  private final SecretKeyHolder secretKeyHolder;\n+  private SaslServer saslServer;\n+\n+  public SparkSaslServer(String secretKeyId, SecretKeyHolder secretKeyHolder) {\n+    this.secretKeyId = secretKeyId;\n+    this.secretKeyHolder = secretKeyHolder;\n+    try {\n+      this.saslServer = Sasl.createSaslServer(DIGEST, null, DEFAULT_REALM, SASL_PROPS,\n+        new DigestCallbackHandler());\n+    } catch (SaslException e) {\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * Determines whether the authentication exchange has completed successfully.\n+   */\n+  public synchronized boolean isComplete() {\n+    return saslServer != null && saslServer.isComplete();\n+  }\n+\n+  /**\n+   * Used to respond to server SASL tokens.\n+   * @param token Server's SASL token\n+   * @return response to send back to the server.\n+   */\n+  public synchronized byte[] response(byte[] token) {\n+    try {\n+      return saslServer != null ? saslServer.evaluateResponse(token) : new byte[0];\n+    } catch (SaslException e) {\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * Disposes of any system resources or security-sensitive information the\n+   * SaslServer might be using.\n+   */\n+  public synchronized void dispose() {\n+    if (saslServer != null) {\n+      try {\n+        saslServer.dispose();\n+      } catch (SaslException e) {\n+        // ignore\n+      } finally {\n+        saslServer = null;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Implementation of javax.security.auth.callback.CallbackHandler for SASL DIGEST-MD5 mechanism.\n+   */\n+  private class DigestCallbackHandler implements CallbackHandler {\n+    @Override\n+    public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n+      for (Callback callback : callbacks) {\n+        if (callback instanceof NameCallback) {\n+          logger.trace(\"SASL server callback: setting username\");\n+          NameCallback nc = (NameCallback) callback;\n+          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n+        } else if (callback instanceof PasswordCallback) {\n+          logger.trace(\"SASL server callback: setting password\");\n+          PasswordCallback pc = (PasswordCallback) callback;\n+          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n+        } else if (callback instanceof RealmCallback) {\n+          logger.trace(\"SASL server callback: setting realm\");\n+          RealmCallback rc = (RealmCallback) callback;\n+          rc.setText(rc.getDefaultText());\n+        } else if (callback instanceof AuthorizeCallback) {\n+          AuthorizeCallback ac = (AuthorizeCallback) callback;\n+          String authId = ac.getAuthenticationID();\n+          String authzId = ac.getAuthorizationID();\n+          ac.setAuthorized(authId.equals(authzId));\n+          if (ac.isAuthorized()) {\n+            ac.setAuthorizedID(authzId);\n+          }\n+          logger.debug(\"SASL Authorization complete, authorized set to {}\", ac.isAuthorized());\n+        } else {\n+          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /* Encode a byte[] identifier as a Base64-encoded string. */\n+  public static String encodeIdentifier(String identifier) {\n+    return BaseEncoding.base64().encode(identifier.getBytes(Charsets.UTF_8));\n+  }\n+\n+  /** Encode a password as a base64-encoded char[] array. */\n+  public static char[] encodePassword(String password) {\n+    if (password != null) {"
  }],
  "prId": 3087
}]