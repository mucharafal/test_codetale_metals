[{
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "Can this just be `registerWithShuffleService`? I think `standalone` is kinda implicit\n",
    "commit": "4d1f8c174f362028a6a439a567bc2241f82a61c6",
    "createdAt": "2014-10-31T01:09:19Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientFactory;\n+import org.apache.spark.network.server.NoOpRpcHandler;\n+import org.apache.spark.network.shuffle.StandaloneShuffleMessages.RegisterExecutor;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class StandaloneShuffleClient implements ShuffleClient {\n+  private final Logger logger = LoggerFactory.getLogger(StandaloneShuffleClient.class);\n+\n+  private final TransportClientFactory clientFactory;\n+  private final String appId;\n+\n+  public StandaloneShuffleClient(TransportConf conf, String appId) {\n+    TransportContext context = new TransportContext(conf, new NoOpRpcHandler());\n+    this.clientFactory = context.createClientFactory();\n+    this.appId = appId;\n+  }\n+\n+  @Override\n+  public void fetchBlocks(\n+      String host,\n+      int port,\n+      String execId,\n+      String[] blockIds,\n+      BlockFetchingListener listener) {\n+    logger.debug(\"Standalone shuffle fetch from {}:{} (executor id {})\", host, port, execId);\n+    try {\n+      TransportClient client = clientFactory.createClient(host, port);\n+      new OneForOneBlockFetcher(client, blockIds, listener)\n+        .start(new StandaloneShuffleMessages.OpenShuffleBlocks(appId, execId, blockIds));\n+    } catch (Exception e) {\n+      logger.error(\"Exception while beginning fetchBlocks\", e);\n+      for (String blockId : blockIds) {\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Registers this executor with a standalone shuffle server. This registration is required to\n+   * inform the shuffle server about where and how we store our shuffle files.\n+   *\n+   * @param host Host of standalone shuffle server.\n+   * @param port Port of standalone shuffle server.\n+   * @param execId This Executor's id.\n+   * @param executorConfig Contains all config necessary for the service to find our shuffle files.\n+   */\n+  public void registerWithStandaloneShuffleService("
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "or maybe `registerWithShuffleServer`, since we're registering with the server\n",
    "commit": "4d1f8c174f362028a6a439a567bc2241f82a61c6",
    "createdAt": "2014-10-31T02:07:39Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientFactory;\n+import org.apache.spark.network.server.NoOpRpcHandler;\n+import org.apache.spark.network.shuffle.StandaloneShuffleMessages.RegisterExecutor;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class StandaloneShuffleClient implements ShuffleClient {\n+  private final Logger logger = LoggerFactory.getLogger(StandaloneShuffleClient.class);\n+\n+  private final TransportClientFactory clientFactory;\n+  private final String appId;\n+\n+  public StandaloneShuffleClient(TransportConf conf, String appId) {\n+    TransportContext context = new TransportContext(conf, new NoOpRpcHandler());\n+    this.clientFactory = context.createClientFactory();\n+    this.appId = appId;\n+  }\n+\n+  @Override\n+  public void fetchBlocks(\n+      String host,\n+      int port,\n+      String execId,\n+      String[] blockIds,\n+      BlockFetchingListener listener) {\n+    logger.debug(\"Standalone shuffle fetch from {}:{} (executor id {})\", host, port, execId);\n+    try {\n+      TransportClient client = clientFactory.createClient(host, port);\n+      new OneForOneBlockFetcher(client, blockIds, listener)\n+        .start(new StandaloneShuffleMessages.OpenShuffleBlocks(appId, execId, blockIds));\n+    } catch (Exception e) {\n+      logger.error(\"Exception while beginning fetchBlocks\", e);\n+      for (String blockId : blockIds) {\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Registers this executor with a standalone shuffle server. This registration is required to\n+   * inform the shuffle server about where and how we store our shuffle files.\n+   *\n+   * @param host Host of standalone shuffle server.\n+   * @param port Port of standalone shuffle server.\n+   * @param execId This Executor's id.\n+   * @param executorConfig Contains all config necessary for the service to find our shuffle files.\n+   */\n+  public void registerWithStandaloneShuffleService("
  }],
  "prId": 3001
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "3 secs is very low? also we should retry\n",
    "commit": "4d1f8c174f362028a6a439a567bc2241f82a61c6",
    "createdAt": "2014-10-31T05:44:26Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientFactory;\n+import org.apache.spark.network.server.NoOpRpcHandler;\n+import org.apache.spark.network.shuffle.StandaloneShuffleMessages.RegisterExecutor;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class StandaloneShuffleClient implements ShuffleClient {\n+  private final Logger logger = LoggerFactory.getLogger(StandaloneShuffleClient.class);\n+\n+  private final TransportClientFactory clientFactory;\n+  private final String appId;\n+\n+  public StandaloneShuffleClient(TransportConf conf, String appId) {\n+    TransportContext context = new TransportContext(conf, new NoOpRpcHandler());\n+    this.clientFactory = context.createClientFactory();\n+    this.appId = appId;\n+  }\n+\n+  @Override\n+  public void fetchBlocks(\n+      String host,\n+      int port,\n+      String execId,\n+      String[] blockIds,\n+      BlockFetchingListener listener) {\n+    logger.debug(\"Standalone shuffle fetch from {}:{} (executor id {})\", host, port, execId);\n+    try {\n+      TransportClient client = clientFactory.createClient(host, port);\n+      new OneForOneBlockFetcher(client, blockIds, listener)\n+        .start(new StandaloneShuffleMessages.OpenShuffleBlocks(appId, execId, blockIds));\n+    } catch (Exception e) {\n+      logger.error(\"Exception while beginning fetchBlocks\", e);\n+      for (String blockId : blockIds) {\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Registers this executor with a standalone shuffle server. This registration is required to\n+   * inform the shuffle server about where and how we store our shuffle files.\n+   *\n+   * @param host Host of standalone shuffle server.\n+   * @param port Port of standalone shuffle server.\n+   * @param execId This Executor's id.\n+   * @param executorConfig Contains all config necessary for the service to find our shuffle files.\n+   */\n+  public void registerWithStandaloneShuffleService(\n+      String host,\n+      int port,\n+      String execId,\n+      ExecutorShuffleConfig executorConfig) {\n+    TransportClient client = clientFactory.createClient(host, port);\n+    byte[] registerExecutorMessage =\n+      JavaUtils.serialize(new RegisterExecutor(appId, execId, executorConfig));\n+    client.sendRpcSync(registerExecutorMessage, 3000);"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "The server should be local, so realistically the connection should take on the order of a few milliseconds. I can agree with retry, though!\n",
    "commit": "4d1f8c174f362028a6a439a567bc2241f82a61c6",
    "createdAt": "2014-10-31T17:30:24Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.shuffle;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientFactory;\n+import org.apache.spark.network.server.NoOpRpcHandler;\n+import org.apache.spark.network.shuffle.StandaloneShuffleMessages.RegisterExecutor;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class StandaloneShuffleClient implements ShuffleClient {\n+  private final Logger logger = LoggerFactory.getLogger(StandaloneShuffleClient.class);\n+\n+  private final TransportClientFactory clientFactory;\n+  private final String appId;\n+\n+  public StandaloneShuffleClient(TransportConf conf, String appId) {\n+    TransportContext context = new TransportContext(conf, new NoOpRpcHandler());\n+    this.clientFactory = context.createClientFactory();\n+    this.appId = appId;\n+  }\n+\n+  @Override\n+  public void fetchBlocks(\n+      String host,\n+      int port,\n+      String execId,\n+      String[] blockIds,\n+      BlockFetchingListener listener) {\n+    logger.debug(\"Standalone shuffle fetch from {}:{} (executor id {})\", host, port, execId);\n+    try {\n+      TransportClient client = clientFactory.createClient(host, port);\n+      new OneForOneBlockFetcher(client, blockIds, listener)\n+        .start(new StandaloneShuffleMessages.OpenShuffleBlocks(appId, execId, blockIds));\n+    } catch (Exception e) {\n+      logger.error(\"Exception while beginning fetchBlocks\", e);\n+      for (String blockId : blockIds) {\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Registers this executor with a standalone shuffle server. This registration is required to\n+   * inform the shuffle server about where and how we store our shuffle files.\n+   *\n+   * @param host Host of standalone shuffle server.\n+   * @param port Port of standalone shuffle server.\n+   * @param execId This Executor's id.\n+   * @param executorConfig Contains all config necessary for the service to find our shuffle files.\n+   */\n+  public void registerWithStandaloneShuffleService(\n+      String host,\n+      int port,\n+      String execId,\n+      ExecutorShuffleConfig executorConfig) {\n+    TransportClient client = clientFactory.createClient(host, port);\n+    byte[] registerExecutorMessage =\n+      JavaUtils.serialize(new RegisterExecutor(appId, execId, executorConfig));\n+    client.sendRpcSync(registerExecutorMessage, 3000);"
  }],
  "prId": 3001
}]