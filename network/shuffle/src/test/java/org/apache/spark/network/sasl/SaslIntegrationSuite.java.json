[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "how about renaming this to `gotException`?  I was momentarily confused thinking this was the result of a successful request.\n",
    "commit": "b491ac7f44880208a5e22d3dea4194eff6c53590",
    "createdAt": "2015-08-17T02:46:30Z",
    "diffHunk": "@@ -160,6 +164,111 @@ public void testNoSaslServer() {\n     }\n   }\n \n+  /**\n+   * This test is not actually testing SASL behavior, but testing that the shuffle service\n+   * performs correct authorization checks based on the SASL authentication data.\n+   */\n+  @Test\n+  public void testAppIsolation() throws Exception {\n+    // Start a new server with the correct RPC handler to serve block data.\n+    ExternalShuffleBlockResolver blockResolver = mock(ExternalShuffleBlockResolver.class);\n+    ExternalShuffleBlockHandler blockHandler = new ExternalShuffleBlockHandler(\n+      new OneForOneStreamManager(), blockResolver);\n+    TransportServerBootstrap bootstrap = new SaslServerBootstrap(conf, secretKeyHolder);\n+    TransportContext blockServerContext = new TransportContext(conf, blockHandler);\n+    TransportServer blockServer = blockServerContext.createServer(Arrays.asList(bootstrap));\n+\n+    TransportClient client1 = null;\n+    TransportClient client2 = null;\n+    TransportClientFactory clientFactory2 = null;\n+    try {\n+      // Create a client, and make a request to fetch blocks from a different app.\n+      clientFactory = blockServerContext.createClientFactory(\n+        Lists.<TransportClientBootstrap>newArrayList(\n+          new SaslClientBootstrap(conf, \"app-1\", secretKeyHolder)));\n+      client1 = clientFactory.createClient(TestUtils.getLocalHost(),\n+        blockServer.getPort());\n+\n+      final AtomicBoolean result = new AtomicBoolean(false);"
  }],
  "prId": 8218
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I think you can delete this, its not checked between here and the next `result.set(false)`\n",
    "commit": "b491ac7f44880208a5e22d3dea4194eff6c53590",
    "createdAt": "2015-08-17T02:47:06Z",
    "diffHunk": "@@ -160,6 +164,111 @@ public void testNoSaslServer() {\n     }\n   }\n \n+  /**\n+   * This test is not actually testing SASL behavior, but testing that the shuffle service\n+   * performs correct authorization checks based on the SASL authentication data.\n+   */\n+  @Test\n+  public void testAppIsolation() throws Exception {\n+    // Start a new server with the correct RPC handler to serve block data.\n+    ExternalShuffleBlockResolver blockResolver = mock(ExternalShuffleBlockResolver.class);\n+    ExternalShuffleBlockHandler blockHandler = new ExternalShuffleBlockHandler(\n+      new OneForOneStreamManager(), blockResolver);\n+    TransportServerBootstrap bootstrap = new SaslServerBootstrap(conf, secretKeyHolder);\n+    TransportContext blockServerContext = new TransportContext(conf, blockHandler);\n+    TransportServer blockServer = blockServerContext.createServer(Arrays.asList(bootstrap));\n+\n+    TransportClient client1 = null;\n+    TransportClient client2 = null;\n+    TransportClientFactory clientFactory2 = null;\n+    try {\n+      // Create a client, and make a request to fetch blocks from a different app.\n+      clientFactory = blockServerContext.createClientFactory(\n+        Lists.<TransportClientBootstrap>newArrayList(\n+          new SaslClientBootstrap(conf, \"app-1\", secretKeyHolder)));\n+      client1 = clientFactory.createClient(TestUtils.getLocalHost(),\n+        blockServer.getPort());\n+\n+      final AtomicBoolean result = new AtomicBoolean(false);\n+\n+      BlockFetchingListener listener = new BlockFetchingListener() {\n+        @Override\n+        public synchronized void onBlockFetchSuccess(String blockId, ManagedBuffer data) {\n+          notifyAll();\n+        }\n+\n+        @Override\n+        public synchronized void onBlockFetchFailure(String blockId, Throwable exception) {\n+          result.set(exception.getMessage().contains(SecurityException.class.getName()));\n+          notifyAll();\n+        }\n+      };\n+\n+      String[] blockIds = new String[] { \"shuffle_2_3_4\", \"shuffle_6_7_8\" };\n+      OneForOneBlockFetcher fetcher = new OneForOneBlockFetcher(client1, \"app-2\", \"0\",\n+        blockIds, listener);\n+      synchronized (listener) {\n+        fetcher.start();\n+        listener.wait();\n+      }\n+      assertTrue(\"Should have failed to fetch blocks from non-authorized app.\", result.get());\n+\n+      // Register an executor so that the next steps work.\n+      ExecutorShuffleInfo executorInfo = new ExecutorShuffleInfo(\n+        new String[] { System.getProperty(\"java.io.tmpdir\") }, 1,\n+        \"org.apache.spark.shuffle.sort.SortShuffleManager\");\n+      RegisterExecutor regmsg = new RegisterExecutor(\"app-1\", \"0\", executorInfo);\n+      client1.sendRpcSync(regmsg.toByteArray(), 10000);\n+\n+      // Make a successful request to fetch blocks, which creates a new stream. But do not actually\n+      // fetch any blocks, to keep the stream open.\n+      result.set(false);"
  }],
  "prId": 8218
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "nit: unused, delete\n",
    "commit": "b491ac7f44880208a5e22d3dea4194eff6c53590",
    "createdAt": "2015-08-17T21:32:21Z",
    "diffHunk": "@@ -19,17 +19,24 @@\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;"
  }],
  "prId": 8218
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "nit: unused, delete (and then the imports too)\n",
    "commit": "b491ac7f44880208a5e22d3dea4194eff6c53590",
    "createdAt": "2015-08-17T21:32:42Z",
    "diffHunk": "@@ -39,44 +46,41 @@\n import org.apache.spark.network.server.StreamManager;\n import org.apache.spark.network.server.TransportServer;\n import org.apache.spark.network.server.TransportServerBootstrap;\n+import org.apache.spark.network.shuffle.BlockFetchingListener;\n import org.apache.spark.network.shuffle.ExternalShuffleBlockHandler;\n+import org.apache.spark.network.shuffle.ExternalShuffleBlockResolver;\n+import org.apache.spark.network.shuffle.OneForOneBlockFetcher;\n+import org.apache.spark.network.shuffle.protocol.BlockTransferMessage;\n+import org.apache.spark.network.shuffle.protocol.ExecutorShuffleInfo;\n+import org.apache.spark.network.shuffle.protocol.OpenBlocks;\n+import org.apache.spark.network.shuffle.protocol.RegisterExecutor;\n+import org.apache.spark.network.shuffle.protocol.StreamHandle;\n import org.apache.spark.network.util.SystemPropertyConfigProvider;\n import org.apache.spark.network.util.TransportConf;\n \n public class SaslIntegrationSuite {\n-  static ExternalShuffleBlockHandler handler;\n+  private final Logger logger = LoggerFactory.getLogger(SaslIntegrationSuite.class);"
  }],
  "prId": 8218
}]