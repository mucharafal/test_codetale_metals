[
  {
    "id" : "99337515-83ab-4295-9da2-5947a8e85ebb",
    "prId" : 919,
    "comments" : [
      {
        "id" : "27032020-c274-47b8-bee8-40bea681b181",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "formatting looks a bit stretched. can something be done with it? e.g. extracting parameters to variables",
        "createdAt" : "2019-09-13T09:18:16Z",
        "updatedAt" : "2019-09-13T11:02:47Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "992b86233b09b98f9a6c34c8da57c19d9562d623",
    "line" : null,
    "diffHunk" : "@@ -95,30 +112,61 @@ final class OnTypeFormattingProvider(\n     shouldAddPipes\n   }\n \n-  def format(\n-      params: DocumentOnTypeFormattingParams\n-  ): Future[java.util.List[TextEdit]] = {\n-    val source = params.getTextDocument.getUri.toAbsolutePath\n-    val range = new Range(params.getPosition, params.getPosition)\n-\n-    val edit = if (source.exists) {\n+  private def withToken(\n+      textId: TextDocumentIdentifier,\n+      range: Range,\n+      newlineAdded: Boolean\n+  )(\n+      fn: (String, meta.Position) => List[TextEdit]\n+  ): Future[List[TextEdit]] = Future {\n+    val source = textId.getUri.toAbsolutePath\n+    if (source.exists) {\n       val sourceText = buffer.get(source).getOrElse(\"\")\n-      val pos = params.getPosition.toMeta(\n+      val pos = range.getStart.toMeta(\n         Input.VirtualFile(source.toString(), sourceText)\n       )\n-      if (pipeInScope(pos, sourceText)) {\n+      if (pipeInScope(pos, sourceText, newlineAdded)) {\n         val tokens =\n           Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n-        tokens.flatMap { tokens: Tokens =>\n-          if (multilineStringInTokens(tokens, pos, sourceText)) {\n-            Some(new TextEdit(range, indent(sourceText, pos) + \"|\"))\n-          } else {\n-            None\n-          }\n+        tokens.toList.flatMap { tokens: Tokens =>\n+          if (multilineStringInTokens(tokens, pos, sourceText))\n+            fn(sourceText, pos)\n+          else Nil\n         }\n-      } else None\n-    } else None\n-    Future.successful(edit.toList.asJava)\n+      } else Nil\n+    } else Nil\n   }\n \n+  def format(\n+      params: DocumentOnTypeFormattingParams\n+  ): Future[List[TextEdit]] = {\n+    val range = new Range(params.getPosition, params.getPosition)\n+    withToken("
  },
  {
    "id" : "91671277-0adb-448b-bf8a-b4a9a39c7a22",
    "prId" : 919,
    "comments" : [
      {
        "id" : "4ce0f36e-158c-4fc5-9053-f93bb043a61d",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "maybe `findLastBetween(source: String, pattern: Char, lowerBound: Int, upperBound: Int)` ? I was kind of expecting it to find first between `currentPos` and `stop`",
        "createdAt" : "2019-09-13T09:24:57Z",
        "updatedAt" : "2019-09-13T11:02:47Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "992b86233b09b98f9a6c34c8da57c19d9562d623",
    "line" : null,
    "diffHunk" : "@@ -37,13 +41,23 @@ final class OnTypeFormattingProvider(\n     }\n   }\n \n-  private def indent(toInput: String, pos: meta.Position): String = {\n-    val beforePos = toInput.substring(0, pos.start)\n-    val lastPipe = beforePos.lastIndexOf(\"|\")\n-    val lastNewline = beforePos.lastIndexOf(\"\\n\", lastPipe)\n-    val indent = beforePos.substring(beforePos.lastIndexOf(\"\\n\")).length\n-    val length = toInput.substring(lastNewline, lastPipe).length\n-    space * (length - indent)\n+  private def findChar("
  },
  {
    "id" : "3f7401ee-970a-45a4-815c-a0ceea7e941e",
    "prId" : 919,
    "comments" : [
      {
        "id" : "4fe63800-c83c-46a4-a67c-db2cbfa47a2e",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "isn't it `lastNewLineBeforePos` ?",
        "createdAt" : "2019-09-13T09:27:05Z",
        "updatedAt" : "2019-09-13T11:02:47Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "992b86233b09b98f9a6c34c8da57c19d9562d623",
    "line" : null,
    "diffHunk" : "@@ -57,13 +71,16 @@ final class OnTypeFormattingProvider(\n     pos.start >= token.start && pos.end <= token.end\n   }\n \n-  private def pipeInScope(pos: meta.Position, text: String): Boolean = {\n-    val firstNewline = text.substring(0, pos.start).lastIndexOf(\"\\n\")\n-    val lastNewline =\n-      text.substring(0, firstNewline).lastIndexOf(\"\\n\")\n-    text\n-      .substring(lastNewline + 1, pos.start)\n-      .contains(\"|\")\n+  private def pipeInScope(\n+      pos: meta.Position,\n+      text: String,\n+      newlineAdded: Boolean\n+  ): Boolean = {\n+    val firstNewline = findChar(text, '\\n', pos.start - 1)"
  },
  {
    "id" : "e31e316f-6349-419e-990c-9f3b20d7c5db",
    "prId" : 919,
    "comments" : [
      {
        "id" : "50c067fb-2e0a-49bb-a0d1-176bcb8d7910",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "could it be named more concretely to express the intent behind this variable?",
        "createdAt" : "2019-09-13T09:31:12Z",
        "updatedAt" : "2019-09-13T11:02:47Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "992b86233b09b98f9a6c34c8da57c19d9562d623",
    "line" : null,
    "diffHunk" : "@@ -57,13 +71,16 @@ final class OnTypeFormattingProvider(\n     pos.start >= token.start && pos.end <= token.end\n   }\n \n-  private def pipeInScope(pos: meta.Position, text: String): Boolean = {\n-    val firstNewline = text.substring(0, pos.start).lastIndexOf(\"\\n\")\n-    val lastNewline =\n-      text.substring(0, firstNewline).lastIndexOf(\"\\n\")\n-    text\n-      .substring(lastNewline + 1, pos.start)\n-      .contains(\"|\")\n+  private def pipeInScope(\n+      pos: meta.Position,\n+      text: String,\n+      newlineAdded: Boolean\n+  ): Boolean = {\n+    val firstNewline = findChar(text, '\\n', pos.start - 1)\n+    val stop ="
  },
  {
    "id" : "4bea57e0-0227-4d23-a034-1f0319539abb",
    "prId" : 919,
    "comments" : [
      {
        "id" : "ada49b92-d8f3-4a07-a7c3-d69b6ee0152b",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "```scala\r\ntokens.toList\r\n  .filter(multilineStringInTokens(_, pos, sourceText))\r\n  .flatMap(_ => fn(sourceText, pos))\r\n```",
        "createdAt" : "2019-09-13T09:34:54Z",
        "updatedAt" : "2019-09-13T11:02:47Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "992b86233b09b98f9a6c34c8da57c19d9562d623",
    "line" : null,
    "diffHunk" : "@@ -95,30 +112,61 @@ final class OnTypeFormattingProvider(\n     shouldAddPipes\n   }\n \n-  def format(\n-      params: DocumentOnTypeFormattingParams\n-  ): Future[java.util.List[TextEdit]] = {\n-    val source = params.getTextDocument.getUri.toAbsolutePath\n-    val range = new Range(params.getPosition, params.getPosition)\n-\n-    val edit = if (source.exists) {\n+  private def withToken(\n+      textId: TextDocumentIdentifier,\n+      range: Range,\n+      newlineAdded: Boolean\n+  )(\n+      fn: (String, meta.Position) => List[TextEdit]\n+  ): Future[List[TextEdit]] = Future {\n+    val source = textId.getUri.toAbsolutePath\n+    if (source.exists) {\n       val sourceText = buffer.get(source).getOrElse(\"\")\n-      val pos = params.getPosition.toMeta(\n+      val pos = range.getStart.toMeta(\n         Input.VirtualFile(source.toString(), sourceText)\n       )\n-      if (pipeInScope(pos, sourceText)) {\n+      if (pipeInScope(pos, sourceText, newlineAdded)) {\n         val tokens =\n           Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n-        tokens.flatMap { tokens: Tokens =>\n-          if (multilineStringInTokens(tokens, pos, sourceText)) {\n-            Some(new TextEdit(range, indent(sourceText, pos) + \"|\"))\n-          } else {\n-            None\n-          }\n+        tokens.toList.flatMap { tokens: Tokens =>"
  },
  {
    "id" : "ad60770b-e5a7-46f2-8627-f6b61ab6b108",
    "prId" : 968,
    "comments" : [
      {
        "id" : "f39108ed-7e4f-4741-aba9-fa492f59a8b5",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Let's maybe move `line =>` etc to a separate function?",
        "createdAt" : "2019-10-07T12:40:32Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f64d2110efe05696503246eef780ee3f06207249",
    "line" : null,
    "diffHunk" : "@@ -156,19 +152,43 @@ final class MultilineStringFormattingProvider(\n     }\n   }\n \n-  def format(\n-      params: DocumentRangeFormattingParams\n-  ): Future[List[TextEdit]] = {\n+  def format(params: DocumentRangeFormattingParams): Future[List[TextEdit]] = {\n     val source = params.getTextDocument.getUri.toAbsolutePath\n     val range = params.getRange()\n     val doc = params.getTextDocument()\n     withToken(doc, range, newlineAdded = false) { (sourceText, position) =>\n-      val newText = indent(sourceText, position.start) + \"|\"\n-      val lines = (range.getStart().getLine() + 1) to range.getEnd().getLine()\n-      lines.map { line =>\n-        val pos = new Position(line, 0)\n-        new TextEdit(new Range(pos, pos), newText)\n+      val splitLines = sourceText.split('\\n')\n+      val defaultIndent = indent(sourceText, position.start)\n+      val linesToFormat = (range.getStart().getLine()) to range\n+        .getEnd()\n+        .getLine()\n+\n+      linesToFormat.map { line =>"
  },
  {
    "id" : "ee535c8c-5932-4a80-9bf1-fda29ae6e3a2",
    "prId" : 968,
    "comments" : [
      {
        "id" : "4770598c-75b6-41fd-a6ed-b0ec42809bed",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "What if there is an empty line pasted?\r\n```\r\n| some line of text\r\n\r\n| another line of text\r\n```\r\n",
        "createdAt" : "2019-10-10T07:53:56Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "012555c3-2dc4-4369-8fa2-f8e212465b59",
        "parentId" : "4770598c-75b6-41fd-a6ed-b0ec42809bed",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Again, good call 👍 ",
        "createdAt" : "2019-10-11T09:18:14Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f64d2110efe05696503246eef780ee3f06207249",
    "line" : null,
    "diffHunk" : "@@ -126,28 +125,55 @@ final class MultilineStringFormattingProvider(\n       textId: TextDocumentIdentifier,\n       range: Range,\n       newlineAdded: Boolean\n-  )(\n-      fn: (String, meta.Position) => List[TextEdit]\n-  ): Future[List[TextEdit]] = Future {\n-    val source = textId.getUri.toAbsolutePath\n-    if (source.exists) {\n-      val sourceText = buffer.get(source).getOrElse(\"\")\n-      val pos = range.getStart.toMeta(\n-        Input.VirtualFile(source.toString(), sourceText)\n-      )\n-      if (pipeInScope(pos, sourceText, newlineAdded)) {\n-        val tokens =\n-          Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n-        tokens.toList\n-          .filter(multilineStringInTokens(_, pos, sourceText))\n-          .flatMap(_ => fn(sourceText, pos))\n+  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n+    Future {\n+      val source = textId.getUri.toAbsolutePath\n+      if (source.exists) {\n+        val sourceText = buffer.get(source).getOrElse(\"\")\n+        val pos = range.getStart.toMeta(\n+          Input.VirtualFile(source.toString(), sourceText)\n+        )\n+        if (pipeInScope(pos, sourceText, newlineAdded)) {\n+          val tokens =\n+            Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n+          tokens.toList\n+            .filter(multilineStringInTokens(_, pos, sourceText))\n+            .flatMap(_ => fn(sourceText, pos))\n+        } else Nil\n       } else Nil\n-    } else Nil\n+    }\n+\n+  private def formatPipeLine(\n+      line: Int,\n+      lines: Array[String],\n+      defaultIndent: String\n+  ): TextEdit = {\n+    val zeroPos = new Position(line, 0)\n+    val lineText = lines(line)\n+    val firstChar = lineText.trim.head\n+    if (charIsPipe(firstChar)) {\n+      val firstPipeIndex = lineText.indexOf('|')\n+\n+      /* There may be an existing pipe on the line the text\n+      was pasted into. We need to see if the first char after\n+      the initial pipe is also a pipe confirming a multilineString\n+      being pasted into another multilineString*/\n+      val firstCharAfterPipe = lineText.trim.tail.trim.head"
  },
  {
    "id" : "850e2a19-00b1-4652-97aa-5dca551eece1",
    "prId" : 968,
    "comments" : [
      {
        "id" : "6bb04605-3273-4026-959b-1b3cf7f7d0d4",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We could simplify it:\r\n```\r\ncase Some(char) if charIsPipe(char) =>\r\n   val secondPipeIndex = lineText.indexOf('|', firstPipeIndex + 1)\r\n   val secondPipePos = new Position(line, secondPipeIndex)\r\n   new TextEdit(new Range(zeroPos, secondPipePos), defaultIndent)\r\ncase _ =>\r\n  val pipePos = new Position(line, firstPipeIndex)\r\n  new TextEdit(new Range(zeroPos, pipePos), defaultIndent)\r\n```\r\n\r\nThe same with the other match",
        "createdAt" : "2019-10-11T15:33:30Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "706b47a7-3bc9-4b3d-9812-2a78fbf3dc37",
        "parentId" : "6bb04605-3273-4026-959b-1b3cf7f7d0d4",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Ahh, yea, that is much nicer. I appreciate all the input!",
        "createdAt" : "2019-10-11T20:04:30Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f64d2110efe05696503246eef780ee3f06207249",
    "line" : null,
    "diffHunk" : "@@ -126,28 +125,64 @@ final class MultilineStringFormattingProvider(\n       textId: TextDocumentIdentifier,\n       range: Range,\n       newlineAdded: Boolean\n-  )(\n-      fn: (String, meta.Position) => List[TextEdit]\n-  ): Future[List[TextEdit]] = Future {\n-    val source = textId.getUri.toAbsolutePath\n-    if (source.exists) {\n-      val sourceText = buffer.get(source).getOrElse(\"\")\n-      val pos = range.getStart.toMeta(\n-        Input.VirtualFile(source.toString(), sourceText)\n-      )\n-      if (pipeInScope(pos, sourceText, newlineAdded)) {\n-        val tokens =\n-          Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n-        tokens.toList\n-          .filter(multilineStringInTokens(_, pos, sourceText))\n-          .flatMap(_ => fn(sourceText, pos))\n+  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n+    Future {\n+      val source = textId.getUri.toAbsolutePath\n+      if (source.exists) {\n+        val sourceText = buffer.get(source).getOrElse(\"\")\n+        val pos = range.getStart.toMeta(\n+          Input.VirtualFile(source.toString(), sourceText)\n+        )\n+        if (pipeInScope(pos, sourceText, newlineAdded)) {\n+          val tokens =\n+            Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n+          tokens.toList\n+            .filter(multilineStringInTokens(_, pos, sourceText))\n+            .flatMap(_ => fn(sourceText, pos))\n+        } else Nil\n       } else Nil\n-    } else Nil\n+    }\n+\n+  private def formatPipeLine(\n+      line: Int,\n+      lines: Array[String],\n+      defaultIndent: String\n+  ): TextEdit = {\n+    val zeroPos = new Position(line, 0)\n+    val lineText = lines(line)\n+    val firstChar = lineText.trim.headOption\n+\n+    firstChar match {\n+      case Some(char) =>\n+        if (charIsPipe(char)) {\n+          val firstPipeIndex = lineText.indexOf('|')\n+          val firstCharAfterPipe = lineText.trim.tail.trim.headOption\n+\n+          firstCharAfterPipe match {\n+            case Some(char) =>"
  },
  {
    "id" : "23486319-b8af-4b58-9e55-73dbc0dd9252",
    "prId" : 968,
    "comments" : [
      {
        "id" : "7b893abb-f38b-417f-95c2-3ec0248112c0",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nit: try to avoid non-symbolic infix operators such as `to`\r\n\r\n```suggestion\r\n      val linesToFormat = range.getStart().getLine()).to(range.getEnd().getLine())\r\n```",
        "createdAt" : "2019-10-13T21:47:13Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9ff791b5-680c-40f1-8476-24119648f32b",
        "parentId" : "7b893abb-f38b-417f-95c2-3ec0248112c0",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Sounds good, made the change.",
        "createdAt" : "2019-10-14T05:28:12Z",
        "updatedAt" : "2019-10-14T05:28:12Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f64d2110efe05696503246eef780ee3f06207249",
    "line" : null,
    "diffHunk" : "@@ -156,19 +181,21 @@ final class MultilineStringFormattingProvider(\n     }\n   }\n \n-  def format(\n-      params: DocumentRangeFormattingParams\n-  ): Future[List[TextEdit]] = {\n+  def format(params: DocumentRangeFormattingParams): Future[List[TextEdit]] = {\n     val source = params.getTextDocument.getUri.toAbsolutePath\n     val range = params.getRange()\n     val doc = params.getTextDocument()\n     withToken(doc, range, newlineAdded = false) { (sourceText, position) =>\n-      val newText = indent(sourceText, position.start) + \"|\"\n-      val lines = (range.getStart().getLine() + 1) to range.getEnd().getLine()\n-      lines.map { line =>\n-        val pos = new Position(line, 0)\n-        new TextEdit(new Range(pos, pos), newText)\n-      }.toList\n+      val splitLines = sourceText.split('\\n')\n+      val defaultIndent = determineDefaultIndent(sourceText, position.start)\n+      val linesToFormat = (range.getStart().getLine()) to range"
  },
  {
    "id" : "4e0d4d8e-4ea1-470c-b384-502888be0d8b",
    "prId" : 968,
    "comments" : [
      {
        "id" : "d592fd05-6bb5-466a-9410-fc01661faa95",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nit: literal patterns could make this a bit nicer to read\r\n\r\n```suggestion\r\n      case Some('|') =>\r\n```",
        "createdAt" : "2019-10-13T21:49:53Z",
        "updatedAt" : "2019-10-14T05:25:56Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1167e6eb-8b29-46a5-b10f-565348d0e7da",
        "parentId" : "d592fd05-6bb5-466a-9410-fc01661faa95",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Ahh, that is simpler. Good call.",
        "createdAt" : "2019-10-14T05:28:53Z",
        "updatedAt" : "2019-10-14T05:28:53Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f64d2110efe05696503246eef780ee3f06207249",
    "line" : null,
    "diffHunk" : "@@ -126,28 +125,54 @@ final class MultilineStringFormattingProvider(\n       textId: TextDocumentIdentifier,\n       range: Range,\n       newlineAdded: Boolean\n-  )(\n-      fn: (String, meta.Position) => List[TextEdit]\n-  ): Future[List[TextEdit]] = Future {\n-    val source = textId.getUri.toAbsolutePath\n-    if (source.exists) {\n-      val sourceText = buffer.get(source).getOrElse(\"\")\n-      val pos = range.getStart.toMeta(\n-        Input.VirtualFile(source.toString(), sourceText)\n-      )\n-      if (pipeInScope(pos, sourceText, newlineAdded)) {\n-        val tokens =\n-          Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n-        tokens.toList\n-          .filter(multilineStringInTokens(_, pos, sourceText))\n-          .flatMap(_ => fn(sourceText, pos))\n+  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n+    Future {\n+      val source = textId.getUri.toAbsolutePath\n+      if (source.exists) {\n+        val sourceText = buffer.get(source).getOrElse(\"\")\n+        val pos = range.getStart.toMeta(\n+          Input.VirtualFile(source.toString(), sourceText)\n+        )\n+        if (pipeInScope(pos, sourceText, newlineAdded)) {\n+          val tokens =\n+            Input.VirtualFile(source.toString(), sourceText).tokenize.toOption\n+          tokens.toList\n+            .filter(multilineStringInTokens(_, pos, sourceText))\n+            .flatMap(_ => fn(sourceText, pos))\n+        } else Nil\n       } else Nil\n-    } else Nil\n+    }\n+\n+  private def formatPipeLine(\n+      line: Int,\n+      lines: Array[String],\n+      defaultIndent: String\n+  ): TextEdit = {\n+    val zeroPos = new Position(line, 0)\n+    val lineText = lines(line)\n+    val firstChar = lineText.trim.headOption\n+\n+    firstChar match {\n+      case Some(char) if charIsPipe(char) =>"
  },
  {
    "id" : "63e97708-6463-49d7-b704-7456fa318f88",
    "prId" : 1245,
    "comments" : [
      {
        "id" : "a522ed6c-f864-473c-b8be-657d92f88c5c",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "What happens if the line doesn’t have a pipe? It’s optional ",
        "createdAt" : "2020-01-04T09:27:50Z",
        "updatedAt" : "2020-01-04T09:27:55Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fd2e645a-350a-4672-8c01-8a3a3c842586",
        "parentId" : "a522ed6c-f864-473c-b8be-657d92f88c5c",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "If there is no pipe on the line it gets filtered out beforehand and the line never enters the `formatPipeLine` method. I suppose I should have added a test for this as well. I did just check it locally and that indeed is how it works.",
        "createdAt" : "2020-01-04T09:35:18Z",
        "updatedAt" : "2020-01-04T09:35:18Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "046a0658-2495-4057-bae0-36810f4a0f72",
        "parentId" : "a522ed6c-f864-473c-b8be-657d92f88c5c",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "I just added another test for this https://github.com/scalameta/metals/pull/1249",
        "createdAt" : "2020-01-04T09:44:57Z",
        "updatedAt" : "2020-01-04T09:44:57Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "25ddacc3853e17014cc610d9cfe8136470e9df4b",
    "line" : 27,
    "diffHunk" : "@@ -159,14 +159,24 @@ final class MultilineStringFormattingProvider(\n           case Some('|') =>\n             val secondPipeIndex = lineText.indexOf('|', firstPipeIndex + 1)\n             val secondPipePos = new Position(line, secondPipeIndex)\n-            new TextEdit(new Range(zeroPos, secondPipePos), defaultIndent)\n+            val textEdit =\n+              new TextEdit(new Range(zeroPos, secondPipePos), defaultIndent)\n+            Some(textEdit)\n           case _ =>\n             val pipePos = new Position(line, firstPipeIndex)\n-            new TextEdit(new Range(zeroPos, pipePos), defaultIndent)\n+            val textEdit =\n+              new TextEdit(new Range(zeroPos, pipePos), defaultIndent)\n+            Some(textEdit)\n         }\n       case _ =>\n-        val newText = defaultIndent + \"|\"\n-        new TextEdit(new Range(zeroPos, zeroPos), newText)\n+        val isFirstLineOfMultiLine = lineText.trim.contains(\"\\\"\\\"\\\"|\")"
  },
  {
    "id" : "c5400de9-0a38-4e7c-aa90-367a9b04af58",
    "prId" : 1427,
    "comments" : [
      {
        "id" : "ec35b47d-e5ca-4068-8d99-2d4b61ae858a",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Since we check previously if there is a pipe in the line, the lastPipe inex will be correct.",
        "createdAt" : "2020-02-13T12:03:54Z",
        "updatedAt" : "2020-02-13T12:03:55Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e673d27c52888fd69c6c7e20b1a3b2839ff8b93f",
    "line" : 5,
    "diffHunk" : "@@ -41,7 +41,7 @@ final class MultilineStringFormattingProvider(\n   }\n \n   private def determineDefaultIndent(sourceText: String, start: Int): String = {\n-    val lastPipe = sourceText.lastIndexBetween('|', upperBound = start)\n+    val lastPipe = sourceText.indexOf('|')"
  },
  {
    "id" : "4b059288-efec-42ce-a2b2-7e17c948f849",
    "prId" : 1478,
    "comments" : [
      {
        "id" : "4c10f01b-3baf-4e6f-a302-7c53309adde6",
        "parentId" : null,
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "If I understand this correctly, this isn't needed here since we can just calculate starting at the position start rather then the position start -1 to determine the last index between the new line and the position start. This is what was throwing the exception when we were trying to get the index using the value here, which was -1 when in the beginning of the file.",
        "createdAt" : "2020-03-04T13:45:01Z",
        "updatedAt" : "2020-03-04T13:45:02Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f97e2a63-cd2c-47e6-995f-9b97849f9bba",
        "parentId" : "4c10f01b-3baf-4e6f-a302-7c53309adde6",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We probably just need `Math.max(pos.start - 1, 0)`",
        "createdAt" : "2020-03-04T14:22:46Z",
        "updatedAt" : "2020-03-04T14:22:47Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "312654f1-4977-426b-9d4a-70b42496333d",
        "parentId" : "4c10f01b-3baf-4e6f-a302-7c53309adde6",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "I'm working on a fix for #1477, so I'll include the fix for both in another pr.",
        "createdAt" : "2020-03-04T14:23:59Z",
        "updatedAt" : "2020-03-04T14:24:00Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "775539ae-c47f-4a59-a57a-8f6780e66e94",
        "parentId" : "4c10f01b-3baf-4e6f-a302-7c53309adde6",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "When pressing enter we search for `newLineBeforePos`(where our newline was added). Then we search for '\\n' before that and assign it to `pipeSearchStop` and it gives us a range [pipeSearchStop, newLineBeforePos] which is our previous line. Then we check if it contains '|' and if that is the case we do formatting(add '|' in current line properly aligned).\r\n\r\nIn current code it fails because it starts to search `pipeSearchStop` from position -1, I think we should simply add `Math.max(0, xxx - 1)` in both cases where we do search for \\n",
        "createdAt" : "2020-03-04T14:29:22Z",
        "updatedAt" : "2020-03-04T14:29:23Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "03de18f3-2f0a-45a5-b32b-1794b26511da",
        "parentId" : "4c10f01b-3baf-4e6f-a302-7c53309adde6",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "@tgodzik you were faster with a comment, ignore mine :P",
        "createdAt" : "2020-03-04T14:37:21Z",
        "updatedAt" : "2020-03-04T14:37:22Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ad66aeec2ed20ba2ae0ee3c45a4372adb5f0fc2e",
    "line" : 4,
    "diffHunk" : "@@ -78,7 +78,7 @@ final class MultilineStringFormattingProvider(\n       newlineAdded: Boolean\n   ): Boolean = {\n     val newLineBeforePos =\n-      text.lastIndexBetween('\\n', upperBound = pos.start - 1)"
  },
  {
    "id" : "8376f70c-8da0-4e2b-beda-36f273dd625a",
    "prId" : 1505,
    "comments" : [
      {
        "id" : "95356fcf-df43-4a5c-b058-282daa2286fb",
        "parentId" : null,
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "unused variable after changes",
        "createdAt" : "2020-03-17T10:18:17Z",
        "updatedAt" : "2020-03-17T14:46:42Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "25ae39a4-58c5-4d9d-b253-a1a9200a82ae",
        "parentId" : "95356fcf-df43-4a5c-b058-282daa2286fb",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Thanks! Removed.",
        "createdAt" : "2020-03-17T14:49:17Z",
        "updatedAt" : "2020-03-17T14:49:17Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fdb5a38d8231228e2f26bf5f72437a9a6868eb6e",
    "line" : null,
    "diffHunk" : "@@ -40,18 +40,23 @@ final class MultilineStringFormattingProvider(\n     }\n   }\n \n-  private def determineDefaultIndent(sourceText: String, start: Int): String = {\n-    val lastPipe = sourceText.indexOf('|')\n-    val lastNewline = sourceText.lastIndexBetween('\\n', upperBound = lastPipe)\n-    space * (lastPipe - lastNewline - 1)\n+  private def determineDefaultIndent(\n+      lines: Array[String],\n+      lineNumberToCheck: Int\n+  ): String = {\n+    val lineToCheck = lines(lineNumberToCheck)\n+    val lastPipe = lineToCheck.indexOf('|')\n+    space * lastPipe\n   }\n \n   private def indent(\n       sourceText: String,\n       start: Int,"
  },
  {
    "id" : "a91ec792-18f9-432d-ae12-10be794c0daf",
    "prId" : 1585,
    "comments" : [
      {
        "id" : "e0ed569c-be82-4d72-b726-edd79e21c3e6",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't think the change is needed, although it does look nicer. We previously used `while` to be sure that we are as optimized as possible and we don't create any additional objects, so maybe we should keep it? I am not 100 % sure if that is super needed, but I would feel saver about it.",
        "createdAt" : "2020-04-07T07:59:12Z",
        "updatedAt" : "2020-04-08T14:25:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44a4099e52ba67ba04b29fc92781f01debbc921f",
    "line" : null,
    "diffHunk" : "@@ -27,14 +27,14 @@ final class MultilineStringFormattingProvider(\n       stringTokenIndex: Int,\n       tokens: Tokens\n   ): Boolean = {\n-    var methodIndex = stringTokenIndex + 1\n-    while (tokens(methodIndex).isWhiteSpaceOrComment ||\n-      tokens(methodIndex).isInstanceOf[Token.Dot]) methodIndex += 1\n-    tokens(methodIndex) match {\n-      case token: Token.Ident if token.value == stripMargin =>\n-        true\n-      case other =>\n-        false\n+    val nextTokenOpt = tokens.tokens"
  },
  {
    "id" : "72039149-92d2-492c-8e8b-78828472965f",
    "prId" : 1585,
    "comments" : [
      {
        "id" : "5e90876e-4efe-42fb-baf1-0f00fa16ae7e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Is `trim` needed?",
        "createdAt" : "2020-04-07T08:00:12Z",
        "updatedAt" : "2020-04-08T14:25:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "78a56a10-06fb-4ff9-9216-c75cc0b140f0",
        "parentId" : "5e90876e-4efe-42fb-baf1-0f00fa16ae7e",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "no in fact. ",
        "createdAt" : "2020-04-07T09:25:32Z",
        "updatedAt" : "2020-04-08T14:25:34Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44a4099e52ba67ba04b29fc92781f01debbc921f",
    "line" : null,
    "diffHunk" : "@@ -43,8 +43,13 @@ final class MultilineStringFormattingProvider(\n       lineNumberToCheck: Int\n   ): String = {\n     val lineToCheck = lines(lineNumberToCheck)\n-    val lastPipe = lineToCheck.indexOf('|')\n-    space * lastPipe\n+    val index =\n+      if (lineToCheck.trim.contains(\"\\\"\\\"\\\"|\")) {"
  },
  {
    "id" : "aa70444d-20e6-44ae-95d7-99a6057aa36c",
    "prId" : 1585,
    "comments" : [
      {
        "id" : "42e2c18e-d92a-4058-9f68-e74540a0bba3",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could you split the imports into separate lines? That's the convention we have in Metals. Also, scalafix is failing due to the fact that one of those is no longer used.",
        "createdAt" : "2020-04-08T11:16:46Z",
        "updatedAt" : "2020-04-08T14:25:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6e384821-b6b0-493d-979a-592e82846d0e",
        "parentId" : "42e2c18e-d92a-4058-9f68-e74540a0bba3",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "yes. thanks ",
        "createdAt" : "2020-04-08T11:27:01Z",
        "updatedAt" : "2020-04-08T14:25:34Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44a4099e52ba67ba04b29fc92781f01debbc921f",
    "line" : null,
    "diffHunk" : "@@ -3,14 +3,14 @@ package scala.meta.internal.metals\n import org.eclipse.lsp4j.DocumentOnTypeFormattingParams\n import org.eclipse.lsp4j.Range\n import org.eclipse.lsp4j.TextEdit\n+\n import scala.concurrent.ExecutionContext\n import scala.concurrent.Future\n import scala.meta.inputs.Input\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.tokens.Token\n-import scala.meta.tokens.Token.Constant\n+import scala.meta.tokens.Token.{Constant, Ident, Interpolation}"
  },
  {
    "id" : "9d025f37-7905-4720-80e7-c51c0ce2b8f4",
    "prId" : 1611,
    "comments" : [
      {
        "id" : "3b2cdb2d-72c2-40fb-926e-5159d7f03a9e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe we can create type alias to make it more explicit? `type StartPosition = meta.Position` and  `type EndPosition = meta.Position`",
        "createdAt" : "2020-04-20T14:58:47Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b46663d2adf7dc3aaeb94c3d98b5ce7234add6b6",
    "line" : null,
    "diffHunk" : "@@ -114,56 +114,86 @@ final class MultilineStringFormattingProvider(\n       tokens: Tokens,\n       startPos: meta.Position,\n       endPos: meta.Position,\n-      sourceText: String\n+      sourceText: String,\n+      newlineAdded: Boolean\n   ): Boolean = {\n-    var tokenIndex = 0\n-    var stringFound = false\n-    var shouldAddPipes = false\n-    while (!stringFound && tokenIndex < tokens.size) {\n-      tokens(tokenIndex) match {\n-        case token: Constant.String if inToken(startPos, endPos, token) =>\n-          stringFound = true\n-          shouldAddPipes = isMultilineString(sourceText, token) &&\n-            hasStripMarginSuffix(tokenIndex, tokens)\n-        case start: Interpolation.Start if start.start < startPos.start =>\n-          var endIndex = tokenIndex + 1\n+    if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n+      def shouldFormatMultiString: PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Constant.String, index: Int) =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            index,\n+            tokens\n+          ) && inToken(startPos, endPos, token)\n+      }\n+\n+      def shouldFormatInterpolationString\n+          : PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Interpolation.Start, index: Int)\n+            if token.start < startPos.start => {\n+          var endIndex = index + 1\n           while (!tokens(endIndex)\n               .isInstanceOf[Interpolation.End]) endIndex += 1\n-          val end = tokens(endIndex)\n-          stringFound = end.end > startPos.end\n-          shouldAddPipes =\n-            stringFound && isMultilineString(sourceText, start) &&\n-              hasStripMarginSuffix(endIndex, tokens)\n-        case _ =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            endIndex,\n+            tokens\n+          )\n+        }\n       }\n-      tokenIndex += 1\n-    }\n-    shouldAddPipes\n+      tokens.zipWithIndex\n+        .exists(\n+          shouldFormatMultiString orElse shouldFormatInterpolationString orElse {\n+            case _ => false\n+          }\n+        )\n+    } else false\n   }\n \n-  private def withToken(\n-      textId: TextDocumentIdentifier,\n-      range: Range,\n-      newlineAdded: Boolean\n-  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n-    Future {\n-      val source = textId.getUri.toAbsolutePath\n-      if (source.exists) {\n-        val sourceText = buffer.get(source).getOrElse(\"\")\n-        val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n-        val startPos = range.getStart.toMeta(virtualFile)\n-        val endPos = range.getEnd.toMeta(virtualFile)\n-        if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n-          val tokens =\n-            virtualFile.tokenize.toOption\n-          tokens\n-            .filter(multilineStringInTokens(_, startPos, endPos, sourceText))\n-            .map(_ => fn(sourceText, startPos))\n-            .getOrElse(Nil)\n-        } else Nil\n-      } else Nil\n-    }\n+  private def withTokenOpt(textId: TextDocumentIdentifier, range: Range)(\n+      fn: (\n+          meta.Position,"
  },
  {
    "id" : "4a9d74e8-4dc4-40d4-ba22-1bb5738456c8",
    "prId" : 1611,
    "comments" : [
      {
        "id" : "c7bd6f4e-48be-4243-a28a-f1a3133ef1f0",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could we maybe operate or indexes here?\r\nFind the right line and then check `\"` until the next `\\n`?\r\n\r\nIt might be more efficient to not use split on the whole file. I am worried about the performance with large files.\r\n\r\nOr alternatively, we could create a method `findLine` that would just do the substring on the needed line. What do you think?",
        "createdAt" : "2020-04-20T16:34:53Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b46663d2adf7dc3aaeb94c3d98b5ce7234add6b6",
    "line" : null,
    "diffHunk" : "@@ -114,56 +114,86 @@ final class MultilineStringFormattingProvider(\n       tokens: Tokens,\n       startPos: meta.Position,\n       endPos: meta.Position,\n-      sourceText: String\n+      sourceText: String,\n+      newlineAdded: Boolean\n   ): Boolean = {\n-    var tokenIndex = 0\n-    var stringFound = false\n-    var shouldAddPipes = false\n-    while (!stringFound && tokenIndex < tokens.size) {\n-      tokens(tokenIndex) match {\n-        case token: Constant.String if inToken(startPos, endPos, token) =>\n-          stringFound = true\n-          shouldAddPipes = isMultilineString(sourceText, token) &&\n-            hasStripMarginSuffix(tokenIndex, tokens)\n-        case start: Interpolation.Start if start.start < startPos.start =>\n-          var endIndex = tokenIndex + 1\n+    if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n+      def shouldFormatMultiString: PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Constant.String, index: Int) =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            index,\n+            tokens\n+          ) && inToken(startPos, endPos, token)\n+      }\n+\n+      def shouldFormatInterpolationString\n+          : PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Interpolation.Start, index: Int)\n+            if token.start < startPos.start => {\n+          var endIndex = index + 1\n           while (!tokens(endIndex)\n               .isInstanceOf[Interpolation.End]) endIndex += 1\n-          val end = tokens(endIndex)\n-          stringFound = end.end > startPos.end\n-          shouldAddPipes =\n-            stringFound && isMultilineString(sourceText, start) &&\n-              hasStripMarginSuffix(endIndex, tokens)\n-        case _ =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            endIndex,\n+            tokens\n+          )\n+        }\n       }\n-      tokenIndex += 1\n-    }\n-    shouldAddPipes\n+      tokens.zipWithIndex\n+        .exists(\n+          shouldFormatMultiString orElse shouldFormatInterpolationString orElse {\n+            case _ => false\n+          }\n+        )\n+    } else false\n   }\n \n-  private def withToken(\n-      textId: TextDocumentIdentifier,\n-      range: Range,\n-      newlineAdded: Boolean\n-  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n-    Future {\n-      val source = textId.getUri.toAbsolutePath\n-      if (source.exists) {\n-        val sourceText = buffer.get(source).getOrElse(\"\")\n-        val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n-        val startPos = range.getStart.toMeta(virtualFile)\n-        val endPos = range.getEnd.toMeta(virtualFile)\n-        if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n-          val tokens =\n-            virtualFile.tokenize.toOption\n-          tokens\n-            .filter(multilineStringInTokens(_, startPos, endPos, sourceText))\n-            .map(_ => fn(sourceText, startPos))\n-            .getOrElse(Nil)\n-        } else Nil\n-      } else Nil\n-    }\n+  private def withTokenOpt(textId: TextDocumentIdentifier, range: Range)(\n+      fn: (\n+          meta.Position,\n+          meta.Position,\n+          String,\n+          Option[Tokens]\n+      ) => List[TextEdit]\n+  ): Future[List[TextEdit]] = {\n+    val source = textId.getUri.toAbsolutePath\n+    if (source.exists) {\n+      val sourceText = buffer.get(source).getOrElse(\"\")\n+      val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n+      val startPos = range.getStart.toMeta(virtualFile)\n+      val endPos = range.getEnd.toMeta(virtualFile)\n+      Future { fn(startPos, endPos, sourceText, virtualFile.tokenize.toOption) }\n+    } else Future.successful(Nil)\n+  }\n+  private def doubleQuoteNotClosed(\n+      sourceText: String,\n+      position: Position\n+  ): Boolean = {\n+    val splitLines = sourceText.split('\\n')"
  },
  {
    "id" : "32676be0-28a3-4bd3-9bec-bd686d438eaf",
    "prId" : 1611,
    "comments" : [
      {
        "id" : "a39fefa6-7e8f-4ec3-9bc6-7c9d98c6cd11",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We are splitting both here and in `doubleQuoteNotClosed` \r\n\r\nMaybe we can calculate `lineBefore` only once?",
        "createdAt" : "2020-04-20T16:45:05Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d6bc3156-93b7-433c-9e10-4199d1f66ad1",
        "parentId" : "a39fefa6-7e8f-4ec3-9bc6-7c9d98c6cd11",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "ok. maybe the class MultilineStringFormattingProvider, could have the lines of the current file.. so the split and all if these operations are only done once?",
        "createdAt" : "2020-04-21T13:30:08Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "991845d1-638d-4b32-add9-a35fb7ff2d18",
        "parentId" : "a39fefa6-7e8f-4ec3-9bc6-7c9d98c6cd11",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could be also, though most likely `substring(startOfLine, endOfLine)` would be fastest.",
        "createdAt" : "2020-04-21T18:59:28Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b46663d2adf7dc3aaeb94c3d98b5ce7234add6b6",
    "line" : null,
    "diffHunk" : "@@ -114,56 +114,86 @@ final class MultilineStringFormattingProvider(\n       tokens: Tokens,\n       startPos: meta.Position,\n       endPos: meta.Position,\n-      sourceText: String\n+      sourceText: String,\n+      newlineAdded: Boolean\n   ): Boolean = {\n-    var tokenIndex = 0\n-    var stringFound = false\n-    var shouldAddPipes = false\n-    while (!stringFound && tokenIndex < tokens.size) {\n-      tokens(tokenIndex) match {\n-        case token: Constant.String if inToken(startPos, endPos, token) =>\n-          stringFound = true\n-          shouldAddPipes = isMultilineString(sourceText, token) &&\n-            hasStripMarginSuffix(tokenIndex, tokens)\n-        case start: Interpolation.Start if start.start < startPos.start =>\n-          var endIndex = tokenIndex + 1\n+    if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n+      def shouldFormatMultiString: PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Constant.String, index: Int) =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            index,\n+            tokens\n+          ) && inToken(startPos, endPos, token)\n+      }\n+\n+      def shouldFormatInterpolationString\n+          : PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Interpolation.Start, index: Int)\n+            if token.start < startPos.start => {\n+          var endIndex = index + 1\n           while (!tokens(endIndex)\n               .isInstanceOf[Interpolation.End]) endIndex += 1\n-          val end = tokens(endIndex)\n-          stringFound = end.end > startPos.end\n-          shouldAddPipes =\n-            stringFound && isMultilineString(sourceText, start) &&\n-              hasStripMarginSuffix(endIndex, tokens)\n-        case _ =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            endIndex,\n+            tokens\n+          )\n+        }\n       }\n-      tokenIndex += 1\n-    }\n-    shouldAddPipes\n+      tokens.zipWithIndex\n+        .exists(\n+          shouldFormatMultiString orElse shouldFormatInterpolationString orElse {\n+            case _ => false\n+          }\n+        )\n+    } else false\n   }\n \n-  private def withToken(\n-      textId: TextDocumentIdentifier,\n-      range: Range,\n-      newlineAdded: Boolean\n-  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n-    Future {\n-      val source = textId.getUri.toAbsolutePath\n-      if (source.exists) {\n-        val sourceText = buffer.get(source).getOrElse(\"\")\n-        val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n-        val startPos = range.getStart.toMeta(virtualFile)\n-        val endPos = range.getEnd.toMeta(virtualFile)\n-        if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n-          val tokens =\n-            virtualFile.tokenize.toOption\n-          tokens\n-            .filter(multilineStringInTokens(_, startPos, endPos, sourceText))\n-            .map(_ => fn(sourceText, startPos))\n-            .getOrElse(Nil)\n-        } else Nil\n-      } else Nil\n-    }\n+  private def withTokenOpt(textId: TextDocumentIdentifier, range: Range)(\n+      fn: (\n+          meta.Position,\n+          meta.Position,\n+          String,\n+          Option[Tokens]\n+      ) => List[TextEdit]\n+  ): Future[List[TextEdit]] = {\n+    val source = textId.getUri.toAbsolutePath\n+    if (source.exists) {\n+      val sourceText = buffer.get(source).getOrElse(\"\")\n+      val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n+      val startPos = range.getStart.toMeta(virtualFile)\n+      val endPos = range.getEnd.toMeta(virtualFile)\n+      Future { fn(startPos, endPos, sourceText, virtualFile.tokenize.toOption) }\n+    } else Future.successful(Nil)\n+  }\n+  private def doubleQuoteNotClosed(\n+      sourceText: String,\n+      position: Position\n+  ): Boolean = {\n+    val splitLines = sourceText.split('\\n')\n+    val lineBefore = splitLines(position.getLine - 1)\n+    lineBefore.count(_ == '\"') % 2 != 0\n+  }\n \n+  private def tryToIndent(\n+      sourceText: String,\n+      newlineAdded: Boolean,\n+      position: Position\n+  ): List[TextEdit] = {\n+    if (newlineAdded && doubleQuoteNotClosed(sourceText, position)) {\n+      val precedentLine = position.getLine - 1\n+      val lines = sourceText.split('\\n')"
  },
  {
    "id" : "78b86320-f12a-447c-8008-f0be92bc997c",
    "prId" : 1611,
    "comments" : [
      {
        "id" : "ff2f60cf-bba4-47b0-bbe8-98147369b3ab",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`fixStringNewline` ?",
        "createdAt" : "2020-04-20T16:50:09Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f1eac6f1-94e7-4b46-a808-a5f76226efc0",
        "parentId" : "ff2f60cf-bba4-47b0-bbe8-98147369b3ab",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "ok. I named it like that because I imagined inside tryIndent, if String, we do that, if you type \"\"\" , do that .... \r\n",
        "createdAt" : "2020-04-21T13:28:19Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b46663d2adf7dc3aaeb94c3d98b5ce7234add6b6",
    "line" : null,
    "diffHunk" : "@@ -114,56 +114,86 @@ final class MultilineStringFormattingProvider(\n       tokens: Tokens,\n       startPos: meta.Position,\n       endPos: meta.Position,\n-      sourceText: String\n+      sourceText: String,\n+      newlineAdded: Boolean\n   ): Boolean = {\n-    var tokenIndex = 0\n-    var stringFound = false\n-    var shouldAddPipes = false\n-    while (!stringFound && tokenIndex < tokens.size) {\n-      tokens(tokenIndex) match {\n-        case token: Constant.String if inToken(startPos, endPos, token) =>\n-          stringFound = true\n-          shouldAddPipes = isMultilineString(sourceText, token) &&\n-            hasStripMarginSuffix(tokenIndex, tokens)\n-        case start: Interpolation.Start if start.start < startPos.start =>\n-          var endIndex = tokenIndex + 1\n+    if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n+      def shouldFormatMultiString: PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Constant.String, index: Int) =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            index,\n+            tokens\n+          ) && inToken(startPos, endPos, token)\n+      }\n+\n+      def shouldFormatInterpolationString\n+          : PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Interpolation.Start, index: Int)\n+            if token.start < startPos.start => {\n+          var endIndex = index + 1\n           while (!tokens(endIndex)\n               .isInstanceOf[Interpolation.End]) endIndex += 1\n-          val end = tokens(endIndex)\n-          stringFound = end.end > startPos.end\n-          shouldAddPipes =\n-            stringFound && isMultilineString(sourceText, start) &&\n-              hasStripMarginSuffix(endIndex, tokens)\n-        case _ =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            endIndex,\n+            tokens\n+          )\n+        }\n       }\n-      tokenIndex += 1\n-    }\n-    shouldAddPipes\n+      tokens.zipWithIndex\n+        .exists(\n+          shouldFormatMultiString orElse shouldFormatInterpolationString orElse {\n+            case _ => false\n+          }\n+        )\n+    } else false\n   }\n \n-  private def withToken(\n-      textId: TextDocumentIdentifier,\n-      range: Range,\n-      newlineAdded: Boolean\n-  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n-    Future {\n-      val source = textId.getUri.toAbsolutePath\n-      if (source.exists) {\n-        val sourceText = buffer.get(source).getOrElse(\"\")\n-        val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n-        val startPos = range.getStart.toMeta(virtualFile)\n-        val endPos = range.getEnd.toMeta(virtualFile)\n-        if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n-          val tokens =\n-            virtualFile.tokenize.toOption\n-          tokens\n-            .filter(multilineStringInTokens(_, startPos, endPos, sourceText))\n-            .map(_ => fn(sourceText, startPos))\n-            .getOrElse(Nil)\n-        } else Nil\n-      } else Nil\n-    }\n+  private def withTokenOpt(textId: TextDocumentIdentifier, range: Range)(\n+      fn: (\n+          meta.Position,\n+          meta.Position,\n+          String,\n+          Option[Tokens]\n+      ) => List[TextEdit]\n+  ): Future[List[TextEdit]] = {\n+    val source = textId.getUri.toAbsolutePath\n+    if (source.exists) {\n+      val sourceText = buffer.get(source).getOrElse(\"\")\n+      val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n+      val startPos = range.getStart.toMeta(virtualFile)\n+      val endPos = range.getEnd.toMeta(virtualFile)\n+      Future { fn(startPos, endPos, sourceText, virtualFile.tokenize.toOption) }\n+    } else Future.successful(Nil)\n+  }\n+  private def doubleQuoteNotClosed(\n+      sourceText: String,\n+      position: Position\n+  ): Boolean = {\n+    val splitLines = sourceText.split('\\n')\n+    val lineBefore = splitLines(position.getLine - 1)\n+    lineBefore.count(_ == '\"') % 2 != 0\n+  }\n \n+  private def tryToIndent("
  },
  {
    "id" : "72c021d5-7c26-48ec-a1b7-3d856c8cf0cb",
    "prId" : 1611,
    "comments" : [
      {
        "id" : "b785cfb6-b813-4083-ba59-0fafd3d583e6",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't think we need to change the name to `withTokenOpt` since we don't have any other method like that.",
        "createdAt" : "2020-04-20T16:51:06Z",
        "updatedAt" : "2020-05-01T10:10:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b46663d2adf7dc3aaeb94c3d98b5ce7234add6b6",
    "line" : null,
    "diffHunk" : "@@ -114,56 +114,86 @@ final class MultilineStringFormattingProvider(\n       tokens: Tokens,\n       startPos: meta.Position,\n       endPos: meta.Position,\n-      sourceText: String\n+      sourceText: String,\n+      newlineAdded: Boolean\n   ): Boolean = {\n-    var tokenIndex = 0\n-    var stringFound = false\n-    var shouldAddPipes = false\n-    while (!stringFound && tokenIndex < tokens.size) {\n-      tokens(tokenIndex) match {\n-        case token: Constant.String if inToken(startPos, endPos, token) =>\n-          stringFound = true\n-          shouldAddPipes = isMultilineString(sourceText, token) &&\n-            hasStripMarginSuffix(tokenIndex, tokens)\n-        case start: Interpolation.Start if start.start < startPos.start =>\n-          var endIndex = tokenIndex + 1\n+    if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n+      def shouldFormatMultiString: PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Constant.String, index: Int) =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            index,\n+            tokens\n+          ) && inToken(startPos, endPos, token)\n+      }\n+\n+      def shouldFormatInterpolationString\n+          : PartialFunction[(Token, Int), Boolean] = {\n+        case (token: Interpolation.Start, index: Int)\n+            if token.start < startPos.start => {\n+          var endIndex = index + 1\n           while (!tokens(endIndex)\n               .isInstanceOf[Interpolation.End]) endIndex += 1\n-          val end = tokens(endIndex)\n-          stringFound = end.end > startPos.end\n-          shouldAddPipes =\n-            stringFound && isMultilineString(sourceText, start) &&\n-              hasStripMarginSuffix(endIndex, tokens)\n-        case _ =>\n+          isMultilineString(sourceText, token) && hasStripMarginSuffix(\n+            endIndex,\n+            tokens\n+          )\n+        }\n       }\n-      tokenIndex += 1\n-    }\n-    shouldAddPipes\n+      tokens.zipWithIndex\n+        .exists(\n+          shouldFormatMultiString orElse shouldFormatInterpolationString orElse {\n+            case _ => false\n+          }\n+        )\n+    } else false\n   }\n \n-  private def withToken(\n-      textId: TextDocumentIdentifier,\n-      range: Range,\n-      newlineAdded: Boolean\n-  )(fn: (String, meta.Position) => List[TextEdit]): Future[List[TextEdit]] =\n-    Future {\n-      val source = textId.getUri.toAbsolutePath\n-      if (source.exists) {\n-        val sourceText = buffer.get(source).getOrElse(\"\")\n-        val virtualFile = Input.VirtualFile(source.toString(), sourceText)\n-        val startPos = range.getStart.toMeta(virtualFile)\n-        val endPos = range.getEnd.toMeta(virtualFile)\n-        if (pipeInScope(startPos, endPos, sourceText, newlineAdded)) {\n-          val tokens =\n-            virtualFile.tokenize.toOption\n-          tokens\n-            .filter(multilineStringInTokens(_, startPos, endPos, sourceText))\n-            .map(_ => fn(sourceText, startPos))\n-            .getOrElse(Nil)\n-        } else Nil\n-      } else Nil\n-    }\n+  private def withTokenOpt(textId: TextDocumentIdentifier, range: Range)("
  }
]