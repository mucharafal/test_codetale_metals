[
  {
    "id" : "db4c3c89-802e-4754-abbb-e545c50314d5",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "f10f6445-628b-4ac7-82e0-35bb357bae1c",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Can we move it to a separate `ammonite` package? We are trying to organize the code better (not that much success yet :sweat_smile: )",
        "createdAt" : "2020-03-30T16:02:32Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "52beceff-aca3-4ca0-aeb2-2118cdb3e464",
        "parentId" : "f10f6445-628b-4ac7-82e0-35bb357bae1c",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Sure!",
        "createdAt" : "2020-04-02T17:20:19Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74ee3107-9f8e-4e25-b6c3-ba86599ce2bc",
        "parentId" : "f10f6445-628b-4ac7-82e0-35bb357bae1c",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Should be fixed.",
        "createdAt" : "2020-04-05T22:12:04Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals"
  },
  {
    "id" : "40d95bbe-cda3-41fd-826e-10b7200e7544",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "bff8dace-04bc-4aff-87bc-0f8e3a51d368",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could we have line by line imports, that's how we do it  most of the codebase",
        "createdAt" : "2020-03-31T16:21:22Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74b6eab8-3c81-48dd-930b-a46ebffe60c1",
        "parentId" : "bff8dace-04bc-4aff-87bc-0f8e3a51d368",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-04-02T17:20:36Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6cf388c0-4306-4055-b3d9-d13723e449b0",
        "parentId" : "bff8dace-04bc-4aff-87bc-0f8e3a51d368",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-04-05T22:12:15Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}"
  },
  {
    "id" : "90c5fd06-ec8d-4e38-91d7-c7fb227b9f58",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "f6d3db5c-a12e-4cd9-9aa3-bb1574c2d429",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`toASCIIString` - will this not be an issue in workspaces using non-ascii characters?",
        "createdAt" : "2020-03-31T16:39:40Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5efbff61-f6e5-4cf2-9666-638dfd155856",
        "parentId" : "f6d3db5c-a12e-4cd9-9aa3-bb1574c2d429",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Related to the formatting of the uri's this morning when I tried this out, the script I had handy had a dash in it, which caused it to be stored with a `$minus`, but then getting `NoSuchFileException`s when anything else is looking for the file with `-` rather than `$minus`.",
        "createdAt" : "2020-04-02T07:25:22Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "804c4877-d3ac-437d-9353-aea7d94f19da",
        "parentId" : "f6d3db5c-a12e-4cd9-9aa3-bb1574c2d429",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Mmmhh… that's a problem.",
        "createdAt" : "2020-04-02T17:25:05Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bfcb965f-bf1b-4a2e-a4af-260e564b7782",
        "parentId" : "f6d3db5c-a12e-4cd9-9aa3-bb1574c2d429",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "> `toASCIIString` - will this not be an issue in workspaces using non-ascii characters?\r\n\r\nSpecial characters get encoded in the resulting string, so it's not a problem.\r\nFor example, with the character `é`, you get\r\n```scala\r\n@ val s = Paths.get(\"é.sc\").toAbsolutePath.toUri.toASCIIString // encode\r\ns: String = \"file://…/e%CC%81.sc\"\r\n@ Paths.get(\".\").toAbsolutePath.normalize.relativize(Paths.get(new URI(s))) // decode back\r\nres12: Path = é.sc\r\n```",
        "createdAt" : "2020-04-05T17:32:52Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "081e9e40-7955-45e4-8e66-8a8a8dd03597",
        "parentId" : "f6d3db5c-a12e-4cd9-9aa3-bb1574c2d429",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "About the problem with `$minus`, I just pushed a commit fixing that in https://github.com/lihaoyi/Ammonite/pull/1053.",
        "createdAt" : "2020-04-05T17:33:02Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString"
  },
  {
    "id" : "43e752bf-622e-47dc-8534-f9bfefb17d8a",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "f2c47686-c7e9-4ca2-acef-8dce22eba094",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe just have a default argument in the method below?",
        "createdAt" : "2020-03-31T16:42:15Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c6411ce9-81e7-48f3-8e69-4ece178fde1f",
        "parentId" : "f2c47686-c7e9-4ca2-acef-8dce22eba094",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Why not. It's just a make-binary-compatibility-easier-to-preserve habit. But maintaining bin compat isn't really a concern in the `metals` module yet I guess.",
        "createdAt" : "2020-04-02T17:26:12Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6644320d-0911-487e-b26a-9ab1f01f01b4",
        "parentId" : "f2c47686-c7e9-4ca2-acef-8dce22eba094",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We don't estimate it will ever be important to have it binary compatible. If needed we will expose an API, but since these packages are internal there are no guarantees for anyone who plans to use them outside of Metals.",
        "createdAt" : "2020-04-02T19:27:56Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a03bc0b1-0e8a-411c-9eba-609d4eff37ef",
        "parentId" : "f2c47686-c7e9-4ca2-acef-8dce22eba094",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Fixed.",
        "createdAt" : "2020-04-05T22:13:02Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)"
  },
  {
    "id" : "d4bb0d50-2034-42ce-8adc-2d40fc464e47",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "79c41fd9-32dd-4ad2-9705-1d465e17f2a0",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "It's better to use Future until the very end, and can it be more specific than `Object`?",
        "createdAt" : "2020-03-31T16:43:05Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "765fe1fb-b3f8-4a2b-9a59-02cc1e90644a",
        "parentId" : "79c41fd9-32dd-4ad2-9705-1d465e17f2a0",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "`Future[Unit]` would be better, indeed (and it works fine).",
        "createdAt" : "2020-04-02T17:42:24Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cf4e24eb-271c-4e3d-9adb-a75294e061e1",
        "parentId" : "79c41fd9-32dd-4ad2-9705-1d465e17f2a0",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Fixed.",
        "createdAt" : "2020-04-05T22:13:18Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {"
  },
  {
    "id" : "5a1491db-1ca4-4c61-b51e-8d4c398b4551",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "e16b9398-710d-418e-b626-fa43c647cc26",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe we can use TokenDistance here",
        "createdAt" : "2020-03-31T16:52:09Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09ddcb4a-efac-4322-aba8-4e435e6a6f1b",
        "parentId" : "e16b9398-710d-418e-b626-fa43c647cc26",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "I'm not sure. `adjustPosition` is supposed to work fine, and deterministically so.",
        "createdAt" : "2020-04-02T17:43:57Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e2418fa6-be34-4096-bc01-829dfe702b59",
        "parentId" : "e16b9398-710d-418e-b626-fa43c647cc26",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Then might be better to keep the adjustPosition. You're right.",
        "createdAt" : "2020-04-02T19:28:29Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {\n+\n+    disconnectOldBuildServer().onComplete {\n+      case Failure(e) =>\n+        scribe.warn(\"Error disconnecting old Ammonite build server\", e)\n+      case Success(()) =>\n+    }\n+\n+    // TODO Look at buffers.open rather than focusedDocument?\n+    val commandScriptOpt = doc.orElse(focusedDocument()) match {\n+      case None =>\n+        val msg = \"No Ammonite script is opened\"\n+        scribe.error(msg)\n+        Left(new Exception(msg))\n+      case Some(path) if path.isAmmoniteScript =>\n+        val it = path.toInputFromBuffers(buffers).value.linesIterator\n+        val versionsOpt = VersionsOption.fromScript(it)\n+        val versions = versionsOpt\n+          .orElse(lastImportVersions)\n+          .getOrElse(\n+            // TODO Warn if any of these is used\n+            AmmVersions\n+              .default()\n+              // temporary, remove once Ammonite is available for 2.12.11\n+              // .withScalaVersion(BuildInfo.scala212)\n+              .withScalaVersion(\"2.12.10\")\n+              // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+              .withAmmoniteVersion(\"2.0.5-bsp-3\")\n+          )\n+        AmmoniteFetcher(versions)\n+          .withInterpOnly(false)\n+          // .withInterpApiOnly(true)\n+          .withProgressBars(false)\n+          .withResolutionParams(\n+            coursierapi.ResolutionParams.create().withScalaVersion(\"2.12.10\")\n+          )\n+          // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+          .withTransformFetch(Some { fetch =>\n+            fetch.addRepositories(\n+              coursierapi.MavenRepository\n+                .of(\"https://dl.bintray.com/alexarchambault/metals-amm\")\n+            )\n+          })\n+          .command() match {\n+          case Left(e) =>\n+            scribe.error(\n+              s\"Error getting Ammonite ${versions.ammoniteVersion} (scala ${versions.scalaVersion})\",\n+              e\n+            )\n+            Left(e)\n+          case Right(command) =>\n+            lastImportVersions = VersionsOption(\n+              Some(versions.ammoniteVersion),\n+              Some(versions.scalaVersion)\n+            )\n+            Right((command, path))\n+        }\n+      case Some(path) =>\n+        val msg =\n+          if (path.toNIO.getFileName.toString.endsWith(\".worksheet.sc\"))\n+            \"Current document is a worksheet, not an Ammonite script\"\n+          else\n+            \"Current document is not an Ammonite script\"\n+        scribe.error(msg)\n+        Left(new Exception(msg))\n+    }\n+\n+    commandScriptOpt match {\n+      case Left(e) =>\n+        val f = new CompletableFuture[Object]\n+        f.completeExceptionally(e)\n+        f\n+      case Right((command, script)) =>\n+        val extraScripts = buffers.open.toVector\n+          .filter(_.isAmmoniteScript)\n+          .filter(_ != script)\n+        val futureConn = BuildServerConnection.fromSockets(\n+          workspace(),\n+          buildClient(),\n+          languageClient(),\n+          () =>\n+            Ammonite\n+              .socketConn(command, script +: extraScripts, workspace()),\n+          tables().dismissedNotifications.ReconnectAmmonite\n+        )\n+        val f = for {\n+          conn <- futureConn\n+          _ <- connectToNewBuildServer(conn)\n+        } yield ()\n+        f.asJavaObject\n+    }\n+  }\n+\n+  def stop(): CompletableFuture[Object] = {\n+    lastImportVersions = VersionsOption(None, None)\n+    disconnectOldBuildServer().asJavaObject\n+  }\n+\n+  def generatedScalaPath(\n+      targetId: BuildTargetIdentifier,\n+      source: AbsolutePath\n+  ): Option[AbsolutePath] =\n+    if (Ammonite.isAmmBuildTarget(targetId) && source.isAmmoniteScript)\n+      buildTargets.scalacOptions(targetId).map { target =>\n+        val rel = source.toRelative(workspace())\n+        val path = Paths\n+          .get(new URI(target.getClassDirectory))\n+          .getParent\n+          .resolve(\n+            s\"src/ammonite/$$file/${rel.toString.stripSuffix(\".sc\")}.scala\"\n+          )\n+        AbsolutePath(path.toAbsolutePath.normalize)\n+      }\n+    else\n+      None\n+\n+  def generatedScalaInputForPc(\n+      targetId: BuildTargetIdentifier,\n+      source: AbsolutePath,\n+      position: Position\n+  ): Option[(Input.VirtualFile, Position)] =\n+    generatedScalaPath(targetId, source)\n+      .map { scalaPath =>\n+        val scInput = source.toInputFromBuffers(buffers)\n+        val input = scalaPath.toInput\n+\n+        val updatedContent = input.value\n+          .replaceAllBetween(\"/*<generated>*/\", \"/*</generated>*/\")(\"\")\n+          .replaceAllBetween(\"/*<script>*/\", \"/*</script>*/\")(\n+            Ammonite.startTag + scInput.value\n+          )\n+        val updatedInput = input.copy(value = updatedContent)\n+\n+        val scriptStartIdx =\n+          updatedContent.indexOf(Ammonite.startTag) + Ammonite.startTag.length\n+        val addedLineCount = updatedContent.lineAtIndex(scriptStartIdx)\n+        val updatedPos =\n+          new Position(addedLineCount + position.getLine, position.getCharacter)\n+        (updatedInput, updatedPos)\n+      }\n+}\n+\n+object Ammonite {\n+\n+  def startTag: String =\n+    \"/*<start>*/\\n\"\n+\n+  def isAmmBuildTarget(id: BuildTargetIdentifier): Boolean =\n+    id.getUri.endsWith(\".sc\")\n+\n+  private def adjustPosition(scalaCode: String): Position => Unit = {\n+    val startIdx = scalaCode.indexOf(startTag)\n+    if (startIdx >= 0) {\n+      val linesBefore = scalaCode.lineAtIndex(startIdx + startTag.length)\n+      pos =>\n+        if (pos.getLine >= linesBefore)\n+          pos.setLine(pos.getLine - linesBefore)\n+    } else\n+      _ => ()\n+  }\n+\n+  private def adjustRange(\n+      range: LspRange,\n+      adjustPos: Position => Unit\n+  ): Unit = {\n+    adjustPos(range.getStart)\n+    adjustPos(range.getEnd)\n+  }\n+\n+  def adjustHoverResp(hover: Hover, scalaCode: String): Unit =\n+    if (hover.getRange != null) {\n+      val adjustPos = adjustPosition(scalaCode)\n+      adjustRange(hover.getRange, adjustPos)\n+    }\n+\n+  def adjustCompletionList(list: CompletionList, scalaCode: String): Unit = {\n+    val adjustPos = adjustPosition(scalaCode)"
  },
  {
    "id" : "3866dfe5-f995-4fb4-83b6-6cce95116076",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "1f9874b1-4b4d-48b5-a2ad-db326e3f9bb0",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "If someone starts AmmoniteServer, they might want to start them all. Relying on whether it's focused doesn't seem that useful for me.",
        "createdAt" : "2020-03-31T17:46:49Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ce375b60-0454-4033-b724-efb4957223ad",
        "parentId" : "1f9874b1-4b4d-48b5-a2ad-db326e3f9bb0",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "I have some projects that are just scripts doing something, and no `.scala` files. So in a situation like that, would I need to start them all?",
        "createdAt" : "2020-04-02T07:27:54Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5dd6c912-9719-402a-869e-38744e5bf3e3",
        "parentId" : "1f9874b1-4b4d-48b5-a2ad-db326e3f9bb0",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "`focusedDocument` is only used to read the scala and Ammonite version (users can put a comment like `// scala 2.13.1, ammonite 2.0.4` at the top of a script), and only so when users use the `ammonite-start` command directly (when they click \"Import\" in the \"Ammonite script detected\" dialog, the script that trigerred the dialog is used instead).\r\n\r\nApart from that, it's not used.\r\n\r\nWhen we start Ammonite, we pass it all the scripts from `buffers.open`. Then, Ammonite loads those, along with their script dependencies. So what is loaded at the end is all opened scripts plus their transitive script dependencies.",
        "createdAt" : "2020-04-05T22:26:55Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {\n+\n+    disconnectOldBuildServer().onComplete {\n+      case Failure(e) =>\n+        scribe.warn(\"Error disconnecting old Ammonite build server\", e)\n+      case Success(()) =>\n+    }\n+\n+    // TODO Look at buffers.open rather than focusedDocument?\n+    val commandScriptOpt = doc.orElse(focusedDocument()) match {"
  },
  {
    "id" : "d3c39bfe-ab6e-4eaf-bbc8-7366fb0a470d",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "3036236b-6ada-4dfb-906b-c9c6216d5e9f",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe let's move logic to fetch Ammonite to a separate method.",
        "createdAt" : "2020-03-31T17:47:25Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "592aea83-3b7d-4085-971e-237e21f49499",
        "parentId" : "3036236b-6ada-4dfb-906b-c9c6216d5e9f",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Done, it's better this way, yes.",
        "createdAt" : "2020-04-05T22:18:20Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {\n+\n+    disconnectOldBuildServer().onComplete {\n+      case Failure(e) =>\n+        scribe.warn(\"Error disconnecting old Ammonite build server\", e)\n+      case Success(()) =>\n+    }\n+\n+    // TODO Look at buffers.open rather than focusedDocument?\n+    val commandScriptOpt = doc.orElse(focusedDocument()) match {\n+      case None =>\n+        val msg = \"No Ammonite script is opened\"\n+        scribe.error(msg)\n+        Left(new Exception(msg))\n+      case Some(path) if path.isAmmoniteScript =>\n+        val it = path.toInputFromBuffers(buffers).value.linesIterator\n+        val versionsOpt = VersionsOption.fromScript(it)\n+        val versions = versionsOpt\n+          .orElse(lastImportVersions)\n+          .getOrElse(\n+            // TODO Warn if any of these is used\n+            AmmVersions\n+              .default()\n+              // temporary, remove once Ammonite is available for 2.12.11\n+              // .withScalaVersion(BuildInfo.scala212)\n+              .withScalaVersion(\"2.12.10\")\n+              // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+              .withAmmoniteVersion(\"2.0.5-bsp-3\")\n+          )\n+        AmmoniteFetcher(versions)"
  },
  {
    "id" : "eadd0f52-4f65-43fd-9f89-96c61b1f6c96",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "61f6f240-1f95-49a4-821c-b1c67f919c6a",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "IF we don't rely on focusedDocument, this will not be needed.",
        "createdAt" : "2020-03-31T17:47:47Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {\n+\n+    disconnectOldBuildServer().onComplete {\n+      case Failure(e) =>\n+        scribe.warn(\"Error disconnecting old Ammonite build server\", e)\n+      case Success(()) =>\n+    }\n+\n+    // TODO Look at buffers.open rather than focusedDocument?\n+    val commandScriptOpt = doc.orElse(focusedDocument()) match {\n+      case None =>\n+        val msg = \"No Ammonite script is opened\"\n+        scribe.error(msg)\n+        Left(new Exception(msg))\n+      case Some(path) if path.isAmmoniteScript =>\n+        val it = path.toInputFromBuffers(buffers).value.linesIterator\n+        val versionsOpt = VersionsOption.fromScript(it)\n+        val versions = versionsOpt\n+          .orElse(lastImportVersions)\n+          .getOrElse(\n+            // TODO Warn if any of these is used\n+            AmmVersions\n+              .default()\n+              // temporary, remove once Ammonite is available for 2.12.11\n+              // .withScalaVersion(BuildInfo.scala212)\n+              .withScalaVersion(\"2.12.10\")\n+              // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+              .withAmmoniteVersion(\"2.0.5-bsp-3\")\n+          )\n+        AmmoniteFetcher(versions)\n+          .withInterpOnly(false)\n+          // .withInterpApiOnly(true)\n+          .withProgressBars(false)\n+          .withResolutionParams(\n+            coursierapi.ResolutionParams.create().withScalaVersion(\"2.12.10\")\n+          )\n+          // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+          .withTransformFetch(Some { fetch =>\n+            fetch.addRepositories(\n+              coursierapi.MavenRepository\n+                .of(\"https://dl.bintray.com/alexarchambault/metals-amm\")\n+            )\n+          })\n+          .command() match {\n+          case Left(e) =>\n+            scribe.error(\n+              s\"Error getting Ammonite ${versions.ammoniteVersion} (scala ${versions.scalaVersion})\",\n+              e\n+            )\n+            Left(e)\n+          case Right(command) =>\n+            lastImportVersions = VersionsOption(\n+              Some(versions.ammoniteVersion),\n+              Some(versions.scalaVersion)\n+            )\n+            Right((command, path))\n+        }\n+      case Some(path) =>"
  },
  {
    "id" : "9a164544-009e-4779-a8ff-329abf3c49c4",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "7f6dffec-b87f-4561-a48d-03edfa5b00b8",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could we document how do we generate the source files for PC?",
        "createdAt" : "2020-03-31T17:49:34Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "92e8d705-6dea-431f-a4f8-58011b7d5003",
        "parentId" : "7f6dffec-b87f-4561-a48d-03edfa5b00b8",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-04-05T22:18:29Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {\n+\n+    disconnectOldBuildServer().onComplete {\n+      case Failure(e) =>\n+        scribe.warn(\"Error disconnecting old Ammonite build server\", e)\n+      case Success(()) =>\n+    }\n+\n+    // TODO Look at buffers.open rather than focusedDocument?\n+    val commandScriptOpt = doc.orElse(focusedDocument()) match {\n+      case None =>\n+        val msg = \"No Ammonite script is opened\"\n+        scribe.error(msg)\n+        Left(new Exception(msg))\n+      case Some(path) if path.isAmmoniteScript =>\n+        val it = path.toInputFromBuffers(buffers).value.linesIterator\n+        val versionsOpt = VersionsOption.fromScript(it)\n+        val versions = versionsOpt\n+          .orElse(lastImportVersions)\n+          .getOrElse(\n+            // TODO Warn if any of these is used\n+            AmmVersions\n+              .default()\n+              // temporary, remove once Ammonite is available for 2.12.11\n+              // .withScalaVersion(BuildInfo.scala212)\n+              .withScalaVersion(\"2.12.10\")\n+              // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+              .withAmmoniteVersion(\"2.0.5-bsp-3\")\n+          )\n+        AmmoniteFetcher(versions)\n+          .withInterpOnly(false)\n+          // .withInterpApiOnly(true)\n+          .withProgressBars(false)\n+          .withResolutionParams(\n+            coursierapi.ResolutionParams.create().withScalaVersion(\"2.12.10\")\n+          )\n+          // do not merge, remove once lihaoyi/Ammonite#1053 is merged\n+          .withTransformFetch(Some { fetch =>\n+            fetch.addRepositories(\n+              coursierapi.MavenRepository\n+                .of(\"https://dl.bintray.com/alexarchambault/metals-amm\")\n+            )\n+          })\n+          .command() match {\n+          case Left(e) =>\n+            scribe.error(\n+              s\"Error getting Ammonite ${versions.ammoniteVersion} (scala ${versions.scalaVersion})\",\n+              e\n+            )\n+            Left(e)\n+          case Right(command) =>\n+            lastImportVersions = VersionsOption(\n+              Some(versions.ammoniteVersion),\n+              Some(versions.scalaVersion)\n+            )\n+            Right((command, path))\n+        }\n+      case Some(path) =>\n+        val msg =\n+          if (path.toNIO.getFileName.toString.endsWith(\".worksheet.sc\"))\n+            \"Current document is a worksheet, not an Ammonite script\"\n+          else\n+            \"Current document is not an Ammonite script\"\n+        scribe.error(msg)\n+        Left(new Exception(msg))\n+    }\n+\n+    commandScriptOpt match {\n+      case Left(e) =>\n+        val f = new CompletableFuture[Object]\n+        f.completeExceptionally(e)\n+        f\n+      case Right((command, script)) =>\n+        val extraScripts = buffers.open.toVector\n+          .filter(_.isAmmoniteScript)\n+          .filter(_ != script)\n+        val futureConn = BuildServerConnection.fromSockets(\n+          workspace(),\n+          buildClient(),\n+          languageClient(),\n+          () =>\n+            Ammonite\n+              .socketConn(command, script +: extraScripts, workspace()),\n+          tables().dismissedNotifications.ReconnectAmmonite\n+        )\n+        val f = for {\n+          conn <- futureConn\n+          _ <- connectToNewBuildServer(conn)\n+        } yield ()\n+        f.asJavaObject\n+    }\n+  }\n+\n+  def stop(): CompletableFuture[Object] = {\n+    lastImportVersions = VersionsOption(None, None)\n+    disconnectOldBuildServer().asJavaObject\n+  }\n+\n+  def generatedScalaPath(\n+      targetId: BuildTargetIdentifier,\n+      source: AbsolutePath\n+  ): Option[AbsolutePath] =\n+    if (Ammonite.isAmmBuildTarget(targetId) && source.isAmmoniteScript)\n+      buildTargets.scalacOptions(targetId).map { target =>\n+        val rel = source.toRelative(workspace())\n+        val path = Paths\n+          .get(new URI(target.getClassDirectory))\n+          .getParent\n+          .resolve(\n+            s\"src/ammonite/$$file/${rel.toString.stripSuffix(\".sc\")}.scala\"\n+          )\n+        AbsolutePath(path.toAbsolutePath.normalize)\n+      }\n+    else\n+      None\n+\n+  def generatedScalaInputForPc(\n+      targetId: BuildTargetIdentifier,\n+      source: AbsolutePath,\n+      position: Position\n+  ): Option[(Input.VirtualFile, Position)] =\n+    generatedScalaPath(targetId, source)\n+      .map { scalaPath =>\n+        val scInput = source.toInputFromBuffers(buffers)\n+        val input = scalaPath.toInput\n+\n+        val updatedContent = input.value"
  },
  {
    "id" : "a941764c-05a5-4bab-87c5-9ed295d52178",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "f1a865fe-03f6-4816-a5a7-96d1c76fdf06",
        "parentId" : null,
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "```suggestion\r\n        case None => Future.unit\r\n```\r\nSuper nitpicky, but this is used in a few places, do you think just using `Future.unit`  is clearer for newcomers?",
        "createdAt" : "2020-04-02T06:29:44Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "726981f9-90c7-493e-8f37-4da21b3f1962",
        "parentId" : "f1a865fe-03f6-4816-a5a7-96d1c76fdf06",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Good point. Note there are still some `Future.successful(())` here or there in metals. The ones here originally came from copied (then updated) code from elsewhere in metals.",
        "createdAt" : "2020-04-05T22:19:48Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())"
  },
  {
    "id" : "3048a40e-935d-4880-8f19-fe2827f5d48c",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "12b27708-bb2a-4d97-a28c-f8061e5ccbaa",
        "parentId" : null,
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "This probably makes sense 👍 ",
        "createdAt" : "2020-04-02T07:28:52Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,390 @@\n+package scala.meta.internal.metals\n+\n+import java.io.InputStream\n+import java.net.URI\n+import java.nio.charset.Charset\n+import java.nio.file.Paths\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.{CompletableFuture, TimeoutException, TimeUnit}\n+\n+import ammrunner.{\n+  AmmoniteFetcher,\n+  Command => AmmCommand,\n+  Versions => AmmVersions,\n+  VersionsOption\n+}\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.lsp4j.{CompletionList, Hover, Position, Range => LspRange}\n+\n+import scala.concurrent.{\n+  ExecutionContext,\n+  ExecutionContextExecutorService,\n+  Future\n+}\n+import scala.meta.inputs.Input\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+final class Ammonite(\n+    buffers: Buffers,\n+    compilers: () => Compilers,\n+    compilations: () => Compilations,\n+    statusBar: () => StatusBar,\n+    diagnostics: () => Diagnostics,\n+    doctor: () => Doctor,\n+    tables: () => Tables,\n+    languageClient: () => MetalsLanguageClient,\n+    buildClient: () => ForwardingMetalsBuildClient,\n+    userConfig: () => UserConfiguration,\n+    indexWorkspace: () => Future[Unit],\n+    workspace: () => AbsolutePath,\n+    focusedDocument: () => Option[AbsolutePath],\n+    buildTargets: BuildTargets\n+)(implicit ec: ExecutionContextExecutorService)\n+    extends Cancelable {\n+\n+  def buildServer: Option[BuildServerConnection] =\n+    buildServer0\n+  def lastImportedBuild: ImportedBuild =\n+    lastImportedBuild0\n+\n+  private var buildServer0 = Option.empty[BuildServerConnection]\n+  private var lastImportedBuild0 = ImportedBuild.empty\n+  private var lastImportVersions = VersionsOption(None, None)\n+\n+  private val cancelables = new MutableCancelable()\n+  private val isCancelled = new AtomicBoolean(false)\n+  def cancel(): Unit = {\n+    if (isCancelled.compareAndSet(false, true)) {\n+      val buildShutdown = buildServer0 match {\n+        case Some(build) => build.shutdown()\n+        case None => Future.successful(())\n+      }\n+      try cancelables.cancel()\n+      catch {\n+        case NonFatal(_) =>\n+      }\n+      try buildShutdown.asJava.get(100, TimeUnit.MILLISECONDS)\n+      catch {\n+        case _: TimeoutException =>\n+      }\n+    }\n+  }\n+\n+  def loaded(path: AbsolutePath): Boolean =\n+    path.isAmmoniteScript && {\n+      val uri = path.toNIO.toUri.toASCIIString\n+      lastImportedBuild0.targetUris.contains(uri)\n+    }\n+\n+  private def connectToNewBuildServer(\n+      build: BuildServerConnection\n+  ): Future[BuildChange] = {\n+    scribe.info(s\"Connected to Ammonite Build server v${build.version}\")\n+    cancelables.add(build)\n+    compilers().cancel()\n+    buildServer0 = Some(build)\n+    val importedBuild0 = // FIXME timed(\"imported ammonite build\") {\n+      MetalsLanguageServer.importedBuild(build)\n+    for {\n+      build0 <- statusBar().trackFuture(\n+        \"Importing Ammonite scripts\",\n+        importedBuild0\n+      )\n+      _ = {\n+        lastImportedBuild0 = build0\n+      }\n+      _ <- indexWorkspace()\n+      // _ = checkRunningBloopVersion(build.version)\n+      _ <- Future.sequence[Unit, List](\n+        compilations()\n+          .cascadeCompileFiles(buffers.open.toSeq) ::\n+          compilers().load(\n+            buffers.open.toSeq.filter(!_.isAmmoniteScript)\n+          ) ::\n+          Nil\n+      )\n+    } yield BuildChange.Reconnected\n+  }\n+\n+  private def disconnectOldBuildServer(): Future[Unit] = {\n+    if (buildServer0.isDefined)\n+      scribe.info(\"disconnected: ammonite build server\")\n+    buildServer0 match {\n+      case None => Future.successful(())\n+      case Some(value) =>\n+        // remove from cancellable too?\n+        buildServer0 = None\n+        lastImportedBuild0 = ImportedBuild.empty\n+        cancelables.remove(value)\n+        diagnostics().resetAmmoniteScripts()\n+        value.shutdown()\n+    }\n+  }\n+\n+  def maybeImport(path: AbsolutePath): Unit =\n+    if (path.isAmmoniteScript && !loaded(path))\n+      languageClient()\n+        .showMessageRequest(Messages.ImportAmmoniteScript.params())\n+        .asScala\n+        .onComplete {\n+          case Failure(e) => scribe.warn(\"Error requesting Ammonite import\", e)\n+          case Success(resp) =>\n+            resp.getTitle match {\n+              case Messages.ImportAmmoniteScript.doImport =>\n+                start(Some(path)).asScala.onComplete {\n+                  case Failure(e) =>\n+                    scribe.warn(s\"Error importing Ammonite script $path\", e)\n+                  case Success(_) =>\n+                }\n+              case _ =>\n+            }\n+        }\n+\n+  def start(): CompletableFuture[Object] =\n+    start(None)\n+\n+  def start(doc: Option[AbsolutePath]): CompletableFuture[Object] = {\n+\n+    disconnectOldBuildServer().onComplete {\n+      case Failure(e) =>\n+        scribe.warn(\"Error disconnecting old Ammonite build server\", e)\n+      case Success(()) =>\n+    }\n+\n+    // TODO Look at buffers.open rather than focusedDocument?"
  }
]