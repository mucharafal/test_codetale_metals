[
  {
    "id" : "d7092e2b-e7e8-4b7e-8072-c6d1737c69a0",
    "prId" : 728,
    "comments" : [
      {
        "id" : "a0a53c8c-83fe-4112-acd8-a216a4d5f1bf",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "> releases",
        "createdAt" : "2019-05-23T13:11:47Z",
        "updatedAt" : "2019-05-24T09:17:46Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9d3f311622eae8bedf5d893e5016c35523e74815",
    "line" : null,
    "diffHunk" : "@@ -69,6 +71,15 @@ case class BuildServerConnection(\n     register(server.buildTargetCompile(params))\n   }\n \n+  def mainClasses(\n+      params: ScalaMainClassesParams\n+  ): CompletableFuture[ScalaMainClassesResult] = {\n+    // TODO use server.buildTargetScalaMainClasses when bloop realises version supporting mainClasses"
  },
  {
    "id" : "9fae14ae-67c2-480d-a7e5-1ff4775bd138",
    "prId" : 852,
    "comments" : [
      {
        "id" : "33d70a80-27a1-4259-9edd-d4ad2d48a3df",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "make it a java.List and you probably won't need a `toJson` method - and it will match the other structures in the bsp/lsp protocol.",
        "createdAt" : "2019-08-12T12:39:00Z",
        "updatedAt" : "2019-10-02T17:05:22Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9e9018bc-5078-414a-b707-61f5765c93e2",
        "parentId" : "33d70a80-27a1-4259-9edd-d4ad2d48a3df",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Done, thanks for the idea!",
        "createdAt" : "2019-08-12T15:32:00Z",
        "updatedAt" : "2019-10-02T17:05:22Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "21f992f2b66ce835b0205c99a71b743ae3ba960f",
    "line" : null,
    "diffHunk" : "@@ -130,13 +133,33 @@ object BuildServerConnection {\n     )\n   }\n \n+  final case class BloopExtraBuildParams(\n+      semanticdbVersion: String,\n+      supportedScalaVersions: Seq[String]"
  },
  {
    "id" : "64f9cb2f-2af6-4a05-89eb-10623e2bcea6",
    "prId" : 942,
    "comments" : [
      {
        "id" : "da7bd938-f5e5-427c-b6a9-367215fa202a",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "For consistency with BSP \r\n```suggestion\r\n  def testClasses(\r\n```",
        "createdAt" : "2019-09-29T21:51:44Z",
        "updatedAt" : "2019-10-04T07:32:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47ea581fbaa603a2dc171e3e913392f05fc4ba11",
    "line" : null,
    "diffHunk" : "@@ -74,9 +71,20 @@ case class BuildServerConnection(\n   def mainClasses(\n       params: ScalaMainClassesParams\n   ): CompletableFuture[ScalaMainClassesResult] = {\n-    // TODO use server.buildTargetScalaMainClasses when bloop releases version supporting mainClasses\n-    CompletableFuture.completedFuture(\n-      new ScalaMainClassesResult(Collections.emptyList())\n+    register(server.buildTargetScalaMainClasses(params))\n+  }\n+\n+  def testSuites("
  },
  {
    "id" : "f62a03ac-e4a0-4fda-bc70-615ea7155a5d",
    "prId" : 942,
    "comments" : [
      {
        "id" : "b0e11f45-22ac-4c36-a9c1-e6e57f8cca71",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Would it make sense to add a guard here to make sure we only send this request to an up-to-date Bloop server that supports debugging? I wonder if we should introduce a debug capability to BSP during the `build/initialize` handshake ðŸ¤” ",
        "createdAt" : "2019-10-01T10:30:00Z",
        "updatedAt" : "2019-10-04T07:32:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f7dec40a-15fe-4d23-8006-3db7a534f662",
        "parentId" : "b0e11f45-22ac-4c36-a9c1-e6e57f8cca71",
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "What do you mean by \"up to date Bloop server\"?\r\nI think it would be much simpler to just let the bsp server tell us by responding\"I don't support debugging because: A or B or C\" (which already happens, for example when bloop runs on jre and not on jdk). The cost is relatively low, because running is a seldom triggered action. \r\n\r\nOf course, in principle you are right, the debug capability should also be included in the capabilities of the server but in this case the gain would be minuscule",
        "createdAt" : "2019-10-02T07:17:22Z",
        "updatedAt" : "2019-10-04T07:32:50Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "680a60b3-d4ad-4a2b-9186-c1a4ea50ce87",
        "parentId" : "b0e11f45-22ac-4c36-a9c1-e6e57f8cca71",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I see, thanks for the explanation. For now this is fine. It would be nice to introduce a \"debug capability\" in BSP so that we only send debug requests to build servers that support it. Currently, Metals even ignores the \"compile capability\".",
        "createdAt" : "2019-10-02T14:01:36Z",
        "updatedAt" : "2019-10-04T07:32:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "47ea581fbaa603a2dc171e3e913392f05fc4ba11",
    "line" : 40,
    "diffHunk" : "@@ -74,9 +71,20 @@ case class BuildServerConnection(\n   def mainClasses(\n       params: ScalaMainClassesParams\n   ): CompletableFuture[ScalaMainClassesResult] = {\n-    // TODO use server.buildTargetScalaMainClasses when bloop releases version supporting mainClasses\n-    CompletableFuture.completedFuture(\n-      new ScalaMainClassesResult(Collections.emptyList())\n+    register(server.buildTargetScalaMainClasses(params))\n+  }\n+\n+  def testClasses(\n+      params: ScalaTestClassesParams\n+  ): CompletableFuture[ScalaTestClassesResult] = {\n+    register(server.buildTargetScalaTestClasses(params))\n+  }\n+\n+  def startDebugSession(params: DebugSessionParams): CompletableFuture[URI] = {"
  },
  {
    "id" : "6c6591e7-5f3f-4efe-80dd-89336012906c",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "3beb1433-ec1e-415a-96f1-ed0066d8cd2a",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Forgot about this one :fearful: Will fix this and figure out the test failures.\r\n\r\n",
        "createdAt" : "2020-01-08T10:54:25Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bd5aa74d-11fe-424c-94cc-e3ef57ffab5d",
        "parentId" : "3beb1433-ec1e-415a-96f1-ed0066d8cd2a",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Should be fixed - all the methods that were using server now by default try to reconnect if connection is dead.",
        "createdAt" : "2020-01-08T14:42:12Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -18,77 +17,134 @@ import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n )(implicit ec: ExecutionContext)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.displayName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = {\n+    synchronized {\n+      Option(awaitingConnection.get) match {\n+        case Some(promise) => promise.future\n+        case None =>\n+          val params = Messages.DisconnectedServer.params()\n+          languageClient.showMessageRequest(params).asScala.flatMap {\n+            case response\n+                if response == Messages.DisconnectedServer.reconnect =>\n+              val newPromise = Promise[LauncherConnection]()\n+              awaitingConnection.set(newPromise)\n+              val reconnect = restablishConnection().map { launcherConnection =>\n+                currentConnection.set(launcherConnection)\n+                awaitingConnection.set(null)\n+                ongoingRequests.addAll(launcherConnection.cancelables)\n+                launcherConnection\n+              }\n+              newPromise.completeWith(reconnect)\n+              newPromise.future\n+            case _ => throw new InterruptedException\n+          }\n+\n+      }\n+    }\n+  }\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {\n+      reconnect()\n+    } else {\n+      Future.successful(currentConnection.get)\n+    }\n+    connect\n+      .flatMap { launcherConnection =>\n+        val e = action(launcherConnection.server)\n+        ongoingRequests.add(\n+          Cancelable(() =>\n+            Try(e.completeExceptionally(new InterruptedException()))\n+          )\n+        )\n+        e.asScala\n+      }\n+      .recoverWith {\n+        case _: IOException =>\n+          reconnect().flatMap(conn => action(conn.server).asScala)\n+      }\n+      .asJava\n   }\n \n   def compile(params: CompileParams): CompletableFuture[CompileResult] = {\n-    register(server.buildTargetCompile(params))\n+    register { server =>\n+      server.buildTargetCompile(params)\n+    }\n   }\n \n   def mainClasses(\n       params: ScalaMainClassesParams\n   ): CompletableFuture[ScalaMainClassesResult] = {\n-    register(server.buildTargetScalaMainClasses(params))\n+    register(server => server.buildTargetScalaMainClasses(params))\n   }\n \n   def testClasses(\n       params: ScalaTestClassesParams\n   ): CompletableFuture[ScalaTestClassesResult] = {\n-    register(server.buildTargetScalaTestClasses(params))\n+    register(server => server.buildTargetScalaTestClasses(params))\n   }\n \n   def startDebugSession(params: DebugSessionParams): CompletableFuture[URI] = {\n-    register(\n+    register(server =>\n       server\n         .startDebugSession(params)\n         .thenApply(address => URI.create(address.getUri))\n     )\n   }\n \n+  // TODO it should be FUTURe"
  },
  {
    "id" : "4c65b7be-cde7-4c26-a863-9b2d7f307c56",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "75aabf3b-1e2a-4ed5-876e-f1aa66b9679e",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "typo: re**e**stablish?",
        "createdAt" : "2020-01-09T10:20:13Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f2c61ed-fe77-4110-9a3a-a41276893252",
        "parentId" : "75aabf3b-1e2a-4ed5-876e-f1aa66b9679e",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Fixed",
        "createdAt" : "2020-01-09T19:32:27Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],"
  },
  {
    "id" : "c0fbfef8-926d-4383-96b9-f8e69c9c9e4f",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "262e3292-a973-4fa0-8cc5-2a9fd4f40351",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "can be called `promise`",
        "createdAt" : "2020-01-09T10:26:12Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "43b21e72-1c97-4045-86b5-4314fa5bb19e",
        "parentId" : "262e3292-a973-4fa0-8cc5-2a9fd4f40351",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "No longer needed",
        "createdAt" : "2020-01-09T19:32:18Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()"
  },
  {
    "id" : "0f7af72d-8447-4a68-952b-dc765f17f1c7",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "b77ad716-0720-4bb1-a934-1fc20ae7af45",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "Why InterruptedException?",
        "createdAt" : "2020-01-09T10:32:34Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "62401b75-3635-4efb-af8f-c4b829234c2f",
        "parentId" : "b77ad716-0720-4bb1-a934-1fc20ae7af45",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "User interrupts the compilation, I think that's what is thrown in case of cancelling?",
        "createdAt" : "2020-01-09T12:18:18Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bb1b771f-4201-402f-b997-464805b0b31f",
        "parentId" : "b77ad716-0720-4bb1-a934-1fc20ae7af45",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I will drop that and just return the old connection.",
        "createdAt" : "2020-01-09T17:31:27Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException"
  },
  {
    "id" : "679f2cbb-208b-48e4-b638-6fddeaa0f6f0",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "8a632962-8927-4dfe-a9d6-0220dc8a4fe8",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "Doesn't `isClosed` tells us that we have closed the connection?",
        "createdAt" : "2020-01-09T10:44:22Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d2ff3943-8ca2-49ea-9be1-1bb3199f492c",
        "parentId" : "8a632962-8927-4dfe-a9d6-0220dc8a4fe8",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Yes, that's why we need to reconnenct via new socket.",
        "createdAt" : "2020-01-09T12:18:48Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b1943c0a-c13b-4418-b9d6-f1d12e07b946",
        "parentId" : "8a632962-8927-4dfe-a9d6-0220dc8a4fe8",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I dropped that altogether.",
        "createdAt" : "2020-01-09T17:31:53Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException\n+        }\n+\n+    }\n+  }\n+\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {"
  },
  {
    "id" : "dd4f95d0-35c8-40b9-9cae-5e363dea5684",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "6f967cd4-32fd-46b7-a065-29c0245e8b7b",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "This block is not synchronized, so multiple threads could wait on the line #95 to issue a reconnections while in fact only on of them should do this. synchronizing over this block should prevent that.",
        "createdAt" : "2020-01-09T10:48:47Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dd17e8b7-c081-4434-a456-1f04def9fb9e",
        "parentId" : "6f967cd4-32fd-46b7-a065-29c0245e8b7b",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Reconnection itself is synchronized and if it's already reconnecting, the future from the promise is returned.",
        "createdAt" : "2020-01-09T12:19:30Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b13effd6-4cb4-40f3-8bb8-1c48425081bc",
        "parentId" : "6f967cd4-32fd-46b7-a065-29c0245e8b7b",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Ach right, there is still race condition there. Thanks!",
        "createdAt" : "2020-01-09T17:32:18Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException\n+        }\n+\n+    }\n+  }\n+\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {\n+      reconnect()\n+    } else {\n+      Future.successful(currentConnection.get)\n+    }"
  },
  {
    "id" : "870e2930-19bc-4ab4-bc30-54fd302ca68c",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "2dfe1e5b-b1db-48c2-8530-774bcd5b2143",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "`e` as in `exception`?\r\n",
        "createdAt" : "2020-01-09T10:59:54Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "402921b8-56a5-489a-9622-fa2eeef016db",
        "parentId" : "2dfe1e5b-b1db-48c2-8530-774bcd5b2143",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "It's more a `result` - renamed",
        "createdAt" : "2020-01-09T19:31:53Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException\n+        }\n+\n+    }\n+  }\n+\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {\n+      reconnect()\n+    } else {\n+      Future.successful(currentConnection.get)\n+    }\n+    val future = connect\n+      .flatMap { launcherConnection =>\n+        val e = action(launcherConnection.server)"
  },
  {
    "id" : "0ffc3bbc-6e56-4953-b376-adbbd686a25e",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "17677530-de5c-4a16-ab79-95700d7ee50f",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "We could call `action` as a separate `map` step to make the flow more readable\r\n```scala\r\nconnect\r\n  .map(action)\r\n  .map { future =>\r\n    ongoingRequests.add(...)\r\n    future.asScala\r\n  }\r\n```",
        "createdAt" : "2020-01-09T11:02:46Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f0de0bb7-c503-4247-9aad-502d8f136cbc",
        "parentId" : "17677530-de5c-4a16-ab79-95700d7ee50f",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I think this is fine, besides we are doing flatMap there, so can't really separate it.",
        "createdAt" : "2020-01-09T17:33:38Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException\n+        }\n+\n+    }\n+  }\n+\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {\n+      reconnect()\n+    } else {\n+      Future.successful(currentConnection.get)\n+    }\n+    val future = connect\n+      .flatMap { launcherConnection =>\n+        val e = action(launcherConnection.server)\n+        ongoingRequests.add(\n+          Cancelable(() =>\n+            Try(e.completeExceptionally(new InterruptedException()))\n+          )\n+        )\n+        e.asScala\n+      }\n+      .recoverWith {\n+        case _: IOException =>\n+          reconnect().flatMap(conn => action(conn.server).asScala)\n+      }"
  },
  {
    "id" : "af9037c4-7eca-464b-981a-c2faba047d17",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "4047befc-f130-4189-a3f9-f2d966618a10",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "this could be moved outside to keep the flow nicer:\r\n```scala\r\nregister(server => server.startDebugSession(params))\r\n  .thenApply(address => URI.create(address.getUri)\r\n```",
        "createdAt" : "2020-01-09T11:04:24Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException\n+        }\n+\n+    }\n+  }\n+\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {\n+      reconnect()\n+    } else {\n+      Future.successful(currentConnection.get)\n+    }\n+    val future = connect\n+      .flatMap { launcherConnection =>\n+        val e = action(launcherConnection.server)\n+        ongoingRequests.add(\n+          Cancelable(() =>\n+            Try(e.completeExceptionally(new InterruptedException()))\n+          )\n+        )\n+        e.asScala\n+      }\n+      .recoverWith {\n+        case _: IOException =>\n+          reconnect().flatMap(conn => action(conn.server).asScala)\n+      }\n+    CancelTokens.future(_ => future)\n   }\n \n   def compile(params: CompileParams): CompletableFuture[CompileResult] = {\n-    register(server.buildTargetCompile(params))\n+    register { server =>\n+      server.buildTargetCompile(params)\n+    }\n   }\n \n   def mainClasses(\n       params: ScalaMainClassesParams\n   ): CompletableFuture[ScalaMainClassesResult] = {\n-    register(server.buildTargetScalaMainClasses(params))\n+    register(server => server.buildTargetScalaMainClasses(params))\n   }\n \n   def testClasses(\n       params: ScalaTestClassesParams\n   ): CompletableFuture[ScalaTestClassesResult] = {\n-    register(server.buildTargetScalaTestClasses(params))\n+    register(server => server.buildTargetScalaTestClasses(params))\n   }\n \n   def startDebugSession(params: DebugSessionParams): CompletableFuture[URI] = {\n-    register(\n+    register(server =>\n       server\n         .startDebugSession(params)\n         .thenApply(address => URI.create(address.getUri))"
  },
  {
    "id" : "05a9cc1f-c22e-4e19-a12e-be982b2ac411",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "404742a0-620c-4732-b9b9-e988bafe4272",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "other registrations use the `()` but this one uses `{}` - let's keep it consistent",
        "createdAt" : "2020-01-09T11:04:57Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2d99ef3e-4e42-48ea-9721-1405550b848c",
        "parentId" : "404742a0-620c-4732-b9b9-e988bafe4272",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Fixed",
        "createdAt" : "2020-01-09T19:31:22Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -12,84 +11,156 @@ import java.util.concurrent.atomic.AtomicBoolean\n import ch.epfl.scala.bsp4j._\n import org.eclipse.lsp4j.jsonrpc.Launcher\n \n-import scala.concurrent.ExecutionContext\n import scala.concurrent.ExecutionContextExecutorService\n import scala.concurrent.Future\n import scala.meta.internal.pc.InterruptException\n import scala.meta.io.AbsolutePath\n import scala.util.Try\n-import scala.collection.JavaConverters._\n import com.google.gson.Gson\n+import java.util.concurrent.atomic.AtomicReference\n+import scala.concurrent.Promise\n+import MetalsEnrichments._\n+import java.io.IOException\n+import org.eclipse.lsp4j.services.LanguageClient\n \n /**\n  * An actively running and initialized BSP connection.\n  */\n case class BuildServerConnection(\n-    workspace: AbsolutePath,\n-    client: MetalsBuildClient,\n-    server: MetalsBuildServer,\n-    cancelables: List[Cancelable],\n-    initializeResult: InitializeBuildResult,\n-    name: String,\n-    version: String\n-)(implicit ec: ExecutionContext)\n+    restablishConnection: () => Future[LauncherConnection],\n+    private val initialConnection: LauncherConnection,\n+    languageClient: LanguageClient\n+)(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n-  private val ongoingRequests = new MutableCancelable().addAll(cancelables)\n+  private val currentConnection = new AtomicReference(initialConnection)\n+  private var awaitingConnection: AtomicReference[Promise[LauncherConnection]] =\n+    new AtomicReference()\n+\n+  private val ongoingRequests =\n+    new MutableCancelable().addAll(initialConnection.cancelables)\n+\n+  def version = currentConnection.get.version\n+\n+  def name = currentConnection.get.socketConnection.serverName\n \n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = Future {\n     try {\n-      server.buildShutdown().get(2, TimeUnit.SECONDS)\n-      server.onBuildExit()\n+      currentConnection.get.server.buildShutdown().get(2, TimeUnit.SECONDS)\n+      currentConnection.get.server.onBuildExit()\n       // Cancel pending compilations on our side, this is not needed for Bloop.\n       cancel()\n     } catch {\n       case e: TimeoutException =>\n         scribe.error(\n-          s\"timeout: build server '${initializeResult.getDisplayName}' during shutdown\"\n+          s\"timeout: build server '${currentConnection.get.displayName}' during shutdown\"\n         )\n       case InterruptException() =>\n       case e: Throwable =>\n         scribe.error(\n-          s\"build shutdown: ${initializeResult.getDisplayName()}\",\n+          s\"build shutdown: ${currentConnection.get.displayName}\",\n           e\n         )\n     }\n   }\n \n-  private def register[T](e: CompletableFuture[T]): CompletableFuture[T] = {\n-    ongoingRequests.add(\n-      Cancelable(() => Try(e.completeExceptionally(new InterruptedException())))\n-    )\n-    e\n+  private def reconnect() = synchronized {\n+    Option(awaitingConnection.get) match {\n+      case Some(promise) => promise.future\n+      case None =>\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            val newPromise = Promise[LauncherConnection]()\n+            awaitingConnection.set(newPromise)\n+            val reconnect = restablishConnection().map { launcherConnection =>\n+              currentConnection.set(launcherConnection)\n+              awaitingConnection.set(null)\n+              ongoingRequests.addAll(launcherConnection.cancelables)\n+              launcherConnection\n+            }\n+            newPromise.completeWith(reconnect)\n+            newPromise.future\n+          case _ => throw new InterruptedException\n+        }\n+\n+    }\n+  }\n+\n+  private def register[T](\n+      action: MetalsBuildServer => CompletableFuture[T]\n+  ): CompletableFuture[T] = {\n+    val connect = if (currentConnection.get.socketConnection.isClosed) {\n+      reconnect()\n+    } else {\n+      Future.successful(currentConnection.get)\n+    }\n+    val future = connect\n+      .flatMap { launcherConnection =>\n+        val e = action(launcherConnection.server)\n+        ongoingRequests.add(\n+          Cancelable(() =>\n+            Try(e.completeExceptionally(new InterruptedException()))\n+          )\n+        )\n+        e.asScala\n+      }\n+      .recoverWith {\n+        case _: IOException =>\n+          reconnect().flatMap(conn => action(conn.server).asScala)\n+      }\n+    CancelTokens.future(_ => future)\n   }\n \n   def compile(params: CompileParams): CompletableFuture[CompileResult] = {\n-    register(server.buildTargetCompile(params))\n+    register { server =>\n+      server.buildTargetCompile(params)\n+    }"
  },
  {
    "id" : "45293c6e-be5a-44f3-9a4b-755733f943e5",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "252a14bd-cfcc-4f5d-ad87-2c6d92495acf",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "I think \r\n```scala\r\ncase connection =>\r\n``` \r\nwould be more readable. we could use `connection.output` and `connection.input` where applicable",
        "createdAt" : "2020-01-09T11:09:25Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "18e4837b-d98f-4c12-9b9e-113c644455ea",
        "parentId" : "252a14bd-cfcc-4f5d-ad87-2c6d92495acf",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Changed the code, so this is no longer relevant.",
        "createdAt" : "2020-01-09T17:36:04Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : 250,
    "diffHunk" : "@@ -110,34 +181,46 @@ object BuildServerConnection {\n   def fromStreams(\n       workspace: AbsolutePath,\n       localClient: MetalsBuildClient,\n-      output: OutputStream,\n-      input: InputStream,\n-      onShutdown: List[Cancelable],\n-      name: String\n-  )(implicit ec: ExecutionContextExecutorService): BuildServerConnection = {\n-    val tracePrinter = GlobalTrace.setupTracePrinter(\"BSP\")\n-    val launcher = new Launcher.Builder[MetalsBuildServer]()\n-      .traceMessages(tracePrinter)\n-      .setOutput(output)\n-      .setInput(input)\n-      .setLocalService(localClient)\n-      .setRemoteInterface(classOf[MetalsBuildServer])\n-      .setExecutorService(ec)\n-      .create()\n-    val listening = launcher.startListening()\n-    val server = launcher.getRemoteProxy\n-    val result = BuildServerConnection.initialize(workspace, server)\n-    val stopListening =\n-      Cancelable(() => listening.cancel(false))\n-    BuildServerConnection(\n-      workspace,\n-      localClient,\n-      server,\n-      stopListening :: onShutdown,\n-      result,\n-      name,\n-      result.getVersion()\n-    )\n+      languageClient: LanguageClient,\n+      setupConnection: () => Future[SocketConnection]\n+  )(\n+      implicit ec: ExecutionContextExecutorService\n+  ): Future[BuildServerConnection] = {\n+\n+    def setupServer(): Future[LauncherConnection] = {\n+      setupConnection().map {\n+        case conn @ SocketConnection(name, output, input, cancelables) =>"
  },
  {
    "id" : "549cab91-cbbb-49c1-9d09-6e40f4b47486",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "5f2bfe5d-9cf4-42a4-b47f-388592c75206",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "typo: ou**t**put",
        "createdAt" : "2020-01-09T11:09:59Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eea8ed4b-d56b-4311-ade5-a73834089693",
        "parentId" : "5f2bfe5d-9cf4-42a4-b47f-388592c75206",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Fixed",
        "createdAt" : "2020-01-09T19:26:56Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -183,3 +266,23 @@ object BuildServerConnection {\n     result\n   }\n }\n+\n+case class SocketConnection(\n+    serverName: String,\n+    ouput: ClosableOutputStream,"
  },
  {
    "id" : "b4ea2771-91a3-44d3-82c7-6cb9e8e2d61b",
    "prId" : 1266,
    "comments" : [
      {
        "id" : "177414cf-92f4-461b-b004-0a4cb9b9d256",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "maybe rename to `connect`?",
        "createdAt" : "2020-01-09T11:26:19Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5241cf0a-18c6-4fdc-ade1-253214235163",
        "parentId" : "177414cf-92f4-461b-b004-0a4cb9b9d256",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Renamed",
        "createdAt" : "2020-01-09T19:24:50Z",
        "updatedAt" : "2020-01-09T19:41:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0f92bf439ec2e556ef2dd37eb204d08963b7f24b",
    "line" : null,
    "diffHunk" : "@@ -110,34 +181,46 @@ object BuildServerConnection {\n   def fromStreams(\n       workspace: AbsolutePath,\n       localClient: MetalsBuildClient,\n-      output: OutputStream,\n-      input: InputStream,\n-      onShutdown: List[Cancelable],\n-      name: String\n-  )(implicit ec: ExecutionContextExecutorService): BuildServerConnection = {\n-    val tracePrinter = GlobalTrace.setupTracePrinter(\"BSP\")\n-    val launcher = new Launcher.Builder[MetalsBuildServer]()\n-      .traceMessages(tracePrinter)\n-      .setOutput(output)\n-      .setInput(input)\n-      .setLocalService(localClient)\n-      .setRemoteInterface(classOf[MetalsBuildServer])\n-      .setExecutorService(ec)\n-      .create()\n-    val listening = launcher.startListening()\n-    val server = launcher.getRemoteProxy\n-    val result = BuildServerConnection.initialize(workspace, server)\n-    val stopListening =\n-      Cancelable(() => listening.cancel(false))\n-    BuildServerConnection(\n-      workspace,\n-      localClient,\n-      server,\n-      stopListening :: onShutdown,\n-      result,\n-      name,\n-      result.getVersion()\n-    )\n+      languageClient: LanguageClient,\n+      setupConnection: () => Future[SocketConnection]"
  },
  {
    "id" : "cf617f1b-351a-4031-8efb-38018b192eb2",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "f313215d-400d-490e-9220-4671a18fd2eb",
        "parentId" : null,
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "Question: Bloop doesn't support scala3 yet?",
        "createdAt" : "2020-03-31T14:35:37Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "97643820-9ab8-4134-b3b3-2e42d60b59f9",
        "parentId" : "f313215d-400d-490e-9220-4671a18fd2eb",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "It does, but there is no need to send supportedScalaVersions, which is basically an information on which Scala versions are supported by that Scalameta version.",
        "createdAt" : "2020-04-03T16:55:04Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aba6a5b9-446b-4803-919f-f46109e57cc9",
        "parentId" : "f313215d-400d-490e-9220-4671a18fd2eb",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It would make sense to have `BuildInfo.supportedScala2Versions` to simplify the filtering logic here",
        "createdAt" : "2020-04-04T07:58:12Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -235,8 +235,11 @@ object BuildServerConnection {\n   ): InitializeBuildResult = {\n     val extraParams = BloopExtraBuildParams(\n       BuildInfo.scalametaVersion,\n-      BuildInfo.supportedScalaVersions.asJava\n+      BuildInfo.supportedScalaVersions"
  },
  {
    "id" : "e322b97a-2e71-4013-b848-b69974a1f266",
    "prId" : 1538,
    "comments" : [
      {
        "id" : "693f5261-53bf-47fb-905a-e4d716c854f8",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't think this should be removed. It's used for tracing the BSP messages. ",
        "createdAt" : "2020-03-31T16:23:01Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fe411dc2-5fce-4024-b866-1b11a4645da8",
        "parentId" : "693f5261-53bf-47fb-905a-e4d716c854f8",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Oh I removed that thinking it was code I had added myselfâ€¦",
        "createdAt" : "2020-04-02T17:21:19Z",
        "updatedAt" : "2020-05-21T11:17:43Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "849108c0-6719-4226-a6c9-ef835ae0d3eb",
        "parentId" : "693f5261-53bf-47fb-905a-e4d716c854f8",
        "author" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "body" : "Should be fixed.",
        "createdAt" : "2020-04-05T22:12:23Z",
        "updatedAt" : "2020-05-21T11:17:44Z",
        "lastEditedBy" : {
          "login" : "alexarchambault",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/7063723?u=d5befca0ebfec0042dad7ef93973490eef750ff4&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0681fa0b1417b7ac622101d279667c6900a2506e",
    "line" : null,
    "diffHunk" : "@@ -191,7 +190,6 @@ object BuildServerConnection {\n         case conn @ SocketConnection(name, output, input, cancelables) =>\n           val tracePrinter = GlobalTrace.setupTracePrinter(\"BSP\")\n           val launcher = new Launcher.Builder[MetalsBuildServer]()\n-            .traceMessages(tracePrinter)"
  },
  {
    "id" : "5abb06a3-1994-42f0-a34f-a7a643c3016c",
    "prId" : 1677,
    "comments" : [
      {
        "id" : "482f6bd5-9c0f-41ca-8e95-49111c14d523",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "This uses the promise from the launcher to reconnect when the connection is finished.",
        "createdAt" : "2020-04-29T17:18:46Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a8fa1e6d-b1f0-4bb5-9b6c-18fdc53c020a",
        "parentId" : "482f6bd5-9c0f-41ca-8e95-49111c14d523",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I'm not sure I understand the logic here, what is the difference between this and the logic below?\r\n\r\n```suggestion\r\n  initialConnection.onConnectionFinished(reconnect)\r\n```\r\n",
        "createdAt" : "2020-05-01T07:54:10Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ff711fd-c74a-4c00-87aa-6c1d8a56853c",
        "parentId" : "482f6bd5-9c0f-41ca-8e95-49111c14d523",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`onConnectionFinished` is coming from the process or the launcher to say that the connection is finished.  `onReconnection` is used to later reindex the workspace.\r\n\r\nThe alternative is to do it in the MetalsLanguageServer and just do a full reconnect, but then it will be less seamless for the user. \r\n\r\nLauncherConnection stoped -> BuildServerConnection.reconnect -> MetalsLanguageServer.indexWorkspace",
        "createdAt" : "2020-05-01T09:57:21Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6cba5d3a-24d9-4b20-a526-389c0b48d1e0",
        "parentId" : "482f6bd5-9c0f-41ca-8e95-49111c14d523",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I think this is a bit better than a full reconnect, because we will not lose any requests to the build server.",
        "createdAt" : "2020-05-01T15:55:37Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "38751291a84f683f8d8eb60ed8a73ce8657936c9",
    "line" : null,
    "diffHunk" : "@@ -32,11 +34,19 @@ class BuildServerConnection private (\n     ],\n     initialConnection: BuildServerConnection.LauncherConnection,\n     languageClient: LanguageClient,\n-    tables: Tables\n+    tables: Tables,\n+    config: MetalsServerConfig\n )(implicit ec: ExecutionContextExecutorService)\n     extends Cancelable {\n \n   @volatile private var connection = Future.successful(initialConnection)\n+  connection.foreach { conn => conn.onConnectionFinished(reconnect) }"
  },
  {
    "id" : "94947ff1-0547-4c7f-8a1f-f50345b2244d",
    "prId" : 1677,
    "comments" : [
      {
        "id" : "580d7dfd-5b2d-4d38-8b5f-0a4577692aac",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We need to reindex the workspace and this is to make sure that we will only try to reindex once we finished the indexing at least once.",
        "createdAt" : "2020-04-29T17:19:25Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "38751291a84f683f8d8eb60ed8a73ce8657936c9",
    "line" : 43,
    "diffHunk" : "@@ -47,6 +57,12 @@ class BuildServerConnection private (\n   // the name is set before when establishing conenction\n   def name: String = initialConnection.socketConnection.serverName\n \n+  def onReconnection(\n+      index: BuildServerConnection => Future[Unit]\n+  ): Unit = {\n+    onReconnection.set(index)"
  },
  {
    "id" : "e2c2d45e-743b-4348-811c-18dbc00187db",
    "prId" : 1677,
    "comments" : [
      {
        "id" : "c87d6252-0950-4eab-b6fa-55fabb2f0412",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Depends now on the user configuration.",
        "createdAt" : "2020-04-29T17:19:51Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "38751291a84f683f8d8eb60ed8a73ce8657936c9",
    "line" : 86,
    "diffHunk" : "@@ -118,21 +138,45 @@ class BuildServerConnection private (\n   }\n \n   private def askUser(): Future[BuildServerConnection.LauncherConnection] = {\n-    val notification = tables.dismissedNotifications.ReconnectBsp\n-    if (!notification.isDismissed) {\n-      val params = Messages.DisconnectedServer.params()\n-      languageClient.showMessageRequest(params).asScala.flatMap {\n-        case response if response == Messages.DisconnectedServer.reconnect =>\n-          reestablishConnection()\n-        case response if response == Messages.DisconnectedServer.notNow =>\n-          notification.dismiss(5, TimeUnit.MINUTES)\n-          connection\n+    if (config.askToReconnect) {"
  },
  {
    "id" : "f34db583-02f0-4847-9a84-1dfce0927de7",
    "prId" : 1677,
    "comments" : [
      {
        "id" : "094daf32-7df7-4b3c-9358-e391a46692b9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Here we actually specify that we want to reindex.",
        "createdAt" : "2020-04-29T17:20:18Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "38751291a84f683f8d8eb60ed8a73ce8657936c9",
    "line" : null,
    "diffHunk" : "@@ -118,21 +138,45 @@ class BuildServerConnection private (\n   }\n \n   private def askUser(): Future[BuildServerConnection.LauncherConnection] = {\n-    val notification = tables.dismissedNotifications.ReconnectBsp\n-    if (!notification.isDismissed) {\n-      val params = Messages.DisconnectedServer.params()\n-      languageClient.showMessageRequest(params).asScala.flatMap {\n-        case response if response == Messages.DisconnectedServer.reconnect =>\n-          reestablishConnection()\n-        case response if response == Messages.DisconnectedServer.notNow =>\n-          notification.dismiss(5, TimeUnit.MINUTES)\n-          connection\n+    if (config.askToReconnect) {\n+      val notification = tables.dismissedNotifications.ReconnectBsp\n+      if (!notification.isDismissed) {\n+        val params = Messages.DisconnectedServer.params()\n+        languageClient.showMessageRequest(params).asScala.flatMap {\n+          case response if response == Messages.DisconnectedServer.reconnect =>\n+            reestablishConnection()\n+          case response if response == Messages.DisconnectedServer.notNow =>\n+            notification.dismiss(5, TimeUnit.MINUTES)\n+            connection\n+          case _ =>\n+            connection\n+        }\n+      } else {\n+        connection\n       }\n     } else {\n-      connection\n+      reestablishConnection()\n     }\n   }\n \n+  private def reconnect(): Future[BuildServerConnection.LauncherConnection] = {\n+    val original = connection\n+    synchronized {\n+      // if the future is different then the connection is already being reestablished\n+      if (connection eq original) {\n+        connection = askUser().map { conn =>\n+          // version can change when reconnecting\n+          _version.set(conn.version)\n+          ongoingRequests.addAll(conn.cancelables)\n+          conn.onConnectionFinished(reconnect)\n+          conn\n+        }\n+        connection.foreach(_ => onReconnection.get()(this))"
  },
  {
    "id" : "19fc1f70-d865-4751-b52f-6fdd1e8ed2ea",
    "prId" : 1677,
    "comments" : [
      {
        "id" : "ddc466b6-72c1-4d0a-9c17-9fc513689521",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "by using `compareAndSet(false, true` you could guarantee here that the method will be called exactly once, hence making it idempotent.",
        "createdAt" : "2020-05-04T09:07:35Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "82b3d70e-083f-4bd3-b060-195bb99a9ac2",
        "parentId" : "ddc466b6-72c1-4d0a-9c17-9fc513689521",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Good idea! Fixed it!",
        "createdAt" : "2020-05-04T10:21:28Z",
        "updatedAt" : "2020-05-04T13:57:13Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "38751291a84f683f8d8eb60ed8a73ce8657936c9",
    "line" : null,
    "diffHunk" : "@@ -47,9 +58,16 @@ class BuildServerConnection private (\n   // the name is set before when establishing conenction\n   def name: String = initialConnection.socketConnection.serverName\n \n+  def onReconnection(\n+      index: BuildServerConnection => Future[Unit]\n+  ): Unit = {\n+    onReconnection.set(index)\n+  }\n+\n   /** Run build/shutdown procedure */\n   def shutdown(): Future[Unit] = connection.map { conn =>\n     try {\n+      isShuttingDown.set(true)"
  },
  {
    "id" : "d05759b2-f30c-4d21-8838-bf5c64d8ee99",
    "prId" : 1985,
    "comments" : [
      {
        "id" : "eb662ca2-2dd7-43ba-b7d3-3686e9a39450",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "This is to avoid timeouts we were having from time to time.",
        "createdAt" : "2020-08-21T14:18:29Z",
        "updatedAt" : "2020-08-21T14:58:03Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8e26e2d8d28a3d420f4f5bc7efb45ebe19ab460b",
    "line" : 5,
    "diffHunk" : "@@ -310,7 +310,11 @@ object BuildServerConnection {\n     // and we want to fail fast if the connection is not\n     val result =\n       try {\n-        initializeResult.get(5, TimeUnit.SECONDS)\n+        def isCI: Boolean = \"true\" == System.getenv(\"CI\")"
  }
]