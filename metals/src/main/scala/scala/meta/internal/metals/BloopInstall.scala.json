[
  {
    "id" : "ad03fed7-86f5-4ce4-bd4c-207ed21d5e06",
    "prId" : 337,
    "comments" : [
      {
        "id" : "edc34b9f-c6aa-4747-b2cc-385f6e45cc80",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "out of date (it mentions addPluginSbt)",
        "createdAt" : "2018-11-21T21:27:12Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f5f285a4-de4e-4781-8e20-f0db549dfc65",
        "parentId" : "edc34b9f-c6aa-4747-b2cc-385f6e45cc80",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Updated docstrings.",
        "createdAt" : "2018-11-23T11:46:40Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature"
  },
  {
    "id" : "40e62e7a-c858-4847-9fab-55daa9acc6eb",
    "prId" : 337,
    "comments" : [
      {
        "id" : "200c312c-33ce-4ba0-8fcf-5582406577f1",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Isn't this the same as the fix for 4395 above?",
        "createdAt" : "2018-11-21T21:43:31Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "aef9e74f-ab60-4af2-8afc-a63668c1b81e",
        "parentId" : "200c312c-33ce-4ba0-8fcf-5582406577f1",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Yes, that workaround wasn't necessary after all since we don't use -addPluginSbtFile",
        "createdAt" : "2018-11-23T19:36:47Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : 191,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")\n+    scribe.info(s\"running $prettyArgs\")\n+    // NOTE(olafur): older versions of VS Code don't respect cancellation of\n+    // window/showMessageRequest, meaning the \"cancel build import\" button\n+    // stays forever in view even after successful build import. In newer\n+    // VS Code versions the message is hidden after a delay.\n+    val taskResponse =\n+      languageClient.metalsSlowTask(Messages.BloopInstallProgress)\n+    handler.response = Some(taskResponse)\n+    val processFuture = handler.completeProcess.future.map { result =>\n+      taskResponse.cancel(true)\n+      scribe.info(s\"time: Ran 'sbt bloopInstall' in $elapsed\")\n+      result\n+    }\n+    taskResponse.asScala.foreach { item =>\n+      if (item.cancel) {\n+        scribe.info(\"User cancelled build import\")\n+        handler.completeProcess.complete(\n+          Success(BloopInstallResult.Cancelled)\n+        )\n+        BloopInstall.destroyProcess(runningProcess)\n+      }\n+    }\n+    if (!config.isExtensionsEnabled) {\n+      processFuture.trackInStatusBar(\"Running sbt bloopInstall\")\n+    }\n+    cancelables\n+      .add(() => BloopInstall.destroyProcess(runningProcess))\n+      .add(() => taskResponse.cancel(true))\n+    processFuture\n+  }\n+\n+  private val pendingChange = new AtomicBoolean(false)\n+  private val notification = tables.dismissedNotifications.ImportChanges\n+  def reimportIfChanged(forceImport: Boolean)(\n+      implicit ec: ExecutionContextExecutorService\n+  ): Future[BloopInstallResult] = {\n+    for {\n+      sbt <- buildTools.asSbt.orElse {\n+        scribe.warn(\"Unable to parse sbt build\")\n+        None\n+      }\n+      current <- SbtChecksum.current(workspace)\n+      if forceImport || (tables.sbtChecksums.getStatus(current) match {\n+        case Some(status) if !status.isCancelled =>\n+          scribe.info(s\"skipping build import with status '$status'\")\n+          false\n+        case _ =>\n+          true\n+      })\n+      if forceImport || {\n+        val isDismissed = notification.isDismissed\n+        if (isDismissed) {\n+          scribe.info(\"skipping build import with status 'Dismissed'\")\n+        }\n+        !isDismissed\n+      }\n+      if forceImport || pendingChange.compareAndSet(false, true)\n+    } yield {\n+      tables.sbtChecksums.setStatus(current, Status.Requested)\n+      val request = for {\n+        userResponse <- requestImport(buildTools, languageClient, forceImport)\n+        installResult <- {\n+          if (userResponse.isYes) {\n+            SbtChecksum\n+              .current(workspace)\n+              .foreach { checksum =>\n+                tables.sbtChecksums.setStatus(checksum, Status.Started)\n+              }\n+            runUnconditionally(sbt)\n+          } else {\n+            // Don't spam the user with requests during rapid build changes.\n+            notification.dismiss(2, TimeUnit.MINUTES)\n+            Future.successful(BloopInstallResult.Rejected)\n+          }\n+        }\n+      } yield {\n+        for {\n+          status <- installResult.toChecksumStatus\n+          checksum <- SbtChecksum.current(workspace)\n+        } {\n+          tables.sbtChecksums.setStatus(checksum, status)\n+        }\n+        installResult\n+      }\n+      request.onComplete(_ => pendingChange.set(false))\n+      request\n+    }\n+\n+  }.getOrElse(Future.successful(BloopInstallResult.Unchanged))\n+\n+  private def requestImport(\n+      buildTools: BuildTools,\n+      languageClient: MetalsLanguageClient,\n+      forceImport: Boolean\n+  )(implicit ec: ExecutionContext): Future[Confirmation] = {\n+    if (forceImport) Future.successful(Confirmation.Yes)\n+    else {\n+      if (buildTools.isBloop) {\n+        languageClient\n+          .showMessageRequest(ReimportSbtProject.params)\n+          .asScala\n+          .map { item =>\n+            if (item == dontShowAgain) {\n+              notification.dismissForever()\n+            }\n+            Confirmation.fromBoolean(item == ReimportSbtProject.yes)\n+          }\n+      } else {\n+        languageClient\n+          .showMessageRequest(ImportBuildViaBloop.params)\n+          .asScala\n+          .map { item =>\n+            if (item == dontShowAgain) {\n+              notification.dismissForever()\n+            }\n+            Confirmation.fromBoolean(item == ImportBuildViaBloop.yes)\n+          }\n+      }\n+    }\n+  }\n+\n+}\n+\n+object BloopInstall {\n+\n+  // Creates ~/.sbt/1.0/plugins if it doesn't exist, see\n+  // https://github.com/sbt/sbt/issues/4395\n+  private def workAroundIssue4395(): Unit = {\n+    val plugins = pluginsDirectory(\"1.0\")\n+    Files.createDirectories(plugins.toNIO)\n+  }\n+\n+  def pluginsDirectory(version: String): AbsolutePath = {\n+    AbsolutePath(System.getProperty(\"user.home\"))\n+      .resolve(\".sbt\")\n+      .resolve(version)\n+      .resolve(\"plugins\")\n+  }\n+\n+  private def writeGlobalPluginFile(sbt: Sbt): Unit = {\n+    val plugins =\n+      if (sbt.version.startsWith(\"0.13\")) pluginsDirectory(\"0.13\")\n+      else pluginsDirectory(\"1.0\")\n+    Files.createDirectories(plugins.toNIO)"
  },
  {
    "id" : "269c2cbc-d7e9-4420-8f55-37f977816c73",
    "prId" : 337,
    "comments" : [
      {
        "id" : "175446a1-5cb6-47da-a5f0-c1f8b01ae305",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "why are these interpolators? Also why the triple quotes?",
        "createdAt" : "2018-11-21T21:55:46Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aa674779-4194-40e4-8912-6f16ec1f3608",
        "parentId" : "175446a1-5cb6-47da-a5f0-c1f8b01ae305",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "There used to be interpolators but now they're no longer needed so single quote `\"` is enough (and cleaner)",
        "createdAt" : "2018-11-23T11:47:08Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\""
  },
  {
    "id" : "37b7400b-f21c-4f41-b376-f66b2d8ca018",
    "prId" : 337,
    "comments" : [
      {
        "id" : "1a65dd75-96da-499a-bb4a-c125e9c26722",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Is the `replace` needed? I don't see where `;` are introduced",
        "createdAt" : "2018-11-21T21:56:11Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1033bb90-88f8-4b5f-a38a-aa414da6bda8",
        "parentId" : "1a65dd75-96da-499a-bb4a-c125e9c26722",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It wasn't needed, removed.",
        "createdAt" : "2018-11-24T08:00:48Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")"
  },
  {
    "id" : "03e6ca09-14b3-4592-858e-6ffa53aed0ed",
    "prId" : 337,
    "comments" : [
      {
        "id" : "c7afa01d-c56a-4fc3-a958-ae767298a142",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I'm not sure I follow this. Why tracking in status bar only if the extension is not enabled?",
        "createdAt" : "2018-11-21T21:57:32Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74f773fe-9a8a-4187-b62a-9fea830d46ef",
        "parentId" : "c7afa01d-c56a-4fc3-a958-ae767298a142",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good point, this is confusing. It was added last minute while iterating on the vim support. In short, if `slowTask` is not supported then we can direct the progress to the status bar (which vim supports).\r\n\r\nI will clean up extension handling so that it's organized differently\r\n\r\n- metals.slow-task=off|on|status\r\n- metals.status=off|on|log-message \r\n\r\nAllowing you to redirect slow tasks to the status bar, and redirect status bar to the logs. ",
        "createdAt" : "2018-11-23T11:51:23Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")\n+    scribe.info(s\"running $prettyArgs\")\n+    // NOTE(olafur): older versions of VS Code don't respect cancellation of\n+    // window/showMessageRequest, meaning the \"cancel build import\" button\n+    // stays forever in view even after successful build import. In newer\n+    // VS Code versions the message is hidden after a delay.\n+    val taskResponse =\n+      languageClient.metalsSlowTask(Messages.BloopInstallProgress)\n+    handler.response = Some(taskResponse)\n+    val processFuture = handler.completeProcess.future.map { result =>\n+      taskResponse.cancel(true)\n+      scribe.info(s\"time: Ran 'sbt bloopInstall' in $elapsed\")\n+      result\n+    }\n+    taskResponse.asScala.foreach { item =>\n+      if (item.cancel) {\n+        scribe.info(\"User cancelled build import\")\n+        handler.completeProcess.complete(\n+          Success(BloopInstallResult.Cancelled)\n+        )\n+        BloopInstall.destroyProcess(runningProcess)\n+      }\n+    }\n+    if (!config.isExtensionsEnabled) {"
  },
  {
    "id" : "37803c9d-daaf-4861-9c67-ac5f44f72834",
    "prId" : 337,
    "comments" : [
      {
        "id" : "63fba50c-355d-4846-a072-55b4a3f0d028",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Not a fan of all these `if` in the for-comprehension. They're a bit hard to read.",
        "createdAt" : "2018-11-21T21:58:39Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5ce088f2-6527-44e5-89e9-d01221efd355",
        "parentId" : "63fba50c-355d-4846-a072-55b4a3f0d028",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I agree this particular case was bad, the core logic was just messy. I've refactored things now and it should be better, I still like `if` inside for comprehensions however :)",
        "createdAt" : "2018-11-24T08:00:38Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")\n+    scribe.info(s\"running $prettyArgs\")\n+    // NOTE(olafur): older versions of VS Code don't respect cancellation of\n+    // window/showMessageRequest, meaning the \"cancel build import\" button\n+    // stays forever in view even after successful build import. In newer\n+    // VS Code versions the message is hidden after a delay.\n+    val taskResponse =\n+      languageClient.metalsSlowTask(Messages.BloopInstallProgress)\n+    handler.response = Some(taskResponse)\n+    val processFuture = handler.completeProcess.future.map { result =>\n+      taskResponse.cancel(true)\n+      scribe.info(s\"time: Ran 'sbt bloopInstall' in $elapsed\")\n+      result\n+    }\n+    taskResponse.asScala.foreach { item =>\n+      if (item.cancel) {\n+        scribe.info(\"User cancelled build import\")\n+        handler.completeProcess.complete(\n+          Success(BloopInstallResult.Cancelled)\n+        )\n+        BloopInstall.destroyProcess(runningProcess)\n+      }\n+    }\n+    if (!config.isExtensionsEnabled) {\n+      processFuture.trackInStatusBar(\"Running sbt bloopInstall\")\n+    }\n+    cancelables\n+      .add(() => BloopInstall.destroyProcess(runningProcess))\n+      .add(() => taskResponse.cancel(true))\n+    processFuture\n+  }\n+\n+  private val pendingChange = new AtomicBoolean(false)\n+  private val notification = tables.dismissedNotifications.ImportChanges\n+  def reimportIfChanged(forceImport: Boolean)(\n+      implicit ec: ExecutionContextExecutorService\n+  ): Future[BloopInstallResult] = {\n+    for {\n+      sbt <- buildTools.asSbt.orElse {\n+        scribe.warn(\"Unable to parse sbt build\")\n+        None\n+      }\n+      current <- SbtChecksum.current(workspace)\n+      if forceImport || (tables.sbtChecksums.getStatus(current) match {\n+        case Some(status) if !status.isCancelled =>\n+          scribe.info(s\"skipping build import with status '$status'\")\n+          false\n+        case _ =>\n+          true\n+      })\n+      if forceImport || {\n+        val isDismissed = notification.isDismissed\n+        if (isDismissed) {\n+          scribe.info(\"skipping build import with status 'Dismissed'\")\n+        }\n+        !isDismissed\n+      }\n+      if forceImport || pendingChange.compareAndSet(false, true)"
  },
  {
    "id" : "a55124e1-d83f-4e07-b058-e71f853b5e21",
    "prId" : 337,
    "comments" : [
      {
        "id" : "7c800747-7b31-4dce-9a2a-6affb2a357cf",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "![](https://i.imgflip.com/2n5b2l.jpg)",
        "createdAt" : "2018-11-21T22:01:44Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3de58ac6-183d-46f1-b067-352e5c4d3267",
        "parentId" : "7c800747-7b31-4dce-9a2a-6affb2a357cf",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This was just a bad method overall, the logic wasn't even good. I've refactored it into smaller components and hopefully cleaned up handling of sbt checksums. It's still not ideal but livable.",
        "createdAt" : "2018-11-23T19:36:20Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : 126,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")\n+    scribe.info(s\"running $prettyArgs\")\n+    // NOTE(olafur): older versions of VS Code don't respect cancellation of\n+    // window/showMessageRequest, meaning the \"cancel build import\" button\n+    // stays forever in view even after successful build import. In newer\n+    // VS Code versions the message is hidden after a delay.\n+    val taskResponse =\n+      languageClient.metalsSlowTask(Messages.BloopInstallProgress)\n+    handler.response = Some(taskResponse)\n+    val processFuture = handler.completeProcess.future.map { result =>\n+      taskResponse.cancel(true)\n+      scribe.info(s\"time: Ran 'sbt bloopInstall' in $elapsed\")\n+      result\n+    }\n+    taskResponse.asScala.foreach { item =>\n+      if (item.cancel) {\n+        scribe.info(\"User cancelled build import\")\n+        handler.completeProcess.complete(\n+          Success(BloopInstallResult.Cancelled)\n+        )\n+        BloopInstall.destroyProcess(runningProcess)\n+      }\n+    }\n+    if (!config.isExtensionsEnabled) {\n+      processFuture.trackInStatusBar(\"Running sbt bloopInstall\")\n+    }\n+    cancelables\n+      .add(() => BloopInstall.destroyProcess(runningProcess))\n+      .add(() => taskResponse.cancel(true))\n+    processFuture\n+  }\n+\n+  private val pendingChange = new AtomicBoolean(false)\n+  private val notification = tables.dismissedNotifications.ImportChanges\n+  def reimportIfChanged(forceImport: Boolean)(\n+      implicit ec: ExecutionContextExecutorService\n+  ): Future[BloopInstallResult] = {\n+    for {\n+      sbt <- buildTools.asSbt.orElse {\n+        scribe.warn(\"Unable to parse sbt build\")\n+        None\n+      }\n+      current <- SbtChecksum.current(workspace)\n+      if forceImport || (tables.sbtChecksums.getStatus(current) match {\n+        case Some(status) if !status.isCancelled =>\n+          scribe.info(s\"skipping build import with status '$status'\")\n+          false\n+        case _ =>\n+          true\n+      })\n+      if forceImport || {\n+        val isDismissed = notification.isDismissed\n+        if (isDismissed) {\n+          scribe.info(\"skipping build import with status 'Dismissed'\")\n+        }\n+        !isDismissed\n+      }\n+      if forceImport || pendingChange.compareAndSet(false, true)\n+    } yield {\n+      tables.sbtChecksums.setStatus(current, Status.Requested)\n+      val request = for {\n+        userResponse <- requestImport(buildTools, languageClient, forceImport)\n+        installResult <- {\n+          if (userResponse.isYes) {\n+            SbtChecksum\n+              .current(workspace)\n+              .foreach { checksum =>\n+                tables.sbtChecksums.setStatus(checksum, Status.Started)\n+              }\n+            runUnconditionally(sbt)\n+          } else {\n+            // Don't spam the user with requests during rapid build changes.\n+            notification.dismiss(2, TimeUnit.MINUTES)\n+            Future.successful(BloopInstallResult.Rejected)\n+          }\n+        }\n+      } yield {\n+        for {"
  },
  {
    "id" : "f261a3ad-8ced-47e5-ad71-8a07fd0b6bc6",
    "prId" : 337,
    "comments" : [
      {
        "id" : "933c4afd-94aa-4c02-ae3e-d843bf204c65",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I'm probably missing something, but shouldn't this branch return `Confirmation.DontShowAgain`?",
        "createdAt" : "2018-11-21T22:03:48Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ca551e3-4b67-44a2-acdc-9e63d12f8cf0",
        "parentId" : "933c4afd-94aa-4c02-ae3e-d843bf204c65",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "`Confirmation.DontShowAgain` was removed.",
        "createdAt" : "2018-11-24T07:59:35Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")\n+    scribe.info(s\"running $prettyArgs\")\n+    // NOTE(olafur): older versions of VS Code don't respect cancellation of\n+    // window/showMessageRequest, meaning the \"cancel build import\" button\n+    // stays forever in view even after successful build import. In newer\n+    // VS Code versions the message is hidden after a delay.\n+    val taskResponse =\n+      languageClient.metalsSlowTask(Messages.BloopInstallProgress)\n+    handler.response = Some(taskResponse)\n+    val processFuture = handler.completeProcess.future.map { result =>\n+      taskResponse.cancel(true)\n+      scribe.info(s\"time: Ran 'sbt bloopInstall' in $elapsed\")\n+      result\n+    }\n+    taskResponse.asScala.foreach { item =>\n+      if (item.cancel) {\n+        scribe.info(\"User cancelled build import\")\n+        handler.completeProcess.complete(\n+          Success(BloopInstallResult.Cancelled)\n+        )\n+        BloopInstall.destroyProcess(runningProcess)\n+      }\n+    }\n+    if (!config.isExtensionsEnabled) {\n+      processFuture.trackInStatusBar(\"Running sbt bloopInstall\")\n+    }\n+    cancelables\n+      .add(() => BloopInstall.destroyProcess(runningProcess))\n+      .add(() => taskResponse.cancel(true))\n+    processFuture\n+  }\n+\n+  private val pendingChange = new AtomicBoolean(false)\n+  private val notification = tables.dismissedNotifications.ImportChanges\n+  def reimportIfChanged(forceImport: Boolean)(\n+      implicit ec: ExecutionContextExecutorService\n+  ): Future[BloopInstallResult] = {\n+    for {\n+      sbt <- buildTools.asSbt.orElse {\n+        scribe.warn(\"Unable to parse sbt build\")\n+        None\n+      }\n+      current <- SbtChecksum.current(workspace)\n+      if forceImport || (tables.sbtChecksums.getStatus(current) match {\n+        case Some(status) if !status.isCancelled =>\n+          scribe.info(s\"skipping build import with status '$status'\")\n+          false\n+        case _ =>\n+          true\n+      })\n+      if forceImport || {\n+        val isDismissed = notification.isDismissed\n+        if (isDismissed) {\n+          scribe.info(\"skipping build import with status 'Dismissed'\")\n+        }\n+        !isDismissed\n+      }\n+      if forceImport || pendingChange.compareAndSet(false, true)\n+    } yield {\n+      tables.sbtChecksums.setStatus(current, Status.Requested)\n+      val request = for {\n+        userResponse <- requestImport(buildTools, languageClient, forceImport)\n+        installResult <- {\n+          if (userResponse.isYes) {\n+            SbtChecksum\n+              .current(workspace)\n+              .foreach { checksum =>\n+                tables.sbtChecksums.setStatus(checksum, Status.Started)\n+              }\n+            runUnconditionally(sbt)\n+          } else {\n+            // Don't spam the user with requests during rapid build changes.\n+            notification.dismiss(2, TimeUnit.MINUTES)\n+            Future.successful(BloopInstallResult.Rejected)\n+          }\n+        }\n+      } yield {\n+        for {\n+          status <- installResult.toChecksumStatus\n+          checksum <- SbtChecksum.current(workspace)\n+        } {\n+          tables.sbtChecksums.setStatus(checksum, status)\n+        }\n+        installResult\n+      }\n+      request.onComplete(_ => pendingChange.set(false))\n+      request\n+    }\n+\n+  }.getOrElse(Future.successful(BloopInstallResult.Unchanged))\n+\n+  private def requestImport(\n+      buildTools: BuildTools,\n+      languageClient: MetalsLanguageClient,\n+      forceImport: Boolean\n+  )(implicit ec: ExecutionContext): Future[Confirmation] = {\n+    if (forceImport) Future.successful(Confirmation.Yes)\n+    else {\n+      if (buildTools.isBloop) {\n+        languageClient\n+          .showMessageRequest(ReimportSbtProject.params)\n+          .asScala\n+          .map { item =>\n+            if (item == dontShowAgain) {\n+              notification.dismissForever()\n+            }"
  },
  {
    "id" : "e74e10eb-1e3e-4337-8bc1-93227d95091e",
    "prId" : 337,
    "comments" : [
      {
        "id" : "ec16377d-8f3e-4e2f-bf9d-b7b48cae81ce",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "The check seems redundant. Is there anything wrong in writing the file unconditionally?",
        "createdAt" : "2018-11-21T22:04:55Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "91deda67-5b83-4838-8c50-857041fc7e62",
        "parentId" : "ec16377d-8f3e-4e2f-bf9d-b7b48cae81ce",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I added a detailed commit. I haven't validated 100% but the idea is to avoid triggering sbt re-compilation of global plugins, that can slow down the import by 5-10 seconds",
        "createdAt" : "2018-11-23T19:39:07Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : 202,
    "diffHunk" : "@@ -0,0 +1,314 @@\n+package scala.meta.internal.metals\n+\n+import com.zaxxer.nuprocess.NuAbstractProcessHandler\n+import com.zaxxer.nuprocess.NuProcess\n+import com.zaxxer.nuprocess.NuProcessBuilder\n+import fansi.ErrorMode\n+import java.nio.ByteBuffer\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Files\n+import java.util.concurrent.CompletableFuture\n+import java.util.concurrent.ScheduledExecutorService\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.ExecutionContextExecutorService\n+import scala.concurrent.Future\n+import scala.concurrent.Promise\n+import scala.meta.internal.metals.BuildTool.Sbt\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.SbtChecksum.Status\n+import scala.meta.io.AbsolutePath\n+import scala.util.Success\n+\n+/**\n+ * Runs `sbt bloopInstall` processes.\n+ *\n+ * Handles responsibilities like:\n+ * - persist .metals/sbt.md5 checksum file after successful bloopInstall\n+ * - automatically install sbt-bloop and sbt-metals via -addPluginSbt feature\n+ *   introduced in sbt v1.2.0.\n+ */\n+final class BloopInstall(\n+    workspace: AbsolutePath,\n+    languageClient: MetalsLanguageClient,\n+    sh: ScheduledExecutorService,\n+    buildTools: BuildTools,\n+    time: Time,\n+    tables: Tables,\n+    messages: Messages,\n+    config: MetalsServerConfig\n+)(implicit ec: ExecutionContext, statusBar: StatusBar)\n+    extends Cancelable {\n+  import messages._\n+  private val cancelables = new MutableCancelable()\n+  override def cancel(): Unit = {\n+    cancelables.cancel()\n+  }\n+\n+  override def toString: String = s\"BloopInstall($workspace)\"\n+\n+  def runUnconditionally(sbt: Sbt): Future[BloopInstallResult] = {\n+    BloopInstall.writeGlobalPluginFile(sbt)\n+    BloopInstall.workAroundIssue4395()\n+    val elapsed = new Timer(time)\n+    val handler = new BloopInstall.ProcessHandler()\n+    val args = List(\n+      s\"\"\"sbt\"\"\",\n+      s\"\"\"-Dscalameta.version=4.0.0-163560a8\"\"\",\n+      s\"\"\"-Djline.terminal=jline.UnsupportedTerminal\"\"\",\n+      s\"\"\"-Dsbt.log.noformat=true\"\"\",\n+      s\"\"\"-Dfile.encoding=UTF-8\"\"\",\n+      s\"\"\"metalsEnable\"\"\",\n+      s\"\"\"bloopInstall\"\"\"\n+    )\n+    val pb = new NuProcessBuilder(handler, args.asJava)\n+    pb.setCwd(workspace.toNIO)\n+    pb.environment().put(\"COURSIER_PROGRESS\", \"disable\")\n+    pb.environment().put(\"METALS_ENABLED\", \"true\")\n+    val runningProcess = pb.start()\n+    val prettyArgs = args.mkString(\" \").replace(\"; \", \"\")\n+    scribe.info(s\"running $prettyArgs\")\n+    // NOTE(olafur): older versions of VS Code don't respect cancellation of\n+    // window/showMessageRequest, meaning the \"cancel build import\" button\n+    // stays forever in view even after successful build import. In newer\n+    // VS Code versions the message is hidden after a delay.\n+    val taskResponse =\n+      languageClient.metalsSlowTask(Messages.BloopInstallProgress)\n+    handler.response = Some(taskResponse)\n+    val processFuture = handler.completeProcess.future.map { result =>\n+      taskResponse.cancel(true)\n+      scribe.info(s\"time: Ran 'sbt bloopInstall' in $elapsed\")\n+      result\n+    }\n+    taskResponse.asScala.foreach { item =>\n+      if (item.cancel) {\n+        scribe.info(\"User cancelled build import\")\n+        handler.completeProcess.complete(\n+          Success(BloopInstallResult.Cancelled)\n+        )\n+        BloopInstall.destroyProcess(runningProcess)\n+      }\n+    }\n+    if (!config.isExtensionsEnabled) {\n+      processFuture.trackInStatusBar(\"Running sbt bloopInstall\")\n+    }\n+    cancelables\n+      .add(() => BloopInstall.destroyProcess(runningProcess))\n+      .add(() => taskResponse.cancel(true))\n+    processFuture\n+  }\n+\n+  private val pendingChange = new AtomicBoolean(false)\n+  private val notification = tables.dismissedNotifications.ImportChanges\n+  def reimportIfChanged(forceImport: Boolean)(\n+      implicit ec: ExecutionContextExecutorService\n+  ): Future[BloopInstallResult] = {\n+    for {\n+      sbt <- buildTools.asSbt.orElse {\n+        scribe.warn(\"Unable to parse sbt build\")\n+        None\n+      }\n+      current <- SbtChecksum.current(workspace)\n+      if forceImport || (tables.sbtChecksums.getStatus(current) match {\n+        case Some(status) if !status.isCancelled =>\n+          scribe.info(s\"skipping build import with status '$status'\")\n+          false\n+        case _ =>\n+          true\n+      })\n+      if forceImport || {\n+        val isDismissed = notification.isDismissed\n+        if (isDismissed) {\n+          scribe.info(\"skipping build import with status 'Dismissed'\")\n+        }\n+        !isDismissed\n+      }\n+      if forceImport || pendingChange.compareAndSet(false, true)\n+    } yield {\n+      tables.sbtChecksums.setStatus(current, Status.Requested)\n+      val request = for {\n+        userResponse <- requestImport(buildTools, languageClient, forceImport)\n+        installResult <- {\n+          if (userResponse.isYes) {\n+            SbtChecksum\n+              .current(workspace)\n+              .foreach { checksum =>\n+                tables.sbtChecksums.setStatus(checksum, Status.Started)\n+              }\n+            runUnconditionally(sbt)\n+          } else {\n+            // Don't spam the user with requests during rapid build changes.\n+            notification.dismiss(2, TimeUnit.MINUTES)\n+            Future.successful(BloopInstallResult.Rejected)\n+          }\n+        }\n+      } yield {\n+        for {\n+          status <- installResult.toChecksumStatus\n+          checksum <- SbtChecksum.current(workspace)\n+        } {\n+          tables.sbtChecksums.setStatus(checksum, status)\n+        }\n+        installResult\n+      }\n+      request.onComplete(_ => pendingChange.set(false))\n+      request\n+    }\n+\n+  }.getOrElse(Future.successful(BloopInstallResult.Unchanged))\n+\n+  private def requestImport(\n+      buildTools: BuildTools,\n+      languageClient: MetalsLanguageClient,\n+      forceImport: Boolean\n+  )(implicit ec: ExecutionContext): Future[Confirmation] = {\n+    if (forceImport) Future.successful(Confirmation.Yes)\n+    else {\n+      if (buildTools.isBloop) {\n+        languageClient\n+          .showMessageRequest(ReimportSbtProject.params)\n+          .asScala\n+          .map { item =>\n+            if (item == dontShowAgain) {\n+              notification.dismissForever()\n+            }\n+            Confirmation.fromBoolean(item == ReimportSbtProject.yes)\n+          }\n+      } else {\n+        languageClient\n+          .showMessageRequest(ImportBuildViaBloop.params)\n+          .asScala\n+          .map { item =>\n+            if (item == dontShowAgain) {\n+              notification.dismissForever()\n+            }\n+            Confirmation.fromBoolean(item == ImportBuildViaBloop.yes)\n+          }\n+      }\n+    }\n+  }\n+\n+}\n+\n+object BloopInstall {\n+\n+  // Creates ~/.sbt/1.0/plugins if it doesn't exist, see\n+  // https://github.com/sbt/sbt/issues/4395\n+  private def workAroundIssue4395(): Unit = {\n+    val plugins = pluginsDirectory(\"1.0\")\n+    Files.createDirectories(plugins.toNIO)\n+  }\n+\n+  def pluginsDirectory(version: String): AbsolutePath = {\n+    AbsolutePath(System.getProperty(\"user.home\"))\n+      .resolve(\".sbt\")\n+      .resolve(version)\n+      .resolve(\"plugins\")\n+  }\n+\n+  private def writeGlobalPluginFile(sbt: Sbt): Unit = {\n+    val plugins =\n+      if (sbt.version.startsWith(\"0.13\")) pluginsDirectory(\"0.13\")\n+      else pluginsDirectory(\"1.0\")\n+    Files.createDirectories(plugins.toNIO)\n+    val bytes = globalMetalsSbt.getBytes(StandardCharsets.UTF_8)\n+    val destination = plugins.resolve(\"metals.sbt\")\n+    if (destination.isFile && destination.readAllBytes.sameElements(bytes)) {\n+      () // do nothing\n+    } else {\n+      Files.write(destination.toNIO, bytes)\n+    }"
  },
  {
    "id" : "1af6b0df-c64d-473b-8661-129cce006437",
    "prId" : 337,
    "comments" : [
      {
        "id" : "58232ae8-e624-41eb-a793-5f761a0e9105",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "typo, og -> on",
        "createdAt" : "2018-11-24T13:00:42Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "853cebf5-cf1d-4eee-a235-e304ad841d07",
        "parentId" : "58232ae8-e624-41eb-a793-5f761a0e9105",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "`s/og/of/`",
        "createdAt" : "2018-11-25T11:14:24Z",
        "updatedAt" : "2018-11-27T10:23:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ab78d5883e2e77a843cca1ea641084e6e4a2875",
    "line" : null,
    "diffHunk" : "@@ -233,7 +193,11 @@ object BloopInstall {\n     val bytes = globalMetalsSbt.getBytes(StandardCharsets.UTF_8)\n     val destination = plugins.resolve(\"metals.sbt\")\n     if (destination.isFile && destination.readAllBytes.sameElements(bytes)) {\n-      () // do nothing\n+      // Do nothing if the file is unchanged. If we write to the file unconditionally\n+      // we risk triggering sbt re-compilation og global plugins that slows down"
  },
  {
    "id" : "34024853-ac9c-4324-81c7-1c51c8e96b88",
    "prId" : 351,
    "comments" : [
      {
        "id" : "c4f518d8-b9a2-47aa-b1c6-391d628413cc",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Can it ever be just \"SNAPSHOT\" like in the past?",
        "createdAt" : "2018-11-29T09:56:47Z",
        "updatedAt" : "2018-11-29T09:56:48Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e1257a38-9c07-4a91-a097-190125d86531",
        "parentId" : "c4f518d8-b9a2-47aa-b1c6-391d628413cc",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nope, it was nice while it lasted but caused troubles when the vscode plugin picked up ancient local builds from people who tried metals ages ago",
        "createdAt" : "2018-11-29T10:04:38Z",
        "updatedAt" : "2018-11-29T10:04:38Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "836fd11722c43ba821d53f192ab7f3bac35643f9",
    "line" : 7,
    "diffHunk" : "@@ -205,11 +205,25 @@ object BloopInstall {\n   /**\n    * Contents of metals.sbt file that is installed globally.\n    */\n-  private def globalMetalsSbt: String =\n+  private def globalMetalsSbt: String = {\n+    val resolvers =\n+      if (BuildInfo.metalsVersion.endsWith(\"-SNAPSHOT\")) {"
  },
  {
    "id" : "bd4e06c7-30a8-44e3-85e4-5bca9439c8d5",
    "prId" : 417,
    "comments" : [
      {
        "id" : "04388832-f4a7-468a-8d1b-d5d8ad040984",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can we create an extension method `AbsolutePath.createDirectories()` in `MetalsEnrichments` that performs this check? It would make it easier to reuse in the future.",
        "createdAt" : "2018-12-16T16:29:41Z",
        "updatedAt" : "2018-12-17T11:33:22Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "33fc2a0b28c3ea880850d439c9d45777519fc70d",
    "line" : null,
    "diffHunk" : "@@ -215,7 +215,12 @@ object BloopInstall {\n     val plugins =\n       if (sbt.version.startsWith(\"0.13\")) pluginsDirectory(\"0.13\")\n       else pluginsDirectory(\"1.0\")\n-    Files.createDirectories(plugins.toNIO)\n+    val isSymlink = Files.isSymbolicLink(plugins.toNIO) &&\n+      Files.isDirectory(Files.readSymbolicLink(plugins.toNIO))\n+    // createDirectories checks whether the directory exists, but it doesn't follow symlinks\n+    if (!isSymlink) {\n+      Files.createDirectories(plugins.toNIO)"
  },
  {
    "id" : "447d73b4-719f-4512-b596-e7b80ddc2c98",
    "prId" : 727,
    "comments" : [
      {
        "id" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "`output.indexOf('\\n') > 0` ? no need to follow up `contains` with the `indexOf`. Asa a result we can also drop the inner `if` :)",
        "createdAt" : "2019-05-22T05:35:44Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cc283a61-32f7-4d03-88d6-a07585111a00",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "or maybe something like:\r\n```\r\nval lines = output.splitBy(char == '\\n') // if no '\\n' then lines == Array(output)\r\nlines.dropRight(1).forEach(fn)\r\noutput = lines.last  // last entry is everything after the last '\\n'\r\n```",
        "createdAt" : "2019-05-22T05:38:05Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e085ab73-d1a5-4344-a7ed-ec8ad2031aa8",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Is it possible to use `String.linesIterator.foreach(...)` in this situation?",
        "createdAt" : "2019-05-22T09:28:41Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "478ef788-8842-457a-b3ec-48b542fe596d",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "the problems is that `\"asbcd\\n\".linesIterator.size == 1` and I need to differentiate between \"asbcd\\n\" and \"asbcd\" situation. I think this while is a more straightforward solution",
        "createdAt" : "2019-05-22T11:57:41Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4bc040c5-12ef-45c2-ab9c-b1ffac55c8d0",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "also if I do it this way I will always have everything written properly till the end since build tools always end with \\n",
        "createdAt" : "2019-05-22T11:59:20Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a695b03c-8c46-4c0b-ac0f-508011ad8532",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Here's an implementation that doesn't use while, vars or string concat\r\n\r\n```scala\r\n@   def forallLines(text: String, fn: String => Unit): Unit = {\r\n      def loop(start: Int): Unit = {\r\n        val nl = text.indexOf('\\n', start)\r\n        if (nl < 0) {\r\n          fn(text.substring(start))\r\n        } else {\r\n          fn(text.substring(start, nl))\r\n          loop(nl + 1) // hop over newline character\r\n        }\r\n      }\r\n      loop(0)\r\n    }\r\ndefined function forallLines\r\n\r\n@ forallLines(\"a\\nb\\n\", line => pprint.log(line))\r\nammonite.$sess.cmd9.res9:1 line: \"a\"\r\nammonite.$sess.cmd9.res9:1 line: \"b\"\r\nammonite.$sess.cmd9.res9:1 line: \"\"\r\n```",
        "createdAt" : "2019-05-22T12:07:54Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a2b4ec86-97be-4d39-943e-c482e899bea1",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I'm concerned this doesn't handle `\\r\\n` however, which `String.linesIterator` does. I would recommend using `linesIterator` instead and if the trailing endline is important then you can add a special case for it\r\n```scala\r\noutput.linesIterator.foreach(fn)\r\nif (output.endsWith(\"\\n\")) fn(\"\")\r\n```",
        "createdAt" : "2019-05-22T12:09:30Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0036acc7-62db-499e-8b2e-d9543d308688",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "That var is a buffer between invocations though, that's why it's important. Maven send a single line in 3 parts. I did switch it to StringBuilder which should be better for now. As for lineIterator I will check what will happen with `\\r\\n`.",
        "createdAt" : "2019-05-22T12:35:21Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "32777b23-4c2c-44ad-bedd-1a8081cd74ae",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Is it necessary to do `fn(line)` on each individual line? What happens if we call `scribe.info` on messages with multiple newlines?",
        "createdAt" : "2019-05-22T12:42:44Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "59eb5218-6955-4630-bed5-50ca15a684db",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "It looks a little misaligned in logs then, but \\n work",
        "createdAt" : "2019-05-22T14:18:23Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c6293f6e-ec44-4923-82fb-749a5eec7505",
        "parentId" : "8a92ca1b-3faf-427d-ae63-50884e4956b2",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Ok, added using lineIter and I also check if we should include the last line depending if it ends with \\n",
        "createdAt" : "2019-05-22T14:56:11Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec9c0395fa83c2e41f0331e8f4bddea0b2709085",
    "line" : null,
    "diffHunk" : "@@ -243,9 +244,14 @@ object BloopInstall {\n         fn: String => Unit\n     ): Unit = {\n       if (!closed) {\n-        val text = toPlainString(buffer).trim\n-        if (text.nonEmpty) {\n-          fn(text)\n+        val text = toPlainString(buffer)\n+        output = output + text\n+        while (output.contains('\\n')) {"
  },
  {
    "id" : "f4bad371-7e74-4e28-914b-ebe4e0cab8b6",
    "prId" : 727,
    "comments" : [
      {
        "id" : "35c4f0cc-8088-4e61-9530-b1ecde52dd27",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : " isn't it quiva and then Java lent of appending inside a loop? Here, we are not the one controlling how often will that happen, so (even though Java 8 and then Java 9 greatly increased the performance of appending strings) I am not sure just concatenating strings here is the best approach.",
        "createdAt" : "2019-05-22T05:45:50Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "18d7df37-b072-47ba-a748-71b1238590fe",
        "parentId" : "35c4f0cc-8088-4e61-9530-b1ecde52dd27",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Using StringBuilder after sugestion",
        "createdAt" : "2019-05-22T11:58:03Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec9c0395fa83c2e41f0331e8f4bddea0b2709085",
    "line" : null,
    "diffHunk" : "@@ -243,9 +244,14 @@ object BloopInstall {\n         fn: String => Unit\n     ): Unit = {\n       if (!closed) {\n-        val text = toPlainString(buffer).trim\n-        if (text.nonEmpty) {\n-          fn(text)\n+        val text = toPlainString(buffer)\n+        output = output + text"
  },
  {
    "id" : "c7b3f69a-14dd-4b4c-be3e-0c590264b92e",
    "prId" : 727,
    "comments" : [
      {
        "id" : "b9b252c0-3a5a-4b04-acb1-edc10810896b",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "It looks like both of the input channels are using the same \"queue\"? Is there no contention between them? Does the `onStdout` and `onStderr` happen in the exact same order as in the process? Are they handled by the same thread underneath (i.e. the Process class in scala library there is a thread for each of them so they might trigger those methods in any order they want). If there are two threads handling `stderr` and `stdout` then we either need some means of synchronization on the `log` method or even better two queues. Otherwise those would  probably get intertwined. \r\nBut if everything here is safe, then please add a comment ;)",
        "createdAt" : "2019-05-22T05:52:49Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c80afafb-539c-4ce2-be6d-06084637b847",
        "parentId" : "b9b252c0-3a5a-4b04-acb1-edc10810896b",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Separated the different outputs - thanks! Haven't noticed it.",
        "createdAt" : "2019-05-22T11:58:39Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec9c0395fa83c2e41f0331e8f4bddea0b2709085",
    "line" : null,
    "diffHunk" : "@@ -214,6 +214,7 @@ object BloopInstall {\n   private class ProcessHandler() extends NuAbstractProcessHandler {\n     var response: Option[CompletableFuture[_]] = None\n     val completeProcess = Promise[BloopInstallResult]()\n+    var output = \"\""
  },
  {
    "id" : "1a1d44e8-6acb-42df-bd36-082ce4984813",
    "prId" : 727,
    "comments" : [
      {
        "id" : "40f15756-542e-46a8-aabf-f09c6e3ef96d",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Should we flush the buffer on exit?",
        "createdAt" : "2019-05-22T15:06:54Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b67a8faf-1e5a-4250-887f-a94cf1535f8c",
        "parentId" : "40f15756-542e-46a8-aabf-f09c6e3ef96d",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Which buffer? We just use the logger and pretty sure it has autoflush set.",
        "createdAt" : "2019-05-22T15:20:37Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c29f9830-28e3-447c-ac23-0740b091ca3c",
        "parentId" : "40f15756-542e-46a8-aabf-f09c6e3ef96d",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "What happens in the following scenario?\r\n\r\n- stdout prints `\"Hello\"`, with no newline\r\n- process exits\r\n\r\nI expect `\"Hello\"` to get printed out on exit.",
        "createdAt" : "2019-05-23T06:25:32Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2e87f7c8-4d4d-49c8-b9e3-7f68c6bfe06e",
        "parentId" : "40f15756-542e-46a8-aabf-f09c6e3ef96d",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "But that is not going to happen, we only run build tools using this class.  \r\n\r\nI can account for scenario, but it seems really hypothetical.",
        "createdAt" : "2019-05-23T07:26:19Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "61da1e59-5b85-407e-89c9-f27e929aaa67",
        "parentId" : "40f15756-542e-46a8-aabf-f09c6e3ef96d",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Ok, added additional logging on exit.",
        "createdAt" : "2019-05-23T07:33:00Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c0395fa83c2e41f0331e8f4bddea0b2709085",
    "line" : 26,
    "diffHunk" : "@@ -214,6 +214,8 @@ object BloopInstall {\n   private class ProcessHandler() extends NuAbstractProcessHandler {\n     var response: Option[CompletableFuture[_]] = None\n     val completeProcess = Promise[BloopInstallResult]()\n+    val standardOutput = new StringBuilder\n+    val errorOutput = new StringBuilder\n \n     override def onStart(nuProcess: NuProcess): Unit = {"
  },
  {
    "id" : "e24311cd-cc06-4d32-a02a-a08c4118cf05",
    "prId" : 727,
    "comments" : [
      {
        "id" : "fb8439a7-40b6-4ec8-b0ce-129533b0e4fb",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "What happens to the non-last lines? It looks like they get removed here  ",
        "createdAt" : "2019-05-22T15:10:11Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a3e8e374-3781-4dbd-b116-347e09636170",
        "parentId" : "fb8439a7-40b6-4ec8-b0ce-129533b0e4fb",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "my bad, forgot foreach - that would come up in maven",
        "createdAt" : "2019-05-22T15:19:16Z",
        "updatedAt" : "2019-05-24T09:56:49Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec9c0395fa83c2e41f0331e8f4bddea0b2709085",
    "line" : null,
    "diffHunk" : "@@ -232,20 +234,28 @@ object BloopInstall {\n     }\n \n     override def onStdout(buffer: ByteBuffer, closed: Boolean): Unit = {\n-      log(closed, buffer)(out => scribe.info(out))\n+      log(standardOutput, closed, buffer)(out => scribe.info(out))\n     }\n \n     override def onStderr(buffer: ByteBuffer, closed: Boolean): Unit = {\n-      log(closed, buffer)(out => scribe.error(out))\n+      log(errorOutput, closed, buffer)(out => scribe.error(out))\n     }\n \n-    private def log(closed: Boolean, buffer: ByteBuffer)(\n+    private def log(output: StringBuilder, closed: Boolean, buffer: ByteBuffer)(\n         fn: String => Unit\n     ): Unit = {\n       if (!closed) {\n-        val text = toPlainString(buffer).trim\n-        if (text.nonEmpty) {\n-          fn(text)\n+        val text = toPlainString(buffer)\n+        output.append(text)\n+        val lines = output.linesIterator.toList\n+        if (output.endsWith(\"\\n\")){\n+          lines.foreach(fn)\n+          output.clear()\n+        } else {\n+          lines.take(lines.size - 1)\n+          val last = lines.last\n+          output.clear()"
  },
  {
    "id" : "87fe5398-7332-408a-b2d1-c9f9a8d78d4b",
    "prId" : 1186,
    "comments" : [
      {
        "id" : "c8bbd610-7789-4c54-b311-872ca95868be",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "```suggestion\r\n  // notifications. This method is synchronized to prevent asking the user\r\n```",
        "createdAt" : "2019-12-15T10:56:29Z",
        "updatedAt" : "2019-12-15T11:01:28Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9748c822-71ee-4c6d-8b1f-ba30db4cb42a",
        "parentId" : "c8bbd610-7789-4c54-b311-872ca95868be",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Fixed, good excuse to run the tests again  l",
        "createdAt" : "2019-12-15T11:01:48Z",
        "updatedAt" : "2019-12-15T11:01:48Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5054a085c03e78b119d7ba0df2efafaefb0f8675",
    "line" : null,
    "diffHunk" : "@@ -135,10 +135,14 @@ final class BloopInstall(\n     }\n   }\n \n+  // NOTE(olafur) there's a chance that we get two build change notifications in\n+  // a very short period due to duplicate `didSave` and file watching\n+  // notificiations. This method is synchronized to prevent asking the user"
  },
  {
    "id" : "091c54f7-8d5e-473a-ba58-9172677546bb",
    "prId" : 1758,
    "comments" : [
      {
        "id" : "590efd3c-44a7-4e5b-a023-431a30fc2b22",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "This seems duplicated with `MetalsLanguageServer.supportedBuildTool`, if we filter them before, there will be no need for checking it again.",
        "createdAt" : "2020-05-18T10:41:32Z",
        "updatedAt" : "2020-05-21T13:59:54Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "82833ad1c0108993cd84f5b3b8aba65d1107aace",
    "line" : null,
    "diffHunk" : "@@ -201,4 +212,38 @@ final class BloopInstall(\n       }\n   }\n \n+  private def requestBuildToolChoice(\n+      buildTools: List[BuildTool]\n+  ): Future[Option[BuildTool]] = {\n+    languageClient\n+      .showMessageRequest(ChooseBuildTool.params(buildTools))\n+      .asScala\n+      .map { choice =>\n+        val selectedBuildTool =\n+          buildTools.find(buildTool =>\n+            new MessageActionItem(buildTool.executableName) == choice\n+          )\n+        selectedBuildTool match {\n+          case Some(buildTool) => {\n+            val isCompatibleVersion = SemVer.isCompatibleVersion(\n+              buildTool.minimumVersion,\n+              buildTool.version\n+            )\n+            if (isCompatibleVersion) {"
  },
  {
    "id" : "94f8fd1c-efd1-4d33-81b2-c72df02a34c3",
    "prId" : 1779,
    "comments" : [
      {
        "id" : "e92b5da0-8cfd-4151-83d4-4d97bb12e781",
        "parentId" : null,
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "It could be simplified to `foundBuildTool.foreach(...)`",
        "createdAt" : "2020-05-26T07:46:33Z",
        "updatedAt" : "2020-05-26T07:50:43Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a752a4daf60e10c60ef129d816a6ce74b4391c25",
    "line" : null,
    "diffHunk" : "@@ -221,9 +221,15 @@ final class BloopInstall(\n       .showMessageRequest(ChooseBuildTool.params(buildTools))\n       .asScala\n       .map { choice =>\n-        buildTools.find(buildTool =>\n+        val foundBuildTool = buildTools.find(buildTool =>\n           new MessageActionItem(buildTool.executableName) == choice\n         )\n+        foundBuildTool match {"
  }
]