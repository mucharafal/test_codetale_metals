[
  {
    "id" : "24ea548d-72af-4fcc-b340-8d81be5c358b",
    "prId" : 855,
    "comments" : [
      {
        "id" : "4ea0b090-c792-4723-b8c2-3ae313d9db71",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "since both directories and files can be sources, maybe we can drop the \"item\" from the name? It makes the name more clear\r\n\r\n```suggestion\r\n    def watch(path: AbsolutePath, isSource: Boolean): Unit = {\r\n```",
        "createdAt" : "2019-08-07T06:43:16Z",
        "updatedAt" : "2019-08-07T07:33:22Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "cfc7c2736fc5bb933eebff3ee83d32552074e005",
    "line" : 11,
    "diffHunk" : "@@ -49,25 +49,26 @@ final class FileWatcher(\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesItemsToWatch = new util.ArrayList[Path]()\n     val createdSourceDirectories = new util.ArrayList[AbsolutePath]()\n-    def watch(dir: AbsolutePath, isSourceDirectory: Boolean): Unit = {\n-      if (!dir.isDirectory) {\n-        dir.createDirectories()\n-        if (isSourceDirectory) createdSourceDirectories.add(dir)\n+    def watch(path: AbsolutePath, isSourceItem: Boolean): Unit = {"
  },
  {
    "id" : "c523b4a3-4860-42a3-8db3-32a0ab85e73f",
    "prId" : 855,
    "comments" : [
      {
        "id" : "6b8075b5-dab1-4a14-9f71-625419c5a9bd",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "what if the file is missing? should we create it then too? \r\nmaybe then a rule should be something like:\r\na) `if path.hasExtension then path.createFile`\r\nb) `if path.endsWith(\"/\") then path.createDirectories else path.createFile`\r\nor something else?",
        "createdAt" : "2019-08-07T06:46:25Z",
        "updatedAt" : "2019-08-07T07:33:22Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "cfc7c2736fc5bb933eebff3ee83d32552074e005",
    "line" : 12,
    "diffHunk" : "@@ -49,25 +49,26 @@ final class FileWatcher(\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesItemsToWatch = new util.ArrayList[Path]()\n     val createdSourceDirectories = new util.ArrayList[AbsolutePath]()\n-    def watch(dir: AbsolutePath, isSourceDirectory: Boolean): Unit = {\n-      if (!dir.isDirectory) {\n-        dir.createDirectories()\n-        if (isSourceDirectory) createdSourceDirectories.add(dir)\n+    def watch(path: AbsolutePath, isSourceItem: Boolean): Unit = {\n+      if (!path.isDirectory && !path.isFile) {"
  },
  {
    "id" : "329c94ad-8557-4e78-bd14-2ecd3bb73ab1",
    "prId" : 855,
    "comments" : [
      {
        "id" : "da4f97e9-b112-4c7f-8bd1-4b21f44cfea4",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "let's hope this won't become a bottleneck",
        "createdAt" : "2019-08-07T07:32:13Z",
        "updatedAt" : "2019-08-07T07:33:22Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dea36821-3df1-457b-949d-3a86b6afea33",
        "parentId" : "da4f97e9-b112-4c7f-8bd1-4b21f44cfea4",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Added a separate file watcher that watches parent dir and filters on the known files.",
        "createdAt" : "2019-08-07T18:00:57Z",
        "updatedAt" : "2019-08-07T18:00:57Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "cfc7c2736fc5bb933eebff3ee83d32552074e005",
    "line" : 17,
    "diffHunk" : "@@ -49,25 +49,26 @@ final class FileWatcher(\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesItemsToWatch = new util.ArrayList[Path]()\n     val createdSourceDirectories = new util.ArrayList[AbsolutePath]()\n-    def watch(dir: AbsolutePath, isSourceDirectory: Boolean): Unit = {\n-      if (!dir.isDirectory) {\n-        dir.createDirectories()\n-        if (isSourceDirectory) createdSourceDirectories.add(dir)\n+    def watch(path: AbsolutePath, isSourceItem: Boolean): Unit = {\n+      if (!path.isDirectory && !path.isFile) {\n+        path.createDirectories()\n+        if (isSourceItem) createdSourceDirectories.add(path)\n       }\n-      directoriesToWatch.add(dir.toNIO)\n+      if (path.isFile) sourcesItemsToWatch.add(path.toNIO.getParent())"
  },
  {
    "id" : "a3f9b0f8-4695-40d2-bbb3-21e29f910674",
    "prId" : 857,
    "comments" : [
      {
        "id" : "39bf3017-99f6-4e1b-a600-80319e57f7f2",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "```suggestion\r\n  class FileListener(watched: Set[Path]) extends DirectoryChangeListener {\r\n```\r\nthis way, we can have `(...) && watched(event.path())` instead of `(...) && files(event.path())`",
        "createdAt" : "2019-08-08T06:27:47Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0dd3eede29c603619dd79001b736615bb5743729",
    "line" : null,
    "diffHunk" : "@@ -37,62 +37,103 @@ final class FileWatcher(\n     didChangeWatchedFiles: DirectoryChangeEvent => Unit\n ) extends Cancelable {\n \n-  private val executor = Executors.newFixedThreadPool(1)\n-  ThreadPools.discardRejectedRunnables(\"FileWatcher.executor\", executor)\n-  private var activeWatcher: Option[DirectoryWatcher] = None\n-  private var watching: CompletableFuture[Void] = new CompletableFuture()\n+  private val directoryExecutor = Executors.newFixedThreadPool(1)\n+  private val fileExecutor = Executors.newFixedThreadPool(1)\n+\n+  ThreadPools.discardRejectedRunnables(\n+    \"FileWatcher.executor\",\n+    directoryExecutor\n+  )\n+  ThreadPools.discardRejectedRunnables(\"FileWatcher.fileExecutor\", fileExecutor)\n+\n+  private var activeDirectoryWatcher: Option[DirectoryWatcher] = None\n+  private var activeFileWatcher: Option[DirectoryWatcher] = None\n+\n+  private var directoryWatching: CompletableFuture[Void] =\n+    new CompletableFuture()\n+  private var fileWatching: CompletableFuture[Void] = new CompletableFuture()\n \n   override def cancel(): Unit = {\n     stopWatching()\n-    executor.shutdown()\n-    activeWatcher.foreach(_.close())\n+    directoryExecutor.shutdown()\n+    fileExecutor.shutdown()\n+    activeDirectoryWatcher.foreach(_.close())\n+    activeFileWatcher.foreach(_.close())\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesDirectoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesFilesToWatch = new util.ArrayList[Path]()\n     val createdSourceDirectories = new util.ArrayList[AbsolutePath]()\n-    def watch(dir: AbsolutePath, isSourceDirectory: Boolean): Unit = {\n-      if (!dir.isDirectory) {\n-        dir.createDirectories()\n-        if (isSourceDirectory) createdSourceDirectories.add(dir)\n+    def watch(path: AbsolutePath, isSource: Boolean): Unit = {\n+      if (!path.isDirectory && !path.isFile) {\n+        val pathToCreate = if (path.isScalaOrJava) {\n+          AbsolutePath(path.toNIO.getParent())\n+        } else {\n+          path\n+        }\n+        pathToCreate.createDirectories()\n+        if (isSource) createdSourceDirectories.add(pathToCreate)\n       }\n-      directoriesToWatch.add(dir.toNIO)\n+      if (path.isScalaOrJava) sourcesFilesToWatch.add(path.toNIO)\n+      else sourcesDirectoriesToWatch.add(path.toNIO)\n     }\n     // Watch the source directories for \"goto definition\" index.\n-    buildTargets.sourceDirectories.foreach(watch(_, isSourceDirectory = true))\n+    buildTargets.sourceItems.foreach(watch(_, isSource = true))\n     buildTargets.scalacOptions.foreach { item =>\n       // Watch META-INF/semanticdb directories for \"find references\" index.\n       watch(\n         item.targetroot.resolve(Directories.semanticdb),\n-        isSourceDirectory = false\n+        isSource = false\n       )\n     }\n-    startWatching(directoriesToWatch)\n+    startWatching(sourcesFilesToWatch, sourcesDirectoriesToWatch)\n     createdSourceDirectories.asScala.foreach(_.delete())\n   }\n \n-  private def startWatching(paths: util.List[Path]): Unit = {\n+  private def startWatching(\n+      files: util.List[Path],\n+      directories: util.List[Path]\n+  ): Unit = {\n     stopWatching()\n-    val watcher = DirectoryWatcher\n+    val directoryWatcher = DirectoryWatcher\n+      .builder()\n+      .paths(directories)\n+      .listener(new DirectoryListener())\n+      .build()\n+    activeDirectoryWatcher = Some(directoryWatcher)\n+    directoryWatching = directoryWatcher.watchAsync(directoryExecutor)\n+\n+    val fileWatcher = DirectoryWatcher\n       .builder()\n-      .paths(paths)\n-      .listener(new Listener)\n+      .paths(files.map(_.getParent()))\n+      .listener(new FileListener(files = files.asScala.toSet))\n       .build()\n-    activeWatcher = Some(watcher)\n-    watching = watcher.watchAsync(executor)\n+    activeFileWatcher = Some(fileWatcher)\n+    fileWatching = fileWatcher.watchAsync(fileExecutor)\n   }\n \n   private def stopWatching(): Unit = {\n-    activeWatcher.foreach(_.close())\n-    watching.cancel(false)\n+    activeDirectoryWatcher.foreach(_.close())\n+    activeFileWatcher.foreach(_.close())\n+    fileWatching.cancel(false)\n+    directoryWatching.cancel(false)\n   }\n \n-  class Listener extends DirectoryChangeListener {\n+  class DirectoryListener extends DirectoryChangeListener {\n     override def onEvent(event: DirectoryChangeEvent): Unit = {\n       if (!Files.isDirectory(event.path())) {\n         didChangeWatchedFiles(event)\n       }\n     }\n   }\n \n+  class FileListener(files: Set[Path]) extends DirectoryChangeListener {"
  },
  {
    "id" : "7b65ff4c-f2d5-46b7-ba98-1afb66f0d997",
    "prId" : 857,
    "comments" : [
      {
        "id" : "aeaaca8d-a311-4821-a661-8575d3772194",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "sourceDirectories\r\n```suggestion\r\n    val sourceDirectoriesToWatch = new util.ArrayList[Path]()\r\n```",
        "createdAt" : "2019-08-08T06:55:33Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "722541d4-6e3a-4e1e-909a-de5ead749f80",
        "parentId" : "aeaaca8d-a311-4821-a661-8575d3772194",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "changed",
        "createdAt" : "2019-08-08T12:31:49Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0dd3eede29c603619dd79001b736615bb5743729",
    "line" : null,
    "diffHunk" : "@@ -37,62 +37,103 @@ final class FileWatcher(\n     didChangeWatchedFiles: DirectoryChangeEvent => Unit\n ) extends Cancelable {\n \n-  private val executor = Executors.newFixedThreadPool(1)\n-  ThreadPools.discardRejectedRunnables(\"FileWatcher.executor\", executor)\n-  private var activeWatcher: Option[DirectoryWatcher] = None\n-  private var watching: CompletableFuture[Void] = new CompletableFuture()\n+  private val directoryExecutor = Executors.newFixedThreadPool(1)\n+  private val fileExecutor = Executors.newFixedThreadPool(1)\n+\n+  ThreadPools.discardRejectedRunnables(\n+    \"FileWatcher.executor\",\n+    directoryExecutor\n+  )\n+  ThreadPools.discardRejectedRunnables(\"FileWatcher.fileExecutor\", fileExecutor)\n+\n+  private var activeDirectoryWatcher: Option[DirectoryWatcher] = None\n+  private var activeFileWatcher: Option[DirectoryWatcher] = None\n+\n+  private var directoryWatching: CompletableFuture[Void] =\n+    new CompletableFuture()\n+  private var fileWatching: CompletableFuture[Void] = new CompletableFuture()\n \n   override def cancel(): Unit = {\n     stopWatching()\n-    executor.shutdown()\n-    activeWatcher.foreach(_.close())\n+    directoryExecutor.shutdown()\n+    fileExecutor.shutdown()\n+    activeDirectoryWatcher.foreach(_.close())\n+    activeFileWatcher.foreach(_.close())\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesDirectoriesToWatch = new util.ArrayList[Path]()"
  },
  {
    "id" : "f7b4f42d-723e-48e3-9e03-d800e59ad796",
    "prId" : 857,
    "comments" : [
      {
        "id" : "83dacdd0-4150-4650-927d-3e9a3b340659",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "```suggestion\r\n    val sourceFilesToWatch = new util.ArrayList[Path]()\r\n```",
        "createdAt" : "2019-08-08T06:55:42Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "84f658b1-6e1c-4e32-a69b-f51472db9bd4",
        "parentId" : "83dacdd0-4150-4650-927d-3e9a3b340659",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "changed",
        "createdAt" : "2019-08-08T12:31:33Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0dd3eede29c603619dd79001b736615bb5743729",
    "line" : null,
    "diffHunk" : "@@ -37,62 +37,103 @@ final class FileWatcher(\n     didChangeWatchedFiles: DirectoryChangeEvent => Unit\n ) extends Cancelable {\n \n-  private val executor = Executors.newFixedThreadPool(1)\n-  ThreadPools.discardRejectedRunnables(\"FileWatcher.executor\", executor)\n-  private var activeWatcher: Option[DirectoryWatcher] = None\n-  private var watching: CompletableFuture[Void] = new CompletableFuture()\n+  private val directoryExecutor = Executors.newFixedThreadPool(1)\n+  private val fileExecutor = Executors.newFixedThreadPool(1)\n+\n+  ThreadPools.discardRejectedRunnables(\n+    \"FileWatcher.executor\",\n+    directoryExecutor\n+  )\n+  ThreadPools.discardRejectedRunnables(\"FileWatcher.fileExecutor\", fileExecutor)\n+\n+  private var activeDirectoryWatcher: Option[DirectoryWatcher] = None\n+  private var activeFileWatcher: Option[DirectoryWatcher] = None\n+\n+  private var directoryWatching: CompletableFuture[Void] =\n+    new CompletableFuture()\n+  private var fileWatching: CompletableFuture[Void] = new CompletableFuture()\n \n   override def cancel(): Unit = {\n     stopWatching()\n-    executor.shutdown()\n-    activeWatcher.foreach(_.close())\n+    directoryExecutor.shutdown()\n+    fileExecutor.shutdown()\n+    activeDirectoryWatcher.foreach(_.close())\n+    activeFileWatcher.foreach(_.close())\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesDirectoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesFilesToWatch = new util.ArrayList[Path]()"
  },
  {
    "id" : "197e9ebf-f634-4010-8d83-0af046d74e41",
    "prId" : 857,
    "comments" : [
      {
        "id" : "b392bd56-b955-46ff-920d-877134a01d18",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "please, add a comment that we create those paths just to get a notification they don't exist",
        "createdAt" : "2019-08-08T06:56:56Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "89b3f78a-e473-45f2-8689-1f039a70dfe0",
        "parentId" : "b392bd56-b955-46ff-920d-877134a01d18",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "added",
        "createdAt" : "2019-08-08T12:31:23Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0dd3eede29c603619dd79001b736615bb5743729",
    "line" : 44,
    "diffHunk" : "@@ -37,62 +37,103 @@ final class FileWatcher(\n     didChangeWatchedFiles: DirectoryChangeEvent => Unit\n ) extends Cancelable {\n \n-  private val executor = Executors.newFixedThreadPool(1)\n-  ThreadPools.discardRejectedRunnables(\"FileWatcher.executor\", executor)\n-  private var activeWatcher: Option[DirectoryWatcher] = None\n-  private var watching: CompletableFuture[Void] = new CompletableFuture()\n+  private val directoryExecutor = Executors.newFixedThreadPool(1)\n+  private val fileExecutor = Executors.newFixedThreadPool(1)\n+\n+  ThreadPools.discardRejectedRunnables(\n+    \"FileWatcher.executor\",\n+    directoryExecutor\n+  )\n+  ThreadPools.discardRejectedRunnables(\"FileWatcher.fileExecutor\", fileExecutor)\n+\n+  private var activeDirectoryWatcher: Option[DirectoryWatcher] = None\n+  private var activeFileWatcher: Option[DirectoryWatcher] = None\n+\n+  private var directoryWatching: CompletableFuture[Void] =\n+    new CompletableFuture()\n+  private var fileWatching: CompletableFuture[Void] = new CompletableFuture()\n \n   override def cancel(): Unit = {\n     stopWatching()\n-    executor.shutdown()\n-    activeWatcher.foreach(_.close())\n+    directoryExecutor.shutdown()\n+    fileExecutor.shutdown()\n+    activeDirectoryWatcher.foreach(_.close())\n+    activeFileWatcher.foreach(_.close())\n   }\n \n   def restart(): Unit = {\n-    val directoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesDirectoriesToWatch = new util.ArrayList[Path]()\n+    val sourcesFilesToWatch = new util.ArrayList[Path]()\n     val createdSourceDirectories = new util.ArrayList[AbsolutePath]()\n-    def watch(dir: AbsolutePath, isSourceDirectory: Boolean): Unit = {\n-      if (!dir.isDirectory) {\n-        dir.createDirectories()\n-        if (isSourceDirectory) createdSourceDirectories.add(dir)\n+    def watch(path: AbsolutePath, isSource: Boolean): Unit = {\n+      if (!path.isDirectory && !path.isFile) {"
  },
  {
    "id" : "f7530bc5-d839-4bb6-85ef-911630b11973",
    "prId" : 935,
    "comments" : [
      {
        "id" : "b398c238-74ef-4e49-82bd-76de02546b76",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "could you add a comment inthe code why this change is important?",
        "createdAt" : "2019-10-14T10:43:20Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f9ca42b5-3285-4c22-86a6-d0c2515bab0d",
        "parentId" : "b398c238-74ef-4e49-82bd-76de02546b76",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "File hashing was taking up to seven minutes for me while trying out this PR on a larger codebase. \r\n\r\nPlease wait for when I request a review before making more comments, I will try to clean up the implementation and separate independent changes toÂ isolated PRs. ",
        "createdAt" : "2019-10-20T09:46:18Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -93,30 +97,20 @@ final class FileWatcher(\n         )\n       }\n     }\n-    startWatching(sourceFilesToWatch, sourceDirectoriesToWatch)\n+    startWatching(new ju.ArrayList(sourceDirectoriesToWatch))\n     createdSourceDirectories.asScala.foreach(_.delete())\n   }\n \n-  private def startWatching(\n-      files: util.List[Path],\n-      directories: util.List[Path]\n-  ): Unit = {\n+  private def startWatching(directories: util.List[Path]): Unit = {\n     stopWatching()\n     val directoryWatcher = DirectoryWatcher\n       .builder()\n       .paths(directories)\n       .listener(new DirectoryListener())\n+      .fileHashing(false)"
  },
  {
    "id" : "3b5c20bf-d112-4db9-b587-68dfbd87626b",
    "prId" : 1145,
    "comments" : [
      {
        "id" : "b9e983b6-f94f-4bb0-a7e8-ea2493fdfaeb",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "can you explain more why it can happen and why it is of no consequence?",
        "createdAt" : "2019-12-04T19:13:01Z",
        "updatedAt" : "2019-12-05T11:14:30Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "91d42e7e-c55a-4d89-988a-de81ff0c6aa0",
        "parentId" : "b9e983b6-f94f-4bb0-a7e8-ea2493fdfaeb",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I added a comment\r\n\r\n>      // safe to ignore because we're closing the file watcher and\r\n>      // this error won't affect correctness of Metals.",
        "createdAt" : "2019-12-05T10:28:33Z",
        "updatedAt" : "2019-12-05T11:14:30Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c032fa899f1747d53cf2025b6e1cf03227b19980",
    "line" : null,
    "diffHunk" : "@@ -93,34 +100,31 @@ final class FileWatcher(\n         )\n       }\n     }\n-    startWatching(sourceFilesToWatch, sourceDirectoriesToWatch)\n-    createdSourceDirectories.asScala.foreach(_.delete())\n+    startWatching(new ju.ArrayList(sourceDirectoriesToWatch))\n+    createdSourceDirectories.asScala.foreach { dir =>\n+      if (dir.isEmptyDirectory) {\n+        dir.delete()\n+      }\n+    }\n   }\n \n-  private def startWatching(\n-      files: util.List[Path],\n-      directories: util.List[Path]\n-  ): Unit = {\n+  private def startWatching(directories: util.List[Path]): Unit = {\n     stopWatching()\n     val directoryWatcher = DirectoryWatcher\n       .builder()\n       .paths(directories)\n       .listener(new DirectoryListener())\n+      .fileHashing(false)\n       .build()\n     activeDirectoryWatcher = Some(directoryWatcher)\n     directoryWatching = directoryWatcher.watchAsync(directoryExecutor)\n-\n-    val fileWatcher = DirectoryWatcher\n-      .builder()\n-      .paths(files.map(_.getParent()))\n-      .listener(new FileListener(watched = files.asScala.toSet))\n-      .build()\n-    activeFileWatcher = Some(fileWatcher)\n-    fileWatching = fileWatcher.watchAsync(fileExecutor)\n   }\n \n   private def stopWatching(): Unit = {\n-    activeDirectoryWatcher.foreach(_.close())\n+    try activeDirectoryWatcher.foreach(_.close())\n+    catch {\n+      case _: ju.ConcurrentModificationException => // ignore, can happen"
  },
  {
    "id" : "9a1f3d62-37e3-43f3-8e7d-b4deb39c02f4",
    "prId" : 1435,
    "comments" : [
      {
        "id" : "c3c53aa6-6604-4aa9-af64-8dd2f29343b1",
        "parentId" : null,
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "we could add a comment why it has dedicated branch that is doing the same logic.",
        "createdAt" : "2020-02-17T13:01:21Z",
        "updatedAt" : "2020-02-17T16:18:06Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dfeddeda-2be2-46f9-ad6b-b1564709495c",
        "parentId" : "c3c53aa6-6604-4aa9-af64-8dd2f29343b1",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "added",
        "createdAt" : "2020-02-17T14:48:30Z",
        "updatedAt" : "2020-02-17T16:18:06Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "fb025d5358f8296b853bbb7ede33b89e75356b35",
    "line" : 54,
    "diffHunk" : "@@ -129,22 +123,14 @@ final class FileWatcher(\n       // this error won't affect correctness of Metals.\n       case _: ju.ConcurrentModificationException =>\n     }\n-    activeFileWatcher.foreach(_.close())\n-    fileWatching.cancel(false)\n     directoryWatching.cancel(false)\n   }\n \n   class DirectoryListener extends DirectoryChangeListener {\n     override def onEvent(event: DirectoryChangeEvent): Unit = {\n-      if (!Files.isDirectory(event.path())) {\n+      if (event.eventType() == EventType.OVERFLOW) {"
  },
  {
    "id" : "b391cbd4-7902-4408-8bca-928647a07f0d",
    "prId" : 1629,
    "comments" : [
      {
        "id" : "132a3f34-0d5f-45a0-8f94-e1c5c8ab18ed",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe we could instead of modifying `createDirectories` just inline the modified method here? I wouldn't add the additional logic to `MetalsEnrichments`'s `createDirectories`, since it's used in many places and in most cases not needed.\r\n",
        "createdAt" : "2020-04-16T13:58:34Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ba6c0600-eff9-4d6f-9bf4-f062a8156304",
        "parentId" : "132a3f34-0d5f-45a0-8f94-e1c5c8ab18ed",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "you prefer to have a separate method that takes a path and getAllAbsolutePathToCreate? \r\n\r\nWe can add tests to make sure that the old an new version of createDirectories have the same behavior? ",
        "createdAt" : "2020-04-16T14:15:27Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "96c99b6d-cddd-4f96-8433-9b2c0b945b81",
        "parentId" : "132a3f34-0d5f-45a0-8f94-e1c5c8ab18ed",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I would prefer a separate method for sure. I believe it could be added here, I don't think it's something we will use besides this case.\r\n\r\nNo need to add additional tests. I just think it will be more optimized to create all dirs at the same time by default. Usually it's a single filesystem operation.",
        "createdAt" : "2020-04-16T14:24:43Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a8c2cafc-51cf-47df-9dfc-3c9274c9dbeb",
        "parentId" : "132a3f34-0d5f-45a0-8f94-e1c5c8ab18ed",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "It's not. The implementation creates all nonexistent parent directories first. ",
        "createdAt" : "2020-04-16T14:43:04Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0b15fe8f-9ba3-4462-b5ce-0d1a2eef251d",
        "parentId" : "132a3f34-0d5f-45a0-8f94-e1c5c8ab18ed",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "That's right, that's why I think it's better to use the new more complicated method only in case of the FileWatcher.",
        "createdAt" : "2020-04-16T16:31:43Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "02befa0f-fc3b-48c3-be8d-7656705fb8c5",
        "parentId" : "132a3f34-0d5f-45a0-8f94-e1c5c8ab18ed",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Ok, I actually misunderstood. You meant that Java implementation is doing the same as the new here. We can leave it then. ",
        "createdAt" : "2020-04-16T17:27:27Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "11a3ce5f2d61d4805920381b556695ad432792e5",
    "line" : null,
    "diffHunk" : "@@ -67,11 +67,13 @@ final class FileWatcher(\n         } else {\n           path\n         }\n-        pathToCreate.createDirectories()\n+        val createdPaths = pathToCreate.createDirectories()"
  },
  {
    "id" : "30c64da9-c330-477c-ba21-edebfacc23d7",
    "prId" : 1629,
    "comments" : [
      {
        "id" : "08d898f6-73dc-4b3e-9aaa-53c9e61f9314",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could you add a comment on why you need to sort and reverse it? It took me a while to realize what's going on.",
        "createdAt" : "2020-04-16T14:06:49Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f2be2e30-fa4b-44f8-b786-e596137cad68",
        "parentId" : "08d898f6-73dc-4b3e-9aaa-53c9e61f9314",
        "author" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "body" : "you're right. In fact we need to delete all children before parent paths.",
        "createdAt" : "2020-04-16T14:10:07Z",
        "updatedAt" : "2020-04-17T10:03:37Z",
        "lastEditedBy" : {
          "login" : "mlachkar",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/7843237?u=d2941da73011b9a49767ac863ce5bc20b7b10ed7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "11a3ce5f2d61d4805920381b556695ad432792e5",
    "line" : 22,
    "diffHunk" : "@@ -95,7 +97,7 @@ final class FileWatcher(\n       }\n     }\n     startWatching(new ju.ArrayList(sourceDirectoriesToWatch))\n-    createdSourceDirectories.asScala.foreach { dir =>\n+    createdSourceDirectories.asScala.sortBy(_.toNIO).reverse.foreach { dir =>"
  },
  {
    "id" : "48e73c7f-976b-473f-9997-49aa4b4be391",
    "prId" : 2014,
    "comments" : [
      {
        "id" : "4d903538-68e4-4448-b9bf-88ccd7d1e145",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Checked locally on Linux - Ubuntu and it seems that it doesn't work unless I create the directory with:\r\n`targetroot.resolve(Directories.semanticdb).createDirectories()`\r\nany idea why that might be?\r\n\r\n",
        "createdAt" : "2020-08-21T10:30:34Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "11a2f8e6-4b70-4e2d-b9a8-0c4d3f7fc00a",
        "parentId" : "4d903538-68e4-4448-b9bf-88ccd7d1e145",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "So maybe we could just revert the change with creating the non existing directories?",
        "createdAt" : "2020-08-21T10:37:00Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8fb0e5fa-79b0-4193-bc5c-019a71e1fb55",
        "parentId" : "4d903538-68e4-4448-b9bf-88ccd7d1e145",
        "author" : {
          "login" : "eatkins",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "body" : "Yeah, I reverted this part of the change and tests look like they will pass. I had assumed that the only reason for the directory creation was to make watch work. From the perspective of the swoval file tree repository, no directory creation should be necessary to detect changes in directories that don't exist at registration time. It seems like ideally we would document why the directories need to be created or create them closer to the code that actually relies on their creation.",
        "createdAt" : "2020-08-21T16:19:53Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "eatkins",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e209ff5b-d727-43d1-9147-f055d3ca5fa3",
        "parentId" : "4d903538-68e4-4448-b9bf-88ccd7d1e145",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "They were actually being created just for directory watching, but we are not getting any updates if it's not created here either.\r\n\r\n> From the perspective of the swoval file tree repository, no directory creation should be necessary to detect changes in directories that don't exist at registration time.\r\n\r\nMight it be a bug on Linux/Ubuntu ?",
        "createdAt" : "2020-08-21T16:48:59Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13192ebb3ddfb265aceb4225904caf6a57ae07e0",
    "line" : null,
    "diffHunk" : "@@ -91,117 +94,32 @@ final class FileWatcher(\n       }\n     }\n     // Watch the source directories for \"goto definition\" index.\n-    buildTargets.sourceRoots.foreach(watch(_, isSource = true))\n-    buildTargets.sourceItems.foreach(watch(_, isSource = true))\n+    buildTargets.sourceRoots.foreach(watch)\n+    buildTargets.sourceItems.foreach(watch)\n     buildTargets.scalacOptions.foreach { item =>\n       for {\n         scalaInfo <- buildTargets.scalaInfo(item.getTarget)\n       } {\n         val targetroot = item.targetroot(scalaInfo.getScalaVersion)\n         if (!targetroot.isJar) {\n           // Watch META-INF/semanticdb directories for \"find references\" index.\n-          watch(\n-            targetroot.resolve(Directories.semanticdb),\n-            isSource = false\n-          )\n+          watch(targetroot.resolve(Directories.semanticdb))"
  },
  {
    "id" : "a8345ec9-b6b2-429c-8b44-bf0045381369",
    "prId" : 2014,
    "comments" : [
      {
        "id" : "bdf0ddb2-6a12-46c7-8419-161fcd0ce024",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe we could change it to :\r\n`@volatile private var repository: Option[FileTreeRepository[HashCode]] = None`\r\n?",
        "createdAt" : "2020-08-21T10:39:23Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "68d24ff5-9502-4abf-abba-af7dfeda0e80",
        "parentId" : "bdf0ddb2-6a12-46c7-8419-161fcd0ce024",
        "author" : {
          "login" : "eatkins",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "body" : "This is obviously a coding preference thing but I prefer using `AtomicReference` to the `var foo: Option[X] = None` pattern. I know that using null is often considered an anti-pattern in scala but I find that atomic references work really nicely. They force you to think about the state of the variable more than a var does because you can't simply dereference it like a var, you have to call `get` on it. This makes me think more about the control flow that leads to the call to `get` and what state I expect the variable to be in which I find helpful for mutable references. Of course it could be `AtomicReference[Option[FileTreeRepository[HashCode]]]` to avoid null handling but I like avoiding unnecessary boxing where possible.\r\n\r\nThat being said, this is just my personal stylistic preference and isn't important to this particular change set so if you would feel more comfortable with a `var`, I'll make that change.",
        "createdAt" : "2020-08-21T16:07:11Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "eatkins",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/2658825?u=8ff05fe0cc4369d7c79d2521ef29f314e11445c2&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "03bfe6f0-69f4-4070-ad31-09ad90a7fe29",
        "parentId" : "bdf0ddb2-6a12-46c7-8419-161fcd0ce024",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Both are really not ideal. We can leave as is, thanks!",
        "createdAt" : "2020-08-21T16:46:21Z",
        "updatedAt" : "2020-08-22T03:26:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "13192ebb3ddfb265aceb4225904caf6a57ae07e0",
    "line" : 84,
    "diffHunk" : "@@ -42,46 +45,46 @@ final class FileWatcher(\n     buildTargets: BuildTargets,\n     didChangeWatchedFiles: DirectoryChangeEvent => Unit\n ) extends Cancelable {\n-\n-  private val directoryExecutor = Executors.newFixedThreadPool(1)\n-  private val fileExecutor = Executors.newFixedThreadPool(1)\n-\n-  ThreadPools.discardRejectedRunnables(\n-    \"FileWatcher.executor\",\n-    directoryExecutor\n-  )\n-  ThreadPools.discardRejectedRunnables(\n-    \"FileWatcher.fileExecutor\",\n-    fileExecutor\n-  )\n-\n-  private var activeWatchers: Option[Watchers] = None\n+  private def newRepository: FileTreeRepository[HashCode] = {\n+    val hasher = FileHasher.DEFAULT_FILE_HASHER\n+    val converter: Converter[HashCode] = (path: TypedPath) =>\n+      try hasher.hash(path.getPath)\n+      catch { case _: IOException => HashCode.empty() }\n+    val repo = FileTreeRepositories.get(converter, /*follow symlinks*/ true)\n+    def entryToEvent(kind: EventType, entry: Entry[_]): DirectoryChangeEvent =\n+      new DirectoryChangeEvent(kind, entry.getTypedPath.getPath, 1)\n+    repo.addCacheObserver(new CacheObserver[HashCode] {\n+      override def onCreate(entry: Entry[HashCode]): Unit = {\n+        didChangeWatchedFiles(entryToEvent(EventType.CREATE, entry))\n+      }\n+      override def onDelete(entry: Entry[HashCode]): Unit = {\n+        didChangeWatchedFiles(entryToEvent(EventType.DELETE, entry))\n+      }\n+      override def onUpdate(\n+          previous: Entry[HashCode],\n+          current: Entry[HashCode]\n+      ): Unit = {\n+        if (previous.getValue != current.getValue) {\n+          didChangeWatchedFiles(entryToEvent(EventType.MODIFY, current))\n+        }\n+      }\n+      override def onError(ex: IOException) = {}\n+    })\n+    repo\n+  }\n+  private val repository = new AtomicReference[FileTreeRepository[HashCode]]\n \n   override def cancel(): Unit = {\n-    stopWatching()\n-    directoryExecutor.shutdown()\n-    activeWatchers.foreach(_.close())\n+    repository.getAndSet(null) match {\n+      case null =>"
  }
]