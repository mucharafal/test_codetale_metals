[
  {
    "id" : "70c31d46-f234-4cc2-81d8-1bf3be582ee8",
    "prId" : 934,
    "comments" : [
      {
        "id" : "e5ac5853-7bdb-41c5-9e88-afa880b91e39",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "would this save us a new line?\r\n```private val implementations = TrieMap.empty[String, Set[ClassLocation]]```",
        "createdAt" : "2019-09-19T14:57:15Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "763f4cdc-8763-4e6f-8ecb-5d30df074d2b",
        "parentId" : "e5ac5853-7bdb-41c5-9e88-afa880b91e39",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Switched to concurrentHashMap in case we ever run indexing multithreaded. \r\n",
        "createdAt" : "2019-09-19T21:28:02Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3fb388c4-7fb0-425d-8de7-d85f0f33169a",
        "parentId" : "e5ac5853-7bdb-41c5-9e88-afa880b91e39",
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "isn't a TrieMap (from `scala.collection.concurrent`) already thread-safe?",
        "createdAt" : "2019-09-19T22:00:16Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fe9a9977-9632-4221-98a1-bfafb0aa8628",
        "parentId" : "e5ac5853-7bdb-41c5-9e88-afa880b91e39",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "`TrieMap` is already thread safe. ",
        "createdAt" : "2019-09-20T09:12:13Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2cdba38f-b4c0-4735-a708-35dff5d2579c",
        "parentId" : "e5ac5853-7bdb-41c5-9e88-afa880b91e39",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "It doesn't have the compute method though, which I am using here.",
        "createdAt" : "2019-09-20T09:16:47Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] ="
  },
  {
    "id" : "91cdd19f-c6f5-44fe-93f7-24789aef29bf",
    "prId" : 934,
    "comments" : [
      {
        "id" : "ecdb5a34-feca-4a90-9409-b9e268d627ba",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "how about `clear` or `invalidate`? Those are used for similar actions in the project already",
        "createdAt" : "2019-09-19T14:58:17Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {"
  },
  {
    "id" : "c0245d79-4088-400a-8383-b7ca5f53dd60",
    "prId" : 934,
    "comments" : [
      {
        "id" : "3340bdce-4837-4a55-9892-5826d33e5339",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "maybe implementation**s** since there can be more than one?",
        "createdAt" : "2019-09-19T14:58:55Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementation(params: TextDocumentPositionParams): List[Location] = {"
  },
  {
    "id" : "1aee029a-da9e-4f11-bafe-be7847ad1067",
    "prId" : 934,
    "comments" : [
      {
        "id" : "d74de0eb-aa0a-4891-b235-3cb3cac70da1",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "`defn` -> `impl` ?",
        "createdAt" : "2019-09-19T15:00:01Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementation(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      defn <- findImplementation(occ.symbol)"
  },
  {
    "id" : "7d8685dc-ee4b-4f3c-8c62-a9053a103c97",
    "prId" : 934,
    "comments" : [
      {
        "id" : "093d5b9e-691e-4f0b-9135-b727d6573b61",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "maybe we could use `getOrDefault(symbol, Set.empty)` to simplify the logic? \r\n\r\n```scala\r\nimplementations.getOrDefault(symbol, Set.empty).flatMap { implementation =>\r\n  implementation ++ findAllImpl(implementation.symbol.symbol)\r\n}",
        "createdAt" : "2019-09-19T15:07:48Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "66ae82cf-bacb-4602-836b-c256cefb8bda",
        "parentId" : "093d5b9e-691e-4f0b-9135-b727d6573b61",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "A bit different, but now it takes up less code.",
        "createdAt" : "2019-09-19T21:28:45Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementation(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      defn <- findImplementation(occ.symbol)\n+      range <- defn.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(defn.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      implementations.get(symbol) match {"
  },
  {
    "id" : "295cc5b4-8527-4f4a-90df-dcfed0623c9b",
    "prId" : 934,
    "comments" : [
      {
        "id" : "6b65c61c-ac8b-48aa-88f3-e236f777ea3c",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "can a loc.symbol.symbol be equal to `symbol` the parameter? If yes, then that would be an infinite loop",
        "createdAt" : "2019-09-19T15:08:27Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6a5c43b7-dce9-4db5-b0fe-77cf5c02c008",
        "parentId" : "6b65c61c-ac8b-48aa-88f3-e236f777ea3c",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We only get a loop if class hierachies create a loop which I don't think is possible.",
        "createdAt" : "2019-09-19T15:26:23Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c7ba5165-6ad7-4d15-84c7-e6c26e7ff3f4",
        "parentId" : "6b65c61c-ac8b-48aa-88f3-e236f777ea3c",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Anyway loc.symbol can't be equal to symbol since their relation is `extends` and `A extends A` is not possible",
        "createdAt" : "2019-09-19T20:13:30Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementation(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      defn <- findImplementation(occ.symbol)\n+      range <- defn.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(defn.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      implementations.get(symbol) match {\n+        case None => Set.empty\n+        case Some(set) =>\n+          set ++ set\n+            .flatMap(\n+              loc => findAllImpl(loc.symbol.symbol)"
  },
  {
    "id" : "4aedd662-2bcd-45bb-90c2-813c9cf25648",
    "prId" : 934,
    "comments" : [
      {
        "id" : "a398d064-12f3-4d8e-8b75-6d1ba814b8fa",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "making the set in `implementations` mutable would simplify the logic as long as those sets remain \"in scope\" of this provider.",
        "createdAt" : "2019-09-19T15:12:48Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f228c193-c80f-4ba4-b69c-f37231e53c4e",
        "parentId" : "a398d064-12f3-4d8e-8b75-6d1ba814b8fa",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't think this will change much, one line less and I prefer using immutable sets there. Will refactor the logic there though.",
        "createdAt" : "2019-09-19T20:30:01Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b8a1eebc-0783-4b1a-9e54-3aa82231f8a6",
        "parentId" : "a398d064-12f3-4d8e-8b75-6d1ba814b8fa",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Changed to ConcurrentHashMap and switched to `compute` I will leace the immutable set.",
        "createdAt" : "2019-09-19T21:29:37Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementation(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      defn <- findImplementation(occ.symbol)\n+      range <- defn.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(defn.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      implementations.get(symbol) match {\n+        case None => Set.empty\n+        case Some(set) =>\n+          set ++ set\n+            .flatMap(\n+              loc => findAllImpl(loc.symbol.symbol)\n+            )\n+      }\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  def onChange(docs: TextDocuments): Unit = {\n+    docs.documents.foreach { doc =>\n+      doc.symbols.foreach { thisSymbol =>\n+        thisSymbol.signature match {\n+          case ClassSignature(typeParameters, parents, self, declarations) =>\n+            parents.collect {\n+              case TypeRef(_, symbol, _) =>\n+                doc.occurrences\n+                  .find(\n+                    occ =>\n+                      occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+                  )\n+                  .foreach { occ =>\n+                    val children ="
  },
  {
    "id" : "6498602d-e5ee-4f06-ac6c-33a847b9cbb2",
    "prId" : 934,
    "comments" : [
      {
        "id" : "f39d1a39-9f4e-4e39-b4fb-d2f7ad1e5176",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "Just my purism kicks in:\r\n```suggestion\r\n  private case class ClassLocation(symbol: SymbolOccurrence, uri: String)\r\n```",
        "createdAt" : "2019-09-19T15:14:46Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,87 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.collection.concurrent.TrieMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations: TrieMap[String, Set[ClassLocation]] =\n+    TrieMap.empty\n+\n+  def reset(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementation(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      defn <- findImplementation(occ.symbol)\n+      range <- defn.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(defn.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      implementations.get(symbol) match {\n+        case None => Set.empty\n+        case Some(set) =>\n+          set ++ set\n+            .flatMap(\n+              loc => findAllImpl(loc.symbol.symbol)\n+            )\n+      }\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  def onChange(docs: TextDocuments): Unit = {\n+    docs.documents.foreach { doc =>\n+      doc.symbols.foreach { thisSymbol =>\n+        thisSymbol.signature match {\n+          case ClassSignature(typeParameters, parents, self, declarations) =>\n+            parents.collect {\n+              case TypeRef(_, symbol, _) =>\n+                doc.occurrences\n+                  .find(\n+                    occ =>\n+                      occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+                  )\n+                  .foreach { occ =>\n+                    val children =\n+                      implementations.getOrElse(symbol, Set.empty)\n+                    implementations.put(\n+                      symbol,\n+                      children + ClassLocation(occ, doc.uri)\n+                    )\n+                  }\n+            }\n+          case _ =>\n+        }\n+      }\n+    }\n+  }\n+\n+  case class ClassLocation(symbol: SymbolOccurrence, uri: String)"
  },
  {
    "id" : "63af2445-c158-489c-b78a-6615740525bf",
    "prId" : 934,
    "comments" : [
      {
        "id" : "a0ad4f21-26ed-40c5-92bb-880090831382",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nit: I personally think for comprehensions make it easier to read what's going on\r\n```suggestion\r\nfor {\r\n  doc <- docs.documents.iterator\r\n  thisSymbol <- doc.symbols.iterator\r\n  occ <- doc.occurrences.iterator.find(occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition)\r\n} {\r\n  addFromSignature(thisSymbol.signature, occ, doc)\r\n}\r\n```\r\n",
        "createdAt" : "2019-09-20T09:25:08Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5cf19d60-7746-49d5-bb9b-1d7cf5b0d20a",
        "parentId" : "a0ad4f21-26ed-40c5-92bb-880090831382",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Fixed",
        "createdAt" : "2019-09-20T15:08:27Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]\n+\n+  def clear(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      impl <- findImplementation(occ.symbol)\n+      range <- impl.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(impl.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  def onChange(docs: TextDocuments): Unit = {\n+    docs.documents.foreach { doc =>"
  },
  {
    "id" : "ad1b87d2-0497-4a11-aec2-49fcfaed3443",
    "prId" : 934,
    "comments" : [
      {
        "id" : "6067b236-1156-46b5-b951-315ec1fdb33b",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "maybe we could use \r\n```scala\r\ncase sig: ClassSignature => \r\n  (...)\r\n```\r\n\r\nand use field accessors instead?",
        "createdAt" : "2019-09-20T09:25:30Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]\n+\n+  def clear(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      impl <- findImplementation(occ.symbol)\n+      range <- impl.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(impl.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  def onChange(docs: TextDocuments): Unit = {\n+    docs.documents.foreach { doc =>\n+      doc.symbols.foreach { thisSymbol =>\n+        doc.occurrences\n+          .find(\n+            occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+          )\n+          .foreach(occ => addFromSignature(thisSymbol.signature, occ, doc))\n+      }\n+    }\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = implementations.getOrDefault(symbol, Set.empty)\n+      directImpl ++ directImpl\n+        .flatMap(\n+          loc => findAllImpl(loc.symbol.symbol)\n+        )\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  private def addFromSignature(\n+      signature: Signature,\n+      occ: SymbolOccurrence,\n+      doc: TextDocument\n+  ): Unit = {\n+    signature match {\n+      case ClassSignature("
  },
  {
    "id" : "dbadc7ae-e92b-464c-ae2e-33ac0ef067a2",
    "prId" : 934,
    "comments" : [
      {
        "id" : "23d15349-0ec0-4d2b-a3dc-d8c2174314f7",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nit: I generally avoid binding variable names that are unused, I find this easier to read\r\n```suggestion\r\n      case c: ClassSignature => c.parents.collect { ... }\r\n```",
        "createdAt" : "2019-09-20T09:26:21Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "97957ec8-1db8-4d22-916b-4f94830aeb35",
        "parentId" : "23d15349-0ec0-4d2b-a3dc-d8c2174314f7",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Done",
        "createdAt" : "2019-09-20T15:08:35Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]\n+\n+  def clear(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      impl <- findImplementation(occ.symbol)\n+      range <- impl.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(impl.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  def onChange(docs: TextDocuments): Unit = {\n+    docs.documents.foreach { doc =>\n+      doc.symbols.foreach { thisSymbol =>\n+        doc.occurrences\n+          .find(\n+            occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+          )\n+          .foreach(occ => addFromSignature(thisSymbol.signature, occ, doc))\n+      }\n+    }\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = implementations.getOrDefault(symbol, Set.empty)\n+      directImpl ++ directImpl\n+        .flatMap(\n+          loc => findAllImpl(loc.symbol.symbol)\n+        )\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  private def addFromSignature(\n+      signature: Signature,\n+      occ: SymbolOccurrence,\n+      doc: TextDocument\n+  ): Unit = {\n+    signature match {\n+      case ClassSignature("
  },
  {
    "id" : "3b46c23c-2f43-4860-b4c9-5a8537889d8e",
    "prId" : 934,
    "comments" : [
      {
        "id" : "da345c62-f469-4e2d-8273-31d5b82f4ecd",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "```suggestion\r\n  private case class ClassLocation(symbol: SymbolOccurrence, path: java.nio.file.Path)\r\n```\r\n\r\nWherever possible I prefer nio `Path` because they have a small memory footprint.",
        "createdAt" : "2019-09-20T09:40:15Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c8632fee-3642-40de-bc65-690ec2ea01a2",
        "parentId" : "da345c62-f469-4e2d-8273-31d5b82f4ecd",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Changed to Path",
        "createdAt" : "2019-09-20T15:09:14Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]\n+\n+  def clear(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      impl <- findImplementation(occ.symbol)\n+      range <- impl.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)\n+      path = workspace.toNIO.resolve(Paths.get(impl.uri))\n+      uri = path.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  def onChange(docs: TextDocuments): Unit = {\n+    docs.documents.foreach { doc =>\n+      doc.symbols.foreach { thisSymbol =>\n+        doc.occurrences\n+          .find(\n+            occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+          )\n+          .foreach(occ => addFromSignature(thisSymbol.signature, occ, doc))\n+      }\n+    }\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = implementations.getOrDefault(symbol, Set.empty)\n+      directImpl ++ directImpl\n+        .flatMap(\n+          loc => findAllImpl(loc.symbol.symbol)\n+        )\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  private def addFromSignature(\n+      signature: Signature,\n+      occ: SymbolOccurrence,\n+      doc: TextDocument\n+  ): Unit = {\n+    signature match {\n+      case ClassSignature(\n+          typeParameters,\n+          parents,\n+          self,\n+          declarations\n+          ) =>\n+        parents.collect {\n+          case TypeRef(_, symbol, _) =>\n+            val loc = ClassLocation(occ, doc.uri)\n+            implementations.compute(symbol, { (_, set) =>\n+              if (set == null) Set(loc)\n+              else set + loc\n+            })\n+        }\n+      case _ =>\n+    }\n+  }\n+\n+  private case class ClassLocation(symbol: SymbolOccurrence, uri: String)"
  },
  {
    "id" : "edc43c1c-cc89-4c8d-9445-2616b274a352",
    "prId" : 934,
    "comments" : [
      {
        "id" : "395fafe0-4631-4acf-9cbe-1c8754dbfbf5",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think you need to use a custom `positionOccurrence` for the file where the `impl` symbol is defined. The test cases don't seem to stress the situation when there are multiple source files. It would also be good to have a test case with multiple projects, although I don't think the current implementation has issues with that it will become more relevant as we add `implementation` for methods.",
        "createdAt" : "2019-09-20T09:44:00Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3c86bfdc-290a-4bd7-84c4-0bb80a673729",
        "parentId" : "395fafe0-4631-4acf-9cbe-1c8754dbfbf5",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Right, I started looking at that and will for sure need to add test cases with multiple files. Right now I don't think it's really needed, but I can add that nonetheless.",
        "createdAt" : "2019-09-20T09:53:25Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e38c65ee-62cb-4673-8eaf-324e5a9555e0",
        "parentId" : "395fafe0-4631-4acf-9cbe-1c8754dbfbf5",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Actually, I was all wrong :O After adding the multiple files suite, I found the issue you were talking about",
        "createdAt" : "2019-09-20T13:57:10Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,90 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]\n+\n+  def clear(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      impl <- findImplementation(occ.symbol)\n+      range <- impl.symbol.range\n+      revised <- positionOccurrence.distance.toRevised(range.toLSP)"
  },
  {
    "id" : "98ec2fdc-1372-43f2-9b21-95f5916e9a5f",
    "prId" : 934,
    "comments" : [
      {
        "id" : "2cd213b1-9134-42b4-9a17-0f63c3d3d845",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "The `impl.uri` file may no longer exist since the index doesn't clean up stale data.",
        "createdAt" : "2019-09-20T09:44:42Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d56f5d2b-450f-480d-9163-4a6377ffb852",
        "parentId" : "2cd213b1-9134-42b4-9a17-0f63c3d3d845",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Fixed and tested.",
        "createdAt" : "2019-09-20T15:10:39Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,90 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]\n+\n+  def clear(): Unit = {\n+    implementations.clear()\n+  }\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+    val result = semanticdbs.textDocument(source)\n+    for {\n+      doc <- result.documentIncludingStale.toList\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        doc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      impl <- findImplementation(occ.symbol)"
  },
  {
    "id" : "2e2ffef2-a687-4d8b-a300-d072058834ce",
    "prId" : 934,
    "comments" : [
      {
        "id" : "93993a1b-8659-4404-92c2-16ba0cf30add",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Would it be possible to use an index that is shaped something like this `Map[Path, ???]`? I think that would make it easier to incrementally update the index and remove stale data as files get deleted. It's OK if querying takes a performance hit, I don't querying will be a bottleneck.",
        "createdAt" : "2019-09-20T09:47:01Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3d4689c1-7586-488c-b6ec-aade3309668f",
        "parentId" : "93993a1b-8659-4404-92c2-16ba0cf30add",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Added path as the key in the main map, it serves as a kind of namespace now. Thanks!",
        "createdAt" : "2019-09-20T15:10:26Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,90 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementations =\n+    new ConcurrentHashMap[String, Set[ClassLocation]]"
  },
  {
    "id" : "3aedddda-9df1-4404-b3a0-6e64fb8caf4b",
    "prId" : 934,
    "comments" : [
      {
        "id" : "ef0a9355-0c0e-4332-a1b7-51b616c7f4c5",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "is `path` used anywhere?",
        "createdAt" : "2019-09-20T16:32:55Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5f4e02fc-e8af-4e17-8af0-9d6c73a12628",
        "parentId" : "ef0a9355-0c0e-4332-a1b7-51b616c7f4c5",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "No, replaced by `_`",
        "createdAt" : "2019-09-20T17:19:54Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = if (fileSource == source) positionOccurrence.distance\n+      else TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = for {\n+        (path, symbols) <- implementationsInPath.asScala"
  },
  {
    "id" : "daa6e9e1-b6df-44dd-8360-515a49b53cf2",
    "prId" : 934,
    "comments" : [
      {
        "id" : "50ed3b5d-a57c-4055-9a55-38bcf5f9217e",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "could you extract the body to make it more readable?",
        "createdAt" : "2019-09-20T16:47:56Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5898dbf5-9e95-4fec-9f9b-576a3bac9993",
        "parentId" : "50ed3b5d-a57c-4055-9a55-38bcf5f9217e",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Moved it to another method",
        "createdAt" : "2019-09-20T17:23:52Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = if (fileSource == source) positionOccurrence.distance\n+      else TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = for {\n+        (path, symbols) <- implementationsInPath.asScala\n+        symbolImpls <- symbols.get(symbol).toList\n+        impl <- symbolImpls\n+      } yield impl\n+      directImpl.toSet ++ directImpl\n+        .flatMap(\n+          loc => findAllImpl(loc.symbol.symbol)\n+        )\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  def clear(): Unit = {\n+    implementationsInPath.clear()\n+  }\n+\n+  def onDelete(path: Path): Unit = {\n+    implementationsInPath.remove(path)\n+  }\n+\n+  def onChange(docs: TextDocuments, path: Path): Unit = {\n+    implementationsInPath.compute(\n+      path, { (_, _) =>"
  },
  {
    "id" : "55cfac8a-d903-49b3-a26c-020edd7ab1b9",
    "prId" : 934,
    "comments" : [
      {
        "id" : "5d4d072a-1486-45c7-bbe4-46897e6f07e6",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "do we even need the `findAllImpl` ? Could we move its body to `findImplementation` ?",
        "createdAt" : "2019-09-20T16:50:57Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a313a931-5f4a-49f0-811c-276122e8a7f9",
        "parentId" : "5d4d072a-1486-45c7-bbe4-46897e6f07e6",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Not needed, removed and left one func.",
        "createdAt" : "2019-09-20T17:24:14Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = if (fileSource == source) positionOccurrence.distance\n+      else TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {"
  },
  {
    "id" : "a68ba330-795c-4b7d-ae50-e53c46e4be61",
    "prId" : 934,
    "comments" : [
      {
        "id" : "b24aa199-8634-45e0-88df-48ad8549b4fc",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "it is only used in a false branch of the next `if` statement. Maybe those could be merged?",
        "createdAt" : "2019-09-20T16:53:42Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f4efe8f4-728f-4522-bdd9-d59ee1be2073",
        "parentId" : "b24aa199-8634-45e0-88df-48ad8549b4fc",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Actually, this is an optimization that most likely will not be needed. I will remove the `if else`, it clouds the logic somewhat",
        "createdAt" : "2019-09-20T17:18:44Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)"
  },
  {
    "id" : "60ce4745-db43-438e-a7de-066c478ca1b1",
    "prId" : 934,
    "comments" : [
      {
        "id" : "d9907654-46b2-45d1-906a-c6f15ed3ec33",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "it returns `Option[List[(Symbol, Location)]]` right? We could easily make it a `List[(Symbol, Location)]` which would simplify `onChange` a bit:\r\n```scala\r\n          parents <- addFromSignature(thisSymbol.signature, occ, doc).toList\r\n          parent <- parents\r\n        } yield parent\r\n```\r\n\r\nwould become \r\n```scala\r\n          parent <- addFromSignature(thisSymbol.signature, occ, doc).toList\r\n        } yield parent\r\n```",
        "createdAt" : "2019-09-20T16:57:25Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1c2f7046-c9d3-4d4a-a6d4-f7eb2b7abb78",
        "parentId" : "d9907654-46b2-45d1-906a-c6f15ed3ec33",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Switched to Seq and it simplified the code.",
        "createdAt" : "2019-09-20T17:24:54Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = if (fileSource == source) positionOccurrence.distance\n+      else TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = for {\n+        (path, symbols) <- implementationsInPath.asScala\n+        symbolImpls <- symbols.get(symbol).toList\n+        impl <- symbolImpls\n+      } yield impl\n+      directImpl.toSet ++ directImpl\n+        .flatMap(\n+          loc => findAllImpl(loc.symbol.symbol)\n+        )\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  def clear(): Unit = {\n+    implementationsInPath.clear()\n+  }\n+\n+  def onDelete(path: Path): Unit = {\n+    implementationsInPath.remove(path)\n+  }\n+\n+  def onChange(docs: TextDocuments, path: Path): Unit = {\n+    implementationsInPath.compute(\n+      path, { (_, _) =>\n+        val allParents = for {\n+          doc <- docs.documents\n+          thisSymbol <- doc.symbols\n+          occ <- doc.occurrences\n+            .find(\n+              occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+            )\n+            .toList\n+          parents <- addFromSignature(thisSymbol.signature, occ, doc).toList\n+          parent <- parents\n+        } yield parent\n+\n+        allParents.groupBy(_._1).map {\n+          case (symbol, locations) =>\n+            symbol -> locations.map(_._2).toSet\n+        }\n+      }\n+    )\n+  }\n+\n+  private def addFromSignature("
  },
  {
    "id" : "891f2319-2c9d-431f-aa7e-11b6c967db65",
    "prId" : 934,
    "comments" : [
      {
        "id" : "449788d8-77bc-448b-989e-19a228494bb5",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "rename function to `collectParentsOf` or something?",
        "createdAt" : "2019-09-20T16:57:53Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ed7ba1ce-982a-4468-b0c9-fc71ab0a3ca1",
        "parentId" : "449788d8-77bc-448b-989e-19a228494bb5",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Renamed",
        "createdAt" : "2019-09-20T17:25:08Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = if (fileSource == source) positionOccurrence.distance\n+      else TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    def findAllImpl(symbol: String): Set[ClassLocation] = {\n+      val directImpl = for {\n+        (path, symbols) <- implementationsInPath.asScala\n+        symbolImpls <- symbols.get(symbol).toList\n+        impl <- symbolImpls\n+      } yield impl\n+      directImpl.toSet ++ directImpl\n+        .flatMap(\n+          loc => findAllImpl(loc.symbol.symbol)\n+        )\n+    }\n+    findAllImpl(symbol)\n+  }\n+\n+  def clear(): Unit = {\n+    implementationsInPath.clear()\n+  }\n+\n+  def onDelete(path: Path): Unit = {\n+    implementationsInPath.remove(path)\n+  }\n+\n+  def onChange(docs: TextDocuments, path: Path): Unit = {\n+    implementationsInPath.compute(\n+      path, { (_, _) =>\n+        val allParents = for {\n+          doc <- docs.documents\n+          thisSymbol <- doc.symbols\n+          occ <- doc.occurrences\n+            .find(\n+              occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+            )\n+            .toList\n+          parents <- addFromSignature(thisSymbol.signature, occ, doc).toList\n+          parent <- parents\n+        } yield parent\n+\n+        allParents.groupBy(_._1).map {\n+          case (symbol, locations) =>\n+            symbol -> locations.map(_._2).toSet\n+        }\n+      }\n+    )\n+  }\n+\n+  private def addFromSignature("
  },
  {
    "id" : "ace0ddd8-dd71-410c-866f-0a6bccdd6989",
    "prId" : 934,
    "comments" : [
      {
        "id" : "d7caeb8c-f70a-4850-87bc-42ed62f70ce1",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can you please add type annotations to methods, it would make it easier to review the code on GitHub",
        "createdAt" : "2019-09-23T09:23:59Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,120 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    val directImpl = for {\n+      (_, symbols) <- implementationsInPath.asScala\n+      symbolImpls <- symbols.get(symbol).toList\n+      impl <- symbolImpls\n+    } yield impl\n+    directImpl.toSet ++ directImpl\n+      .flatMap(\n+        loc => findImplementation(loc.symbol.symbol)\n+      )\n+  }\n+\n+  def clear(): Unit = {\n+    implementationsInPath.clear()\n+  }\n+\n+  def onDelete(path: Path): Unit = {\n+    implementationsInPath.remove(path)\n+  }\n+\n+  def onChange(docs: TextDocuments, path: Path): Unit = {\n+    implementationsInPath.compute(\n+      path, { (_, _) =>\n+        computeInheritance(docs)\n+      }\n+    )\n+  }\n+\n+  private def computeInheritance(docs: TextDocuments) = {"
  },
  {
    "id" : "0670c8dc-3980-4650-b462-ff293bc2b0c8",
    "prId" : 934,
    "comments" : [
      {
        "id" : "48720ddb-ff4e-4552-92f4-eca7e83c944e",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We should not eagerly compute the occurrence while building the index. The `onChange` method is on a very hot path, it runs during the \"Indexing...\" stage and blocks other functionality from working. We should aim to do as little work as possible while indexing SemanticDB files, it preferable to compute more on the fly when responding to requests such as `textDocument/implementation`.",
        "createdAt" : "2019-09-23T09:26:33Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "976e3e49-7080-44c4-9685-89cfb537a291",
        "parentId" : "48720ddb-ff4e-4552-92f4-eca7e83c944e",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Changed to calculate occurrence only when being asked about the implementation",
        "createdAt" : "2019-09-24T16:32:46Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,120 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    val directImpl = for {\n+      (_, symbols) <- implementationsInPath.asScala\n+      symbolImpls <- symbols.get(symbol).toList\n+      impl <- symbolImpls\n+    } yield impl\n+    directImpl.toSet ++ directImpl\n+      .flatMap(\n+        loc => findImplementation(loc.symbol.symbol)\n+      )\n+  }\n+\n+  def clear(): Unit = {\n+    implementationsInPath.clear()\n+  }\n+\n+  def onDelete(path: Path): Unit = {\n+    implementationsInPath.remove(path)\n+  }\n+\n+  def onChange(docs: TextDocuments, path: Path): Unit = {\n+    implementationsInPath.compute(\n+      path, { (_, _) =>\n+        computeInheritance(docs)\n+      }\n+    )\n+  }\n+\n+  private def computeInheritance(docs: TextDocuments) = {\n+    val allParents = for {\n+      doc <- docs.documents\n+      thisSymbol <- doc.symbols\n+      occ <- doc.occurrences"
  },
  {
    "id" : "e451f2ef-bb61-4f86-adb1-e0302558c30f",
    "prId" : 934,
    "comments" : [
      {
        "id" : "b0e59901-ec31-47c4-a00e-0752ac7059f6",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "```suggestion\r\n          case t: TypeRef => t.symbol\r\n```",
        "createdAt" : "2019-09-23T09:26:58Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c64c5597-8c14-483e-aec7-7109081e4239",
        "parentId" : "b0e59901-ec31-47c4-a00e-0752ac7059f6",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Done",
        "createdAt" : "2019-09-24T16:32:14Z",
        "updatedAt" : "2019-10-03T13:51:34Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d837625e03b77aa42a76d4f700137294452174fa",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,120 @@\n+package scala.meta.internal.metals\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.lsp4j.TextDocumentPositionParams\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+import java.nio.file.Paths\n+import scala.meta.internal.semanticdb.TextDocuments\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.Signature\n+import scala.meta.internal.semanticdb.TextDocument\n+import java.util.concurrent.ConcurrentHashMap\n+import java.nio.file.Path\n+\n+final class ImplementationProvider(\n+    semanticdbs: Semanticdbs,\n+    workspace: AbsolutePath,\n+    buffer: Buffers,\n+    definitionProvider: DefinitionProvider\n+) {\n+  private val implementationsInPath =\n+    new ConcurrentHashMap[Path, Map[String, Set[ClassLocation]]]\n+\n+  def implementations(params: TextDocumentPositionParams): List[Location] = {\n+    val source = params.getTextDocument.getUri.toAbsolutePath\n+\n+    def findSemanticdb(fileSource: AbsolutePath) =\n+      semanticdbs\n+        .textDocument(fileSource)\n+        .documentIncludingStale\n+        .toList\n+\n+    for {\n+      currentDoc <- findSemanticdb(source)\n+      positionOccurrence = definitionProvider.positionOccurrence(\n+        source,\n+        params,\n+        currentDoc\n+      )\n+      occ <- positionOccurrence.occurrence.toList\n+      (file, locations) <- findImplementation(occ.symbol).groupBy(_.file)\n+      fileSource = AbsolutePath(file)\n+      doc <- findSemanticdb(fileSource)\n+      distance = TokenEditDistance.fromBuffer(fileSource, doc.text, buffer)\n+      impl <- locations\n+      range <- impl.symbol.range\n+      revised <- distance.toRevised(range.toLSP)\n+      uri = impl.file.toUri.toString\n+    } yield new Location(uri, revised)\n+  }\n+\n+  private def findImplementation(symbol: String): Set[ClassLocation] = {\n+    val directImpl = for {\n+      (_, symbols) <- implementationsInPath.asScala\n+      symbolImpls <- symbols.get(symbol).toList\n+      impl <- symbolImpls\n+    } yield impl\n+    directImpl.toSet ++ directImpl\n+      .flatMap(\n+        loc => findImplementation(loc.symbol.symbol)\n+      )\n+  }\n+\n+  def clear(): Unit = {\n+    implementationsInPath.clear()\n+  }\n+\n+  def onDelete(path: Path): Unit = {\n+    implementationsInPath.remove(path)\n+  }\n+\n+  def onChange(docs: TextDocuments, path: Path): Unit = {\n+    implementationsInPath.compute(\n+      path, { (_, _) =>\n+        computeInheritance(docs)\n+      }\n+    )\n+  }\n+\n+  private def computeInheritance(docs: TextDocuments) = {\n+    val allParents = for {\n+      doc <- docs.documents\n+      thisSymbol <- doc.symbols\n+      occ <- doc.occurrences\n+        .find(\n+          occ => occ.symbol == thisSymbol.symbol && occ.role.isDefinition\n+        )\n+        .toList\n+      parent <- parentsFromSignature(thisSymbol.signature, occ, doc).toList\n+    } yield parent\n+\n+    allParents.groupBy(_._1).map {\n+      case (symbol, locations) =>\n+        symbol -> locations.map(_._2).toSet\n+    }\n+  }\n+\n+  private def parentsFromSignature(\n+      signature: Signature,\n+      occ: SymbolOccurrence,\n+      doc: TextDocument\n+  ) = {\n+    val filePath = workspace.toNIO.resolve(Paths.get(doc.uri))\n+    val loc = ClassLocation(occ, filePath)\n+    signature match {\n+      case classSig: ClassSignature =>\n+        val allLocations = classSig.parents.collect {\n+          case TypeRef(_, symbol, _) =>"
  }
]