[
  {
    "id" : "114aa908-b966-4446-a271-9b486dde5418",
    "prId" : 721,
    "comments" : [
      {
        "id" : "bc23c9d1-b646-4af4-b3ca-7a125dd5b9d3",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Let's avoid importing methods directly\r\n```diff\r\n- import scala.meta.internal.metals.TokenEditDistance.fromBuffer\r\n+ import scala.meta.internal.metals.TokenEditDistance.fromBuffer\r\n```",
        "createdAt" : "2019-05-20T14:45:19Z",
        "updatedAt" : "2019-05-22T07:33:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e3c999e9b79f7d0d6a4c95756d12ec54f6abbc90",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,51 @@\n+package scala.meta.internal.metals\n+import java.util\n+import java.util.Collections._\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.{lsp4j => l}\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.TokenEditDistance.fromBuffer"
  },
  {
    "id" : "2421ffab-17b2-4eda-9d87-37e0adcf4121",
    "prId" : 721,
    "comments" : [
      {
        "id" : "0a8fe4d5-a590-4c92-a4de-1278e7968f74",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "```diff\r\n- occurrence.range.map(_.toLSP).flatMap(distance.toRevised).toSeq\r\n+ occurrence.range.flatMap(r => distance.toRevised.toLSP).toList\r\n```\r\n",
        "createdAt" : "2019-05-20T14:47:07Z",
        "updatedAt" : "2019-05-22T07:33:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e3c999e9b79f7d0d6a4c95756d12ec54f6abbc90",
    "line" : 39,
    "diffHunk" : "@@ -0,0 +1,51 @@\n+package scala.meta.internal.metals\n+import java.util\n+import java.util.Collections._\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import org.eclipse.{lsp4j => l}\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.TokenEditDistance.fromBuffer\n+import scala.meta.internal.mtags.Semanticdbs\n+import scala.meta.io.AbsolutePath\n+\n+final class CodeLensProvider(\n+    classes: BuildTargetClasses,\n+    buffers: Buffers,\n+    buildTargets: BuildTargets,\n+    semanticdbs: Semanticdbs\n+) {\n+  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n+    buildTargets.inverseSources(path) match {\n+      case Some(buildTarget) if !classes.main(buildTarget).isEmpty =>\n+        findLenses(path, buildTarget).asJava\n+      case _ =>\n+        emptyList[l.CodeLens]()\n+    }\n+  }\n+\n+  private def findLenses(\n+      path: AbsolutePath,\n+      buildTarget: BuildTargetIdentifier\n+  ): List[l.CodeLens] = {\n+    semanticdbs.textDocument(path).documentIncludingStale match {\n+      case Some(textDocument) =>\n+        val distance = fromBuffer(path, textDocument.text, buffers)\n+        val mainClasses = classes.main(buildTarget)\n+\n+        val lenses = for {\n+          occurrence <- textDocument.occurrences\n+          if mainClasses.containsKey(occurrence.symbol)\n+          mainClass = mainClasses.get(occurrence.symbol)\n+          range <- occurrence.range"
  },
  {
    "id" : "f1f37e20-9927-497a-a9e4-0d0bca5982d3",
    "prId" : 923,
    "comments" : [
      {
        "id" : "8be7a344-275f-4dc2-9349-394e0d3045e9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Can we use explicit `ExecutionContext` in parameters?",
        "createdAt" : "2019-09-18T09:56:53Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "04486aa5-8022-4497-9d49-b57de17a52a1",
        "parentId" : "8be7a344-275f-4dc2-9349-394e0d3045e9",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "To explain, I think it would be useful to give explicit context to Providers so that we know what each of them are using. Will be easier to figure out if we need to optimize.",
        "createdAt" : "2019-09-18T11:06:50Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "52e6cfd6-095b-4b5e-ba1f-2e2cbbdf2446",
        "parentId" : "8be7a344-275f-4dc2-9349-394e0d3045e9",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "The convention in the codebase so far has been to pass around the `ExecutionContext` implicitly, is there a reason we should do it differently for `CodeLensProvider`?",
        "createdAt" : "2019-09-23T09:33:30Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9261f15f-d189-4156-8d4c-beee34eb71b1",
        "parentId" : "8be7a344-275f-4dc2-9349-394e0d3045e9",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I'm fine with implicit, I just thought it might help to have explicit ones for the providers. But should not be important currently.",
        "createdAt" : "2019-09-23T10:04:08Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "37c28b7f-ed00-435b-9101-2835686c0a05",
        "parentId" : "8be7a344-275f-4dc2-9349-394e0d3045e9",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It's not possible to explicitly pass the `ExecutionContext` in for comprehensions\r\n```scala\r\nfor {\r\n  a <- foo()\r\n} yield a + 2\r\n```",
        "createdAt" : "2019-09-23T15:14:55Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b13f0b7d-31cb-478f-accb-f20f4ccfbfb6",
        "parentId" : "8be7a344-275f-4dc2-9349-394e0d3045e9",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I just really meant this for constructors like here.",
        "createdAt" : "2019-09-23T15:19:01Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "34b736c65504efc71e34421317b1346d8671e0ea",
    "line" : 32,
    "diffHunk" : "@@ -1,50 +1,114 @@\n package scala.meta.internal.metals\n-import java.util\n+\n import java.util.Collections._\n+\n import ch.epfl.scala.{bsp4j => b}\n import org.eclipse.{lsp4j => l}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.ClientCommands.StartDebugSession\n+import scala.meta.internal.metals.CodeLensProvider._\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.internal.mtags.Semanticdbs\n import scala.meta.io.AbsolutePath\n \n final class CodeLensProvider(\n-    classes: BuildTargetClasses,\n+    buildTargetClasses: BuildTargetClasses,\n     buffers: Buffers,\n     buildTargets: BuildTargets,\n+    compilations: Compilations,\n     semanticdbs: Semanticdbs\n-) {\n-  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n-    buildTargets.inverseSources(path) match {\n-      case Some(buildTarget) if classes.main(buildTarget).nonEmpty =>\n-        findLenses(path, buildTarget).asJava\n-      case _ =>\n-        emptyList[l.CodeLens]()\n-    }\n+)(implicit ec: ExecutionContext) {"
  },
  {
    "id" : "7a0eab9b-9068-4772-9fe6-21a3599b8145",
    "prId" : 923,
    "comments" : [
      {
        "id" : "532ff0a7-c7d2-4fbc-b878-c61f71a254d3",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`names` seems to always be a single parameter. ",
        "createdAt" : "2019-09-18T10:02:27Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34b736c65504efc71e34421317b1346d8671e0ea",
    "line" : null,
    "diffHunk" : "@@ -1,50 +1,114 @@\n package scala.meta.internal.metals\n-import java.util\n+\n import java.util.Collections._\n+\n import ch.epfl.scala.{bsp4j => b}\n import org.eclipse.{lsp4j => l}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.ClientCommands.StartDebugSession\n+import scala.meta.internal.metals.CodeLensProvider._\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.internal.mtags.Semanticdbs\n import scala.meta.io.AbsolutePath\n \n final class CodeLensProvider(\n-    classes: BuildTargetClasses,\n+    buildTargetClasses: BuildTargetClasses,\n     buffers: Buffers,\n     buildTargets: BuildTargets,\n+    compilations: Compilations,\n     semanticdbs: Semanticdbs\n-) {\n-  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n-    buildTargets.inverseSources(path) match {\n-      case Some(buildTarget) if classes.main(buildTarget).nonEmpty =>\n-        findLenses(path, buildTarget).asJava\n-      case _ =>\n-        emptyList[l.CodeLens]()\n-    }\n+)(implicit ec: ExecutionContext) {\n+  // code lenses will be refreshed after compilation or when workspace gets indexed\n+  def findLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    val lenses = buildTargets\n+      .inverseSources(path)\n+      .filterNot(compilations.isCurrentlyCompiling)\n+      .map { buildTarget =>\n+        val classes = buildTargetClasses.classesOf(buildTarget)\n+        val lenses = findLenses(path, buildTarget, classes)\n+        lenses\n+      }\n+\n+    lenses.getOrElse(Nil)\n   }\n \n   private def findLenses(\n       path: AbsolutePath,\n-      buildTarget: b.BuildTargetIdentifier\n-  ): List[l.CodeLens] = {\n+      target: b.BuildTargetIdentifier,\n+      classes: BuildTargetClasses.Classes\n+  ): Seq[l.CodeLens] = {\n     semanticdbs.textDocument(path).documentIncludingStale match {\n       case Some(textDocument) =>\n         val distance =\n           TokenEditDistance.fromBuffer(path, textDocument.text, buffers)\n-        val mainClasses = classes.main(buildTarget)\n \n-        val lenses = for {\n+        for {\n           occurrence <- textDocument.occurrences\n-          if mainClasses.contains(occurrence.symbol)\n-          mainClass = mainClasses(occurrence.symbol)\n+          if occurrence.role.isDefinition\n+          symbol = occurrence.symbol\n+          commands = {\n+            val main = classes.mainClasses\n+              .get(symbol)\n+              .map(MainClassLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            val tests = classes.testSuites\n+              .get(symbol)\n+              .map(TestSuitesLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            main ++ tests\n+          }\n+          if commands.nonEmpty\n           range <- occurrence.range\n             .flatMap(r => distance.toRevised(r.toLSP))\n             .toList\n-          arguments = List(buildTarget.getUri, mainClass.getClassName)\n-        } yield\n-          new l.CodeLens(range, ClientCommands.RunMain.toLSP(arguments), null)\n-        lenses.toList\n+          command <- commands\n+        } yield new l.CodeLens(range, command, null)\n       case _ =>\n         Nil\n     }\n   }\n }\n+\n+object CodeLensProvider {\n+  import JsonParser._\n+  sealed trait CommandFactory[A] {\n+    protected def names: List[String]"
  },
  {
    "id" : "31a0c3eb-abd9-4dd6-b477-1dac9fd54cd8",
    "prId" : 923,
    "comments" : [
      {
        "id" : "2b2dde60-597a-40c5-94a5-92e786df8752",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't see any need for creating the whole class hierarchy that is immediately discarded - it's only used to create something else.\r\n\r\nCould we just have 3 methods? `commands` and `testCommands`/`mainCommands` using it ?",
        "createdAt" : "2019-09-18T10:04:29Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0c6f0fc3-6382-4f8d-ab51-3526c8e18e95",
        "parentId" : "2b2dde60-597a-40c5-94a5-92e786df8752",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "See https://github.com/scalameta/metals/pull/923#discussion_r325610141 for a refactoring proposal.",
        "createdAt" : "2019-09-23T09:33:43Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34b736c65504efc71e34421317b1346d8671e0ea",
    "line" : null,
    "diffHunk" : "@@ -1,50 +1,114 @@\n package scala.meta.internal.metals\n-import java.util\n+\n import java.util.Collections._\n+\n import ch.epfl.scala.{bsp4j => b}\n import org.eclipse.{lsp4j => l}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.ClientCommands.StartDebugSession\n+import scala.meta.internal.metals.CodeLensProvider._\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.internal.mtags.Semanticdbs\n import scala.meta.io.AbsolutePath\n \n final class CodeLensProvider(\n-    classes: BuildTargetClasses,\n+    buildTargetClasses: BuildTargetClasses,\n     buffers: Buffers,\n     buildTargets: BuildTargets,\n+    compilations: Compilations,\n     semanticdbs: Semanticdbs\n-) {\n-  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n-    buildTargets.inverseSources(path) match {\n-      case Some(buildTarget) if classes.main(buildTarget).nonEmpty =>\n-        findLenses(path, buildTarget).asJava\n-      case _ =>\n-        emptyList[l.CodeLens]()\n-    }\n+)(implicit ec: ExecutionContext) {\n+  // code lenses will be refreshed after compilation or when workspace gets indexed\n+  def findLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    val lenses = buildTargets\n+      .inverseSources(path)\n+      .filterNot(compilations.isCurrentlyCompiling)\n+      .map { buildTarget =>\n+        val classes = buildTargetClasses.classesOf(buildTarget)\n+        val lenses = findLenses(path, buildTarget, classes)\n+        lenses\n+      }\n+\n+    lenses.getOrElse(Nil)\n   }\n \n   private def findLenses(\n       path: AbsolutePath,\n-      buildTarget: b.BuildTargetIdentifier\n-  ): List[l.CodeLens] = {\n+      target: b.BuildTargetIdentifier,\n+      classes: BuildTargetClasses.Classes\n+  ): Seq[l.CodeLens] = {\n     semanticdbs.textDocument(path).documentIncludingStale match {\n       case Some(textDocument) =>\n         val distance =\n           TokenEditDistance.fromBuffer(path, textDocument.text, buffers)\n-        val mainClasses = classes.main(buildTarget)\n \n-        val lenses = for {\n+        for {\n           occurrence <- textDocument.occurrences\n-          if mainClasses.contains(occurrence.symbol)\n-          mainClass = mainClasses(occurrence.symbol)\n+          if occurrence.role.isDefinition\n+          symbol = occurrence.symbol\n+          commands = {\n+            val main = classes.mainClasses\n+              .get(symbol)\n+              .map(MainClassLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            val tests = classes.testSuites\n+              .get(symbol)\n+              .map(TestSuitesLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            main ++ tests\n+          }\n+          if commands.nonEmpty\n           range <- occurrence.range\n             .flatMap(r => distance.toRevised(r.toLSP))\n             .toList\n-          arguments = List(buildTarget.getUri, mainClass.getClassName)\n-        } yield\n-          new l.CodeLens(range, ClientCommands.RunMain.toLSP(arguments), null)\n-        lenses.toList\n+          command <- commands\n+        } yield new l.CodeLens(range, command, null)\n       case _ =>\n         Nil\n     }\n   }\n }\n+\n+object CodeLensProvider {\n+  import JsonParser._\n+  sealed trait CommandFactory[A] {"
  },
  {
    "id" : "f72ff774-c02e-4106-9fc8-075fa1ea83f4",
    "prId" : 923,
    "comments" : [
      {
        "id" : "d0643d1a-538f-412e-8ba9-4174b6782c8f",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "This gives us no type safety at all, it can turn anything into anything. The method is not really useful, data could easily be a parameter to a method.",
        "createdAt" : "2019-09-18T10:07:13Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34b736c65504efc71e34421317b1346d8671e0ea",
    "line" : null,
    "diffHunk" : "@@ -1,50 +1,114 @@\n package scala.meta.internal.metals\n-import java.util\n+\n import java.util.Collections._\n+\n import ch.epfl.scala.{bsp4j => b}\n import org.eclipse.{lsp4j => l}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.ClientCommands.StartDebugSession\n+import scala.meta.internal.metals.CodeLensProvider._\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.internal.mtags.Semanticdbs\n import scala.meta.io.AbsolutePath\n \n final class CodeLensProvider(\n-    classes: BuildTargetClasses,\n+    buildTargetClasses: BuildTargetClasses,\n     buffers: Buffers,\n     buildTargets: BuildTargets,\n+    compilations: Compilations,\n     semanticdbs: Semanticdbs\n-) {\n-  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n-    buildTargets.inverseSources(path) match {\n-      case Some(buildTarget) if classes.main(buildTarget).nonEmpty =>\n-        findLenses(path, buildTarget).asJava\n-      case _ =>\n-        emptyList[l.CodeLens]()\n-    }\n+)(implicit ec: ExecutionContext) {\n+  // code lenses will be refreshed after compilation or when workspace gets indexed\n+  def findLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    val lenses = buildTargets\n+      .inverseSources(path)\n+      .filterNot(compilations.isCurrentlyCompiling)\n+      .map { buildTarget =>\n+        val classes = buildTargetClasses.classesOf(buildTarget)\n+        val lenses = findLenses(path, buildTarget, classes)\n+        lenses\n+      }\n+\n+    lenses.getOrElse(Nil)\n   }\n \n   private def findLenses(\n       path: AbsolutePath,\n-      buildTarget: b.BuildTargetIdentifier\n-  ): List[l.CodeLens] = {\n+      target: b.BuildTargetIdentifier,\n+      classes: BuildTargetClasses.Classes\n+  ): Seq[l.CodeLens] = {\n     semanticdbs.textDocument(path).documentIncludingStale match {\n       case Some(textDocument) =>\n         val distance =\n           TokenEditDistance.fromBuffer(path, textDocument.text, buffers)\n-        val mainClasses = classes.main(buildTarget)\n \n-        val lenses = for {\n+        for {\n           occurrence <- textDocument.occurrences\n-          if mainClasses.contains(occurrence.symbol)\n-          mainClass = mainClasses(occurrence.symbol)\n+          if occurrence.role.isDefinition\n+          symbol = occurrence.symbol\n+          commands = {\n+            val main = classes.mainClasses\n+              .get(symbol)\n+              .map(MainClassLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            val tests = classes.testSuites\n+              .get(symbol)\n+              .map(TestSuitesLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            main ++ tests\n+          }\n+          if commands.nonEmpty\n           range <- occurrence.range\n             .flatMap(r => distance.toRevised(r.toLSP))\n             .toList\n-          arguments = List(buildTarget.getUri, mainClass.getClassName)\n-        } yield\n-          new l.CodeLens(range, ClientCommands.RunMain.toLSP(arguments), null)\n-        lenses.toList\n+          command <- commands\n+        } yield new l.CodeLens(range, command, null)\n       case _ =>\n         Nil\n     }\n   }\n }\n+\n+object CodeLensProvider {\n+  import JsonParser._\n+  sealed trait CommandFactory[A] {\n+    protected def names: List[String]\n+    protected def dataKind: String\n+\n+    final def commands(\n+        target: b.BuildTargetIdentifier,\n+        arg: A\n+    ): List[l.Command] = {\n+      val params = new b.DebugSessionParams(\n+        List(target).asJava,\n+        dataKind,\n+        data(arg).toJson\n+      )\n+\n+      names.map { name =>\n+        new l.Command(name, StartDebugSession.id, singletonList(params))\n+      }\n+    }\n+\n+    protected def data(data: A): AnyRef"
  },
  {
    "id" : "7ead6939-cc12-449d-838f-e88d6ca663a7",
    "prId" : 923,
    "comments" : [
      {
        "id" : "fe648346-a517-46c7-8155-480864d30f45",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "What do you think about implementing this class like this instead?\r\n\r\n```suggestion\r\ncase class CommandFactory[A](names: List[String], kind: String, arg: A => AnyRef) {\r\n  def commands(..) = ???\r\n}\r\nval mainCommandFactory = CommandFactory[b.ScalaMainClass](List(\"run\"), b.DebugSessionParamsDataKind.SCALA_MAIN_CLASS, arg => arg)\r\nval testCommandFactory = CommandFactory[String](List(\"run\"), b.DebugSessionParamsDataKind.SCALA_TEST_CLASS, arg => List(arg).asJava)\r\n```\r\n\r\nI personally would find such an  implementation easier to read and extend compared to the current trait design.",
        "createdAt" : "2019-09-18T10:59:10Z",
        "updatedAt" : "2019-09-24T10:49:11Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34b736c65504efc71e34421317b1346d8671e0ea",
    "line" : null,
    "diffHunk" : "@@ -1,50 +1,114 @@\n package scala.meta.internal.metals\n-import java.util\n+\n import java.util.Collections._\n+\n import ch.epfl.scala.{bsp4j => b}\n import org.eclipse.{lsp4j => l}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.ClientCommands.StartDebugSession\n+import scala.meta.internal.metals.CodeLensProvider._\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.internal.mtags.Semanticdbs\n import scala.meta.io.AbsolutePath\n \n final class CodeLensProvider(\n-    classes: BuildTargetClasses,\n+    buildTargetClasses: BuildTargetClasses,\n     buffers: Buffers,\n     buildTargets: BuildTargets,\n+    compilations: Compilations,\n     semanticdbs: Semanticdbs\n-) {\n-  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n-    buildTargets.inverseSources(path) match {\n-      case Some(buildTarget) if classes.main(buildTarget).nonEmpty =>\n-        findLenses(path, buildTarget).asJava\n-      case _ =>\n-        emptyList[l.CodeLens]()\n-    }\n+)(implicit ec: ExecutionContext) {\n+  // code lenses will be refreshed after compilation or when workspace gets indexed\n+  def findLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    val lenses = buildTargets\n+      .inverseSources(path)\n+      .filterNot(compilations.isCurrentlyCompiling)\n+      .map { buildTarget =>\n+        val classes = buildTargetClasses.classesOf(buildTarget)\n+        val lenses = findLenses(path, buildTarget, classes)\n+        lenses\n+      }\n+\n+    lenses.getOrElse(Nil)\n   }\n \n   private def findLenses(\n       path: AbsolutePath,\n-      buildTarget: b.BuildTargetIdentifier\n-  ): List[l.CodeLens] = {\n+      target: b.BuildTargetIdentifier,\n+      classes: BuildTargetClasses.Classes\n+  ): Seq[l.CodeLens] = {\n     semanticdbs.textDocument(path).documentIncludingStale match {\n       case Some(textDocument) =>\n         val distance =\n           TokenEditDistance.fromBuffer(path, textDocument.text, buffers)\n-        val mainClasses = classes.main(buildTarget)\n \n-        val lenses = for {\n+        for {\n           occurrence <- textDocument.occurrences\n-          if mainClasses.contains(occurrence.symbol)\n-          mainClass = mainClasses(occurrence.symbol)\n+          if occurrence.role.isDefinition\n+          symbol = occurrence.symbol\n+          commands = {\n+            val main = classes.mainClasses\n+              .get(symbol)\n+              .map(MainClassLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            val tests = classes.testSuites\n+              .get(symbol)\n+              .map(TestSuitesLensFactory.commands(target, _))\n+              .getOrElse(Nil)\n+            main ++ tests\n+          }\n+          if commands.nonEmpty\n           range <- occurrence.range\n             .flatMap(r => distance.toRevised(r.toLSP))\n             .toList\n-          arguments = List(buildTarget.getUri, mainClass.getClassName)\n-        } yield\n-          new l.CodeLens(range, ClientCommands.RunMain.toLSP(arguments), null)\n-        lenses.toList\n+          command <- commands\n+        } yield new l.CodeLens(range, command, null)\n       case _ =>\n         Nil\n     }\n   }\n }\n+\n+object CodeLensProvider {\n+  import JsonParser._\n+  sealed trait CommandFactory[A] {"
  },
  {
    "id" : "d9aa5a89-f4d7-452e-a37f-7f638fe01249",
    "prId" : 942,
    "comments" : [
      {
        "id" : "cd80be12-0bd6-4b7d-ab1a-61516b4c393d",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Could we change those to methods?",
        "createdAt" : "2019-09-25T09:49:38Z",
        "updatedAt" : "2019-10-04T07:32:50Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47ea581fbaa603a2dc171e3e913392f05fc4ba11",
    "line" : null,
    "diffHunk" : "@@ -1,50 +1,106 @@\n package scala.meta.internal.metals\n-import java.util\n+\n import java.util.Collections._\n+\n import ch.epfl.scala.{bsp4j => b}\n+import com.google.gson.JsonElement\n import org.eclipse.{lsp4j => l}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.ClientCommands.StartDebugSession\n+import scala.meta.internal.metals.CodeLensProvider._\n import scala.meta.internal.metals.MetalsEnrichments._\n import scala.meta.internal.mtags.Semanticdbs\n import scala.meta.io.AbsolutePath\n \n final class CodeLensProvider(\n-    classes: BuildTargetClasses,\n+    buildTargetClasses: BuildTargetClasses,\n     buffers: Buffers,\n     buildTargets: BuildTargets,\n+    compilations: Compilations,\n     semanticdbs: Semanticdbs\n-) {\n-  def findLenses(path: AbsolutePath): util.List[l.CodeLens] = {\n-    buildTargets.inverseSources(path) match {\n-      case Some(buildTarget) if classes.main(buildTarget).nonEmpty =>\n-        findLenses(path, buildTarget).asJava\n-      case _ =>\n-        emptyList[l.CodeLens]()\n-    }\n+)(implicit ec: ExecutionContext) {\n+  // code lenses will be refreshed after compilation or when workspace gets indexed\n+  def findLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    val lenses = buildTargets\n+      .inverseSources(path)\n+      .filterNot(compilations.isCurrentlyCompiling)\n+      .map { buildTarget =>\n+        val classes = buildTargetClasses.classesOf(buildTarget)\n+        val lenses = findLenses(path, buildTarget, classes)\n+        lenses\n+      }\n+\n+    lenses.getOrElse(Nil)\n   }\n \n   private def findLenses(\n       path: AbsolutePath,\n-      buildTarget: b.BuildTargetIdentifier\n-  ): List[l.CodeLens] = {\n+      target: b.BuildTargetIdentifier,\n+      classes: BuildTargetClasses.Classes\n+  ): Seq[l.CodeLens] = {\n     semanticdbs.textDocument(path).documentIncludingStale match {\n       case Some(textDocument) =>\n         val distance =\n           TokenEditDistance.fromBuffer(path, textDocument.text, buffers)\n-        val mainClasses = classes.main(buildTarget)\n \n-        val lenses = for {\n+        for {\n           occurrence <- textDocument.occurrences\n-          if mainClasses.contains(occurrence.symbol)\n-          mainClass = mainClasses(occurrence.symbol)\n+          if occurrence.role.isDefinition\n+          symbol = occurrence.symbol\n+          commands = {\n+            val main = classes.mainClasses\n+              .get(symbol)\n+              .map(RunCommandFactory.command(target, _))\n+              .toList\n+            val tests = classes.testSuites\n+              .get(symbol)\n+              .map(TestCommandFactory.command(target, _))\n+              .toList\n+            main ++ tests\n+          }\n+          if commands.nonEmpty\n           range <- occurrence.range\n             .flatMap(r => distance.toRevised(r.toLSP))\n             .toList\n-          arguments = List(buildTarget.getUri, mainClass.getClassName)\n-        } yield\n-          new l.CodeLens(range, ClientCommands.RunMain.toLSP(arguments), null)\n-        lenses.toList\n+          command <- commands\n+        } yield new l.CodeLens(range, command, null)\n       case _ =>\n         Nil\n     }\n   }\n }\n+\n+object CodeLensProvider {\n+  import JsonParser._\n+\n+  val RunCommandFactory ="
  },
  {
    "id" : "2c236553-ca0c-4eb1-99e7-9b3e08421502",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "5abc8beb-b81e-4865-8d2c-bb6c8ee706a2",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I was thinking of having it calculated with a method like `SemanticDBDoc => CodeLenses`, which could be in a separate trait. Both implementations would in a list and we could join their results.\r\n",
        "createdAt" : "2020-03-12T12:33:30Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -61,7 +89,16 @@ final class DebugCodeLensProvider(\n               .get(symbol)\n               .map(testCommand(target, _))\n               .getOrElse(Nil)\n-            main ++ tests\n+            val docWithPath = TextDocumentWithPath(textDocument, path)\n+            val gotoSuperMethod =\n+              createSuperMethodCommand(\n+                docWithPath,\n+                symbol,\n+                occurrence.role,\n+                emptyLensGoSuperCache(),\n+                search\n+              )\n+            main ++ tests ++ gotoSuperMethod"
  },
  {
    "id" : "5e70d5fc-80a4-4295-87f6-1c10ffbd2aae",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "6cdbc75a-211b-4822-b8e5-57b480d957a5",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`DebugCodeLensProvider` -> `CodeLenses` ?",
        "createdAt" : "2020-03-17T18:55:57Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -17,134 +12,36 @@ trait CodeLensProvider {\n }\n \n final class DebugCodeLensProvider("
  },
  {
    "id" : "f3491964-41b6-492b-b88b-da4e13fff63b",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "f9637020-2940-4142-8a3b-4435aef45bb7",
        "parentId" : null,
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Regarding my comment, I think this is where a change would need to happen. We aren't providing any `codeLensProviders` if the `debuggingProvider` is false, but really the superMethod code lens shouldn't be dependent on this.",
        "createdAt" : "2020-03-18T00:59:29Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f1424d55-a2e1-46e7-8a3b-4bb75451da2b",
        "parentId" : "f9637020-2940-4142-8a3b-4435aef45bb7",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "That should be checked inside the RunTest code lense provider for sure. Thanks for finding it @ckipp01 !",
        "createdAt" : "2020-03-18T08:25:14Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b14d27eb-0880-4e0d-b57d-f3a95287ca97",
        "parentId" : "f9637020-2940-4142-8a3b-4435aef45bb7",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "ahh okay now I get what this `debuggingProvider` was for!\r\n\r\nI moved it to where I create a list of lens providers. \r\nIf debugging is off I only create `superMethodProvider` but if debugging is on I create both.\r\n\r\n```scala\r\n    val runTestLensesProvider: List[CodeLenses] = if (clientExperimentalCapabilities.debuggingProvider) {\r\n      List(new RunTestLensesProvider(buildTargetClasses, buffers, buildTargets))\r\n    } else {\r\n      List.empty\r\n    }\r\n```",
        "createdAt" : "2020-03-18T08:54:42Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "60fa5155-851b-4768-9036-50171166efe6",
        "parentId" : "f9637020-2940-4142-8a3b-4435aef45bb7",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "Pushed a change, could you double check it is okay?\r\nhttps://github.com/scalameta/metals/pull/1487/files#diff-f8c05eebbf12c9c21a7d568f09b500eaR395-R402",
        "createdAt" : "2020-03-18T09:15:56Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "daf95ffe-a061-466c-9bfd-d589eae68ce4",
        "parentId" : "f9637020-2940-4142-8a3b-4435aef45bb7",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Woo hoo! Works now 👍 \r\n\r\n![2020-03-18 12 34 13](https://user-images.githubusercontent.com/13974112/76984147-d3afd600-6914-11ea-8668-51e070e8f4e8.gif)\r\n",
        "createdAt" : "2020-03-18T16:34:53Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -17,134 +12,36 @@ trait CodeLensProvider {\n }\n \n final class DebugCodeLensProvider(\n-    buildTargetClasses: BuildTargetClasses,\n-    buffers: Buffers,\n-    buildTargets: BuildTargets,\n-    compilations: Compilations,\n+    codeLensProviders: List[CodeLenses],\n     semanticdbs: Semanticdbs\n-)(implicit ec: ExecutionContext)\n-    extends CodeLensProvider {\n+) extends CodeLensProvider {\n   // code lenses will be refreshed after compilation or when workspace gets indexed\n   def findLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n-    val lenses = buildTargets\n-      .inverseSources(path)\n-      .map { buildTarget =>\n-        val classes = buildTargetClasses.classesOf(buildTarget)\n-        codeLenses(path, buildTarget, classes)\n+    semanticdbs\n+      .textDocument(path)\n+      .documentIncludingStale\n+      .map { textDocument =>\n+        val doc = TextDocumentWithPath(textDocument, path)\n+        codeLensProviders.filter(_.isEnabled).flatMap(_.codeLenses(doc))\n       }\n-\n-    lenses.getOrElse(Nil)\n-  }\n-\n-  private def codeLenses(\n-      path: AbsolutePath,\n-      target: b.BuildTargetIdentifier,\n-      classes: BuildTargetClasses.Classes\n-  ): Seq[l.CodeLens] = {\n-    semanticdbs.textDocument(path).documentIncludingStale match {\n-      case _ if classes.isEmpty =>\n-        Nil\n-      case Some(textDocument) =>\n-        val distance =\n-          TokenEditDistance.fromBuffer(path, textDocument.text, buffers)\n-\n-        for {\n-          occurrence <- textDocument.occurrences\n-          if occurrence.role.isDefinition\n-          symbol = occurrence.symbol\n-          commands = {\n-            val main = classes.mainClasses\n-              .get(symbol)\n-              .map(mainCommand(target, _))\n-              .getOrElse(Nil)\n-            val tests = classes.testClasses\n-              .get(symbol)\n-              .map(testCommand(target, _))\n-              .getOrElse(Nil)\n-            main ++ tests\n-          }\n-          if commands.nonEmpty\n-          range <- occurrence.range\n-            .flatMap(r => distance.toRevised(r.toLSP))\n-            .toList\n-          command <- commands\n-        } yield new l.CodeLens(range, command, null)\n-      case _ =>\n-        Nil\n-    }\n+      .getOrElse(Seq.empty)\n   }\n }\n \n object CodeLensProvider {\n-  import scala.meta.internal.metals.JsonParser._\n-\n   private val Empty: CodeLensProvider = (_: AbsolutePath) => Nil\n \n   def apply(\n-      buildTargetClasses: BuildTargetClasses,\n-      buffers: Buffers,\n-      buildTargets: BuildTargets,\n-      compilations: Compilations,\n+      codeLensProviders: List[CodeLenses],\n       semanticdbs: Semanticdbs,\n       capabilities: ClientExperimentalCapabilities\n   )(implicit ec: ExecutionContext): CodeLensProvider = {\n     if (!capabilities.debuggingProvider) Empty"
  }
]