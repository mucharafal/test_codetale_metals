[
  {
    "id" : "3d839d06-2cbc-4b08-9a1f-e0445a52b370",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "caf8f559-c078-4d67-bedf-dcbb8545ce22",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Let's use `Icons` instead of string here.",
        "createdAt" : "2020-08-14T16:09:24Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be46a8e7-da93-4ac7-9647-73bf72cb5e7f",
        "parentId" : "caf8f559-c078-4d67-bedf-dcbb8545ce22",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-08-17T08:32:28Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,"
  },
  {
    "id" : "6f3b969b-a850-47e5-9062-434792943c64",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "4852ebfb-c46e-4e49-a20d-8bb0476160bb",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n  def isStackTraceFile(path: AbsolutePath): Boolean =\r\n```\r\n?",
        "createdAt" : "2020-08-14T16:10:44Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1eadc0c3-abff-4aba-9565-84d601cd440f",
        "parentId" : "4852ebfb-c46e-4e49-a20d-8bb0476160bb",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "renamed",
        "createdAt" : "2020-08-17T08:33:14Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean ="
  },
  {
    "id" : "03e2ea02-06e5-4360-bc04-cbbe7d66da57",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "d9e4ae1d-00c2-4aee-b84f-08bafd2072f6",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "This should be in buffers, no need to read from Source.",
        "createdAt" : "2020-08-14T16:18:57Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2bc50d85-493f-48f1-b583-21911136a920",
        "parentId" : "d9e4ae1d-00c2-4aee-b84f-08bafd2072f6",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "changed",
        "createdAt" : "2020-08-17T18:15:06Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def highlight(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): java.util.List[l.DocumentHighlight] = {\n+    val lineOpt = readStacktraceFileLine(path, lineNumber)\n+    lineOpt match {\n+      case Some(line) =>\n+        val from = new l.Position(lineNumber, line.indexOf(\"at \") + 3)\n+        val to = new l.Position(lineNumber, line.indexOf(\"(\"))\n+        val range = new l.Range(from, to)\n+        singletonList(\n+          new l.DocumentHighlight(range, l.DocumentHighlightKind.Read)\n+        )\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    stacktraceLenses(readStacktraceFile(path))\n+  }\n+\n+  private def readStacktraceFileLine(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): Option[String] =\n+    readStacktraceFile(path).drop(lineNumber).headOption\n+\n+  private def readStacktraceFile(path: AbsolutePath): List[String] = {\n+    Source.fromFile(path.toString).getLines().toList"
  },
  {
    "id" : "fbe2086b-593e-462e-ad9b-fa89862c67d2",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "2a237e91-6cc2-4fe6-86db-a8574b9d34b0",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't think document highlight makes sense unless we try to highlight lines referencing the same line/file\r\n\r\nHighlighting one line doesn't seem to add anything.",
        "createdAt" : "2020-08-14T16:20:04Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04ddc2bd-0d03-46bb-ad73-f5bd2cf510bc",
        "parentId" : "2a237e91-6cc2-4fe6-86db-a8574b9d34b0",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "I think it was a nice visual aspect for going to definition as you always see relation 'highlight <-> gododefinition available'\r\nbut since goto def is dropped this can be dropped too",
        "createdAt" : "2020-08-17T18:02:01Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def highlight(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): java.util.List[l.DocumentHighlight] = {\n+    val lineOpt = readStacktraceFileLine(path, lineNumber)\n+    lineOpt match {\n+      case Some(line) =>\n+        val from = new l.Position(lineNumber, line.indexOf(\"at \") + 3)"
  },
  {
    "id" : "c0dae413-383d-4a67-b402-8633cc487c6c",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "6cda62c2-d4cf-451c-903b-b16e89f01b29",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "LSP is the only one that uses 0 based ones. Both editor itself and stacktrace are 1-based. Maybe we could make the comment more precise?",
        "createdAt" : "2020-08-14T16:22:52Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09f01cbc-520e-430c-b09a-790d3a5d2cf0",
        "parentId" : "6cda62c2-d4cf-451c-903b-b16e89f01b29",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "updated, not resolving it yet, let me know if it makes more sense",
        "createdAt" : "2020-08-17T17:05:39Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8526351d-f289-4f3c-bcbe-39e8c4159d6a",
        "parentId" : "6cda62c2-d4cf-451c-903b-b16e89f01b29",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`// number is 1-based, but LSP uses 0-based line numbers` ?",
        "createdAt" : "2020-08-17T17:41:09Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "46733268-2ba0-46b0-86a4-ad437e14ef8d",
        "parentId" : "6cda62c2-d4cf-451c-903b-b16e89f01b29",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "haha sorry I wrote a comment and then pushed my change, you must have noticed unchanged comment, WDYT about a new one? :) ",
        "createdAt" : "2020-08-17T18:51:38Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c9e20a1f-d3fe-4539-8ac9-5d736c109278",
        "parentId" : "6cda62c2-d4cf-451c-903b-b16e89f01b29",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "it is mainly the same as you proposed, will mark it as resolved",
        "createdAt" : "2020-08-20T08:34:28Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def highlight(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): java.util.List[l.DocumentHighlight] = {\n+    val lineOpt = readStacktraceFileLine(path, lineNumber)\n+    lineOpt match {\n+      case Some(line) =>\n+        val from = new l.Position(lineNumber, line.indexOf(\"at \") + 3)\n+        val to = new l.Position(lineNumber, line.indexOf(\"(\"))\n+        val range = new l.Range(from, to)\n+        singletonList(\n+          new l.DocumentHighlight(range, l.DocumentHighlightKind.Read)\n+        )\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    stacktraceLenses(readStacktraceFile(path))\n+  }\n+\n+  private def readStacktraceFileLine(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): Option[String] =\n+    readStacktraceFile(path).drop(lineNumber).headOption\n+\n+  private def readStacktraceFile(path: AbsolutePath): List[String] = {\n+    Source.fromFile(path.toString).getLines().toList\n+  }\n+\n+  def definition(\n+      path: AbsolutePath,\n+      position: l.Position\n+  ): java.util.List[Location] = {\n+    val lineOpt = readStacktraceFileLine(path, position.getLine)\n+    lineOpt match {\n+      case Some(line) =>\n+        getSymbolLocationFromLine(line).toList.asJava\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // number is 1-based, but editors are 0-based"
  },
  {
    "id" : "fdf4d808-5d4f-4031-8dd4-98a2fb4248e5",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "b5b6a7df-845a-406f-8c75-058de566f183",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I don't think you can properly get symbol from stacktrace and the logic will always be flaky. Jumping to the line is enough. For example:\r\n```\r\nException in thread \"main\" java.lang.Exception\r\n\tat Main$.$anonfun$main$1(Main.scala:13)\r\n\tat Main$.$anonfun$main$1$adapted(Main.scala:10)\r\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\r\n\tat Main$.main(Main.scala:10)\r\n\tat Main.main(Main.scala)\r\n```\r\n\r\nIt's not possible to map the full symbol `Main$.$anonfun$main$1` to anything similar in sematicDB. We can only map a part of it, which will make the logic flaky. I would drop going to definition.",
        "createdAt" : "2020-08-14T16:33:47Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d292215a-8523-4a94-b6f3-c7975ab4732b",
        "parentId" : "b5b6a7df-845a-406f-8c75-058de566f183",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Although we could do `toplevelFromLine` and just get the toplevel via:\r\n```scala\r\nprivate def getSymbolFromLine(line: String): String = {\r\n  val toplevel = line.substring(line.indexOf(\"at \") + 3, line.indexOf(\".\"))\r\n  val descriptor = if(toplevel.endsWith(\"$\")) List(Descriptor.Term) else List(Descriptor.Type)\r\n  BuildTargetClasses.symbolFromClassName(toplevel.stripSuffix(\"$\"), descriptor)\r\n}\r\n```\r\n\r\nWe might need to move the method from BuildTargetClasses if it makes sense. It's in the class, so some modification will be needed.",
        "createdAt" : "2020-08-17T17:39:11Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "344cd442-aa8d-472b-b50b-1ef7ec980df9",
        "parentId" : "b5b6a7df-845a-406f-8c75-058de566f183",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "okay dropping",
        "createdAt" : "2020-08-17T17:58:31Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : 138,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def highlight(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): java.util.List[l.DocumentHighlight] = {\n+    val lineOpt = readStacktraceFileLine(path, lineNumber)\n+    lineOpt match {\n+      case Some(line) =>\n+        val from = new l.Position(lineNumber, line.indexOf(\"at \") + 3)\n+        val to = new l.Position(lineNumber, line.indexOf(\"(\"))\n+        val range = new l.Range(from, to)\n+        singletonList(\n+          new l.DocumentHighlight(range, l.DocumentHighlightKind.Read)\n+        )\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    stacktraceLenses(readStacktraceFile(path))\n+  }\n+\n+  private def readStacktraceFileLine(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): Option[String] =\n+    readStacktraceFile(path).drop(lineNumber).headOption\n+\n+  private def readStacktraceFile(path: AbsolutePath): List[String] = {\n+    Source.fromFile(path.toString).getLines().toList\n+  }\n+\n+  def definition(\n+      path: AbsolutePath,\n+      position: l.Position\n+  ): java.util.List[Location] = {\n+    val lineOpt = readStacktraceFileLine(path, position.getLine)\n+    lineOpt match {\n+      case Some(line) =>\n+        getSymbolLocationFromLine(line).toList.asJava\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // number is 1-based, but editors are 0-based\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  private def convert(symbol: String): String = {\n+    val components =\n+      symbol.split('.').map(_.replace(\"$\", \"\").replace(\"<init>\", \"init\")).toList\n+    val scope = components.dropRight(1)\n+    val method = components.last\n+    scope.mkString(\"/\") ++ \".\" ++ method ++ \"().\"\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"$gotoicon open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathStr = path.toFile.toString\n+\n+      path.toFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    definitionProvider.fromSymbol(convert(symbol)).asScala.headOption.map {\n+      location =>\n+        val lineNumberOpt = tryGetLineNumberFromStacktrace(line)\n+        lineNumberOpt.foreach { lineNumber =>\n+          adjustPosition(lineNumber, location.getRange().getStart())\n+          adjustPosition(lineNumber, location.getRange().getEnd())\n+        }\n+        location\n+    }\n+  }\n+\n+  private def getSymbolFromLine(line: String): String = {\n+    line.substring(line.indexOf(\"at \") + 3, line.indexOf(\"(\"))"
  },
  {
    "id" : "743c0e00-584a-46ca-8f53-d6b3c15608cb",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "b375d91e-f30a-489a-90ef-ddf2c2c03a49",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Why won't we just jump to the line? What is the definition location needed for if we adjust it anyway?",
        "createdAt" : "2020-08-14T16:36:56Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6d0357d6-ab3b-4e6d-b7cc-dc42d90e93c4",
        "parentId" : "b375d91e-f30a-489a-90ef-ddf2c2c03a49",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "to find out what file are we talking about",
        "createdAt" : "2020-08-17T17:06:31Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "481de5d7-447c-4230-8c9c-13eea0afb0a5",
        "parentId" : "b375d91e-f30a-489a-90ef-ddf2c2c03a49",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "But we do have that information in the stack trace, no?",
        "createdAt" : "2020-08-17T17:22:05Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0be10e0b-5064-42a5-a06f-ac5e0efd2765",
        "parentId" : "b375d91e-f30a-489a-90ef-ddf2c2c03a49",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "ach, ok I get it now. It's just the name of the file and not the full path, that's why you need it here. ",
        "createdAt" : "2020-08-17T17:33:45Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def highlight(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): java.util.List[l.DocumentHighlight] = {\n+    val lineOpt = readStacktraceFileLine(path, lineNumber)\n+    lineOpt match {\n+      case Some(line) =>\n+        val from = new l.Position(lineNumber, line.indexOf(\"at \") + 3)\n+        val to = new l.Position(lineNumber, line.indexOf(\"(\"))\n+        val range = new l.Range(from, to)\n+        singletonList(\n+          new l.DocumentHighlight(range, l.DocumentHighlightKind.Read)\n+        )\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    stacktraceLenses(readStacktraceFile(path))\n+  }\n+\n+  private def readStacktraceFileLine(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): Option[String] =\n+    readStacktraceFile(path).drop(lineNumber).headOption\n+\n+  private def readStacktraceFile(path: AbsolutePath): List[String] = {\n+    Source.fromFile(path.toString).getLines().toList\n+  }\n+\n+  def definition(\n+      path: AbsolutePath,\n+      position: l.Position\n+  ): java.util.List[Location] = {\n+    val lineOpt = readStacktraceFileLine(path, position.getLine)\n+    lineOpt match {\n+      case Some(line) =>\n+        getSymbolLocationFromLine(line).toList.asJava\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // number is 1-based, but editors are 0-based\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  private def convert(symbol: String): String = {\n+    val components =\n+      symbol.split('.').map(_.replace(\"$\", \"\").replace(\"<init>\", \"init\")).toList\n+    val scope = components.dropRight(1)\n+    val method = components.last\n+    scope.mkString(\"/\") ++ \".\" ++ method ++ \"().\"\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"$gotoicon open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathStr = path.toFile.toString\n+\n+      path.toFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    definitionProvider.fromSymbol(convert(symbol)).asScala.headOption.map {"
  },
  {
    "id" : "5d35a784-01a0-4658-bec1-6d2d82460828",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "6570d293-99f1-48a4-a7a0-aadcd8fa0bdf",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Truncate existing file before? ",
        "createdAt" : "2020-08-14T16:38:20Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d31032ba-cd25-4d0e-bd94-663570391b34",
        "parentId" : "6570d293-99f1-48a4-a7a0-aadcd8fa0bdf",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "it is truncated by `new FileWriter` (by default `apppend=false`)",
        "createdAt" : "2020-08-17T17:56:59Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,227 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+import java.util.Collections.singletonList\n+\n+import scala.io.Source\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    definitionProvider: DefinitionProvider,\n+    gotoicon: String,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def matches(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def highlight(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): java.util.List[l.DocumentHighlight] = {\n+    val lineOpt = readStacktraceFileLine(path, lineNumber)\n+    lineOpt match {\n+      case Some(line) =>\n+        val from = new l.Position(lineNumber, line.indexOf(\"at \") + 3)\n+        val to = new l.Position(lineNumber, line.indexOf(\"(\"))\n+        val range = new l.Range(from, to)\n+        singletonList(\n+          new l.DocumentHighlight(range, l.DocumentHighlightKind.Read)\n+        )\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    stacktraceLenses(readStacktraceFile(path))\n+  }\n+\n+  private def readStacktraceFileLine(\n+      path: AbsolutePath,\n+      lineNumber: Int\n+  ): Option[String] =\n+    readStacktraceFile(path).drop(lineNumber).headOption\n+\n+  private def readStacktraceFile(path: AbsolutePath): List[String] = {\n+    Source.fromFile(path.toString).getLines().toList\n+  }\n+\n+  def definition(\n+      path: AbsolutePath,\n+      position: l.Position\n+  ): java.util.List[Location] = {\n+    val lineOpt = readStacktraceFileLine(path, position.getLine)\n+    lineOpt match {\n+      case Some(line) =>\n+        getSymbolLocationFromLine(line).toList.asJava\n+      case None =>\n+        java.util.Collections.emptyList()\n+    }\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // number is 1-based, but editors are 0-based\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  private def convert(symbol: String): String = {\n+    val components =\n+      symbol.split('.').map(_.replace(\"$\", \"\").replace(\"<init>\", \"init\")).toList\n+    val scope = components.dropRight(1)\n+    val method = components.last\n+    scope.mkString(\"/\") ++ \".\" ++ method ++ \"().\"\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"$gotoicon open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathStr = path.toFile.toString\n+\n+      path.toFile.createNewFile()"
  },
  {
    "id" : "c65b2da3-a58c-46c5-a092-ee75649db22c",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "25f22151-e4e9-40d9-a27d-841d448c0a8e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n  private def setToLineStart(lineNumber: Int, pos: l.Position): Unit = {\r\n```\r\n?",
        "createdAt" : "2020-08-19T13:42:36Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e5a47185-c8a4-435a-81fa-6738e3ff4883",
        "parentId" : "25f22151-e4e9-40d9-a27d-841d448c0a8e",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "changed",
        "createdAt" : "2020-08-20T06:46:14Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {"
  },
  {
    "id" : "dfffe6d1-685c-46c9-8003-73c7dfdef39d",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "aaa4cdcb-3943-46b2-a635-4db7295e93c3",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "If we put everything into multiline comment, there would be no need for any workarounds.\r\nWhat about:\r\n```\r\nfw.write(s\"/*\\n$stacktrace\\n*/\")\r\n```\r\nWe could remove some of the workarounds for MetalsLanguageServer.",
        "createdAt" : "2020-08-19T13:44:59Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4832e5ba-59d2-4d25-b9be-a6e4e403e889",
        "parentId" : "aaa4cdcb-3943-46b2-a635-4db7295e93c3",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "updated and reverted `didOpen` workaround",
        "createdAt" : "2020-08-20T07:37:53Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)"
  },
  {
    "id" : "a4ea8c0c-a9ec-4c2e-85a6-16bb14a58c6b",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "81e1007c-a238-4ece-b697-f5b5dbc4917e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n  private def getFileLocationFromLine(line: String): Option[l.Location] = {\r\n```\r\n?",
        "createdAt" : "2020-08-19T13:45:24Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c1cfc66-8d6a-48cc-b488-e83ddc4aed7c",
        "parentId" : "81e1007c-a238-4ece-b697-f5b5dbc4917e",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "changed",
        "createdAt" : "2020-08-20T06:47:46Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {"
  },
  {
    "id" : "c92de0c9-1f31-422a-924e-b016f26c71a1",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "432416e0-17c8-44d3-9d6e-488ca678caab",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe we could do it in a for comprehension? Would be more in tune with the codebase.",
        "createdAt" : "2020-08-19T13:46:21Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "31fee96d-aa35-4b42-b783-b65c924a5b74",
        "parentId" : "432416e0-17c8-44d3-9d6e-488ca678caab",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "that would work but meant different intent.\r\nI want to find file where a symbol can be found, not do transformations on collection.",
        "createdAt" : "2020-08-20T07:13:21Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0ffefdf5-eb6a-4267-9427-e23ab66aea2b",
        "parentId" : "432416e0-17c8-44d3-9d6e-488ca678caab",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I just meant the map and flatMap below. Might have not been too clear :sweat_smile: ",
        "createdAt" : "2020-08-20T08:26:42Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "92106263-bdf6-44a9-8578-93965e1f3e21",
        "parentId" : "432416e0-17c8-44d3-9d6e-488ca678caab",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "yes but there is headOption in between which is important it has no corresponding action in for-comprehension",
        "createdAt" : "2020-08-20T08:30:24Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ce8bda04-eae8-4106-9841-f8521a1704e1",
        "parentId" : "432416e0-17c8-44d3-9d6e-488ca678caab",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "toToplevelSymbol returns you a list of symbols that should be related to given stacktrace line.\r\nWhat I want here is get first one that is found in semanticdb, get file, update position and return it.\r\nI don't want to map every potential symbol to semanticdb one, update position for every one and in the end return first and drop others that I calculated",
        "createdAt" : "2020-08-20T08:33:30Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d3480dcc-e19f-4ff9-a8e5-c53374159f7e",
        "parentId" : "432416e0-17c8-44d3-9d6e-488ca678caab",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Sure, I was about to write that it's fine to leave it as is. ",
        "createdAt" : "2020-08-20T08:54:13Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    convert(symbol)"
  },
  {
    "id" : "02d5a3a0-fd9d-49c6-9c00-21567bff7007",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "17c03351-ec24-4b3b-89ab-f19c2da6bac7",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n  private def symbolFromLine(line: String): String = {\r\n```\r\nmore Scala like.",
        "createdAt" : "2020-08-19T13:47:11Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "080da169-d7e9-474e-a01e-30978740ea5c",
        "parentId" : "17c03351-ec24-4b3b-89ab-f19c2da6bac7",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "changed",
        "createdAt" : "2020-08-20T06:49:52Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    convert(symbol)\n+      .flatMap(s => definitionProvider.fromSymbol(s).asScala.headOption)\n+      .headOption\n+      .map { location =>\n+        val lineNumberOpt = tryGetLineNumberFromStacktrace(line)\n+        lineNumberOpt.foreach { lineNumber =>\n+          adjustPosition(lineNumber, location.getRange().getStart())\n+          adjustPosition(lineNumber, location.getRange().getEnd())\n+        }\n+        location\n+      }\n+  }\n+\n+  private def getSymbolFromLine(line: String): String = {"
  },
  {
    "id" : "c2d315a8-ca2d-4488-a973-aef17be8f4c2",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "e4d7463b-580b-45f4-8afc-cf58235a9e74",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```\r\nif argObject.isJsonPrimitive\r\narg = argObject.getAsJsonPrimitive()\r\n```\r\n\r\n?",
        "createdAt" : "2020-08-19T13:52:28Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9f99aac7-03d7-4497-8674-59c795a838e0",
        "parentId" : "e4d7463b-580b-45f4-8afc-cf58235a9e74",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "doesn't compile",
        "createdAt" : "2020-08-20T07:18:16Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f7c6c8dd-b075-49ee-baca-53bb3a0cd315",
        "parentId" : "e4d7463b-580b-45f4-8afc-cf58235a9e74",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "ok changed to pattern match",
        "createdAt" : "2020-08-20T07:48:58Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    convert(symbol)\n+      .flatMap(s => definitionProvider.fromSymbol(s).asScala.headOption)\n+      .headOption\n+      .map { location =>\n+        val lineNumberOpt = tryGetLineNumberFromStacktrace(line)\n+        lineNumberOpt.foreach { lineNumber =>\n+          adjustPosition(lineNumber, location.getRange().getStart())\n+          adjustPosition(lineNumber, location.getRange().getEnd())\n+        }\n+        location\n+      }\n+  }\n+\n+  private def getSymbolFromLine(line: String): String = {\n+    line.substring(line.indexOf(\"at \") + 3, line.indexOf(\"(\"))\n+  }\n+\n+  private def makeHtmlCommandParams(\n+      stacktrace: String\n+  ): l.ExecuteCommandParams = {\n+    def htmlStack(builder: HtmlBuilder): Unit = {\n+      for (line <- stacktrace.split('\\n')) {\n+        if (line.contains(\"at \")) {\n+          getSymbolLocationFromLine(line) match {\n+            case Some(location) =>\n+              builder\n+                .text(\"at \")\n+                .link(\n+                  gotoLocationUsingUri(\n+                    location.getUri,\n+                    location.getRange.getStart.getLine\n+                  ),\n+                  line.substring(line.indexOf(\"at \") + 3)\n+                )\n+            case None =>\n+              builder.raw(line)\n+          }\n+        } else {\n+          builder.raw(line)\n+        }\n+        builder.raw(\"<br>\")\n+      }\n+    }\n+\n+    val output = new HtmlBuilder()\n+      .element(\"h3\")(_.text(s\"Stacktrace\"))\n+      .call(htmlStack)\n+      .render\n+    new l.ExecuteCommandParams(\n+      \"metals-show-stacktrace\",\n+      List[Object](output).asJava\n+    )\n+  }\n+\n+  private def gotoLocationUsingUri(uri: String, line: Int): String = {\n+    val param = s\"\"\"[\"${uri}\",${line},true]\"\"\"\n+    s\"command:metals.goto-path-uri?${URLEncoder.encode(param)}\"\n+  }\n+\n+  private def parseJsonParams(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[String] = {\n+    for {\n+      args <- Option(commandParams.getArguments)\n+      argObject <- args.asScala.headOption"
  },
  {
    "id" : "d93d205e-80ed-43e8-afa4-3c03f133e192",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "cf4b17cb-cd66-4eb3-9729-31023d547f41",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe just inline the method? It's only used once.",
        "createdAt" : "2020-08-19T13:54:38Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "38293c3d-f8bd-44db-af18-ef5c67469583",
        "parentId" : "cf4b17cb-cd66-4eb3-9729-31023d547f41",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "inlined",
        "createdAt" : "2020-08-20T07:19:16Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    convert(symbol)\n+      .flatMap(s => definitionProvider.fromSymbol(s).asScala.headOption)\n+      .headOption\n+      .map { location =>\n+        val lineNumberOpt = tryGetLineNumberFromStacktrace(line)\n+        lineNumberOpt.foreach { lineNumber =>\n+          adjustPosition(lineNumber, location.getRange().getStart())\n+          adjustPosition(lineNumber, location.getRange().getEnd())\n+        }\n+        location\n+      }\n+  }\n+\n+  private def getSymbolFromLine(line: String): String = {\n+    line.substring(line.indexOf(\"at \") + 3, line.indexOf(\"(\"))\n+  }\n+\n+  private def makeHtmlCommandParams(\n+      stacktrace: String\n+  ): l.ExecuteCommandParams = {\n+    def htmlStack(builder: HtmlBuilder): Unit = {\n+      for (line <- stacktrace.split('\\n')) {\n+        if (line.contains(\"at \")) {\n+          getSymbolLocationFromLine(line) match {\n+            case Some(location) =>\n+              builder\n+                .text(\"at \")\n+                .link(\n+                  gotoLocationUsingUri(\n+                    location.getUri,\n+                    location.getRange.getStart.getLine\n+                  ),\n+                  line.substring(line.indexOf(\"at \") + 3)\n+                )\n+            case None =>\n+              builder.raw(line)\n+          }\n+        } else {\n+          builder.raw(line)\n+        }\n+        builder.raw(\"<br>\")\n+      }\n+    }\n+\n+    val output = new HtmlBuilder()\n+      .element(\"h3\")(_.text(s\"Stacktrace\"))\n+      .call(htmlStack)\n+      .render\n+    new l.ExecuteCommandParams(\n+      \"metals-show-stacktrace\",\n+      List[Object](output).asJava\n+    )\n+  }\n+\n+  private def gotoLocationUsingUri(uri: String, line: Int): String = {\n+    val param = s\"\"\"[\"${uri}\",${line},true]\"\"\"\n+    s\"command:metals.goto-path-uri?${URLEncoder.encode(param)}\"\n+  }\n+\n+  private def parseJsonParams(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[String] = {\n+    for {\n+      args <- Option(commandParams.getArguments)\n+      argObject <- args.asScala.headOption\n+      arg = argObject.asInstanceOf[JsonPrimitive]\n+      if arg.isString()\n+      stacktrace = arg.getAsString()\n+    } yield stacktrace\n+  }\n+}\n+\n+object StacktraceAnalyzer {\n+\n+  def convert(symbolIn: String): List[String] = {\n+    def removeMethodPartFromSymbol(s: String) = s.split('.').init.mkString(\"/\")\n+    val symbol = removeMethodPartFromSymbol(symbolIn)"
  },
  {
    "id" : "2d741e04-ff6e-4e0d-8734-20f7317de4fe",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "0e9db67c-8b1f-468f-af02-8c29745b84fa",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n  def toToplevelSymbol(symbolIn: String): List[String] = {\r\n```\r\n?",
        "createdAt" : "2020-08-19T14:19:32Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "457f04a0-124c-44b3-8b08-247840c89d04",
        "parentId" : "0e9db67c-8b1f-468f-af02-8c29745b84fa",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "renamed",
        "createdAt" : "2020-08-20T07:19:06Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)\n+      Some(makeGotoCommandParams(location))\n+    }\n+  }\n+\n+  private def makeGotoCommandParams(\n+      location: Location\n+  ): l.ExecuteCommandParams = {\n+    new l.ExecuteCommandParams(\n+      ClientCommands.GotoLocation.id,\n+      List[Object](location, java.lang.Boolean.TRUE).asJava\n+    )\n+  }\n+\n+  private def getSymbolLocationFromLine(line: String): Option[l.Location] = {\n+    val symbol = getSymbolFromLine(line)\n+    convert(symbol)\n+      .flatMap(s => definitionProvider.fromSymbol(s).asScala.headOption)\n+      .headOption\n+      .map { location =>\n+        val lineNumberOpt = tryGetLineNumberFromStacktrace(line)\n+        lineNumberOpt.foreach { lineNumber =>\n+          adjustPosition(lineNumber, location.getRange().getStart())\n+          adjustPosition(lineNumber, location.getRange().getEnd())\n+        }\n+        location\n+      }\n+  }\n+\n+  private def getSymbolFromLine(line: String): String = {\n+    line.substring(line.indexOf(\"at \") + 3, line.indexOf(\"(\"))\n+  }\n+\n+  private def makeHtmlCommandParams(\n+      stacktrace: String\n+  ): l.ExecuteCommandParams = {\n+    def htmlStack(builder: HtmlBuilder): Unit = {\n+      for (line <- stacktrace.split('\\n')) {\n+        if (line.contains(\"at \")) {\n+          getSymbolLocationFromLine(line) match {\n+            case Some(location) =>\n+              builder\n+                .text(\"at \")\n+                .link(\n+                  gotoLocationUsingUri(\n+                    location.getUri,\n+                    location.getRange.getStart.getLine\n+                  ),\n+                  line.substring(line.indexOf(\"at \") + 3)\n+                )\n+            case None =>\n+              builder.raw(line)\n+          }\n+        } else {\n+          builder.raw(line)\n+        }\n+        builder.raw(\"<br>\")\n+      }\n+    }\n+\n+    val output = new HtmlBuilder()\n+      .element(\"h3\")(_.text(s\"Stacktrace\"))\n+      .call(htmlStack)\n+      .render\n+    new l.ExecuteCommandParams(\n+      \"metals-show-stacktrace\",\n+      List[Object](output).asJava\n+    )\n+  }\n+\n+  private def gotoLocationUsingUri(uri: String, line: Int): String = {\n+    val param = s\"\"\"[\"${uri}\",${line},true]\"\"\"\n+    s\"command:metals.goto-path-uri?${URLEncoder.encode(param)}\"\n+  }\n+\n+  private def parseJsonParams(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[String] = {\n+    for {\n+      args <- Option(commandParams.getArguments)\n+      argObject <- args.asScala.headOption\n+      arg = argObject.asInstanceOf[JsonPrimitive]\n+      if arg.isString()\n+      stacktrace = arg.getAsString()\n+    } yield stacktrace\n+  }\n+}\n+\n+object StacktraceAnalyzer {\n+\n+  def convert(symbolIn: String): List[String] = {"
  },
  {
    "id" : "919a904f-c8f4-4fe3-a0c0-977a7f13ad90",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "a7fc3604-8f59-4d90-b8cf-b87e0b27e4cc",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n      val stackTraceLocation = new l.Location(pathStr, range)\r\n```",
        "createdAt" : "2020-08-19T14:21:04Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "75e11163-da37-4725-ae72-acaa6f8246ec",
        "parentId" : "a7fc3604-8f59-4d90-b8cf-b87e0b27e4cc",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "renamed",
        "createdAt" : "2020-08-20T07:20:21Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)\n+      val range = new l.Range(pos, pos)\n+      val location = new l.Location(pathStr, range)"
  },
  {
    "id" : "098f9b70-41d3-4ed2-b7cf-d98b7d148bfe",
    "prId" : 1966,
    "comments" : [
      {
        "id" : "795c2e56-8495-47cb-9cce-566aa2553575",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```suggestion\r\n      val fileStartPos = new l.Position(0, 0)\r\n```",
        "createdAt" : "2020-08-19T14:22:45Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fbb9e7d1-f683-4a7d-a226-c58cd853a822",
        "parentId" : "795c2e56-8495-47cb-9cce-566aa2553575",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "renamed",
        "createdAt" : "2020-08-20T07:20:46Z",
        "updatedAt" : "2020-08-20T09:03:33Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f7e1db4a0dcdfe6522e0116b20085a2f3f04584",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,211 @@\n+package scala.meta.internal.metals\n+\n+import java.io.FileWriter\n+import java.net.URLEncoder\n+\n+import scala.util.Try\n+\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.metals.StacktraceAnalyzer._\n+import scala.meta.io.AbsolutePath\n+\n+import com.google.gson.JsonPrimitive\n+import org.eclipse.lsp4j.Location\n+import org.eclipse.{lsp4j => l}\n+\n+class StacktraceAnalyzer(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    definitionProvider: DefinitionProvider,\n+    icons: Icons,\n+    commandsInHtmlSupported: Boolean\n+) {\n+\n+  def analyzeCommand(\n+      commandParams: l.ExecuteCommandParams\n+  ): Option[l.ExecuteCommandParams] = {\n+    parseJsonParams(commandParams)\n+      .flatMap(analyzeStackTrace)\n+  }\n+\n+  def isStackTraceFile(path: AbsolutePath): Boolean =\n+    path == workspace.resolve(Directories.stacktrace)\n+\n+  def stacktraceLenses(path: AbsolutePath): Seq[l.CodeLens] = {\n+    readStacktraceFile(path)\n+      .map(stacktraceLenses)\n+      .getOrElse(Seq.empty)\n+  }\n+\n+  private def readStacktraceFile(path: AbsolutePath): Option[List[String]] = {\n+    buffers.get(path).map(_.split('\\n').toList)\n+  }\n+\n+  private def adjustPosition(lineNumber: Int, pos: l.Position): Unit = {\n+    pos.setLine(lineNumber)\n+    pos.setCharacter(0)\n+  }\n+\n+  private def tryGetLineNumberFromStacktrace(line: String): Try[Int] = {\n+    Try(\n+      // stacktrace line numbers are 1-based but line numbers in LSP protocol are 0-based.\n+      // line number from stacktrace will be used in LSP message that's why \"-1\"\n+      Integer.valueOf(\n+        line.substring(line.indexOf(\":\") + 1, line.indexOf(\")\"))\n+      ) - 1\n+    )\n+  }\n+\n+  def stacktraceLenses(content: List[String]): Seq[l.CodeLens] = {\n+    (for {\n+      (line, row) <- content.zipWithIndex\n+      if line.trim.startsWith(\"at \")\n+      location <- getSymbolLocationFromLine(line)\n+      range = new l.Range(new l.Position(row, 0), new l.Position(row, 0))\n+    } yield makeGotoLocationCodeLens(location, range)).toSeq\n+  }\n+\n+  private def makeGotoLocationCodeLens(\n+      location: l.Location,\n+      range: l.Range\n+  ): l.CodeLens = {\n+    new l.CodeLens(\n+      range,\n+      new l.Command(\n+        s\"${icons.findsuper} open\",\n+        ServerCommands.GotoLocationForPosition.id,\n+        List[Object](location: Object, java.lang.Boolean.TRUE).asJava\n+      ),\n+      null\n+    )\n+  }\n+\n+  private def analyzeStackTrace(\n+      stacktrace: String\n+  ): Option[l.ExecuteCommandParams] = {\n+    if (commandsInHtmlSupported) {\n+      Some(makeHtmlCommandParams(stacktrace))\n+    } else {\n+      val path = workspace.resolve(Directories.stacktrace)\n+      val pathFile = path.toFile\n+      val pathStr = pathFile.toString\n+\n+      pathFile.createNewFile()\n+      val fw = new FileWriter(pathStr)\n+      try {\n+        fw.write(stacktrace)\n+      } finally {\n+        fw.close()\n+      }\n+      val pos = new l.Position(0, 0)"
  }
]