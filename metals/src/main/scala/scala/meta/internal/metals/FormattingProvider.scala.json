[
  {
    "id" : "a8b1efd8-5dd3-4b28-a47d-709ae07fc870",
    "prId" : 429,
    "comments" : [
      {
        "id" : "9bf5e092-81a0-4323-8b8b-0597cb974277",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "These errors may be noisy, since they are triggered even when trying to format a non-parsing buffer. I'm open to suggestions.",
        "createdAt" : "2018-12-19T18:19:01Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9ed37a01-7789-41e1-99d8-3b1ef73ced8c",
        "parentId" : "9bf5e092-81a0-4323-8b8b-0597cb974277",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This should be enough\r\n```scala\r\nscribe.error(s\"scalafmt error: ${e.getMessage}\")\r\n```",
        "createdAt" : "2018-12-20T08:33:33Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,93 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    (for {\n+      scalafmt <- classloadedScalafmt\n+      formatted <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          scalafmt\n+            .format(input.text, configPath.toString, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case None if !userConfig().scalafmtRequireConfigFile =>\n+          scalafmt\n+            .format(input.text, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)"
  },
  {
    "id" : "6d84738e-3206-4927-aa92-43e3f900a1f9",
    "prId" : 429,
    "comments" : [
      {
        "id" : "17206bb6-0c45-4b91-958e-20c66a9f7b5d",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I know nothing about \"classloading best practices\", so I just blindly ported the implementation we had for 0.1.0.\r\n\r\nThere may be better ways to do this.",
        "createdAt" : "2018-12-19T18:20:21Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5afde2c2-5a0e-41e2-8ee4-382e02ad203a",
        "parentId" : "17206bb6-0c45-4b91-958e-20c66a9f7b5d",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This should not be a `val` since the scalafmt version may change. I would make it a `Collections.synchronizedMap[String, Scalafmt]` and fetch on demand. This means the first formatting request may take a while, but we don't slow down server startup.",
        "createdAt" : "2018-12-20T09:47:01Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "845098b7-ee61-4336-95e8-2a36d82fe62a",
        "parentId" : "17206bb6-0c45-4b91-958e-20c66a9f7b5d",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I thought about this, and I assumed it would be ok to restart the server if the Scalafmt version changes.\r\n\r\nThis is actually a nicer idea. I'll work on it üëç ",
        "createdAt" : "2018-12-20T09:48:33Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "64e4bda1-07bd-4a69-a477-4e1a8e5b8541",
        "parentId" : "17206bb6-0c45-4b91-958e-20c66a9f7b5d",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Most critically, we should not slow down server startup by downloading Scalafmt. Only classload it if used.",
        "createdAt" : "2018-12-20T09:52:35Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,93 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    (for {\n+      scalafmt <- classloadedScalafmt\n+      formatted <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          scalafmt\n+            .format(input.text, configPath.toString, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case None if !userConfig().scalafmtRequireConfigFile =>\n+          scalafmt\n+            .format(input.text, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case _ =>\n+          scribe.info(\n+            \"Skipping formatting request because no Scalafmt config file is present\"\n+          )\n+          None\n+      }\n+    } yield {\n+      List(new l.TextEdit(fullDocumentRange, formatted))\n+    }).getOrElse(Nil).asJava\n+  }\n+\n+  private def scalafmtConfigPath: Option[AbsolutePath] = {\n+    val relativePath =\n+      userConfig().scalafmtConfigPath.getOrElse(\".scalafmt.conf\")\n+    Some(workspace.resolve(relativePath))\n+      .filter(path => Files.isRegularFile(path.toNIO))\n+  }\n+\n+  private val classloadedScalafmt: Option[Scalafmt] = {"
  },
  {
    "id" : "4719f79d-853e-451d-bc6e-4e6b4ae1d257",
    "prId" : 429,
    "comments" : [
      {
        "id" : "367a5d68-54a8-4586-9a0d-4677a550aa4b",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Note. I'm not sure anymore if this is the best reflective API. I think the spotless implementation for Gradle might be more robust https://github.com/diffplug/spotless/blob/9ff51754f13d94731f715b9f302a4de606f3f62d/lib/src/main/java/com/diffplug/spotless/scala/ScalaFmtStep.java#L71-L125 I wish scalafmt had the same nice story for reflective invocation as scalafix üòè \r\n\r\nAnyways, I think this is fine for now. I'm tempted to add a nice reflective API in Scalafmt and then we can use that for newer versions.",
        "createdAt" : "2018-12-20T09:03:50Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : 158,
    "diffHunk" : "@@ -0,0 +1,93 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    (for {\n+      scalafmt <- classloadedScalafmt\n+      formatted <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          scalafmt\n+            .format(input.text, configPath.toString, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case None if !userConfig().scalafmtRequireConfigFile =>\n+          scalafmt\n+            .format(input.text, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case _ =>\n+          scribe.info(\n+            \"Skipping formatting request because no Scalafmt config file is present\"\n+          )\n+          None\n+      }\n+    } yield {\n+      List(new l.TextEdit(fullDocumentRange, formatted))\n+    }).getOrElse(Nil).asJava\n+  }\n+\n+  private def scalafmtConfigPath: Option[AbsolutePath] = {\n+    val relativePath =\n+      userConfig().scalafmtConfigPath.getOrElse(\".scalafmt.conf\")\n+    Some(workspace.resolve(relativePath))\n+      .filter(path => Files.isRegularFile(path.toNIO))\n+  }\n+\n+  private val classloadedScalafmt: Option[Scalafmt] = {\n+    embedded.scalafmtJars match {\n+      case Some(classloader) =>\n+        type Scalafmt210 = {\n+          def format(code: String, configFile: String, filename: String): String\n+          def format(code: String, filename: String): String\n+        }\n+        val scalafmt210 = classloader\n+          .loadClass(\"org.scalafmt.cli.Scalafmt210\")"
  },
  {
    "id" : "600f8059-cb4d-458d-8383-11cbbde5896c",
    "prId" : 429,
    "comments" : [
      {
        "id" : "5b940ed4-73bf-46ae-a2e1-ad4e08c5d3cd",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We can remove this, it's not used.",
        "createdAt" : "2018-12-20T09:47:44Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,93 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    (for {\n+      scalafmt <- classloadedScalafmt\n+      formatted <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          scalafmt\n+            .format(input.text, configPath.toString, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case None if !userConfig().scalafmtRequireConfigFile =>\n+          scalafmt\n+            .format(input.text, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case _ =>\n+          scribe.info(\n+            \"Skipping formatting request because no Scalafmt config file is present\"\n+          )\n+          None\n+      }\n+    } yield {\n+      List(new l.TextEdit(fullDocumentRange, formatted))\n+    }).getOrElse(Nil).asJava\n+  }\n+\n+  private def scalafmtConfigPath: Option[AbsolutePath] = {\n+    val relativePath =\n+      userConfig().scalafmtConfigPath.getOrElse(\".scalafmt.conf\")\n+    Some(workspace.resolve(relativePath))\n+      .filter(path => Files.isRegularFile(path.toNIO))\n+  }\n+\n+  private val classloadedScalafmt: Option[Scalafmt] = {\n+    embedded.scalafmtJars match {\n+      case Some(classloader) =>\n+        type Scalafmt210 = {\n+          def format(code: String, configFile: String, filename: String): String\n+          def format(code: String, filename: String): String\n+        }\n+        val scalafmt210 = classloader\n+          .loadClass(\"org.scalafmt.cli.Scalafmt210\")\n+          .newInstance()\n+          .asInstanceOf[Scalafmt210]\n+        Some(new Scalafmt {\n+          def format(\n+              code: String,\n+              configFile: String,\n+              filename: String\n+          ): Try[String] =\n+            Try(scalafmt210.format(code, configFile, filename))\n+          def format(code: String, filename: String): Try[String] ="
  },
  {
    "id" : "09543bb7-51b3-466d-82d8-1e4b12a83345",
    "prId" : 429,
    "comments" : [
      {
        "id" : "5e1db6a7-6e07-4050-8909-4dc7e8d77cc0",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "After each formatting request, we should also clear  `scala.meta.internal.tokenizers.PlatformTokenizerCache.megaCache` https://github.com/scalameta/scalameta/issues/1068 to avoid holding onto a lot of memory. This is a tragedy ü§¶‚Äç‚ôÇÔ∏è ",
        "createdAt" : "2018-12-20T09:48:58Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,93 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    (for {\n+      scalafmt <- classloadedScalafmt\n+      formatted <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          scalafmt\n+            .format(input.text, configPath.toString, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case None if !userConfig().scalafmtRequireConfigFile =>\n+          scalafmt\n+            .format(input.text, input.path)\n+            .fold(e => {\n+              scribe.error(\"Error while running Scalafmt\", e)\n+              None\n+            }, Some(_))\n+        case _ =>\n+          scribe.info(\n+            \"Skipping formatting request because no Scalafmt config file is present\"\n+          )\n+          None\n+      }\n+    } yield {\n+      List(new l.TextEdit(fullDocumentRange, formatted))\n+    }).getOrElse(Nil).asJava\n+  }\n+\n+  private def scalafmtConfigPath: Option[AbsolutePath] = {\n+    val relativePath =\n+      userConfig().scalafmtConfigPath.getOrElse(\".scalafmt.conf\")\n+    Some(workspace.resolve(relativePath))\n+      .filter(path => Files.isRegularFile(path.toNIO))\n+  }\n+\n+  private val classloadedScalafmt: Option[Scalafmt] = {\n+    embedded.scalafmtJars match {\n+      case Some(classloader) =>\n+        type Scalafmt210 = {\n+          def format(code: String, configFile: String, filename: String): String\n+          def format(code: String, filename: String): String\n+        }\n+        val scalafmt210 = classloader\n+          .loadClass(\"org.scalafmt.cli.Scalafmt210\")\n+          .newInstance()\n+          .asInstanceOf[Scalafmt210]\n+        Some(new Scalafmt {\n+          def format(\n+              code: String,\n+              configFile: String,\n+              filename: String\n+          ): Try[String] =\n+            Try(scalafmt210.format(code, configFile, filename))"
  },
  {
    "id" : "8e248d8d-10c1-41c5-8fc2-7eb0bd58f16a",
    "prId" : 429,
    "comments" : [
      {
        "id" : "6a51cf31-3663-494c-b73c-8e3d49d027b3",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nit: log entries start with lowercase `scalafmt error` by convention",
        "createdAt" : "2018-12-20T15:32:47Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,91 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+import scala.meta.internal.tokenizers.PlatformTokenizerCache\n+import com.typesafe.config.ConfigFactory\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    val defaultScalafmtVersion = \"1.5.1\"\n+    (for {\n+      scalafmt <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          val scalafmtConf = ConfigFactory.parseFile(configPath.toNIO.toFile)\n+          val scalafmtVersion = Try(scalafmtConf.getString(\"version\")).toOption\n+            .getOrElse(defaultScalafmtVersion)\n+          classloadScalafmt(scalafmtVersion)\n+        case _ =>\n+          scribe.info(\n+            \"Skipping formatting request because no Scalafmt config file is present\"\n+          )\n+          None\n+      }\n+      configPath <- scalafmtConfigPath\n+      formatted <- scalafmt\n+        .format(input.text, configPath.toString, input.path)\n+        .fold(e => {\n+          scribe.error(s\"Scalafmt error: ${e.getMessage}\")"
  },
  {
    "id" : "cd11f6db-71d2-4b6e-af22-d469eb1b194f",
    "prId" : 429,
    "comments" : [
      {
        "id" : "ac80daf0-34cb-4984-8b21-fa1dccc68f52",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "`filter(_.isFile)`",
        "createdAt" : "2018-12-20T15:33:12Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,91 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+import scala.meta.internal.tokenizers.PlatformTokenizerCache\n+import com.typesafe.config.ConfigFactory\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    val defaultScalafmtVersion = \"1.5.1\"\n+    (for {\n+      scalafmt <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          val scalafmtConf = ConfigFactory.parseFile(configPath.toNIO.toFile)\n+          val scalafmtVersion = Try(scalafmtConf.getString(\"version\")).toOption\n+            .getOrElse(defaultScalafmtVersion)\n+          classloadScalafmt(scalafmtVersion)\n+        case _ =>\n+          scribe.info(\n+            \"Skipping formatting request because no Scalafmt config file is present\"\n+          )\n+          None\n+      }\n+      configPath <- scalafmtConfigPath\n+      formatted <- scalafmt\n+        .format(input.text, configPath.toString, input.path)\n+        .fold(e => {\n+          scribe.error(s\"Scalafmt error: ${e.getMessage}\")\n+          None\n+        }, Some(_))\n+    } yield {\n+      List(new l.TextEdit(fullDocumentRange, formatted))\n+    }).getOrElse(Nil).asJava\n+  }\n+\n+  private def scalafmtConfigPath: Option[AbsolutePath] = {\n+    Some(workspace.resolve(userConfig().scalafmtConfigPath))\n+      .filter(path => Files.isRegularFile(path.toNIO))"
  },
  {
    "id" : "89d7493c-4d8a-4be2-b9ed-fff7ef44b92f",
    "prId" : 429,
    "comments" : [
      {
        "id" : "9376e8f7-eefd-4c3f-b6cc-7b4d0e272d35",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Might want to wrap in `Try` here, it throws on parse error.",
        "createdAt" : "2018-12-20T15:35:34Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,91 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+import scala.meta.internal.tokenizers.PlatformTokenizerCache\n+import com.typesafe.config.ConfigFactory\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    val defaultScalafmtVersion = \"1.5.1\"\n+    (for {\n+      scalafmt <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          val scalafmtConf = ConfigFactory.parseFile(configPath.toNIO.toFile)"
  },
  {
    "id" : "e0c1c745-4c10-459f-bc55-68f93e5a212f",
    "prId" : 429,
    "comments" : [
      {
        "id" : "2a362803-b18e-4925-a084-8a7267dcf717",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "```scala\r\nscribe.error(\"format error: no .scalafmt.conf file (To fix this problem create an empty file $abspath)\")\r\n```\r\nWe should also do a `showMessageRequest` with text\r\n\r\n> Unable to format because there is no `.scalafmt.conf` file in this workspace. To fix this problem create an empty file in $path.\r\n\r\nWe can add a button \"Create .scalafmt.conf\" that writes to that file.",
        "createdAt" : "2018-12-20T15:36:59Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,91 @@\n+package scala.meta.internal.metals\n+\n+import scala.meta._\n+import org.eclipse.{lsp4j => l}\n+import MetalsEnrichments._\n+import scala.language.reflectiveCalls\n+import java.util\n+import java.nio.file.Files\n+import scala.util.Try\n+import scala.meta.internal.tokenizers.PlatformTokenizerCache\n+import com.typesafe.config.ConfigFactory\n+\n+/**\n+ * Implement text formatting using Scalafmt\n+ */\n+final class FormattingProvider(\n+    workspace: AbsolutePath,\n+    buffers: Buffers,\n+    embedded: Embedded,\n+    userConfig: () => UserConfiguration\n+) {\n+\n+  def format(path: AbsolutePath): util.List[l.TextEdit] = {\n+    val input = path.toInputFromBuffers(buffers)\n+    val fullDocumentRange = Position.Range(input, 0, input.chars.length).toLSP\n+    val defaultScalafmtVersion = \"1.5.1\"\n+    (for {\n+      scalafmt <- scalafmtConfigPath match {\n+        case Some(configPath) =>\n+          val scalafmtConf = ConfigFactory.parseFile(configPath.toNIO.toFile)\n+          val scalafmtVersion = Try(scalafmtConf.getString(\"version\")).toOption\n+            .getOrElse(defaultScalafmtVersion)\n+          classloadScalafmt(scalafmtVersion)\n+        case _ =>\n+          scribe.info("
  },
  {
    "id" : "d5dedae6-10bb-44a3-8be2-c6836b7cbd09",
    "prId" : 429,
    "comments" : [
      {
        "id" : "a4d05491-57e5-40ac-99b8-e6ff02de6a44",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nit, is the tuple necessary? seems possible to declare them separately",
        "createdAt" : "2018-12-22T10:13:13Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -51,6 +51,18 @@ final class FormattingProvider(\n         if (config.hasPath(\"version\")) config.getString(\"version\")\n         else defaultScalafmtVersion\n       }\n+      (includeFilters, excludeFilters) = {"
  },
  {
    "id" : "12609a3f-54fa-44b7-8b75-a6e7ec8506df",
    "prId" : 429,
    "comments" : [
      {
        "id" : "5d69137c-d4ed-4d64-9e89-dd01fbb9c741",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "nit: there's no benefit to making this a val, both become methods while vals create an additional field",
        "createdAt" : "2018-12-22T10:22:21Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : null,
    "diffHunk" : "@@ -32,7 +32,8 @@ final class FormattingProvider(\n     icons: Icons\n )(implicit ec: ExecutionContext) {\n \n-  private def defaultScalafmtVersion = \"1.5.1\"\n+  private val defaultScalafmtVersion = \"1.5.1\""
  },
  {
    "id" : "439d34fa-e813-4bc1-aa2c-42618f23b6f2",
    "prId" : 436,
    "comments" : [
      {
        "id" : "3bb43cca-c52d-4846-a1d9-7e9b3d23587b",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nit, I generally try to break up long strings like this at the sentence boundary ",
        "createdAt" : "2018-12-22T12:30:08Z",
        "updatedAt" : "2018-12-22T12:46:39Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "60eb507b658d900f2d1ec18de2b89aff37d0d22a",
    "line" : null,
    "diffHunk" : "@@ -63,7 +63,17 @@ final class FormattingProvider(\n           config.getStringList(\"project.excludeFilters\").asScala\n         else Nil\n       }\n-      if FilterMatcher(includeFilters, excludeFilters).matches(path.toString)\n+      if {\n+        val shouldSkip =\n+          FilterMatcher(includeFilters, excludeFilters).matches(path.toString)\n+        if (shouldSkip) {\n+          scribe.info(\n+            s\"skipping format request for ${path.toRelative(workspace)}. To fix this, update project.excludeFilters or project.includeFilters in ${confPath"
  },
  {
    "id" : "8806d7c1-302d-403a-8d1b-f13796b6f6e3",
    "prId" : 1607,
    "comments" : [
      {
        "id" : "3ec18969-3573-44f8-ae06-8cb60bc39eff",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This var won't persist if the Metals server restarts. Normally we implement \"Don't show again\" by persisting the user's request in a sql database. Example: https://github.com/scalameta/metals/blob/e2320b5b4d7f365c6064ccc3ecb2a105b579a109/metals/src/main/scala/scala/meta/internal/metals/DismissedNotifications.scala",
        "createdAt" : "2020-04-14T10:15:21Z",
        "updatedAt" : "2020-05-03T16:38:04Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "68ff219d-7743-4545-8c62-28916db4104f",
        "parentId" : "3ec18969-3573-44f8-ae06-8cb60bc39eff",
        "author" : {
          "login" : "takezoe",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1094760?u=1a1d6e25860d003717486a151f6a8d70c35efa35&v=4"
        },
        "body" : "That's intentional behavior. If we persist it, we have to provide a way to re-enable it too. So, I thought asking once in each session would be better. I didn't know that we can configure formatting behavior per workspace.",
        "createdAt" : "2020-04-14T13:34:37Z",
        "updatedAt" : "2020-05-03T16:38:04Z",
        "lastEditedBy" : {
          "login" : "takezoe",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1094760?u=1a1d6e25860d003717486a151f6a8d70c35efa35&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e8f884c5-d981-4002-be13-4842ab8ab7b3",
        "parentId" : "3ec18969-3573-44f8-ae06-8cb60bc39eff",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It can be unexpected for the user to select \"Don't show again\", restart VS Code and then get the .scalafmt.conf prompt again.\r\n\r\nI agree it would be nice to have a way to re-enable prompts where the user selected \"Don't show again\", the only way to achieve that right now is to `rm -rf .metals`. This functionality be implemented separately from this PR and it would then work for all \"Don't show again\" prompts.",
        "createdAt" : "2020-04-14T15:07:21Z",
        "updatedAt" : "2020-05-03T16:38:04Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "66dec3b5-23b6-4e6e-b61f-b703a0c12a95",
        "parentId" : "3ec18969-3573-44f8-ae06-8cb60bc39eff",
        "author" : {
          "login" : "takezoe",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1094760?u=1a1d6e25860d003717486a151f6a8d70c35efa35&v=4"
        },
        "body" : "How about changing the behavior of  \"Not now\"? Being asked every time when I save files even after selecting \"Not now\" is annoying. I just want to avoid it.",
        "createdAt" : "2020-04-19T04:01:32Z",
        "updatedAt" : "2020-05-03T16:38:04Z",
        "lastEditedBy" : {
          "login" : "takezoe",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1094760?u=1a1d6e25860d003717486a151f6a8d70c35efa35&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c324ef0-0143-44e4-881f-d9e7f7be1235",
        "parentId" : "3ec18969-3573-44f8-ae06-8cb60bc39eff",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We also use the SQL database to handle \"Not now\" responses to dismiss this prompt for a X number of minutes. For example, here we handle \"Not now\" for the \"Import build\" prompt https://github.com/scalameta/metals/blob/abca8703638fe2768e0058288ae0e3decbe42e07/metals/src/main/scala/scala/meta/internal/metals/BloopInstall.scala#L163\r\n\r\n> Being asked every time when I save files even after selecting \"Not now\" is annoying. I just want to avoid it.\r\n\r\nI agree this is annoying and I'm open to merge this feature but I'm not convinced it's a reliable fix to store this state in the Metals server process because that means the user gets the prompt again when they restart Metals. The reliable fix for this problem is to use the SQL table, which is consistent with how we handle other prompts ",
        "createdAt" : "2020-04-20T11:52:27Z",
        "updatedAt" : "2020-05-03T16:38:04Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "842a7083-8406-43f5-9610-d80a6a2c5385",
        "parentId" : "3ec18969-3573-44f8-ae06-8cb60bc39eff",
        "author" : {
          "login" : "takezoe",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1094760?u=1a1d6e25860d003717486a151f6a8d70c35efa35&v=4"
        },
        "body" : "I got your point. Will keep working on this. Thanks for your advice.",
        "createdAt" : "2020-04-20T14:53:35Z",
        "updatedAt" : "2020-05-03T16:38:04Z",
        "lastEditedBy" : {
          "login" : "takezoe",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1094760?u=1a1d6e25860d003717486a151f6a8d70c35efa35&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c0426de1e26f622e404560ea04b882331e8c8274",
    "line" : null,
    "diffHunk" : "@@ -158,21 +158,28 @@ final class FormattingProvider(\n     }\n   }\n \n+  private var dontAskFileCreation: Boolean = false"
  },
  {
    "id" : "d343269e-24d3-4598-b2e2-fb5a9d47d8f9",
    "prId" : 1851,
    "comments" : [
      {
        "id" : "e186f58e-6b70-4fb6-970b-0775138b623d",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "No interesting logs will be shown here. And even in case of an error, the log will be hidden afterwards. This operation is normally too quick to make sense to open the logs.",
        "createdAt" : "2020-06-24T16:00:52Z",
        "updatedAt" : "2020-06-24T16:01:21Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5a519594c3cabaa8b154b73270439bbfecfe6f5b",
    "line" : 4,
    "diffHunk" : "@@ -271,6 +271,7 @@ final class FormattingProvider(\n       downloadingScalafmt = Promise()\n       statusBar.trackSlowFuture(\n         \"Loading Scalafmt\",\n+        quietLogs = true,"
  }
]