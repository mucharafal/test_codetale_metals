[
  {
    "id" : "5343da06-1285-4280-bdd8-ec9767af64e8",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "77355ed4-0ae1-4b68-a2ac-253b6ecb85ea",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Extract to a method?",
        "createdAt" : "2020-03-12T12:17:48Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,285 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.metals.CodeLensProvider.LensGoSuperCache\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.implementation.SuperMethodProvider._\n+import scala.meta.internal.semanticdb.TypeSignature\n+\n+class SuperMethodProvider() {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {"
  },
  {
    "id" : "cb66b9e1-7b38-435e-9fb1-b47a506c04fe",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "b390c93c-4324-49bd-88b3-bf771ed67f0c",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`methodSlink` -> `methodSymbolLink` ? Let's use full names. And also below.",
        "createdAt" : "2020-03-12T12:20:12Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,285 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.metals.CodeLensProvider.LensGoSuperCache\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.implementation.SuperMethodProvider._\n+import scala.meta.internal.semanticdb.TypeSignature\n+\n+class SuperMethodProvider() {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSlink =>"
  },
  {
    "id" : "17081920-b444-44a3-8690-5af4d9a4028d",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "07824c7e-0f1c-45e7-aa40-a0889152d493",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Join the two filers?",
        "createdAt" : "2020-03-12T12:21:28Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,285 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.metals.CodeLensProvider.LensGoSuperCache\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.implementation.SuperMethodProvider._\n+import scala.meta.internal.semanticdb.TypeSignature\n+\n+class SuperMethodProvider() {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSlink =>\n+            for {\n+              mSymbolInformation <- findSymbol(methodSlink)\n+              if mSymbolInformation.isMethod\n+              methodSignature = mSymbolInformation.signature\n+                .asInstanceOf[MethodSignature]\n+              if checkSignaturesEqual(\n+                mSymbolInformation,\n+                methodSignature,\n+                baseMethodSymbolInformation,\n+                baseMethodInfo,\n+                superClass.asSeenFrom,\n+                findSymbol\n+              )\n+            } yield mSymbolInformation\n+          )\n+          .collectFirst { case Some(value) => value }\n+      case _ =>\n+        None\n+    }\n+\n+  }\n+\n+  private def getSuperClasses(\n+      symbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation],\n+      skip: scala.collection.mutable.Set[SymbolInformation],\n+      asSeenFrom: Map[String, String]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    if (skip.exists(_.symbol == symbolInformation.symbol)) {\n+      List.empty\n+    } else {\n+      skip += symbolInformation\n+      symbolInformation.signature match {\n+        case classSignature: ClassSignature =>\n+          val parents = classSignature.parents\n+            .collect { case x: TypeRef => x }\n+            .filterNot(typeRef => stopSymbols.contains(typeRef.symbol))"
  },
  {
    "id" : "6a7d30d0-a5f0-4890-8274-1a4b0f9b367e",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "4a83fe8d-24a3-429b-bdaf-3be6085e785a",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "methodSlink -> methodSymbolLink",
        "createdAt" : "2020-03-12T12:26:49Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,285 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.metals.CodeLensProvider.LensGoSuperCache\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.implementation.SuperMethodProvider._\n+import scala.meta.internal.semanticdb.TypeSignature\n+\n+class SuperMethodProvider() {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSlink =>\n+            for {\n+              mSymbolInformation <- findSymbol(methodSlink)\n+              if mSymbolInformation.isMethod\n+              methodSignature = mSymbolInformation.signature\n+                .asInstanceOf[MethodSignature]\n+              if checkSignaturesEqual(\n+                mSymbolInformation,\n+                methodSignature,\n+                baseMethodSymbolInformation,\n+                baseMethodInfo,\n+                superClass.asSeenFrom,\n+                findSymbol\n+              )\n+            } yield mSymbolInformation\n+          )\n+          .collectFirst { case Some(value) => value }\n+      case _ =>\n+        None\n+    }\n+\n+  }\n+\n+  private def getSuperClasses(\n+      symbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation],\n+      skip: scala.collection.mutable.Set[SymbolInformation],\n+      asSeenFrom: Map[String, String]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    if (skip.exists(_.symbol == symbolInformation.symbol)) {\n+      List.empty\n+    } else {\n+      skip += symbolInformation\n+      symbolInformation.signature match {\n+        case classSignature: ClassSignature =>\n+          val parents = classSignature.parents\n+            .collect { case x: TypeRef => x }\n+            .filterNot(typeRef => stopSymbols.contains(typeRef.symbol))\n+            .filterNot(typeRef => skip.exists(_.symbol == typeRef.symbol))\n+          val parentsHierarchy = parents\n+            .flatMap(p => findSymbol(p.symbol).map((_, p)))\n+            .map {\n+              case (si, p) =>\n+                val parentASF = AsSeenFrom.calculateAsSeenFrom(\n+                  p,\n+                  classSignature.typeParameters\n+                )\n+                val currentASF =\n+                  AsSeenFrom.translateAsSeenFrom(asSeenFrom, parentASF)\n+                getSuperClasses(si, findSymbol, skip, currentASF)\n+            }\n+            .toList\n+            .reverse\n+            .flatten\n+          val outASF =\n+            AsSeenFrom.toRealNames(classSignature, true, Some(asSeenFrom))\n+          SymbolWithAsSeenFrom(symbolInformation, outASF) +: parentsHierarchy\n+        case sig: TypeSignature =>\n+          val upperBound = sig.upperBound.asInstanceOf[TypeRef]\n+          findSymbol(upperBound.symbol)\n+            .filterNot(s => skip.exists(_.symbol == s.symbol))\n+            .map(si => {\n+              val parentASF =\n+                AsSeenFrom.calculateAsSeenFrom(upperBound, sig.typeParameters)\n+              val currentASF =\n+                AsSeenFrom.translateAsSeenFrom(asSeenFrom, parentASF)\n+              getSuperClasses(si, findSymbol, skip, currentASF)\n+            })\n+            .getOrElse(List.empty)\n+        case _ =>\n+          List.empty\n+      }\n+    }\n+  }\n+\n+  private def calculateClassSuperHierarchyWithCache(\n+      classSymbolInformation: SymbolInformation,\n+      cache: LensGoSuperCache,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    cache.get(classSymbolInformation.symbol) match {\n+      case Some(value) => value\n+      case None =>\n+        val value =\n+          calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        cache(classSymbolInformation.symbol) = value\n+        value\n+    }\n+\n+  }\n+\n+  private def calculateClassSuperHierarchy(\n+      classSymbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    getSuperClasses(\n+      classSymbolInformation,\n+      findSymbol,\n+      scala.collection.mutable.Set[SymbolInformation](),\n+      Map()\n+    )\n+  }\n+\n+  private def findSuperForMethodOrFieldChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      cache: LensGoSuperCache,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[String] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    val result = for {\n+      baseClassSymbolInformation <- classSymbolInformationMaybe.toIterable\n+      if baseClassSymbolInformation.signature.isInstanceOf[ClassSignature]\n+      baseClassSignature = baseClassSymbolInformation.signature\n+        .asInstanceOf[ClassSignature]\n+      SymbolWithAsSeenFrom(superClass, asSeenFrom) <- calculateClassSuperHierarchyWithCache(\n+        baseClassSymbolInformation,\n+        cache,\n+        findSymbol\n+      )\n+      if superClass.signature.isInstanceOf[ClassSignature]\n+      classSig = superClass.signature.asInstanceOf[ClassSignature]\n+      methodSlink <- classSig.getDeclarations.symlinks"
  },
  {
    "id" : "353c485c-c947-48bb-a83c-e9e22952947e",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "03763d06-d6bf-4aef-abba-3bdbe5d9e26e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Do we need to do it here? `toRealNames` should really be translated at the point we are comparing two methods from two specific classes.  ",
        "createdAt" : "2020-03-12T12:28:49Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,285 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.metals.CodeLensProvider.LensGoSuperCache\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.implementation.SuperMethodProvider._\n+import scala.meta.internal.semanticdb.TypeSignature\n+\n+class SuperMethodProvider() {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSlink =>\n+            for {\n+              mSymbolInformation <- findSymbol(methodSlink)\n+              if mSymbolInformation.isMethod\n+              methodSignature = mSymbolInformation.signature\n+                .asInstanceOf[MethodSignature]\n+              if checkSignaturesEqual(\n+                mSymbolInformation,\n+                methodSignature,\n+                baseMethodSymbolInformation,\n+                baseMethodInfo,\n+                superClass.asSeenFrom,\n+                findSymbol\n+              )\n+            } yield mSymbolInformation\n+          )\n+          .collectFirst { case Some(value) => value }\n+      case _ =>\n+        None\n+    }\n+\n+  }\n+\n+  private def getSuperClasses(\n+      symbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation],\n+      skip: scala.collection.mutable.Set[SymbolInformation],\n+      asSeenFrom: Map[String, String]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    if (skip.exists(_.symbol == symbolInformation.symbol)) {\n+      List.empty\n+    } else {\n+      skip += symbolInformation\n+      symbolInformation.signature match {\n+        case classSignature: ClassSignature =>\n+          val parents = classSignature.parents\n+            .collect { case x: TypeRef => x }\n+            .filterNot(typeRef => stopSymbols.contains(typeRef.symbol))\n+            .filterNot(typeRef => skip.exists(_.symbol == typeRef.symbol))\n+          val parentsHierarchy = parents\n+            .flatMap(p => findSymbol(p.symbol).map((_, p)))\n+            .map {\n+              case (si, p) =>\n+                val parentASF = AsSeenFrom.calculateAsSeenFrom(\n+                  p,\n+                  classSignature.typeParameters\n+                )\n+                val currentASF =\n+                  AsSeenFrom.translateAsSeenFrom(asSeenFrom, parentASF)\n+                getSuperClasses(si, findSymbol, skip, currentASF)\n+            }\n+            .toList\n+            .reverse\n+            .flatten\n+          val outASF ="
  },
  {
    "id" : "9de4b295-7a13-4821-ad8d-00d4b1957545",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "03c8cda6-470a-4f24-ab0f-1689a86fc78c",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Either this is no needed or the one inside `calculateClassSuperHierarchy`",
        "createdAt" : "2020-03-12T12:29:26Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,285 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.metals.CodeLensProvider.LensGoSuperCache\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.implementation.SuperMethodProvider._\n+import scala.meta.internal.semanticdb.TypeSignature\n+\n+class SuperMethodProvider() {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (symbolRole.isDefinition && (methodSymbolInformation.isMethod || methodSymbolInformation.isField)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSlink =>\n+            for {\n+              mSymbolInformation <- findSymbol(methodSlink)\n+              if mSymbolInformation.isMethod\n+              methodSignature = mSymbolInformation.signature\n+                .asInstanceOf[MethodSignature]\n+              if checkSignaturesEqual(\n+                mSymbolInformation,\n+                methodSignature,\n+                baseMethodSymbolInformation,\n+                baseMethodInfo,\n+                superClass.asSeenFrom,\n+                findSymbol\n+              )\n+            } yield mSymbolInformation\n+          )\n+          .collectFirst { case Some(value) => value }\n+      case _ =>\n+        None\n+    }\n+\n+  }\n+\n+  private def getSuperClasses(\n+      symbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation],\n+      skip: scala.collection.mutable.Set[SymbolInformation],\n+      asSeenFrom: Map[String, String]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    if (skip.exists(_.symbol == symbolInformation.symbol)) {\n+      List.empty\n+    } else {\n+      skip += symbolInformation\n+      symbolInformation.signature match {\n+        case classSignature: ClassSignature =>\n+          val parents = classSignature.parents\n+            .collect { case x: TypeRef => x }\n+            .filterNot(typeRef => stopSymbols.contains(typeRef.symbol))\n+            .filterNot(typeRef => skip.exists(_.symbol == typeRef.symbol))\n+          val parentsHierarchy = parents\n+            .flatMap(p => findSymbol(p.symbol).map((_, p)))\n+            .map {\n+              case (si, p) =>\n+                val parentASF = AsSeenFrom.calculateAsSeenFrom(\n+                  p,\n+                  classSignature.typeParameters\n+                )\n+                val currentASF =\n+                  AsSeenFrom.translateAsSeenFrom(asSeenFrom, parentASF)\n+                getSuperClasses(si, findSymbol, skip, currentASF)\n+            }\n+            .toList\n+            .reverse\n+            .flatten\n+          val outASF =\n+            AsSeenFrom.toRealNames(classSignature, true, Some(asSeenFrom))\n+          SymbolWithAsSeenFrom(symbolInformation, outASF) +: parentsHierarchy\n+        case sig: TypeSignature =>\n+          val upperBound = sig.upperBound.asInstanceOf[TypeRef]\n+          findSymbol(upperBound.symbol)\n+            .filterNot(s => skip.exists(_.symbol == s.symbol))\n+            .map(si => {\n+              val parentASF =\n+                AsSeenFrom.calculateAsSeenFrom(upperBound, sig.typeParameters)\n+              val currentASF =\n+                AsSeenFrom.translateAsSeenFrom(asSeenFrom, parentASF)\n+              getSuperClasses(si, findSymbol, skip, currentASF)\n+            })\n+            .getOrElse(List.empty)\n+        case _ =>\n+          List.empty\n+      }\n+    }\n+  }\n+\n+  private def calculateClassSuperHierarchyWithCache(\n+      classSymbolInformation: SymbolInformation,\n+      cache: LensGoSuperCache,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    cache.get(classSymbolInformation.symbol) match {\n+      case Some(value) => value\n+      case None =>\n+        val value =\n+          calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        cache(classSymbolInformation.symbol) = value\n+        value\n+    }\n+\n+  }\n+\n+  private def calculateClassSuperHierarchy(\n+      classSymbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    getSuperClasses(\n+      classSymbolInformation,\n+      findSymbol,\n+      scala.collection.mutable.Set[SymbolInformation](),\n+      Map()\n+    )\n+  }\n+\n+  private def findSuperForMethodOrFieldChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      cache: LensGoSuperCache,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[String] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    val result = for {\n+      baseClassSymbolInformation <- classSymbolInformationMaybe.toIterable\n+      if baseClassSymbolInformation.signature.isInstanceOf[ClassSignature]\n+      baseClassSignature = baseClassSymbolInformation.signature\n+        .asInstanceOf[ClassSignature]\n+      SymbolWithAsSeenFrom(superClass, asSeenFrom) <- calculateClassSuperHierarchyWithCache(\n+        baseClassSymbolInformation,\n+        cache,\n+        findSymbol\n+      )\n+      if superClass.signature.isInstanceOf[ClassSignature]\n+      classSig = superClass.signature.asInstanceOf[ClassSignature]\n+      methodSlink <- classSig.getDeclarations.symlinks\n+      mSymbolInformation <- findSymbol(methodSlink).toIterable\n+      if mSymbolInformation.isMethod\n+      methodSignature = mSymbolInformation.signature\n+        .asInstanceOf[MethodSignature]\n+      newASF = AsSeenFrom.toRealNames("
  },
  {
    "id" : "50e0f73b-d74d-4d4e-9862-a5722a719ff8",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "a52758d5-8a57-40a1-a128-04380c4c0cb9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "What if it's not a MethodSignature? what if i'ts a field?",
        "createdAt" : "2020-03-17T18:37:58Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d7998ddd-bce3-4435-b8ae-c38926e5fd5e",
        "parentId" : "a52758d5-8a57-40a1-a128-04380c4c0cb9",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Let's refactor the code below to return `None` when this is not a `MethodSignature`",
        "createdAt" : "2020-03-17T19:55:38Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "22a477ca-a858-42dc-a63f-cabab53e2181",
        "parentId" : "a52758d5-8a57-40a1-a128-04380c4c0cb9",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "If it is a field it is still MethodSignature it turns out, lenses are generated for fields too :)",
        "createdAt" : "2020-03-18T08:15:09Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "88d4f2fd-e336-4a64-9600-1bb52f6dc0bb",
        "parentId" : "a52758d5-8a57-40a1-a128-04380c4c0cb9",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "I moved this casting to method calling this function where I do check `isDefinitionOfMethodField`",
        "createdAt" : "2020-03-18T08:17:51Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "25561775-24bc-44b4-9960-c662ba152bff",
        "parentId" : "a52758d5-8a57-40a1-a128-04380c4c0cb9",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "changed to pattern match :+1:",
        "createdAt" : "2020-03-19T14:43:57Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,276 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.TypeSignature\n+import scala.collection.{mutable => m}\n+import scala.meta.internal.metals.codelenses.SuperMethodLensesProvider.LensGoSuperCache\n+\n+object SuperMethodProvider {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]"
  },
  {
    "id" : "f968a76f-074a-4962-826b-74108c052ba2",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "049dcb23-dab4-4ab1-bff3-6ebff69475fd",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "isn't `baseMethodInfo` already inlcuded in `baseMethodSymbolInformation` ?",
        "createdAt" : "2020-03-17T18:46:51Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c9c216ed-f426-4b85-97c4-82a95a2f1ef7",
        "parentId" : "049dcb23-dab4-4ab1-bff3-6ebff69475fd",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "it is but it has `Signature` tpe, and I need `MethodSignature`. I could do casting here but I prefer to keep casting where check is performed and simply provide it here with correct tpe (but yes it is duplicated).\r\nIf `SymbolInformation` was generic with `SymbolInformation[X <: Signature]` I could say here I need `baseMethodSymbolInformation: SymbolInformation[MethodSignature]` but I can't with current types.",
        "createdAt" : "2020-03-18T08:23:35Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : 80,
    "diffHunk" : "@@ -0,0 +1,276 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.TypeSignature\n+import scala.collection.{mutable => m}\n+import scala.meta.internal.metals.codelenses.SuperMethodLensesProvider.LensGoSuperCache\n+\n+object SuperMethodProvider {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,"
  },
  {
    "id" : "b19693b4-99ab-4df2-8763-b2a291124d9d",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "fb4f5301-86d7-400c-8aa5-f93a0d377e7f",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "```suggestion\r\n              methodSignature = Option(mSymbolInformation.signature).collect { case m: MethodSignature => m }\r\n```",
        "createdAt" : "2020-03-17T19:57:07Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "06d4ca41-243e-4c33-8f59-301350403592",
        "parentId" : "fb4f5301-86d7-400c-8aa5-f93a0d377e7f",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "that is a nice trick! changed :+1:",
        "createdAt" : "2020-03-18T08:26:53Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,276 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.TypeSignature\n+import scala.collection.{mutable => m}\n+import scala.meta.internal.metals.codelenses.SuperMethodLensesProvider.LensGoSuperCache\n+\n+object SuperMethodProvider {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSymbolLink =>\n+            for {\n+              mSymbolInformation <- findSymbol(methodSymbolLink)\n+              if mSymbolInformation.isMethod\n+              methodSignature = mSymbolInformation.signature"
  },
  {
    "id" : "24a074f4-9bb7-47a7-9a8a-5f93afd6842f",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "5a776067-8234-4afd-a033-8a3bb35ed9aa",
        "parentId" : null,
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Can this just be `symbolInformation` rather than `si`",
        "createdAt" : "2020-03-18T01:09:59Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "67083d66-ced9-469d-b329-b295c94b72e0",
        "parentId" : "5a776067-8234-4afd-a033-8a3bb35ed9aa",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "I changed `classSymbolInformation` -> `classSymbolInformationOption`\r\nand `si` -> `classSymbolInformation`\r\nwhat you think?",
        "createdAt" : "2020-03-18T08:32:01Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3c3ee283-fa8f-401b-b0c0-eefef62651af",
        "parentId" : "5a776067-8234-4afd-a033-8a3bb35ed9aa",
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "yea, I think that'd be clear.",
        "createdAt" : "2020-03-18T16:35:27Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,276 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.TypeSignature\n+import scala.collection.{mutable => m}\n+import scala.meta.internal.metals.codelenses.SuperMethodLensesProvider.LensGoSuperCache\n+\n+object SuperMethodProvider {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        cache,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def getSuperMethodHierarchy(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      getSuperMethodHierarchyChecked(\n+        methodSymbolInformation,\n+        documentWithPath,\n+        findSymbol\n+      )\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def getSuperMethodHierarchyChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[List[SymbolInformation]] = {\n+    val classSymbolInformationMaybe =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    classSymbolInformationMaybe.map(classSymbolInformation => {\n+      calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        .flatMap(matchMethodInClass(_, msi, methodInfo, findSymbol))\n+    })\n+  }\n+\n+  private def matchMethodInClass(\n+      superClass: SymbolWithAsSeenFrom,\n+      baseMethodSymbolInformation: SymbolInformation,\n+      baseMethodInfo: MethodSignature,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[SymbolInformation] = {\n+    superClass.symbolInformation.signature match {\n+      case classSig: ClassSignature =>\n+        classSig.getDeclarations.symlinks\n+          .map(methodSymbolLink =>\n+            for {\n+              mSymbolInformation <- findSymbol(methodSymbolLink)\n+              if mSymbolInformation.isMethod\n+              methodSignature = mSymbolInformation.signature\n+                .asInstanceOf[MethodSignature]\n+              if checkSignaturesEqual(\n+                mSymbolInformation,\n+                methodSignature,\n+                baseMethodSymbolInformation,\n+                baseMethodInfo,\n+                superClass.asSeenFrom,\n+                findSymbol\n+              )\n+            } yield mSymbolInformation\n+          )\n+          .collectFirst { case Some(value) => value }\n+      case _ =>\n+        None\n+    }\n+\n+  }\n+\n+  private def getSuperClasses(\n+      symbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation],\n+      skipSymbols: m.Set[String],\n+      asSeenFrom: Map[String, String]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    if (skipSymbols.contains(symbolInformation.symbol)) {\n+      List.empty\n+    } else {\n+      skipSymbols += symbolInformation.symbol\n+      symbolInformation.signature match {\n+        case classSignature: ClassSignature =>\n+          val parents = classSignature.parents\n+            .collect { case x: TypeRef => x }\n+            .filterNot(typeRef =>\n+              stopSymbols.contains(typeRef.symbol) || skipSymbols\n+                .contains(typeRef.symbol)\n+            )\n+          val parentsHierarchy = parents\n+            .flatMap(p => findSymbol(p.symbol).map((_, p)))\n+            .map {\n+              case (si, p) =>\n+                val parentASF = AsSeenFrom.calculateAsSeenFrom(\n+                  p,\n+                  classSignature.typeParameters\n+                )\n+                getSuperClasses(si, findSymbol, skipSymbols, parentASF)\n+            }\n+            .toList\n+            .reverse\n+            .flatten\n+          SymbolWithAsSeenFrom(symbolInformation, asSeenFrom) +: parentsHierarchy\n+        case sig: TypeSignature =>\n+          val upperBound = sig.upperBound.asInstanceOf[TypeRef]\n+          findSymbol(upperBound.symbol)\n+            .filterNot(s => skipSymbols.contains(s.symbol))\n+            .map(si => {\n+              val parentASF =\n+                AsSeenFrom.calculateAsSeenFrom(upperBound, sig.typeParameters)\n+              getSuperClasses(si, findSymbol, skipSymbols, parentASF)\n+            })\n+            .getOrElse(List.empty)\n+        case _ =>\n+          List.empty\n+      }\n+    }\n+  }\n+\n+  private def calculateClassSuperHierarchyWithCache(\n+      classSymbolInformation: SymbolInformation,\n+      cache: LensGoSuperCache,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    cache.get(classSymbolInformation.symbol) match {\n+      case Some(value) => value\n+      case None =>\n+        val value =\n+          calculateClassSuperHierarchy(classSymbolInformation, findSymbol)\n+        cache(classSymbolInformation.symbol) = value\n+        value\n+    }\n+\n+  }\n+\n+  private def calculateClassSuperHierarchy(\n+      classSymbolInformation: SymbolInformation,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): List[SymbolWithAsSeenFrom] = {\n+    getSuperClasses(\n+      classSymbolInformation,\n+      findSymbol,\n+      m.Set[String](),\n+      Map()\n+    )\n+  }\n+\n+  private def findSuperForMethodOrFieldChecked(\n+      msi: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      cache: LensGoSuperCache,\n+      findSymbol: String => Option[SymbolInformation]\n+  ): Option[String] = {\n+    val classSymbolInformation =\n+      findClassInfo(\n+        msi.symbol,\n+        msi.symbol.owner,\n+        documentWithPath.textDocument,\n+        findSymbol\n+      )\n+    val methodInfo = msi.signature.asInstanceOf[MethodSignature]\n+\n+    val result = for {\n+      si <- classSymbolInformation.toIterable"
  },
  {
    "id" : "f1b826b9-69d8-44a9-a819-b377063a11fb",
    "prId" : 1487,
    "comments" : [
      {
        "id" : "6ae0dc14-67f7-4607-baf9-9532b2b0bac5",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can we remove all usage of `asInstanceOf`? The idiomatic way to do this here would be to use pattern matching\r\n```scala\r\ninfo.signature match {\r\n  case m: MethodSignature =>\r\n    ...\r\n    Some(...)\r\n  case _ =>\r\n    None\r\n```",
        "createdAt" : "2020-03-18T11:32:25Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aa8e3fc0-1d99-4ab8-88e8-035ddf23d0f1",
        "parentId" : "6ae0dc14-67f7-4607-baf9-9532b2b0bac5",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "Okay, moved this to `isDefinitionOfMethodField` which returns `Option` and refactored as `for` comprehension. Same with similar situation below :+1:",
        "createdAt" : "2020-03-18T18:44:27Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,280 @@\n+package scala.meta.internal.implementation\n+\n+import scala.meta.internal.semanticdb.Scala._\n+import scala.meta.internal.semanticdb.ClassSignature\n+import scala.meta.internal.semanticdb.MethodSignature\n+import scala.meta.internal.semanticdb.SymbolInformation\n+import scala.meta.internal.semanticdb.SymbolOccurrence\n+import scala.meta.internal.semanticdb.TextDocument\n+import scala.meta.internal.semanticdb.TypeRef\n+import scala.meta.internal.semanticdb.TypeSignature\n+import scala.collection.{mutable => m}\n+import scala.meta.internal.metals.codelenses.SuperMethodLensesProvider.LensGoSuperCache\n+\n+object SuperMethodProvider {\n+\n+  def findSuperForMethodOrField(\n+      methodSymbolInformation: SymbolInformation,\n+      documentWithPath: TextDocumentWithPath,\n+      symbolRole: SymbolOccurrence.Role,\n+      findSymbol: String => Option[SymbolInformation],\n+      cache: LensGoSuperCache\n+  ): Option[String] = {\n+    if (isDefinitionOfMethodField(symbolRole, methodSymbolInformation)) {\n+      findSuperForMethodOrFieldChecked(\n+        methodSymbolInformation,\n+        methodSymbolInformation.signature.asInstanceOf[MethodSignature],"
  },
  {
    "id" : "32d55cb9-b79e-4339-8bb1-14f008be2d93",
    "prId" : 1679,
    "comments" : [
      {
        "id" : "c2035277-66f2-4357-b6aa-8b85d46d7117",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "`msi.displayName` ?",
        "createdAt" : "2020-04-30T10:58:53Z",
        "updatedAt" : "2020-04-30T11:31:56Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fbb0d496-3779-479e-bf67-5219a65e01ed",
        "parentId" : "c2035277-66f2-4357-b6aa-8b85d46d7117",
        "author" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "body" : "changed",
        "createdAt" : "2020-04-30T11:33:19Z",
        "updatedAt" : "2020-04-30T11:33:19Z",
        "lastEditedBy" : {
          "login" : "kpbochenek",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/10478402?u=7a7840d3f5ce4047a19639e6b7977d43e3557158&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ef497ba77ea264fe4a0d730a77c5fc2bbf3dbb8e",
    "line" : null,
    "diffHunk" : "@@ -197,6 +197,7 @@ object SuperMethodProvider {\n         documentWithPath.textDocument,\n         findSymbol\n       )\n+    val methodName = msi.symbol.desc.name.value"
  }
]