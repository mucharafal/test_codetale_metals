[
  {
    "id" : "21709633-4fb3-4025-b852-21ccf01ffcc6",
    "prId" : 935,
    "comments" : [
      {
        "id" : "906b19ab-d175-4b48-ad8d-05ae00342826",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Would we care to have it in `bloop` itself?",
        "createdAt" : "2019-09-24T10:03:33Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1efac48c-7243-48d3-bde4-03b8d263d109",
        "parentId" : "906b19ab-d175-4b48-ad8d-05ae00342826",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "See reply to Marek's comment, this should ideally live in Pants",
        "createdAt" : "2019-09-26T15:49:03Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : 33,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {"
  },
  {
    "id" : "bfcddf54-83c3-4a9e-9824-731213a2f00f",
    "prId" : 935,
    "comments" : [
      {
        "id" : "6f844a03-86a2-4d52-82f9-38c3a40ed9cf",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "maybe just also print the whole help whenever wrong number of arguments is used? ",
        "createdAt" : "2019-09-24T10:07:29Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "58e17b51-63b7-434c-a56d-c9c17b77126c",
        "parentId" : "6f844a03-86a2-4d52-82f9-38c3a40ed9cf",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good idea, done.",
        "createdAt" : "2019-09-26T15:49:09Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {"
  },
  {
    "id" : "7deeb6ef-21c3-41ed-9a64-b018302812b5",
    "prId" : 935,
    "comments" : [
      {
        "id" : "ef89572e-02c6-425c-bc05-4442320bb1e9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "There is nothing about `--with-cache` in help",
        "createdAt" : "2019-09-24T10:08:28Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c155205a-6bd4-4a17-826b-c9cdd29594d4",
        "parentId" : "ef89572e-02c6-425c-bc05-4442320bb1e9",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I removed this line. It's an internal flag that I have only used for local debugging purposes, I can call the `bloopInstall` method directly instead of passing it as a cli arg next time I need to debug more stuff.",
        "createdAt" : "2019-09-26T15:50:34Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")"
  },
  {
    "id" : "3044d63c-d884-4b2f-86e1-8ec74e40c6bf",
    "prId" : 935,
    "comments" : [
      {
        "id" : "3f5c74f2-2c0e-4f77-98b2-534a3bf83e48",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Maybe add some validation whether this is actually a valid path?",
        "createdAt" : "2019-09-24T10:10:09Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "39965773-653c-4a05-9b21-86c4124202a5",
        "parentId" : "3f5c74f2-2c0e-4f77-98b2-534a3bf83e48",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This main method is no longer called from Metals. It's not important to polish the command-line UX for now.",
        "createdAt" : "2019-09-27T12:02:46Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))"
  },
  {
    "id" : "f702b400-4de9-433d-b21d-b84b6924cbac",
    "prId" : 935,
    "comments" : [
      {
        "id" : "c7eba24b-bab5-4b5c-b5bd-bf0a51e8c877",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Should this always be `2.12.10` and that jline version?",
        "createdAt" : "2019-09-24T10:16:32Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0723645f-a7a4-4433-8be5-1d9cfa731719",
        "parentId" : "c7eba24b-bab5-4b5c-b5bd-bf0a51e8c877",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good catch, this is now automatically inferred from the `./pants export` output.",
        "createdAt" : "2019-09-26T17:16:45Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\","
  },
  {
    "id" : "c4721ea0-116a-44b4-aea8-b05309cf21a2",
    "prId" : 935,
    "comments" : [
      {
        "id" : "e8f95af4-5863-49d1-951f-ac451a4ac6e8",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Does this ID always come from pants or is it a twitter specific thing?",
        "createdAt" : "2019-09-24T10:18:54Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1dfccdbd-e15f-41d1-815a-7c04875ea0dd",
        "parentId" : "e8f95af4-5863-49d1-951f-ac451a4ac6e8",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Removed.",
        "createdAt" : "2019-09-26T17:16:58Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\""
  },
  {
    "id" : "a2b04ce1-3e4c-4582-adc2-d9b2554b8788",
    "prId" : 935,
    "comments" : [
      {
        "id" : "6e8cfd13-f218-4eb9-b932-c7dded800bf3",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Is the stream closed anywhere?",
        "createdAt" : "2019-09-24T10:20:56Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d0737a57-2a40-4941-8b6f-0b18a995333d",
        "parentId" : "6e8cfd13-f218-4eb9-b932-c7dded800bf3",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nice catch! The stream gets closed now.",
        "createdAt" : "2019-09-26T17:18:10Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] ="
  },
  {
    "id" : "ba370c5a-a974-4693-ae52-26cd6f1b191c",
    "prId" : 935,
    "comments" : [
      {
        "id" : "1d89703c-ba1a-4045-869b-5c381beafc8a",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Can we combine the two filters?",
        "createdAt" : "2019-09-24T10:22:33Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ec50c13c-e1cd-4d65-9451-ee336075a755",
        "parentId" : "1d89703c-ba1a-4045-869b-5c381beafc8a",
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "I think this nicely separates the meaning behind those.\r\nfirst is just a guard clause and second is a black/white list filtering. The performance loss should be minuscule as this is a stream. Even more, I would even understand splitting those conditions to three, which would make them a bit more readable and would result in nicer formatting",
        "createdAt" : "2019-09-25T08:18:22Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>"
  },
  {
    "id" : "63eea64c-0f9d-4358-b706-1ee561117e43",
    "prId" : 935,
    "comments" : [
      {
        "id" : "59169f03-9649-4446-898f-b32e2d9ca2a1",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Hardcoded Scala version for all pants projects?",
        "createdAt" : "2019-09-24T10:27:41Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "884e92a8-84f1-419d-85ab-188a8be3ccd6",
        "parentId" : "59169f03-9649-4446-898f-b32e2d9ca2a1",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good catch! The version is now inferred based on the output of `./pants export`",
        "createdAt" : "2019-09-27T14:20:25Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++\n+              getLibraryDependencies(\"shaded\") ++\n+              getLibraryDependencies(\"linux-x86_64\") ++\n+              getLibraryDependencies(\"thrift9\")\n+          val knownConfigs =\n+            Set(\"default\", \"linux-x86_64\", \"thrift9\", \"sources\", \"shaded\")\n+          val unknownConfigs = libraryDependencies.flatMap(\n+            lib => lib.obj.keys.toSet -- knownConfigs\n+          )\n+          if (unknownConfigs.nonEmpty) {\n+            println(\n+              s\"[warning] Unknown configs: ${unknownConfigs.mkString(\",\")}\"\n+            )\n+          }\n+          val javaHome =\n+            Option(System.getProperty(\"java.home\")).map(Paths.get(_))\n+          C.Project(\n+            id,\n+            directory = baseDirectory,\n+            sources,\n+            dependencies = dependsOn.toList,\n+            targetDependencies ++ libraryDependencyClasspaths,\n+            out,\n+            classDirectory,\n+            scala = Some(\n+              C.Scala(\n+                \"org.scala-lang\",\n+                \"scala-compiler\",\n+                \"2.12.10\","
  },
  {
    "id" : "7049cd54-6c05-4aff-90c2-329fd7b04345",
    "prId" : 935,
    "comments" : [
      {
        "id" : "716a3365-5889-4877-8df8-36beca51e365",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "This method seems a bit long, can we split it into some more methods? It would for sure be useful to separate the config generation specific methods.",
        "createdAt" : "2019-09-24T10:30:03Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04867870-c975-41cf-b5ca-51019e2e18ca",
        "parentId" : "716a3365-5889-4877-8df8-36beca51e365",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good point, I have split this method into several smaller methods and different classes.",
        "createdAt" : "2019-09-27T12:03:13Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall("
  },
  {
    "id" : "48b7a79f-7aa4-4d8f-8e58-4f988e09fd5c",
    "prId" : 935,
    "comments" : [
      {
        "id" : "0a681652-1452-4616-930c-a089455001a7",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "```scala\r\nList(\"default\", \"shaded\", \"linux-x86_64\", \"thrift9\").map(getLibraryDependencies)\r\n```\r\n?",
        "createdAt" : "2019-09-24T11:27:29Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3ef891be-84be-4abe-aec9-2ab0869bcff3",
        "parentId" : "0a681652-1452-4616-930c-a089455001a7",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Cleaned up.",
        "createdAt" : "2019-09-27T14:20:00Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++"
  },
  {
    "id" : "d076db8b-ffdf-4f80-addc-1f12b32ec746",
    "prId" : 935,
    "comments" : [
      {
        "id" : "ee8a0b6a-c671-45ca-8434-f7b6a9517ff9",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "We can use a list defined above and:\r\n```scala\r\nval knownConfigs = dependencyNames :+ \"sources\"\r\n```",
        "createdAt" : "2019-09-24T11:29:01Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6527ebba-d56f-4ff2-8273-d2f193532cae",
        "parentId" : "ee8a0b6a-c671-45ca-8434-f7b6a9517ff9",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Cleaned up.",
        "createdAt" : "2019-09-27T14:20:07Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++\n+              getLibraryDependencies(\"shaded\") ++\n+              getLibraryDependencies(\"linux-x86_64\") ++\n+              getLibraryDependencies(\"thrift9\")\n+          val knownConfigs ="
  },
  {
    "id" : "77f03481-562a-458c-8d80-039178bed3ca",
    "prId" : 935,
    "comments" : [
      {
        "id" : "63b621be-db76-4274-beb7-7d1cdb150e32",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "how does this package relate to `scala.meta.internal.build.Pants*`? If pants require more configuration, then it should be placed together, for example in `build.pants.BloopPants`. Currently there is no way of knowing the difference without checking the content of those files",
        "createdAt" : "2019-09-25T07:52:19Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0ced59f6-c0f0-4c0a-b5cf-b03503437ba1",
        "parentId" : "63b621be-db76-4274-beb7-7d1cdb150e32",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This logic is separate from the `build.Pants*` classes since it's a standalone command-line interface to export a pants build to Bloop while the `build.Pants*` classes are metals-specific and have the same structure as other `build.{Maven,Mill,Sbt,...}` classes. The `pantsbuild` package should have no dependencies on other parts of the Metals codebase.\r\n\r\nI have a branch to the main pants repository that contains the same PantsBloop code, which I'd like to contribute one day https://github.com/pantsbuild/pants/compare/master...olafurpg:bloop-install?expand=1. The reason I haven't opened that PR yet is because the solution in this PR works with any Pants version that the user has installed locally.",
        "createdAt" : "2019-09-26T15:48:32Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : 1,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild"
  },
  {
    "id" : "8fcf477d-428e-44b1-be48-0cb2ae30ce67",
    "prId" : 935,
    "comments" : [
      {
        "id" : "3bbacbd0-b7e4-4386-98a7-6807499f88f2",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "it can also not be a directory if it is a file or a symlink, which would result in a `java.nio.file.FileAlreadyExistsException`.\r\nThe best way would probably be to assert that `!Files.exist(...)`",
        "createdAt" : "2019-09-25T07:58:23Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a2f066cd-367c-4d80-9049-afb993f3cb29",
        "parentId" : "3bbacbd0-b7e4-4386-98a7-6807499f88f2",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It's OK to let this crash if we can't create a directory.",
        "createdAt" : "2019-09-27T12:03:47Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {"
  },
  {
    "id" : "de3091f7-744c-4da8-b630-96ac1714ec26",
    "prId" : 935,
    "comments" : [
      {
        "id" : "04564899-343f-4d6b-a220-1686b952f29c",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "what is this `query`? Isn't it still a `target`, albeit without some invalid characters? Maybe then sanitization should happen on the callee site?",
        "createdAt" : "2019-09-25T08:00:31Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "389a0eed-3a95-4899-951d-e12669bba2b9",
        "parentId" : "04564899-343f-4d6b-a220-1686b952f29c",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Renamed to `outputFilename`",
        "createdAt" : "2019-09-27T12:03:54Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")"
  },
  {
    "id" : "249569af-1366-4491-a79b-166cfb7b41f5",
    "prId" : 935,
    "comments" : [
      {
        "id" : "0b2d4e66-3f5c-4342-924d-61752616f672",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "you can use `Files.createDirectories(buildroot.resolve(\".bloop\"))`",
        "createdAt" : "2019-09-25T08:01:23Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27b40039-3775-4c67-b159-472fb5b36e43",
        "parentId" : "0b2d4e66-3f5c-4342-924d-61752616f672",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nice trick! It reads much nicer  like that 👍 I updated the code to consistently use this pattern ",
        "createdAt" : "2019-09-27T12:04:23Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")"
  },
  {
    "id" : "a847da2a-da86-4bcf-b817-5f267e84379e",
    "prId" : 935,
    "comments" : [
      {
        "id" : "b336744a-a9e4-431e-a01d-af9e2d702645",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "what if `export` is a symlink?",
        "createdAt" : "2019-09-25T08:02:40Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9105e899-8dd8-470d-99d1-0a46ce991536",
        "parentId" : "b336744a-a9e4-431e-a01d-af9e2d702645",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This file is generated by `./pants export` and should not be a symlink, it's fine to crash if it's a symlink",
        "createdAt" : "2019-09-27T12:04:45Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {"
  },
  {
    "id" : "67d4ebaf-ddf6-46fc-ba6a-4a3fde701c55",
    "prId" : 935,
    "comments" : [
      {
        "id" : "1406317a-33b7-4b56-969d-2d520e0815b4",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "Can it be given a more meaningful name? What kind of `export` is this file? Is this already exported or is it a definition of how to export?",
        "createdAt" : "2019-09-25T08:04:06Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9d1a8378-a6f3-47f1-87ef-265e4d51fc02",
        "parentId" : "1406317a-33b7-4b56-969d-2d520e0815b4",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Renamed to `outputFile`",
        "createdAt" : "2019-09-27T12:04:01Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")"
  },
  {
    "id" : "1758c9d3-b4d6-4062-81af-443570df0fdf",
    "prId" : 935,
    "comments" : [
      {
        "id" : "612869c2-89c2-477c-a33e-0fd6d1605562",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "please, include the entirety of the command to help in debugging if the needs be",
        "createdAt" : "2019-09-25T08:05:27Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d91d05c4-e39b-4cec-9813-d5e5bc5c23f9",
        "parentId" : "612869c2-89c2-477c-a33e-0fd6d1605562",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We include the full command in case of error, which is consistent with the current behavior when we shell out to sbt, Maven, Gradle, ...",
        "createdAt" : "2019-09-27T12:05:14Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")"
  },
  {
    "id" : "14c378c8-5868-474b-a2f2-fd9e3993228c",
    "prId" : 935,
    "comments" : [
      {
        "id" : "f8866f56-0bba-499e-b358-8abe07cafc9d",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "don't we care about the time in case of failure?",
        "createdAt" : "2019-09-25T08:06:34Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")"
  },
  {
    "id" : "84f3ad27-115a-450f-8be8-cf3b868cf04c",
    "prId" : 935,
    "comments" : [
      {
        "id" : "0824ceab-91e9-41b2-b976-f00555cbf695",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "why not propagate the exit code? Then the entire branch would be unnecessary",
        "createdAt" : "2019-09-25T08:06:54Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47ef7b89-c8ba-47b1-84e2-671245be7bec",
        "parentId" : "0824ceab-91e9-41b2-b976-f00555cbf695",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good catch, we throw an exception now instead.",
        "createdAt" : "2019-09-27T12:06:29Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)"
  },
  {
    "id" : "33547281-4049-4b2e-9a27-9284712d0340",
    "prId" : 935,
    "comments" : [
      {
        "id" : "6a94a0ee-f4b9-49f3-b8d8-16d5d7c9f8b7",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "```suggestion\r\n        println(s\"$commandName failed with exit code: $exit\")\r\n```",
        "createdAt" : "2019-09-25T08:07:12Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")"
  },
  {
    "id" : "eb9f9f8d-0db3-45e1-83f8-2e363cbe166e",
    "prId" : 935,
    "comments" : [
      {
        "id" : "2a4765cb-37a6-4814-acbd-33cef77d4060",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "what if symlink? This condition could be extracted to a variable with proper name",
        "createdAt" : "2019-09-25T08:08:27Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6ecf45be-06bc-45fc-b8ca-7f6b204496fe",
        "parentId" : "2a4765cb-37a6-4814-acbd-33cef77d4060",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It's fine to crash in case of a symlink",
        "createdAt" : "2019-09-27T12:06:45Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {"
  },
  {
    "id" : "1109978d-cddc-4faa-abc7-845a07048d42",
    "prId" : 935,
    "comments" : [
      {
        "id" : "47c43fb6-9d54-488f-ac94-15bf61d87846",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "can inline `Files.createDirectories` here",
        "createdAt" : "2019-09-25T08:10:33Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a8c2adef-9282-4c8c-b168-ab43cea8ef82",
        "parentId" : "47c43fb6-9d54-488f-ac94-15bf61d87846",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nice, that reads better.",
        "createdAt" : "2019-09-26T17:17:41Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")"
  },
  {
    "id" : "47d4a7a4-6158-406d-a615-8c6ac6f49744",
    "prId" : 935,
    "comments" : [
      {
        "id" : "73e3a991-e24c-4f81-8c1c-7e154ee5d877",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "could use some vertical spacing to making the code more readable",
        "createdAt" : "2019-09-25T08:11:57Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "55d16178-15f9-46ba-956f-c4481a5259f8",
        "parentId" : "73e3a991-e24c-4f81-8c1c-7e154ee5d877",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good point, done.",
        "createdAt" : "2019-09-27T14:13:53Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\""
  },
  {
    "id" : "92b8ef23-415d-471f-9d13-6e8779472eb5",
    "prId" : 935,
    "comments" : [
      {
        "id" : "a4416aba-b11b-4a50-820f-c74efab043b0",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "this stream is not closed after use",
        "createdAt" : "2019-09-25T08:15:07Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27836b87-58fd-4d45-a72e-81405082cee9",
        "parentId" : "a4416aba-b11b-4a50-820f-c74efab043b0",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nice catch! Fixed now.",
        "createdAt" : "2019-09-26T17:18:12Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream"
  },
  {
    "id" : "e76ce94e-b770-4bfc-8e42-7cd3e7067b21",
    "prId" : 935,
    "comments" : [
      {
        "id" : "f95f46e8-d6db-4b33-b98f-18650c351005",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "is this conversion necessary? it looks like it should already be a list",
        "createdAt" : "2019-09-25T08:19:40Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4642455c-7e27-4555-9897-93d06c1cc5da",
        "parentId" : "f95f46e8-d6db-4b33-b98f-18650c351005",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Fixed.",
        "createdAt" : "2019-09-27T14:17:06Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList"
  },
  {
    "id" : "59570d50-1e17-46fe-a3db-5088aae676f9",
    "prId" : 935,
    "comments" : [
      {
        "id" : "58a68bfc-61d3-46c6-9e47-7fb24377be9c",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "could you refactor this statement? Can't really tell what is going on on a first glance. The closing parenthesis get's lost in all the noise surrounding it. New lines would help a great deal",
        "createdAt" : "2019-09-25T08:20:47Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "964218d0-b899-4665-a83b-19fce1240adc",
        "parentId" : "58a68bfc-61d3-46c6-9e47-7fb24377be9c",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This logic has been extracted into a `Globs` file.",
        "createdAt" : "2019-09-27T14:17:19Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {"
  },
  {
    "id" : "d06f9c29-5fca-4800-a487-3d3641e50d27",
    "prId" : 935,
    "comments" : [
      {
        "id" : "bd60e168-8796-419a-b845-ce879500d5e5",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "if there is a need to wrap a long-spanning `for` expression in a parenthesis, it is a clear sign the code should be extracted and used like: \r\n```scala\r\nval aList = foo(x,y,z).toList\r\n```",
        "createdAt" : "2019-09-25T08:25:26Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eefce36d-a499-45ef-9f2a-5cc2e0096c68",
        "parentId" : "bd60e168-8796-419a-b845-ce879500d5e5",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think it's fine as long as it's only suffixed by something small like `.toList`. I simplified the `yield` expression, however. In this particular case, I wouldn't think it's clearer with a method that returns `Iterator[Path]`",
        "createdAt" : "2019-09-27T14:19:17Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {"
  },
  {
    "id" : "0b8a9ef9-0bdb-4841-88cd-8e2ed5901cdb",
    "prId" : 935,
    "comments" : [
      {
        "id" : "9b1507f9-0c5d-40ba-b434-05bd45f16dc6",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "could be extracted to a method for readibility",
        "createdAt" : "2019-09-25T08:28:35Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7a8e5eed-bf8b-4fa9-9039-399336e9d7dd",
        "parentId" : "9b1507f9-0c5d-40ba-b434-05bd45f16dc6",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-09-27T14:19:48Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module("
  },
  {
    "id" : "7725a691-b65d-4ef7-94fd-ca109433d4d0",
    "prId" : 935,
    "comments" : [
      {
        "id" : "c36c56d4-df48-4f19-b46d-5746cbef44a4",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "it should be extracted to a method",
        "createdAt" : "2019-09-25T08:32:28Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47c47def-7898-4299-a3c0-6d33f7944862",
        "parentId" : "c36c56d4-df48-4f19-b46d-5746cbef44a4",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-09-27T14:22:11Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++\n+              getLibraryDependencies(\"shaded\") ++\n+              getLibraryDependencies(\"linux-x86_64\") ++\n+              getLibraryDependencies(\"thrift9\")\n+          val knownConfigs =\n+            Set(\"default\", \"linux-x86_64\", \"thrift9\", \"sources\", \"shaded\")\n+          val unknownConfigs = libraryDependencies.flatMap(\n+            lib => lib.obj.keys.toSet -- knownConfigs\n+          )\n+          if (unknownConfigs.nonEmpty) {\n+            println(\n+              s\"[warning] Unknown configs: ${unknownConfigs.mkString(\",\")}\"\n+            )\n+          }\n+          val javaHome =\n+            Option(System.getProperty(\"java.home\")).map(Paths.get(_))\n+          C.Project(\n+            id,\n+            directory = baseDirectory,\n+            sources,\n+            dependencies = dependsOn.toList,\n+            targetDependencies ++ libraryDependencyClasspaths,\n+            out,\n+            classDirectory,\n+            scala = Some(\n+              C.Scala(\n+                \"org.scala-lang\",\n+                \"scala-compiler\",\n+                \"2.12.10\",\n+                List.empty[String],\n+                scalaJars.iterator.map(_.toPath).toList,\n+                None,\n+                setup = Some(\n+                  C.CompileSetup(\n+                    C.Mixed,\n+                    addLibraryToBootClasspath = true,\n+                    addCompilerToClasspath = false,\n+                    addExtraJarsToClasspath = false,\n+                    manageBootClasspath = true,\n+                    filterLibraryFromClasspath = true\n+                  )\n+                )\n+              )\n+            ),\n+            java = Some(C.Java(Nil)),\n+            sbt = None,\n+            test = None,\n+            platform = Some(C.Platform.Jvm(C.JvmConfig(javaHome, Nil), None)),\n+            resolution = Some(C.Resolution(libraryDependencySources)),\n+            resources = None\n+          )\n+      }.toSeq\n+      val byName = bloopProjects.map(p => p.name -> p).toMap\n+      val transitiveClasspath = mutable.Map.empty[String, List[Path]]\n+      val isVisited = mutable.Set.empty[String]\n+      def getTransitiveClasspath(name: String): List[Path] = {\n+        if (isVisited(name)) {\n+          transitiveClasspath.getOrElse(name, Nil)\n+        } else {\n+          isVisited += name\n+          val result = transitiveClasspath.getOrElseUpdate(\n+            name, {\n+              val buf = mutable.Set.empty[Path]"
  },
  {
    "id" : "0c075e36-4cd5-471c-87be-e99da1567b73",
    "prId" : 935,
    "comments" : [
      {
        "id" : "34ccef6c-c727-4f10-ad00-2e10eeff1983",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "this branch starts at the line 91. It is way too complex and should be split into smaller units",
        "createdAt" : "2019-09-25T08:59:03Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f6706b90-b6c1-4114-885e-498a7b2de8da",
        "parentId" : "34ccef6c-c727-4f10-ad00-2e10eeff1983",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good point, the logic has been refactored now.",
        "createdAt" : "2019-09-27T14:22:36Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : 625,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++\n+              getLibraryDependencies(\"shaded\") ++\n+              getLibraryDependencies(\"linux-x86_64\") ++\n+              getLibraryDependencies(\"thrift9\")\n+          val knownConfigs =\n+            Set(\"default\", \"linux-x86_64\", \"thrift9\", \"sources\", \"shaded\")\n+          val unknownConfigs = libraryDependencies.flatMap(\n+            lib => lib.obj.keys.toSet -- knownConfigs\n+          )\n+          if (unknownConfigs.nonEmpty) {\n+            println(\n+              s\"[warning] Unknown configs: ${unknownConfigs.mkString(\",\")}\"\n+            )\n+          }\n+          val javaHome =\n+            Option(System.getProperty(\"java.home\")).map(Paths.get(_))\n+          C.Project(\n+            id,\n+            directory = baseDirectory,\n+            sources,\n+            dependencies = dependsOn.toList,\n+            targetDependencies ++ libraryDependencyClasspaths,\n+            out,\n+            classDirectory,\n+            scala = Some(\n+              C.Scala(\n+                \"org.scala-lang\",\n+                \"scala-compiler\",\n+                \"2.12.10\",\n+                List.empty[String],\n+                scalaJars.iterator.map(_.toPath).toList,\n+                None,\n+                setup = Some(\n+                  C.CompileSetup(\n+                    C.Mixed,\n+                    addLibraryToBootClasspath = true,\n+                    addCompilerToClasspath = false,\n+                    addExtraJarsToClasspath = false,\n+                    manageBootClasspath = true,\n+                    filterLibraryFromClasspath = true\n+                  )\n+                )\n+              )\n+            ),\n+            java = Some(C.Java(Nil)),\n+            sbt = None,\n+            test = None,\n+            platform = Some(C.Platform.Jvm(C.JvmConfig(javaHome, Nil), None)),\n+            resolution = Some(C.Resolution(libraryDependencySources)),\n+            resources = None\n+          )\n+      }.toSeq\n+      val byName = bloopProjects.map(p => p.name -> p).toMap\n+      val transitiveClasspath = mutable.Map.empty[String, List[Path]]\n+      val isVisited = mutable.Set.empty[String]\n+      def getTransitiveClasspath(name: String): List[Path] = {\n+        if (isVisited(name)) {\n+          transitiveClasspath.getOrElse(name, Nil)\n+        } else {\n+          isVisited += name\n+          val result = transitiveClasspath.getOrElseUpdate(\n+            name, {\n+              val buf = mutable.Set.empty[Path]\n+              buf ++= byName(name).classpath\n+              byName(name).dependencies.foreach { dep =>\n+                buf ++= getTransitiveClasspath(dep)\n+              }\n+              val children = cycles.children.getOrElse(name, Nil)\n+              children.foreach { child =>\n+                buf ++= getTransitiveClasspath(child)\n+              }\n+              buf.toList.sorted\n+            }\n+          )\n+          result\n+        }\n+      }\n+\n+      val fullClasspathProjects = bloopProjects.map { p =>\n+        val children = cycles.children.getOrElse(p.name, Nil)\n+        val extraSources = children.flatMap(child => byName(child).sources)\n+        val extraDependencies = children.iterator\n+          .flatMap(child => byName(child).dependencies)\n+          .filter(_ != p.name)\n+          .toSeq\n+        p.copy(\n+          classpath = getTransitiveClasspath(p.name),\n+          sources = (p.sources ++ extraSources).distinct,\n+          dependencies = (p.dependencies ++ extraDependencies).distinct\n+        )\n+      }\n+\n+      var generatedProjects = Set.empty[Path]\n+      fullClasspathProjects.foreach { bloop =>\n+        if (!cycles.parents.contains(bloop.name)) {\n+          val out = bloopRoot.resolve(makeFilename(bloop.name) + \".json\")\n+          val json = C.File(BloopVersion, bloop)\n+          _root_.bloop.config.write(json, out)\n+          generatedProjects += out\n+        }\n+      }\n+      cleanOldBloopFiles(bloopRoot, generatedProjects)\n+      Some(BloopInstallResult(fullClasspathProjects.size))\n+    } else {"
  },
  {
    "id" : "80d95c8a-61ff-40ea-ac6c-00d95a342dea",
    "prId" : 935,
    "comments" : [
      {
        "id" : "5113fe2c-0ca7-4e2f-8beb-91b35e3d067e",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "Old or stale?",
        "createdAt" : "2019-09-25T08:59:47Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a5c2fd7-cd63-4b2c-80d5-8b8e94e54ada",
        "parentId" : "5113fe2c-0ca7-4e2f-8beb-91b35e3d067e",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Renamed to \"stale\"",
        "createdAt" : "2019-09-27T14:22:42Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++\n+              getLibraryDependencies(\"shaded\") ++\n+              getLibraryDependencies(\"linux-x86_64\") ++\n+              getLibraryDependencies(\"thrift9\")\n+          val knownConfigs =\n+            Set(\"default\", \"linux-x86_64\", \"thrift9\", \"sources\", \"shaded\")\n+          val unknownConfigs = libraryDependencies.flatMap(\n+            lib => lib.obj.keys.toSet -- knownConfigs\n+          )\n+          if (unknownConfigs.nonEmpty) {\n+            println(\n+              s\"[warning] Unknown configs: ${unknownConfigs.mkString(\",\")}\"\n+            )\n+          }\n+          val javaHome =\n+            Option(System.getProperty(\"java.home\")).map(Paths.get(_))\n+          C.Project(\n+            id,\n+            directory = baseDirectory,\n+            sources,\n+            dependencies = dependsOn.toList,\n+            targetDependencies ++ libraryDependencyClasspaths,\n+            out,\n+            classDirectory,\n+            scala = Some(\n+              C.Scala(\n+                \"org.scala-lang\",\n+                \"scala-compiler\",\n+                \"2.12.10\",\n+                List.empty[String],\n+                scalaJars.iterator.map(_.toPath).toList,\n+                None,\n+                setup = Some(\n+                  C.CompileSetup(\n+                    C.Mixed,\n+                    addLibraryToBootClasspath = true,\n+                    addCompilerToClasspath = false,\n+                    addExtraJarsToClasspath = false,\n+                    manageBootClasspath = true,\n+                    filterLibraryFromClasspath = true\n+                  )\n+                )\n+              )\n+            ),\n+            java = Some(C.Java(Nil)),\n+            sbt = None,\n+            test = None,\n+            platform = Some(C.Platform.Jvm(C.JvmConfig(javaHome, Nil), None)),\n+            resolution = Some(C.Resolution(libraryDependencySources)),\n+            resources = None\n+          )\n+      }.toSeq\n+      val byName = bloopProjects.map(p => p.name -> p).toMap\n+      val transitiveClasspath = mutable.Map.empty[String, List[Path]]\n+      val isVisited = mutable.Set.empty[String]\n+      def getTransitiveClasspath(name: String): List[Path] = {\n+        if (isVisited(name)) {\n+          transitiveClasspath.getOrElse(name, Nil)\n+        } else {\n+          isVisited += name\n+          val result = transitiveClasspath.getOrElseUpdate(\n+            name, {\n+              val buf = mutable.Set.empty[Path]\n+              buf ++= byName(name).classpath\n+              byName(name).dependencies.foreach { dep =>\n+                buf ++= getTransitiveClasspath(dep)\n+              }\n+              val children = cycles.children.getOrElse(name, Nil)\n+              children.foreach { child =>\n+                buf ++= getTransitiveClasspath(child)\n+              }\n+              buf.toList.sorted\n+            }\n+          )\n+          result\n+        }\n+      }\n+\n+      val fullClasspathProjects = bloopProjects.map { p =>\n+        val children = cycles.children.getOrElse(p.name, Nil)\n+        val extraSources = children.flatMap(child => byName(child).sources)\n+        val extraDependencies = children.iterator\n+          .flatMap(child => byName(child).dependencies)\n+          .filter(_ != p.name)\n+          .toSeq\n+        p.copy(\n+          classpath = getTransitiveClasspath(p.name),\n+          sources = (p.sources ++ extraSources).distinct,\n+          dependencies = (p.dependencies ++ extraDependencies).distinct\n+        )\n+      }\n+\n+      var generatedProjects = Set.empty[Path]\n+      fullClasspathProjects.foreach { bloop =>\n+        if (!cycles.parents.contains(bloop.name)) {\n+          val out = bloopRoot.resolve(makeFilename(bloop.name) + \".json\")\n+          val json = C.File(BloopVersion, bloop)\n+          _root_.bloop.config.write(json, out)\n+          generatedProjects += out\n+        }\n+      }\n+      cleanOldBloopFiles(bloopRoot, generatedProjects)\n+      Some(BloopInstallResult(fullClasspathProjects.size))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def cleanOldBloopFiles("
  },
  {
    "id" : "6248ac87-b11c-40ec-8bd5-6373558a5277",
    "prId" : 935,
    "comments" : [
      {
        "id" : "346af51b-8308-42cb-aa17-a94f49e1a7d8",
        "parentId" : null,
        "author" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "body" : "those conditions could be put in `filter` clauses for greater readability",
        "createdAt" : "2019-09-25T09:00:24Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "marek1840",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/3709537?u=2bdae30d4b911a57f5cb033e41831a6373de88bb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09211a7e-3484-400a-bfc1-0c4a5e1e3930",
        "parentId" : "346af51b-8308-42cb-aa17-a94f49e1a7d8",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-09-27T14:23:53Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,373 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import coursier._\n+import java.nio.file.Paths\n+import scala.sys.process._\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import java.nio.file.PathMatcher\n+import java.nio.file.FileSystems\n+import java.util.stream.Collectors\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import java.util.concurrent.TimeUnit\n+import ujson.Value\n+import ujson.Str\n+\n+object BloopPants {\n+\n+  def main(args: Array[String]): Unit = {\n+    if (args.isEmpty) {\n+      println(\"missing <workspace>\")\n+    } else if (args.sameElements(Array(\"--help\"))) {\n+      println(\n+        \"\"\"pants-bloop <workspacedir> <target>\"\n+          |\n+          |Command-line tool to export a Pants build into Bloop JSON config files.\n+          |\n+          |workpacedir: the base directory of the workspace where pants.ini exists.\n+          |target: a target to export such as \"src/scala::\".\n+          |\"\"\".stripMargin\n+      )\n+    } else if (args.length < 2) {\n+      println(\"missing <target>\")\n+    } else {\n+      val buildroot = Paths.get(args(0))\n+      val target = args(1)\n+      val isCached = args.contains(\"--with-cache\")\n+      val timer = new Timer()\n+      bloopInstall(buildroot, target, isCached) match {\n+        case None =>\n+          println(\"bloopInstall failed\")\n+          sys.exit(1)\n+        case Some(result) =>\n+          println(\n+            s\"Exported ${result.exportedTargetCount} project(s) in $timer\"\n+          )\n+      }\n+    }\n+  }\n+\n+  case class BloopInstallResult(exportedTargetCount: Int)\n+\n+  def bloopInstall(\n+      buildroot: Path,\n+      target: String,\n+      isCached: Boolean\n+  ): Option[BloopInstallResult] = {\n+    val pantsd = buildroot.resolve(\".pants.d\").resolve(\"metals\")\n+    if (!Files.isDirectory(pantsd)) {\n+      Files.createDirectories(pantsd)\n+    }\n+\n+    val query = target.replaceAll(\"[^a-zA-Z0-9]\", \"\")\n+\n+    val export = pantsd.resolve(s\"$query.json\")\n+    val bloopRoot = buildroot.resolve(\".bloop\")\n+    Files.createDirectories(bloopRoot)\n+\n+    if (!isCached || !Files.isRegularFile(export)) {\n+      val exportTimer = new Timer()\n+      val pantsBinary = buildroot.resolve(\"pants\").toString()\n+      val commandName = s\"$pantsBinary export $target\"\n+      println(s\"running '$commandName', this may take a while...\")\n+      val command = List[String](\n+        pantsBinary,\n+        \"--export-libraries-sources\",\n+        s\"--export-output-file=$export\",\n+        \"export\",\n+        target\n+      )\n+      val exit = Process(command, Some(buildroot.toFile)).!\n+      if (exit != 0) {\n+        println(s\"$commandName exit: $exit\")\n+        sys.exit(1)\n+      }\n+      println(s\"time: ran $commandName in $exportTimer\")\n+    }\n+\n+    if (Files.isRegularFile(export)) {\n+      val text =\n+        new String(Files.readAllBytes(export), StandardCharsets.UTF_8)\n+      val json = ujson.read(text)\n+      val cycles = Cycles.findConnectedComponents(json)\n+      val scalaJars = coursier\n+        .Fetch()\n+        .addDependencies(\n+          dep\"org.scala-lang:scala-compiler:2.12.10\",\n+          dep\"jline:jline:2.14.6\"\n+        )\n+        .run()\n+      def mkGlob(str: String): PathMatcher = {\n+        FileSystems\n+          .getDefault()\n+          .getPathMatcher(\n+            \"glob:\" + buildroot\n+              .resolve(str.replaceAllLiterally(\"**/*\", \"**\"))\n+              .toString()\n+          )\n+      }\n+      val targets = json.obj(\"targets\").obj\n+      val libraries = json.obj(\"libraries\").obj\n+      val bloopProjects: Seq[C.Project] = targets.iterator.map {\n+        case (id, target) =>\n+          val isLogging = id == \"util/util-logging/src/main/scala/com/twitter/logging:logging\"\n+          val baseDirectories = for {\n+            roots <- target.obj.get(\"roots\").toList\n+            root <- roots.arr\n+            sourceRoot <- root.obj.get(\"source_root\")\n+          } yield Paths.get(sourceRoot.str)\n+          val baseDirectory = baseDirectories.headOption.getOrElse(buildroot)\n+          val jsonPath = bloopRoot.resolve(id + \".json\")\n+          val out = bloopRoot.resolve(makeFilename(id))\n+          val classDirectory = out.resolve(\"classes\")\n+          Files.createDirectories(classDirectory)\n+          val (globs, excludes) = target.obj.get(\"globs\") match {\n+            case None =>\n+              baseDirectories.map { dir =>\n+                val path = buildroot.resolve(dir).resolve(\"**\")\n+                Str(path.toString())\n+              } -> Nil\n+            case Some(globs) =>\n+              val ex = globs.obj.get(\"exclude\") match {\n+                case None => Nil\n+                case Some(excludes) =>\n+                  for {\n+                    exclude <- excludes.arr.toSeq\n+                    globs <- exclude.obj.get(\"globs\").toSeq\n+                    glob <- globs.arr\n+                  } yield mkGlob(glob.str)\n+              }\n+              globs.obj(\"globs\").arr -> ex\n+          }\n+          val sources: List[Path] = globs.iterator.flatMap { glob =>\n+            // NOTE(olafurpg): it's not ideal that we reimplement the glob\n+            // expansion logic here. It would be nice to use an official\n+            // library instead.\n+            if (glob.str.contains(\"*\")) {\n+              val parent = buildroot.resolve(glob.str).getParent()\n+              val includes = mkGlob(glob.str)\n+              val stream: java.util.stream.Stream[Path] =\n+                if (parent.endsWith(\"**\")) {\n+                  if (Files.isDirectory(parent.getParent()))\n+                    Files.walk(parent.getParent())\n+                  else java.util.stream.Stream.empty()\n+                } else if (Files.isDirectory(parent)) {\n+                  Files.list(parent)\n+                } else {\n+                  java.util.stream.Stream.empty()\n+                }\n+\n+              stream\n+                .map[Path] { path =>\n+                  if (path.isAbsolute()) path.toAbsolutePath()\n+                  else buildroot.resolve(path).toAbsolutePath()\n+                }\n+                .filter { path =>\n+                  Files.isRegularFile(path)\n+                }\n+                .filter { path =>\n+                  includes.matches(path) &&\n+                  !excludes.exists(_.matches(path))\n+                }\n+                .collect(Collectors.toList())\n+                .asScala\n+                .toList\n+            } else {\n+              val path = Paths.get(glob.str)\n+              val abspath =\n+                if (path.isAbsolute()) path\n+                else buildroot.resolve(path)\n+              List(abspath)\n+            }\n+          }.toList\n+          val dependsOn = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+            acyclicDependency = cycles.parents.getOrElse(\n+              dependency.str,\n+              dependency.str\n+            )\n+            if acyclicDependency != id\n+            if targets(acyclicDependency)\n+              .obj(\"pants_target_type\")\n+              .str != \"files\"\n+          } yield acyclicDependency).toList\n+          val targetDependencies: List[Path] = (for {\n+            dependency <- target.obj(\"targets\").arr.iterator\n+          } yield\n+            bloopRoot\n+              .resolve(makeFilename(dependency.str))\n+              .resolve(\"classes\")).toList\n+          val libraryDependencies: List[Value] = (for {\n+            dependency <- target.obj(\"libraries\").arr.iterator\n+            library <- libraries.get(dependency.str)\n+          } yield library).toList\n+          def getLibraryDependencies(key: String): List[Path] =\n+            (for {\n+              lib <- libraryDependencies\n+              default <- lib.obj.get(key)\n+            } yield Paths.get(default.str))\n+          val libraryDependencySources: List[C.Module] =\n+            for {\n+              source <- getLibraryDependencies(\"sources\")\n+            } yield\n+              C.Module(\n+                \"\",\n+                \"\",\n+                \"\",\n+                None,\n+                artifacts = List(\n+                  C.Artifact(\n+                    \"\",\n+                    classifier = Some(\"sources\"),\n+                    None,\n+                    path = source\n+                  )\n+                )\n+              )\n+          val libraryDependencyClasspaths: List[Path] =\n+            getLibraryDependencies(\"default\") ++\n+              getLibraryDependencies(\"shaded\") ++\n+              getLibraryDependencies(\"linux-x86_64\") ++\n+              getLibraryDependencies(\"thrift9\")\n+          val knownConfigs =\n+            Set(\"default\", \"linux-x86_64\", \"thrift9\", \"sources\", \"shaded\")\n+          val unknownConfigs = libraryDependencies.flatMap(\n+            lib => lib.obj.keys.toSet -- knownConfigs\n+          )\n+          if (unknownConfigs.nonEmpty) {\n+            println(\n+              s\"[warning] Unknown configs: ${unknownConfigs.mkString(\",\")}\"\n+            )\n+          }\n+          val javaHome =\n+            Option(System.getProperty(\"java.home\")).map(Paths.get(_))\n+          C.Project(\n+            id,\n+            directory = baseDirectory,\n+            sources,\n+            dependencies = dependsOn.toList,\n+            targetDependencies ++ libraryDependencyClasspaths,\n+            out,\n+            classDirectory,\n+            scala = Some(\n+              C.Scala(\n+                \"org.scala-lang\",\n+                \"scala-compiler\",\n+                \"2.12.10\",\n+                List.empty[String],\n+                scalaJars.iterator.map(_.toPath).toList,\n+                None,\n+                setup = Some(\n+                  C.CompileSetup(\n+                    C.Mixed,\n+                    addLibraryToBootClasspath = true,\n+                    addCompilerToClasspath = false,\n+                    addExtraJarsToClasspath = false,\n+                    manageBootClasspath = true,\n+                    filterLibraryFromClasspath = true\n+                  )\n+                )\n+              )\n+            ),\n+            java = Some(C.Java(Nil)),\n+            sbt = None,\n+            test = None,\n+            platform = Some(C.Platform.Jvm(C.JvmConfig(javaHome, Nil), None)),\n+            resolution = Some(C.Resolution(libraryDependencySources)),\n+            resources = None\n+          )\n+      }.toSeq\n+      val byName = bloopProjects.map(p => p.name -> p).toMap\n+      val transitiveClasspath = mutable.Map.empty[String, List[Path]]\n+      val isVisited = mutable.Set.empty[String]\n+      def getTransitiveClasspath(name: String): List[Path] = {\n+        if (isVisited(name)) {\n+          transitiveClasspath.getOrElse(name, Nil)\n+        } else {\n+          isVisited += name\n+          val result = transitiveClasspath.getOrElseUpdate(\n+            name, {\n+              val buf = mutable.Set.empty[Path]\n+              buf ++= byName(name).classpath\n+              byName(name).dependencies.foreach { dep =>\n+                buf ++= getTransitiveClasspath(dep)\n+              }\n+              val children = cycles.children.getOrElse(name, Nil)\n+              children.foreach { child =>\n+                buf ++= getTransitiveClasspath(child)\n+              }\n+              buf.toList.sorted\n+            }\n+          )\n+          result\n+        }\n+      }\n+\n+      val fullClasspathProjects = bloopProjects.map { p =>\n+        val children = cycles.children.getOrElse(p.name, Nil)\n+        val extraSources = children.flatMap(child => byName(child).sources)\n+        val extraDependencies = children.iterator\n+          .flatMap(child => byName(child).dependencies)\n+          .filter(_ != p.name)\n+          .toSeq\n+        p.copy(\n+          classpath = getTransitiveClasspath(p.name),\n+          sources = (p.sources ++ extraSources).distinct,\n+          dependencies = (p.dependencies ++ extraDependencies).distinct\n+        )\n+      }\n+\n+      var generatedProjects = Set.empty[Path]\n+      fullClasspathProjects.foreach { bloop =>\n+        if (!cycles.parents.contains(bloop.name)) {\n+          val out = bloopRoot.resolve(makeFilename(bloop.name) + \".json\")\n+          val json = C.File(BloopVersion, bloop)\n+          _root_.bloop.config.write(json, out)\n+          generatedProjects += out\n+        }\n+      }\n+      cleanOldBloopFiles(bloopRoot, generatedProjects)\n+      Some(BloopInstallResult(fullClasspathProjects.size))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  def cleanOldBloopFiles(\n+      bloopRoot: Path,\n+      generatedProjects: Set[Path]\n+  ): Unit = {\n+    val ls = Files.list(bloopRoot)\n+    try {\n+      ls.forEach { path =>\n+        if (Files.isRegularFile(path) &&"
  },
  {
    "id" : "fc67c9c8-c31a-4fdd-8116-39e227f97430",
    "prId" : 935,
    "comments" : [
      {
        "id" : "592572d2-5f3a-4cc3-817c-bc6baaf74297",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "I believe Jorge was strongly opposed to anything than bloop modifying the config file while it's working :thinking: ",
        "createdAt" : "2019-12-05T16:13:45Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "814628d1-f111-44bb-8a02-c81b8bd1695b",
        "parentId" : "592572d2-5f3a-4cc3-817c-bc6baaf74297",
        "author" : {
          "login" : "jvican",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/2462974?u=247f9a0cfd142440687595dce462fabed087e912&v=4"
        },
        "body" : "The config file can be modified while it's working, but it must be updated atomically. I don't remember being strongly opposed to this, but I do remember mentioning that tools that don't own these configuration files should never update them, that's something that only the original build tool can do. Let me know if this clarifies your thinking @tgodzik :smile:",
        "createdAt" : "2019-12-05T16:47:30Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "jvican",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/2462974?u=247f9a0cfd142440687595dce462fabed087e912&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cc7ce33b-80f3-4861-ae1c-e5bf78eeb461",
        "parentId" : "592572d2-5f3a-4cc3-817c-bc6baaf74297",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "@jvican Thanks! That makes sense, I must have misunderstood previously.",
        "createdAt" : "2019-12-05T16:56:53Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d1511798-3474-438b-977f-de255d2b5125",
        "parentId" : "592572d2-5f3a-4cc3-817c-bc6baaf74297",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Sounds great! I will follow up with a PR to make our file write operations atomic.\r\n\r\nWe use `_root_.bloop.config.write(json, out)` to write most of the JSON files in the Pants export. This step here happens only when the user creates a new file and we need to re-expand the file globs.",
        "createdAt" : "2019-12-05T20:24:45Z",
        "updatedAt" : "2019-12-05T20:24:45Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : 84,
    "diffHunk" : "@@ -0,0 +1,657 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import java.nio.file.Paths\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import scala.collection.mutable\n+import ujson.Value\n+import scala.util.Success\n+import scala.util.Failure\n+import scala.util.Try\n+import scala.meta.internal.metals.BuildInfo\n+import scala.meta.internal.metals.Timer\n+import scala.meta.internal.metals.Time\n+import java.nio.file.NoSuchFileException\n+import scala.meta.internal.mtags.MD5\n+import scala.util.Properties\n+import coursierapi.Dependency\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.process.SystemProcess\n+import scala.meta.pc.CancelToken\n+import scala.util.control.NonFatal\n+import scala.meta.internal.pc.InterruptException\n+import scala.meta.internal.metals.MetalsLogger\n+import scala.meta.io.AbsolutePath\n+import scala.meta.internal.ansi.LineListener\n+import java.util.concurrent.CancellationException\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import scala.sys.process.Process\n+\n+object BloopPants {\n+\n+  def main(argStrings: Array[String]): Unit = {\n+    MetalsLogger.updateDefaultFormat()\n+    Args.parse(argStrings.toList) match {\n+      case Left(errors) =>\n+        errors.foreach { error =>\n+          scribe.error(error)\n+        }\n+        System.exit(1)\n+      case Right(args) =>\n+        if (args.isHelp) {\n+          println(args.helpMessage)\n+        } else if (args.isRegenerate) {\n+          bloopRegenerate(\n+            AbsolutePath(args.workspace),\n+            args.targets\n+          )(ExecutionContext.global)\n+        } else {\n+          val workspace = args.workspace\n+          val targets = args.targets\n+          val timer = new Timer(Time.system)\n+          val installResult = bloopInstall(args)(ExecutionContext.global)\n+          installResult match {\n+            case Failure(exception) =>\n+              scribe.error(s\"bloopInstall failed in $timer\", exception)\n+              sys.exit(1)\n+            case Success(count) =>\n+              scribe.info(s\"time: exported ${count} Pants target(s) in $timer\")\n+          }\n+        }\n+    }\n+  }\n+\n+  def bloopAddOwnerOf(\n+      workspace: AbsolutePath,\n+      source: AbsolutePath\n+  ): Seq[BuildTargetIdentifier] = synchronized {\n+    val targets = pantsOwnerOf(workspace, source)\n+    if (targets.nonEmpty) {\n+      val bloopDir = workspace.resolve(\".bloop\")\n+      for {\n+        target <- targets\n+        jsonFile = bloopDir.resolve(BloopPants.makeJsonFilename(target))\n+        if jsonFile.isFile\n+      } {\n+        val json = ujson.read(jsonFile.readText)\n+        val sources = json(\"project\")(\"sources\").arr\n+        val sourceStr = Value.Str(source.toString())\n+        if (!sources.contains(sourceStr)) {\n+          sources += sourceStr\n+          jsonFile.writeText(ujson.write(json, indent = 4))"
  },
  {
    "id" : "2b7def8f-5f26-4c44-84cf-dda022eeb61c",
    "prId" : 935,
    "comments" : [
      {
        "id" : "0f46655b-6c0e-4c65-a189-9a88b4085a6a",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Shouldn't we use the process runner from the bloopInstall function?",
        "createdAt" : "2019-12-05T16:27:53Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2b2d19d6-8d62-4e8c-aaf1-c9e670eeed45",
        "parentId" : "0f46655b-6c0e-4c65-a189-9a88b4085a6a",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "No, since that one launches `metals/slowTask` and we call several system processes in this step.",
        "createdAt" : "2019-12-05T19:24:11Z",
        "updatedAt" : "2019-12-05T19:30:31Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a95ae87fd9621161d156685f32480fcb7bb451a4",
    "line" : 212,
    "diffHunk" : "@@ -0,0 +1,657 @@\n+package scala.meta.internal.pantsbuild\n+\n+import bloop.config.{Config => C}\n+import java.nio.file.Paths\n+import java.nio.file.Files\n+import java.nio.charset.StandardCharsets\n+import java.nio.file.Path\n+import scala.collection.mutable\n+import ujson.Value\n+import scala.util.Success\n+import scala.util.Failure\n+import scala.util.Try\n+import scala.meta.internal.metals.BuildInfo\n+import scala.meta.internal.metals.Timer\n+import scala.meta.internal.metals.Time\n+import java.nio.file.NoSuchFileException\n+import scala.meta.internal.mtags.MD5\n+import scala.util.Properties\n+import coursierapi.Dependency\n+import scala.concurrent.ExecutionContext\n+import scala.meta.internal.metals.MetalsEnrichments._\n+import scala.meta.internal.process.SystemProcess\n+import scala.meta.pc.CancelToken\n+import scala.util.control.NonFatal\n+import scala.meta.internal.pc.InterruptException\n+import scala.meta.internal.metals.MetalsLogger\n+import scala.meta.io.AbsolutePath\n+import scala.meta.internal.ansi.LineListener\n+import java.util.concurrent.CancellationException\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier\n+import scala.sys.process.Process\n+\n+object BloopPants {\n+\n+  def main(argStrings: Array[String]): Unit = {\n+    MetalsLogger.updateDefaultFormat()\n+    Args.parse(argStrings.toList) match {\n+      case Left(errors) =>\n+        errors.foreach { error =>\n+          scribe.error(error)\n+        }\n+        System.exit(1)\n+      case Right(args) =>\n+        if (args.isHelp) {\n+          println(args.helpMessage)\n+        } else if (args.isRegenerate) {\n+          bloopRegenerate(\n+            AbsolutePath(args.workspace),\n+            args.targets\n+          )(ExecutionContext.global)\n+        } else {\n+          val workspace = args.workspace\n+          val targets = args.targets\n+          val timer = new Timer(Time.system)\n+          val installResult = bloopInstall(args)(ExecutionContext.global)\n+          installResult match {\n+            case Failure(exception) =>\n+              scribe.error(s\"bloopInstall failed in $timer\", exception)\n+              sys.exit(1)\n+            case Success(count) =>\n+              scribe.info(s\"time: exported ${count} Pants target(s) in $timer\")\n+          }\n+        }\n+    }\n+  }\n+\n+  def bloopAddOwnerOf(\n+      workspace: AbsolutePath,\n+      source: AbsolutePath\n+  ): Seq[BuildTargetIdentifier] = synchronized {\n+    val targets = pantsOwnerOf(workspace, source)\n+    if (targets.nonEmpty) {\n+      val bloopDir = workspace.resolve(\".bloop\")\n+      for {\n+        target <- targets\n+        jsonFile = bloopDir.resolve(BloopPants.makeJsonFilename(target))\n+        if jsonFile.isFile\n+      } {\n+        val json = ujson.read(jsonFile.readText)\n+        val sources = json(\"project\")(\"sources\").arr\n+        val sourceStr = Value.Str(source.toString())\n+        if (!sources.contains(sourceStr)) {\n+          sources += sourceStr\n+          jsonFile.writeText(ujson.write(json, indent = 4))\n+          scribe.info(s\"add source: $jsonFile\")\n+        }\n+      }\n+    }\n+    targets.map { target =>\n+      val baseDirectory = PantsConfiguration.baseDirectory(workspace, target)\n+      PantsConfiguration.toBloopBuildTarget(baseDirectory, target)\n+    }\n+  }\n+\n+  def pantsOwnerOf(\n+      workspace: AbsolutePath,\n+      source: AbsolutePath\n+  ): Seq[String] = {\n+    try {\n+      val relpath = source.toRelative(workspace).toString()\n+      val output = Process(\n+        List[String](\n+          workspace.resolve(\"pants\").toString(),\n+          s\"--owner-of=$relpath\",\n+          \"list\"\n+        ),\n+        cwd = Some(workspace.toFile)\n+      ).!!\n+      output.linesIterator.toSeq.distinct\n+    } catch {\n+      case NonFatal(_) =>\n+        Nil\n+    }\n+  }\n+\n+  private def targetDirectory(target: String): String = {\n+    val colon = target.lastIndexOf(':')\n+    if (colon < 0) target\n+    else target.substring(0, colon)\n+  }\n+\n+  private def interruptedTry[T](thunk: => T): Try[T] =\n+    try {\n+      Success(thunk)\n+    } catch {\n+      case NonFatal(e) => Failure(e)\n+      case e @ InterruptException() => Failure(e)\n+    }\n+\n+  def bloopInstall(args: Args)(implicit ec: ExecutionContext): Try[Int] =\n+    interruptedTry {\n+      val cacheDir = Files.createDirectories(\n+        args.workspace.resolve(\".pants.d\").resolve(\"metals\")\n+      )\n+      val outputFilename = {\n+        val processed =\n+          args.targets.map(_.replaceAll(\"[^a-zA-Z0-9]\", \"\")).mkString\n+        if (processed.isEmpty()) {\n+          MD5.compute(args.targets.mkString) // necessary for targets like \"::/\"\n+        } else {\n+          processed\n+        }\n+      }\n+      val outputFile = cacheDir.resolve(s\"$outputFilename.json\")\n+      val bloopDir = Files.createDirectories(args.out.resolve(\".bloop\"))\n+      args.token.checkCanceled()\n+\n+      val filemap = Filemap.fromPants(args.workspace, args.targets)\n+      val fileCount = filemap.fileCount()\n+      if (fileCount > args.maxFileCount) {\n+        val targetSyntax = args.targets.mkString(\"'\", \"' '\", \"'\")\n+        scribe.error(\n+          s\"The target set ${targetSyntax} is too broad, it expands to ${fileCount} source files \" +\n+            s\"when the maximum number of allowed source files is ${args.maxFileCount}. \" +\n+            s\"To fix this problem, configure a smaller set of Pants targets.\"\n+        )\n+        throw new CancellationException(\"too many Pants targets\")\n+      }\n+      args.onFilemap(filemap)\n+\n+      if (!args.isCache || !Files.isRegularFile(outputFile)) {\n+        runPantsExport(args, outputFile)\n+      }\n+\n+      if (Files.isRegularFile(outputFile)) {\n+        val text =\n+          new String(Files.readAllBytes(outputFile), StandardCharsets.UTF_8)\n+        val json = ujson.read(text)\n+        new BloopPants(args, bloopDir, json, filemap).run()\n+      } else {\n+        throw new NoSuchFileException(\n+          outputFile.toString(),\n+          null,\n+          \"expected this file to exist after running `./pants export`\"\n+        )\n+      }\n+    }\n+\n+  def bloopRegenerate(\n+      workspace: AbsolutePath,\n+      targets: List[String]\n+  )(implicit ec: ExecutionContext): Unit = {\n+    val filemap = Filemap.fromPants(workspace.toNIO, targets)\n+    val bloopDir = workspace.resolve(\".bloop\")\n+    for {\n+      (target, files) <- filemap.iterator()\n+      jsonFile = bloopDir.resolve(BloopPants.makeJsonFilename(target))\n+      if jsonFile.isFile\n+    } {\n+      val json = ujson.read(jsonFile.readText)\n+      val newSources =\n+        files.iterator.map(file => Value.Str(file.toString)).toBuffer\n+      json(\"project\")(\"sources\") = newSources\n+      jsonFile.writeText(ujson.write(json, indent = 4))\n+    }\n+  }\n+\n+  private def runPantsExport(\n+      args: Args,\n+      outputFile: Path\n+  )(implicit ec: ExecutionContext): Unit = {\n+    val pantsBinary = args.workspace.resolve(\"pants\").toString()\n+    val command = List[String](\n+      pantsBinary,\n+      s\"--no-quiet\",\n+      s\"--export-libraries-sources\",\n+      s\"--export-output-file=$outputFile\",\n+      s\"export-classpath\",\n+      s\"export\"\n+    ) ++ args.targets\n+    val shortName = \"pants export-classpath export\"\n+    SystemProcess.run("
  },
  {
    "id" : "16350849-1950-44bc-8ade-8073bf0377e4",
    "prId" : 1181,
    "comments" : [
      {
        "id" : "ba1d59b8-31b5-4a52-a582-8f5d714ac53a",
        "parentId" : null,
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "nit: `if (!export.cycles.parents.contains(project.name))`",
        "createdAt" : "2019-12-10T20:32:07Z",
        "updatedAt" : "2019-12-11T10:39:31Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "714147af-17d4-43bd-a400-cf067587770f",
        "parentId" : "ba1d59b8-31b5-4a52-a582-8f5d714ac53a",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-12-11T10:08:09Z",
        "updatedAt" : "2019-12-11T10:39:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "da92e30ee6e1e5d61ccb46ecfc290af2da243900",
    "line" : null,
    "diffHunk" : "@@ -263,89 +253,81 @@ private class BloopPants(\n       Properties.versionNumberString\n     }\n   val allScalaJars: Seq[Path] = {\n-    val scalaJars = libraries.collect {\n-      case (module, jar) if isScalaJar(module) =>\n-        Paths.get(jar.obj(\"default\").str)\n-    }.toSeq\n-    val hasScalaCompiler =\n-      scalaJars.exists(_.getFileName().toString().contains(\"scala-compiler\"))\n-    if (hasScalaCompiler) {\n-      scalaJars\n-    } else {\n-      scalaJars ++\n-        coursierapi.Fetch\n-          .create()\n-          .addDependencies(\n-            Dependency.of(\"org.scala-lang\", \"scala-compiler\", compilerVersion)\n-          )\n-          .fetch()\n-          .asScala\n-          .map(_.toPath)\n+    val compilerClasspath = export.scalaPlatform.compilerClasspath\n+    if (compilerClasspath.nonEmpty) compilerClasspath\n+    else {\n+      val scalaJars: Seq[Path] = export.libraries\n+        .collect {\n+          case (module, jar) if isScalaJar(module) => jar.default\n+        }\n+        .flatten\n+        .toSeq\n+      val hasScalaCompiler =\n+        scalaJars.exists(_.getFileName().toString().contains(\"scala-compiler\"))\n+      if (hasScalaCompiler) {\n+        scalaJars\n+      } else {\n+        scalaJars ++\n+          coursierapi.Fetch\n+            .create()\n+            .addDependencies(\n+              Dependency.of(\"org.scala-lang\", \"scala-compiler\", compilerVersion)\n+            )\n+            .fetch()\n+            .asScala\n+            .map(_.toPath)\n+      }\n     }\n   }\n \n   def run(): Int = {\n     token.checkCanceled()\n-    // Create Bloop projects that only contain the classpath of direct\n-    // dependencies but not transitive dependencies.\n-    val shallowClasspathProjects = targets.collect {\n-      case (id, target) if isSupportedTargetType(target) =>\n-        toBloopProject(id, target)\n-    }\n-    val byName = shallowClasspathProjects.map(p => p.name -> p).toMap\n-\n-    // Add full transitive classpath to Bloop projects.\n-    val fullClasspathProjects = shallowClasspathProjects.map { p =>\n-      val children = cycles.children.getOrElse(p.name, Nil)\n-      val extraSources = children.flatMap(child => byName(child).sources)\n-      val extraDependencies = children\n-        .flatMap(child => byName(child).dependencies)\n-        .filter(_ != p.name)\n-      val dependencies = (p.dependencies ++ extraDependencies).distinct\n-      p.copy(\n-        classpath = getTransitiveClasspath(p.name, byName),\n-        sources = (p.sources ++ extraSources).distinct,\n-        dependencies = dependencies.filterNot(_.isBinaryDependency)\n-      )\n-    }\n-\n-    val binaryDependenciesToCompile = mutable.Set.empty[String]\n-    for {\n-      project <- shallowClasspathProjects\n-      if !project.name.isBinaryDependency\n-      dependency <- project.dependencies.iterator\n-      if dependency.isBinaryDependency\n-      dependencyProject <- byName.get(dependency)\n-      if dependencyProject.sources.nonEmpty\n-    } {\n-      binaryDependenciesToCompile += dependency\n-    }\n-\n-    val binaryDependencyResolution =\n+    val projects = export.targets.valuesIterator\n+      .filter(_.isTargetRoot)\n+      .map(toBloopProject)\n+      .toList\n+    // Only emit library sources in one resolution to avoid duplicated\n+    // `*-sources.jar` references.\n+    val binaryDependenciesSourcesIterator =\n       binaryDependencySources.iterator.map(newSourceModule)\n-    var generatedProjects = Set.empty[Path]\n-    fullClasspathProjects.foreach { bloop =>\n-      if (cycles.parents.contains(bloop.name) ||\n-        bloop.name.isBinaryDependency) {\n-        // do nothing\n+    val generatedProjects = new mutable.LinkedHashSet[Path]\n+    val byName = projects.map(p => p.name -> p).toMap\n+    projects.foreach { project =>\n+      if (export.cycles.parents.contains(project.name)) {"
  },
  {
    "id" : "f915087a-3e8e-4c05-8665-3b4fbad250c5",
    "prId" : 1181,
    "comments" : [
      {
        "id" : "ed4cdbf1-8468-42b2-a482-f92a50a67ec4",
        "parentId" : null,
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "nit: I think the `.toList` is unnecessary",
        "createdAt" : "2019-12-10T20:44:17Z",
        "updatedAt" : "2019-12-11T10:39:31Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "87fc5cb5-a4c0-4ad8-b4c7-a81978deebbf",
        "parentId" : "ed4cdbf1-8468-42b2-a482-f92a50a67ec4",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "done",
        "createdAt" : "2019-12-11T10:08:41Z",
        "updatedAt" : "2019-12-11T10:39:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "da92e30ee6e1e5d61ccb46ecfc290af2da243900",
    "line" : null,
    "diffHunk" : "@@ -354,156 +336,72 @@ private class BloopPants(\n     generatedProjects.size\n   }\n \n-  private val unsupportedTargetType = Set(\n-    \"files\", \"page\", \"python_binary\", \"python_tests\", \"python_library\",\n-    \"python_requirement_library\"\n-  )\n-\n-  implicit class XtensionTargetString(value: String) {\n-    def isBinaryDependency: Boolean = {\n-      !userTargets.exists(target => value.startsWith(target.stripSuffix(\"::\")))\n-    }\n-    def baseDirectory: Path =\n-      PantsConfiguration.baseDirectory(AbsolutePath(workspace), value).toNIO\n-  }\n-  implicit class XtensionValue(value: Value) {\n-    def pantsTargetType: String = value.obj(\"pants_target_type\").str\n-    def targetType: String = value.obj(\"target_type\").str\n-    def id: String = value.obj(\"id\").str\n-    def isTestTarget: Boolean = targetType == \"TEST\"\n-    def isResourceTarget: Boolean = targetType == \"RESOURCE\"\n-  }\n-  private def isSupportedTargetType(target: Value): Boolean =\n-    // Instead of whitelisting which target types we support, we hardcode which\n-    // known target types we know we don't support. Pants plugins can introduce\n-    // new target types that are minor variations of for example `scala_library`\n-    // that we may want to support.\n-    !unsupportedTargetType.contains(target.pantsTargetType)\n-\n-  private def toBloopProject(\n-      id: String,\n-      target: Value\n-  ): C.Project = {\n-\n-    val baseDirectories = for {\n-      roots <- target.obj.get(\"roots\").toList\n-      root <- roots.arr\n-      sourceRoot <- root.obj.get(\"source_root\")\n-    } yield Paths.get(sourceRoot.str)\n-\n-    val baseDirectory = id.baseDirectory\n-\n-    val sources =\n-      if (target.isResourceTarget) Nil\n-      else filemap.forTarget(id).toList\n-\n-    // Extract target dependencies.\n-    val dependsOn = (for {\n-      dependency <- target.obj(\"targets\").arr\n-      acyclicDependency = cycles.acyclicDependency(dependency.str)\n-      if acyclicDependency != id\n-      if isSupportedTargetType(targets(acyclicDependency))\n-    } yield acyclicDependency).toList\n-\n-    // Extract class directories of direct target dependencies.\n-    val dependencyClassdirectories: List[Path] = (for {\n-      dependency <- target.obj(\"targets\").arr\n-      classDir <- makeClassdirectory(dependency.str)\n-    } yield classDir).toList\n-\n-    // Extract 3rd party library dependencies, and their associated sources.\n-    val libraryDependencies = for {\n-      dependency <- target.obj(\"libraries\").arr\n-      library <- libraries.get(dependency.str)\n+  private def toBloopProject(target: PantsTarget): C.Project = {\n+\n+    val baseDirectory: Path = PantsConfiguration\n+      .baseDirectory(AbsolutePath(workspace), target.name)\n+      .toNIO\n+\n+    val sources: List[Path] =\n+      if (target.targetType.isResource) Nil\n+      else filemap.forTarget(target.name).toList\n+\n+    val transitiveDependencies: List[PantsTarget] = (for {\n+      dependency <- target.transitiveDependencies\n+      if dependency != target.name\n+    } yield export.targets(dependency)).toList\n+\n+    val dependencies: List[String] = for {\n+      dependency <- transitiveDependencies\n+      // Rewrite dependencies on targets that belong to a cyclic component.\n+      acyclicDependencyName = cycles.acyclicDependency(dependency.name)\n+      if acyclicDependencyName != target.name\n+      acyclicDependency = export.targets(acyclicDependencyName)\n+      if acyclicDependency.isTargetRoot && !acyclicDependency.targetType.isAnyResource\n+    } yield acyclicDependency.name\n+\n+    val libraries: List[PantsLibrary] = for {\n+      dependency <- transitiveDependencies\n+      libraryName <- dependency.libraries\n+      library <- export.libraries.get(libraryName).toList"
  },
  {
    "id" : "8cc89fcf-de62-416e-9b8f-d2a476e9a2c0",
    "prId" : 1181,
    "comments" : [
      {
        "id" : "d2f180dd-bf5d-457c-a4d0-2096353f111a",
        "parentId" : null,
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "nit: I think indenting the `if` would make these filters more readable.",
        "createdAt" : "2019-12-10T20:45:43Z",
        "updatedAt" : "2019-12-11T10:39:31Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bc18280f-2fdc-4331-9507-12dbaefdd9ca",
        "parentId" : "d2f180dd-bf5d-457c-a4d0-2096353f111a",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This is how scalafmt formats this. Originally it used to indent `if` filters in for comprehensions but it got changed because it got weird in places like\r\n```scala\r\nfor {\r\n  a <- list()\r\n  b <- list()\r\n  if a > 2\r\n  if b < 1\r\n```",
        "createdAt" : "2019-12-11T10:10:05Z",
        "updatedAt" : "2019-12-11T10:39:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "da92e30ee6e1e5d61ccb46ecfc290af2da243900",
    "line" : 413,
    "diffHunk" : "@@ -354,156 +336,72 @@ private class BloopPants(\n     generatedProjects.size\n   }\n \n-  private val unsupportedTargetType = Set(\n-    \"files\", \"page\", \"python_binary\", \"python_tests\", \"python_library\",\n-    \"python_requirement_library\"\n-  )\n-\n-  implicit class XtensionTargetString(value: String) {\n-    def isBinaryDependency: Boolean = {\n-      !userTargets.exists(target => value.startsWith(target.stripSuffix(\"::\")))\n-    }\n-    def baseDirectory: Path =\n-      PantsConfiguration.baseDirectory(AbsolutePath(workspace), value).toNIO\n-  }\n-  implicit class XtensionValue(value: Value) {\n-    def pantsTargetType: String = value.obj(\"pants_target_type\").str\n-    def targetType: String = value.obj(\"target_type\").str\n-    def id: String = value.obj(\"id\").str\n-    def isTestTarget: Boolean = targetType == \"TEST\"\n-    def isResourceTarget: Boolean = targetType == \"RESOURCE\"\n-  }\n-  private def isSupportedTargetType(target: Value): Boolean =\n-    // Instead of whitelisting which target types we support, we hardcode which\n-    // known target types we know we don't support. Pants plugins can introduce\n-    // new target types that are minor variations of for example `scala_library`\n-    // that we may want to support.\n-    !unsupportedTargetType.contains(target.pantsTargetType)\n-\n-  private def toBloopProject(\n-      id: String,\n-      target: Value\n-  ): C.Project = {\n-\n-    val baseDirectories = for {\n-      roots <- target.obj.get(\"roots\").toList\n-      root <- roots.arr\n-      sourceRoot <- root.obj.get(\"source_root\")\n-    } yield Paths.get(sourceRoot.str)\n-\n-    val baseDirectory = id.baseDirectory\n-\n-    val sources =\n-      if (target.isResourceTarget) Nil\n-      else filemap.forTarget(id).toList\n-\n-    // Extract target dependencies.\n-    val dependsOn = (for {\n-      dependency <- target.obj(\"targets\").arr\n-      acyclicDependency = cycles.acyclicDependency(dependency.str)\n-      if acyclicDependency != id\n-      if isSupportedTargetType(targets(acyclicDependency))\n-    } yield acyclicDependency).toList\n-\n-    // Extract class directories of direct target dependencies.\n-    val dependencyClassdirectories: List[Path] = (for {\n-      dependency <- target.obj(\"targets\").arr\n-      classDir <- makeClassdirectory(dependency.str)\n-    } yield classDir).toList\n-\n-    // Extract 3rd party library dependencies, and their associated sources.\n-    val libraryDependencies = for {\n-      dependency <- target.obj(\"libraries\").arr\n-      library <- libraries.get(dependency.str)\n+  private def toBloopProject(target: PantsTarget): C.Project = {\n+\n+    val baseDirectory: Path = PantsConfiguration\n+      .baseDirectory(AbsolutePath(workspace), target.name)\n+      .toNIO\n+\n+    val sources: List[Path] =\n+      if (target.targetType.isResource) Nil\n+      else filemap.forTarget(target.name).toList\n+\n+    val transitiveDependencies: List[PantsTarget] = (for {\n+      dependency <- target.transitiveDependencies\n+      if dependency != target.name\n+    } yield export.targets(dependency)).toList\n+\n+    val dependencies: List[String] = for {\n+      dependency <- transitiveDependencies\n+      // Rewrite dependencies on targets that belong to a cyclic component.\n+      acyclicDependencyName = cycles.acyclicDependency(dependency.name)\n+      if acyclicDependencyName != target.name\n+      acyclicDependency = export.targets(acyclicDependencyName)\n+      if acyclicDependency.isTargetRoot && !acyclicDependency.targetType.isAnyResource\n+    } yield acyclicDependency.name\n+\n+    val libraries: List[PantsLibrary] = for {\n+      dependency <- transitiveDependencies\n+      libraryName <- dependency.libraries\n+      library <- export.libraries.get(libraryName).toList\n     } yield library\n-    val libraryDependencyConfigs: List[String] =\n-      List(\"test\", \"default\", \"shaded\", \"linux-x86_64\", \"thrift9\")\n-    val libraryDependencyClasspaths =\n-      getLibraryDependencies(libraryDependencies, libraryDependencyConfigs)\n-    val sourcesConfigs = List(\"sources\")\n-    val libraryDependencySources =\n-      getLibraryDependencies(libraryDependencies, sourcesConfigs)\n-\n-    // Warn about unfamiliar configurations.\n-    val knownConfigs = sourcesConfigs ::: libraryDependencyConfigs\n-    val unknownConfigs = libraryDependencies\n-      .flatMap(lib => lib.obj.keys.toSet -- knownConfigs)\n-      .distinct\n-    if (unknownConfigs.nonEmpty) {\n-      val kinds = unknownConfigs.mkString(\",\")\n-      println(\n-        s\"[warning] Unknown configs for target '${id}' with type '${target.targetType}': ${kinds}\"\n-      )\n-    }\n-\n-    val out = bloopDir.resolve(BloopPants.makeFilename(id))\n-    val classDirectory = out.resolve(\"classes\")\n-    val javaHome = Option(System.getProperty(\"java.home\")).map(Paths.get(_))\n-\n-    val resources =\n-      if (target.isResourceTarget) {\n-        // Resources are relativized by the directory where the BUILD file exists.\n-        Some(List(baseDirectory))\n-      } else {\n-        None\n-      }\n-\n-    val test = if (target.pantsTargetType.contains(\"test\")) {\n-      val scalatest = C.TestFramework(\n-        List(\n-          \"org.scalatest.tools.Framework\",\n-          \"org.scalatest.tools.ScalaTestFramework\"\n-        )\n-      )\n-      // These test frameworks are the default output from running `show\n-      // testFrameworks` in sbt (excluding spec2). The output from `./pants\n-      // export` doesn't include the configured test frameworks.\n-      val defaultTestFrameworks = List(\n-        scalatest,\n-        C.TestFramework(List(\"org.scalacheck.ScalaCheckFramework\")),\n-        C.TestFramework(List(\"com.novocode.junit.JUnitFramework\"))\n-      )\n-      Some(\n-        C.Test(\n-          frameworks = defaultTestFrameworks,\n-          options = C.TestOptions(\n-            excludes = Nil,\n-            arguments = List(\n-              C.TestArgument(\n-                List(\"-o\"),\n-                Some(scalatest)\n-              )\n-            )\n-          )\n-        )\n-      )\n-    } else {\n-      None\n-    }\n \n-    val resolution: Option[C.Resolution] =\n-      if (id.isBinaryDependency) {\n-        binaryDependencySources ++= libraryDependencySources\n-        binaryDependencySources ++= enclosingSourceDirectory(baseDirectory)\n-        None\n-      } else {\n-        Some(\n-          C.Resolution(\n-            libraryDependencySources.iterator.map(newSourceModule).toList\n-          )\n-        )\n-      }\n+    val classpath = new mutable.LinkedHashSet[Path]()\n+    classpath ++= (for {\n+      dependency <- transitiveDependencies\n+      if dependency.isTargetRoot\n+    } yield dependency.classesDir(bloopDir))\n+    classpath ++= (for {\n+      dependency <- transitiveDependencies\n+      if !dependency.isTargetRoot"
  },
  {
    "id" : "64c19fb7-16b2-45ed-ae67-3837c9a7df7c",
    "prId" : 1181,
    "comments" : [
      {
        "id" : "b3e96cc3-7589-4e56-b238-993f8d72a642",
        "parentId" : null,
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "rename to something like `exportClasspathCache`? \r\nnit: `private val`",
        "createdAt" : "2019-12-10T20:50:04Z",
        "updatedAt" : "2019-12-11T10:39:31Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7a187a75-19c3-4338-a20e-e7be58790423",
        "parentId" : "b3e96cc3-7589-4e56-b238-993f8d72a642",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "done, made all following methods private",
        "createdAt" : "2019-12-11T10:11:18Z",
        "updatedAt" : "2019-12-11T10:39:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "da92e30ee6e1e5d61ccb46ecfc290af2da243900",
    "line" : null,
    "diffHunk" : "@@ -526,19 +424,68 @@ private class BloopPants(\n       ),\n       java = Some(C.Java(Nil)),\n       sbt = None,\n-      test = test,\n+      test = bloopTestFrameworks,\n       platform = Some(C.Platform.Jvm(C.JvmConfig(javaHome, Nil), None)),\n-      resolution = resolution\n+      resolution = None\n     )\n   }\n \n+  val myExportClasspath: mutable.Map[String, List[Path]] ="
  },
  {
    "id" : "70819ae0-83bb-40bb-a975-37c7a80b9b4d",
    "prId" : 1181,
    "comments" : [
      {
        "id" : "3ca5b1f6-7456-4412-9fb1-8bd7fd5ace4f",
        "parentId" : null,
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "How come we are excluding spec2?",
        "createdAt" : "2019-12-10T20:51:57Z",
        "updatedAt" : "2019-12-11T10:39:31Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "afc414dd-0655-4f55-b81c-865dcb45055e",
        "parentId" : "3ca5b1f6-7456-4412-9fb1-8bd7fd5ace4f",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Updated the list to be exactly the same as default output from sbt.",
        "createdAt" : "2019-12-11T10:15:17Z",
        "updatedAt" : "2019-12-11T10:39:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "da92e30ee6e1e5d61ccb46ecfc290af2da243900",
    "line" : null,
    "diffHunk" : "@@ -526,19 +424,68 @@ private class BloopPants(\n       ),\n       java = Some(C.Java(Nil)),\n       sbt = None,\n-      test = test,\n+      test = bloopTestFrameworks,\n       platform = Some(C.Platform.Jvm(C.JvmConfig(javaHome, Nil), None)),\n-      resolution = resolution\n+      resolution = None\n     )\n   }\n \n+  val myExportClasspath: mutable.Map[String, List[Path]] =\n+    mutable.Map.empty[String, List[Path]]\n+  val exportClasspathDir: AbsolutePath = AbsolutePath(\n+    workspace.resolve(\"dist\").resolve(\"export-classpath\")\n+  )\n+  def exportClasspath(target: PantsTarget): List[Path] = {\n+    myExportClasspath.getOrElseUpdate(\n+      target.name, {\n+        val classpathFile =\n+          exportClasspathDir.resolve(target.id + \"-classpath.txt\")\n+        if (classpathFile.isFile) {\n+          Classpath(classpathFile.readText.trim()).entries.map(_.toNIO)\n+        } else {\n+          Nil\n+        }\n+      }\n+    )\n+  }\n   lazy val dist: mutable.Buffer[Path] = Files\n     .list(\n       workspace.resolve(\"dist\").resolve(\"export-classpath\")\n     )\n     .asScala\n     .toBuffer\n \n+  def bloopTestFrameworks: Option[C.Test] = {\n+    val scalatest = C.TestFramework(\n+      List(\n+        \"org.scalatest.tools.Framework\",\n+        \"org.scalatest.tools.ScalaTestFramework\"\n+      )\n+    )\n+    // These test frameworks are the default output from running `show\n+    // testFrameworks` in sbt (excluding spec2). The output from `./pants"
  },
  {
    "id" : "4793dfb6-98bc-4aeb-a656-cd181e6a8093",
    "prId" : 1352,
    "comments" : [
      {
        "id" : "997c946a-b217-4070-a20b-940808210a67",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Let's drop this logging statement",
        "createdAt" : "2020-01-25T16:54:56Z",
        "updatedAt" : "2020-01-28T02:16:30Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be7973c4-3530-4d15-a19a-6ff67dfd938b",
        "parentId" : "997c946a-b217-4070-a20b-940808210a67",
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "done",
        "createdAt" : "2020-01-27T16:42:48Z",
        "updatedAt" : "2020-01-28T02:16:30Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "be7a84552b77893b7f348eeb8d622c35ad102402",
    "line" : null,
    "diffHunk" : "@@ -218,6 +213,19 @@ object BloopPants {\n     }\n   }\n \n+  private def symlinkToOut(args: Args): Unit = {\n+    val workspaceBloop = args.workspace.resolve(\".bloop\")\n+\n+    if (!Files.exists(workspaceBloop) || Files.isSymbolicLink(workspaceBloop)) {\n+      val outBloop = args.out.resolve(\".bloop\")\n+      val actionWord =\n+        if (Files.isSymbolicLink(workspaceBloop)) \"overwriting\" else \"creating\"\n+      scribe.info(s\"$actionWord symlink from $workspaceBloop to $outBloop\")"
  },
  {
    "id" : "92ab209e-0a90-4eaa-94a2-de7df7fbf45b",
    "prId" : 1352,
    "comments" : [
      {
        "id" : "24abacb0-32f3-4744-802f-8c8549b5da6d",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can you please configure IntelliJ to \r\n\r\n* sort everything alphabetically\r\n* don't group prefix with `import a.{b,c}`",
        "createdAt" : "2020-01-25T16:55:54Z",
        "updatedAt" : "2020-01-28T02:16:30Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fe9beba2-7a99-426f-908f-35b0cdd37b0e",
        "parentId" : "24abacb0-32f3-4744-802f-8c8549b5da6d",
        "author" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-01-27T16:42:32Z",
        "updatedAt" : "2020-01-28T02:16:30Z",
        "lastEditedBy" : {
          "login" : "wiwa",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1862202?u=67d3c93419e4dd2a110dc2135e1b5ebaf98919c2&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "be7a84552b77893b7f348eeb8d622c35ad102402",
    "line" : 6,
    "diffHunk" : "@@ -1,38 +1,32 @@\n package scala.meta.internal.pantsbuild\n \n import bloop.config.{Config => C}\n-import java.nio.file.Paths\n-import java.nio.file.Files\n+import ch.epfl.scala.bsp4j.BuildTargetIdentifier"
  },
  {
    "id" : "42b0366d-55e3-4294-8873-ef816122e2f4",
    "prId" : 1452,
    "comments" : [
      {
        "id" : "b420c5c2-2cf7-48eb-a408-1fb365048f62",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Just found an issue because this method doesn't handle directory entries. Will need to fix before merge",
        "createdAt" : "2020-02-19T18:23:15Z",
        "updatedAt" : "2020-02-20T13:33:20Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dcacb8a18d292284be112d50252c0662a17f314e",
    "line" : null,
    "diffHunk" : "@@ -538,69 +503,58 @@ private class BloopPants(\n     )\n   }\n \n-  private val exportClasspathCache: mutable.Map[String, List[Path]] =\n-    mutable.Map.empty[String, List[Path]]\n-  private val exportClasspathDir: AbsolutePath = AbsolutePath(\n-    workspace.resolve(\"dist\").resolve(\"export-classpath\")\n-  )\n-  private val exportClasspathJars = mutable.Map.empty[Path, Option[Path]]\n-  def exportClasspathJar(\n-      target: PantsTarget,\n-      entry: Path,\n-      suffix: String\n-  ): Option[Path] = {\n-    exportClasspathJars.getOrElseUpdate(\n-      entry, {\n-        val out = bloopJars.resolve(s\"${target.id}$suffix.jar\")\n-        try {\n-          val attr = Files.readAttributes(entry, classOf[BasicFileAttributes])\n-          if (attr.isRegularFile()) {\n-            // Copy jar from `.pants.d/` directory to `.bloop/` directory to ensure that the\n-            // Bloop classpath is isolated from the Pants classpath.\n-            Files.copy(entry, out, StandardCopyOption.REPLACE_EXISTING)\n-            Some(out)\n-          } else {\n-            // Leave directory entries unchanged, don't copy them to `.bloop/` directory.\n-            Some(entry)\n-          }\n-        } catch {\n-          case _: IOException =>\n-            // Does not exist, ignore this entry.\n-            None\n-        }\n-      }\n-    )\n+  private def toImmutableJar(library: PantsLibrary, path: Path): Path = {\n+    val filename = BloopPants.makeReadableFilename(library.name) + \".jar\"\n+    toImmutableJar(filename, path)\n   }\n-\n-  private val bloopJars =\n-    Files.createDirectories(bloopDir.resolve(\"bloop-jars\"))\n-  private def exportClasspath(target: PantsTarget): List[Path] = {\n-    exportClasspathCache.getOrElseUpdate(\n-      target.name, {\n-        val classpathFile =\n-          exportClasspathDir.resolve(target.id + \"-classpath.txt\")\n-        if (classpathFile.isFile) {\n-          val classpath =\n-            Classpath(classpathFile.readText.trim()).entries.map(_.toNIO)\n-          classpath.iterator.zipWithIndex.flatMap {\n-            case (entry, 0) => exportClasspathJar(target, entry, \"\")\n-            case (entry, i) => exportClasspathJar(target, entry, s\"-$i\")\n-          }.toList\n-        } else {\n-          Nil\n+  private def toImmutableJar(filename: String, path: Path): Path = {\n+    // NOTE(olafur): Jars that live inside $WORKSPACE/.pants.d get overwritten\n+    // by Pants during compilation. We copy these jars over to the Bloop\n+    // directory so that the Bloop incremental cache is unaffected by the\n+    // `./pants compile` tasks that the user is running.\n+    if (path.startsWith(mutableJarsHome)) {"
  },
  {
    "id" : "cd5d2334-2eb9-4738-b47a-4bd63ffe04bf",
    "prId" : 1470,
    "comments" : [
      {
        "id" : "e8281afd-3872-40f9-8c85-9eec03ea3ab7",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I believe the following is sufficient\r\n```suggestion\r\n      val sourceDirs = List(baseDirectory)\r\n```",
        "createdAt" : "2020-03-13T09:29:01Z",
        "updatedAt" : "2020-03-16T09:31:24Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cffc64a967e86ba8dd86bb0f2f7ffbe1fc775166",
    "line" : null,
    "diffHunk" : "@@ -404,12 +422,22 @@ private class BloopPants(\n         Some(List(baseDirectory))\n       }\n \n+    val sourceRoots = {\n+      val sourceDirs = sources ++ sourcesGlobs.toSeq.flatten.map(_.directory)"
  },
  {
    "id" : "3383010c-053d-413a-affb-3d1d44b01deb",
    "prId" : 1530,
    "comments" : [
      {
        "id" : "48ae2613-8aae-4420-ac84-5b28ff54ebab",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Does this line have an effect since we primarily use sources globs?",
        "createdAt" : "2020-03-24T09:54:25Z",
        "updatedAt" : "2020-03-30T15:21:16Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "77c1fdfe-7730-40b7-af99-f6b64c6c67fa",
        "parentId" : "48ae2613-8aae-4420-ac84-5b28ff54ebab",
        "author" : {
          "login" : "tpasternak",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1066003?u=589ea83a961d9cbeb0998e4f811cfa828a01d949&v=4"
        },
        "body" : "Right, I fixed it, but I'm still not sure if it's enough",
        "createdAt" : "2020-03-24T13:27:27Z",
        "updatedAt" : "2020-03-30T15:21:16Z",
        "lastEditedBy" : {
          "login" : "tpasternak",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1066003?u=589ea83a961d9cbeb0998e4f811cfa828a01d949&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ce4c5970d464b2306b20138ffb17932deb74020",
    "line" : null,
    "diffHunk" : "@@ -261,9 +261,27 @@ private class BloopPants(\n     )\n     val isBaseDirectory =\n       projects.iterator.filter(_.sources.nonEmpty).map(_.directory).toSet\n+    // NOTE(olafur): generate synthetic projects to improve the file tree view\n+    // in IntelliJ. Details: https://github.com/olafurpg/intellij-bsp-pants/issues/7\n+    val syntheticProjects: List[C.Project] = sourceRoots.flatMap { root =>\n+      if (isBaseDirectory(root.toNIO) || projects.exists(\n+          p => p.sources.exists(_.getParent == root.toNIO)"
  },
  {
    "id" : "f86b4bfc-721e-4591-929e-5b6f94071d0c",
    "prId" : 1530,
    "comments" : [
      {
        "id" : "0358e09d-ee5f-4025-a4fe-385a4130b75d",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "It looks like you're using an older version of Scalafmt, which is causing these diffs 🤔 ",
        "createdAt" : "2020-03-24T09:54:55Z",
        "updatedAt" : "2020-03-30T15:21:16Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ce4c5970d464b2306b20138ffb17932deb74020",
    "line" : null,
    "diffHunk" : "@@ -620,7 +638,9 @@ private class BloopPants(\n         path.filename != \"bloop.settings.json\" &&\n         !generatedProjects(path.toNIO)\n       }\n-      .foreach { path => Files.deleteIfExists(path.toNIO) }\n+      .foreach { path =>"
  },
  {
    "id" : "b71f28c5-5182-4285-ac0c-ec24a488779a",
    "prId" : 1530,
    "comments" : [
      {
        "id" : "706e6e37-44ba-4192-92b4-5173c1c7e40c",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Let's refactor the `projects.exists(...)` expression into a local def to make it more readable",
        "createdAt" : "2020-03-24T13:35:31Z",
        "updatedAt" : "2020-03-30T15:21:16Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ce4c5970d464b2306b20138ffb17932deb74020",
    "line" : null,
    "diffHunk" : "@@ -261,9 +261,28 @@ private class BloopPants(\n     )\n     val isBaseDirectory =\n       projects.iterator.filter(_.sources.nonEmpty).map(_.directory).toSet\n+    // NOTE(olafur): generate synthetic projects to improve the file tree view\n+    // in IntelliJ. Details: https://github.com/olafurpg/intellij-bsp-pants/issues/7\n+    val syntheticProjects: List[C.Project] = sourceRoots.flatMap { root =>\n+      if (isBaseDirectory(root.toNIO) || projects.exists(p =>\n+          p.sources.exists(_.getParent == root.toNIO)"
  },
  {
    "id" : "bb14192d-d90c-4342-81d4-55a070bf9ea3",
    "prId" : 1530,
    "comments" : [
      {
        "id" : "611c5020-efb6-44de-a510-595e2fadbb56",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Is this condition necessary? The `.directory` field is always `baseDirectory` https://github.com/scalameta/metals/blob/775d2bff9c37acab065a9a465e6984db7ad1c03e/metals/src/main/scala/scala/meta/internal/pantsbuild/PantsGlobs.scala#L34",
        "createdAt" : "2020-03-30T10:40:40Z",
        "updatedAt" : "2020-03-30T15:21:16Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6d71539d-6e4f-4d7e-ab16-d6a37429ebfd",
        "parentId" : "611c5020-efb6-44de-a510-595e2fadbb56",
        "author" : {
          "login" : "tpasternak",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1066003?u=589ea83a961d9cbeb0998e4f811cfa828a01d949&v=4"
        },
        "body" : "right",
        "createdAt" : "2020-03-30T14:45:32Z",
        "updatedAt" : "2020-03-30T15:21:16Z",
        "lastEditedBy" : {
          "login" : "tpasternak",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1066003?u=589ea83a961d9cbeb0998e4f811cfa828a01d949&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e6ed3e16-908e-49bf-b00c-a2cabe925183",
        "parentId" : "611c5020-efb6-44de-a510-595e2fadbb56",
        "author" : {
          "login" : "tpasternak",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1066003?u=589ea83a961d9cbeb0998e4f811cfa828a01d949&v=4"
        },
        "body" : "changed the whole condition `projects.exists(_.directory == root.toNIO)` ",
        "createdAt" : "2020-03-30T15:27:57Z",
        "updatedAt" : "2020-03-30T15:27:57Z",
        "lastEditedBy" : {
          "login" : "tpasternak",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1066003?u=589ea83a961d9cbeb0998e4f811cfa828a01d949&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "297dfce5-84d6-45c1-9a6a-0408f4b905a1",
        "parentId" : "611c5020-efb6-44de-a510-595e2fadbb56",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This case is already covered by `isBaseDirectory`, which contains `Project.directory` entries. I'm not sure this condition needs to exist.\r\n\r\nI suspect the problem with the synthetic modules approach is that we're generating modules with a resource directory. I feel like we need a different approach. I think it's best to close this for now and I will try to think of something else.",
        "createdAt" : "2020-03-30T15:54:59Z",
        "updatedAt" : "2020-03-30T15:55:00Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ce4c5970d464b2306b20138ffb17932deb74020",
    "line" : null,
    "diffHunk" : "@@ -262,9 +262,38 @@ private class BloopPants(\n     )\n     val isBaseDirectory =\n       projects.iterator.filter(_.sources.nonEmpty).map(_.directory).toSet\n+\n+    def existsProjectDefinedAtRoot(\n+        projects: Seq[C.Project],\n+        root: AbsolutePath\n+    ): Boolean =\n+      projects.exists(p =>\n+        p.sources.exists(_.getParent == root.toNIO)\n+          || p.sourcesGlobs.exists(_.exists(_.directory == root.toNIO))"
  }
]