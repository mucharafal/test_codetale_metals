[
  {
    "id" : "7683059e-a0eb-4631-bbd0-586a9706001c",
    "prId" : 763,
    "comments" : [
      {
        "id" : "445024db-dfb2-407f-9823-e415ea1ae9b5",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "@olafurpg this should do it.",
        "createdAt" : "2019-06-16T13:24:39Z",
        "updatedAt" : "2019-06-18T18:13:44Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8b8f8c663ffe7481455869fe747514f96e7e658b",
    "line" : null,
    "diffHunk" : "@@ -89,19 +88,15 @@ abstract class BasePCSuite extends BaseSuite {\n     }\n   }\n   def indexScalaLibrary(): Unit = {\n-    val sources = CoursierSmall.fetch(\n-      new Settings()\n-        .withClassifiers(List(\"sources\"))\n-        .withDependencies(\n-          List(\n-            new Dependency(\n-              \"org.scala-lang\",\n-              \"scala-library\",\n-              BuildInfoVersions.scala212\n-            )\n-          )\n-        )\n-    )\n+    val sources = Fetch"
  },
  {
    "id" : "37ccd1d9-af8b-47fe-a9b3-642446c008fb",
    "prId" : 763,
    "comments" : [
      {
        "id" : "8c980b2d-9904-4775-a8f3-a3881b0c6644",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : ":+1:\r\n",
        "createdAt" : "2019-06-18T09:20:58Z",
        "updatedAt" : "2019-06-18T18:13:44Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8b8f8c663ffe7481455869fe747514f96e7e658b",
    "line" : 47,
    "diffHunk" : "@@ -89,19 +87,21 @@ abstract class BasePCSuite extends BaseSuite {\n     }\n   }\n   def indexScalaLibrary(): Unit = {\n-    val sources = CoursierSmall.fetch(\n-      new Settings()\n-        .withClassifiers(List(\"sources\"))\n-        .withDependencies(\n-          List(\n-            new Dependency(\n-              \"org.scala-lang\",\n-              \"scala-library\",\n-              BuildInfoVersions.scala212\n-            )\n-          )\n+    val sources = Fetch()\n+      .addClassifiers(Classifier.sources)\n+      .addDependencies(\n+        Dependency(\n+          mod\"org.scala-lang:scala-library\",\n+          // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion"
  },
  {
    "id" : "4a705b96-5fe5-482c-9463-0dd311c99a8f",
    "prId" : 1031,
    "comments" : [
      {
        "id" : "703b05f8-09be-42ac-9183-97e47d9c2ae2",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "`false` is already the default, so you can leave this unchanged",
        "createdAt" : "2019-11-07T09:52:26Z",
        "updatedAt" : "2019-11-10T21:00:37Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d86f1fab85d5e22c96d5b7f681c79dc78116aaac",
    "line" : null,
    "diffHunk" : "@@ -34,7 +34,10 @@ abstract class BasePCSuite extends BaseSuite {\n   val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n   def extraClasspath: Seq[Path] = Nil\n   def scalacOptions: Seq[String] = Nil\n-  def config: PresentationCompilerConfig = PresentationCompilerConfigImpl()\n+  def config: PresentationCompilerConfig =\n+    PresentationCompilerConfigImpl().copy(\n+      isMagicIndentClient = false"
  },
  {
    "id" : "ea5987b6-7ac0-4923-8dce-3cc556b0e1d6",
    "prId" : 1277,
    "comments" : [
      {
        "id" : "5ec6c7c9-fa1e-4c82-aada-c4b473c8baac",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "since we're at it, is this still true for Windows on GitHub Actions? The comment mentions Appveyor",
        "createdAt" : "2020-01-09T11:52:59Z",
        "updatedAt" : "2020-01-26T10:34:42Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2f2d9999-50a9-4206-8fd4-661a65c2448a",
        "parentId" : "5ec6c7c9-fa1e-4c82-aada-c4b473c8baac",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "From what I remember sources are available on Github Actions.",
        "createdAt" : "2020-01-13T19:38:23Z",
        "updatedAt" : "2020-01-26T10:34:42Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "49287d98409399c613ea481aeb08529f827e5982",
    "line" : null,
    "diffHunk" : "@@ -67,25 +72,27 @@ abstract class BasePCSuite extends BaseSuite {\n     JdkSources().foreach(jdk => index.addSourceJar(jdk))\n   }\n \n-  override def test(options: TestOptions)(fun: => Any): Unit = {\n+  override def funsuiteRunTest(options: TestOptions, body: => Any): Any = {\n     // We are unable to infer the JDK jars on Appveyor\n     // tests.BasePCSuite.indexJDK(BasePCSuite.scala:44)\n     val testName =\n       if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n         s\"${BuildInfo.scalaCompilerVersion}-${options.name}\"\n       else options.name\n-    super.test(options.copy(name = testName)) {\n-      try {\n-        fun\n-      } catch {\n-        case NonFatal(e)\n-            if e.getMessage != null &&\n-              e.getMessage.contains(\"x$1\") &&\n-              !hasJdkSources =>\n-          // ignore failing test if jdk sources are missing\n-          ()\n+    super.funsuiteRunTest(\n+      options.copy(name = testName), {\n+        try {\n+          body\n+        } catch {\n+          case NonFatal(e)\n+              if e.getMessage != null &&\n+                e.getMessage.contains(\"x$1\") &&\n+                !hasJdkSources =>\n+            // ignore failing test if jdk sources are missing\n+            ()\n+        }\n       }\n-    }\n+    )\n   }"
  },
  {
    "id" : "2695f5e7-75fa-4c7b-8d2f-624de6ac3b35",
    "prId" : 1277,
    "comments" : [
      {
        "id" : "b47d6b8c-4978-47f7-9e37-744c14eacc60",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I would try removing this",
        "createdAt" : "2020-01-16T07:33:58Z",
        "updatedAt" : "2020-01-26T10:34:42Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "49287d98409399c613ea481aeb08529f827e5982",
    "line" : null,
    "diffHunk" : "@@ -67,25 +71,27 @@ abstract class BasePCSuite extends BaseSuite {\n     JdkSources().foreach(jdk => index.addSourceJar(jdk))\n   }\n \n-  override def test(options: TestOptions)(fun: => Any): Unit = {\n+  override def munitRunTest(options: TestOptions, body: => Any): Any = {\n     // We are unable to infer the JDK jars on Appveyor\n     // tests.BasePCSuite.indexJDK(BasePCSuite.scala:44)\n     val testName =\n       if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n         s\"${BuildInfo.scalaCompilerVersion}-${options.name}\"\n       else options.name\n-    super.test(options.copy(name = testName)) {\n-      try {\n-        fun\n-      } catch {\n-        case NonFatal(e)\n-            if e.getMessage != null &&\n-              e.getMessage.contains(\"x$1\") &&\n-              !hasJdkSources =>\n-          // ignore failing test if jdk sources are missing\n-          ()\n+    super.munitRunTest(\n+      options.copy(name = testName), {\n+        try {\n+          body\n+        } catch {\n+          case NonFatal(e)\n+              if e.getMessage != null &&\n+                e.getMessage.contains(\"x$1\") &&\n+                !hasJdkSources =>\n+            // ignore failing test if jdk sources are missing"
  },
  {
    "id" : "b50de6ba-1730-452a-9cf0-420b8f7247ae",
    "prId" : 1277,
    "comments" : [
      {
        "id" : "e512d87d-8c51-44f5-941c-5c1b69de7bff",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I think this is a good chance to try removing this: it may not be needed on GitHub actions",
        "createdAt" : "2020-01-26T04:08:16Z",
        "updatedAt" : "2020-01-26T10:34:42Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "49287d98409399c613ea481aeb08529f827e5982",
    "line" : null,
    "diffHunk" : "@@ -67,25 +71,31 @@ abstract class BasePCSuite extends BaseSuite {\n     JdkSources().foreach(jdk => index.addSourceJar(jdk))\n   }\n \n-  override def test(options: TestOptions)(fun: => Any): Unit = {\n-    // We are unable to infer the JDK jars on Appveyor\n-    // tests.BasePCSuite.indexJDK(BasePCSuite.scala:44)\n+  override def munitNewTest(test: Test): Test = {\n     val testName =\n       if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-        s\"${BuildInfo.scalaCompilerVersion}-${options.name}\"\n-      else options.name\n-    super.test(options.copy(name = testName)) {\n-      try {\n-        fun\n-      } catch {\n-        case NonFatal(e)\n-            if e.getMessage != null &&\n-              e.getMessage.contains(\"x$1\") &&\n-              !hasJdkSources =>\n-          // ignore failing test if jdk sources are missing\n-          ()\n+        s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n+      else test.name\n+    test.withName(testName)\n+  }\n+\n+  override def munitRunTest(options: TestOptions, body: => Any): Any = {"
  },
  {
    "id" : "726ea184-deed-40c5-b07b-bf10fdba3252",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "5497bd81-039a-4270-b331-e66269656f1e",
        "parentId" : null,
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Changed the way we run cross suite in order to be able to easily extend the existing tests without the need for having all test dependencies work in Scala 3. I now start a compiler for each version and create tests for all supported version.\r\n\r\nAs an added bonus, this way found a number of issues, which were missed because cross tests were not tested the same as mtags would eventually be used. This way is closer to that.",
        "createdAt" : "2020-03-25T17:23:47Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,121 +1,203 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import java.util.concurrent.ConcurrentHashMap\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n+import scala.meta.internal.metals.BuildInfo\n import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n-import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.metals.ScalaVersions\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n+import java.nio.file.Paths\n+import scala.meta.internal.mtags.ClasspathLoader\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val presentationCompilers = new ConcurrentHashMap[String, TestEnvironment]\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected def newIndex =\n+    new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n-  def params(code: String, filename: String = \"test.scala\"): (String, Int) = {\n+  private def newPresentationCompiler(scalaVersion: String): TestEnvironment = {\n+\n+    val binaryVersion =\n+      ScalaVersions.scalaBinaryVersionFromFullVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (ScalaVersions.isScala3Version(scalaVersion))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val scalaLibrary: Seq[Path] = Fetch\n+      .create()\n+      .withDependencies(scalaDependencies: _*)\n+      .fetch()\n+      .asScala\n+      .map(_.toPath())\n+\n+    val extraClasspath: Seq[Path] =\n+      Fetch\n+        .create()\n+        .withDependencies(extraDependencies(scalaVersion): _*)\n+        .fetch()\n+        .asScala\n+        .map(_.toPath())\n+\n+    val extraScala211Classpath = ClasspathLoader\n+      .getURLs(this.getClass.getClassLoader)\n+      .filter(!_.toString().contains(\"scala\"))\n+      .map(url => Paths.get(url.toURI))\n+\n+    // pprint.log(extraScala211Classpath)\n+\n+    val myclasspath: Seq[Path] = (extraClasspath ++ scalaLibrary).filterNot {\n+      path =>\n+        val filename = path.toString()\n+        filename.contains(\"scala-reflect\") ||\n+        filename.contains(\"scala-compiler\") ||\n+        filename.contains(\"scala-xml\")\n+    }\n+\n+    val index = newIndex\n+    if (requiresJdkSources)\n+      JdkSources().foreach(jdk => index.addSourceJar(jdk))\n+    if (requiresScalaLibrarySources)\n+      indexScalaLibrary(index, scalaVersion)\n+    val indexer = new Docstrings(index)\n+    val workspace = new TestingWorkspaceSearch\n+    val search = new TestingSymbolSearch(\n+      ClasspathSearch.fromClasspath(myclasspath),\n+      new Docstrings(index),\n+      workspace,\n+      index\n+    )\n+\n+    val scalacOpts = scalacOptions(myclasspath)\n+\n+    val pc = TestEnvironment"
  },
  {
    "id" : "6b586214-bebc-4390-a7d6-27a4c6ce3769",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "4fb32e1b-caa6-4a0c-bfdb-8e72ab371b58",
        "parentId" : null,
        "author" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "body" : "Leftover `pprint` can be removed.",
        "createdAt" : "2020-04-04T09:03:10Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "ckipp01",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/13974112?u=7b6a2ddab8eec6f99e4e40ae9b81f71cb5ba92e5&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eb5344d6-4396-471c-bbe6-cdc189c3882f",
        "parentId" : "4fb32e1b-caa6-4a0c-bfdb-8e72ab371b58",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Fixed, thanks!",
        "createdAt" : "2020-04-06T18:03:30Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,121 +1,203 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import java.util.concurrent.ConcurrentHashMap\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n+import scala.meta.internal.metals.BuildInfo\n import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n-import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.metals.ScalaVersions\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n+import java.nio.file.Paths\n+import scala.meta.internal.mtags.ClasspathLoader\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val presentationCompilers = new ConcurrentHashMap[String, TestEnvironment]\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected def newIndex =\n+    new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n-  def params(code: String, filename: String = \"test.scala\"): (String, Int) = {\n+  private def newPresentationCompiler(scalaVersion: String): TestEnvironment = {\n+\n+    val binaryVersion =\n+      ScalaVersions.scalaBinaryVersionFromFullVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (ScalaVersions.isScala3Version(scalaVersion))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val scalaLibrary: Seq[Path] = Fetch\n+      .create()\n+      .withDependencies(scalaDependencies: _*)\n+      .fetch()\n+      .asScala\n+      .map(_.toPath())\n+\n+    val extraClasspath: Seq[Path] =\n+      Fetch\n+        .create()\n+        .withDependencies(extraDependencies(scalaVersion): _*)\n+        .fetch()\n+        .asScala\n+        .map(_.toPath())\n+\n+    val extraScala211Classpath = ClasspathLoader\n+      .getURLs(this.getClass.getClassLoader)\n+      .filter(!_.toString().contains(\"scala\"))\n+      .map(url => Paths.get(url.toURI))\n+\n+    // pprint.log(extraScala211Classpath)"
  },
  {
    "id" : "f4bbb045-7f7c-4364-aef9-c60dca8f0bc9",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "b52a1af4-6c8d-47e8-a433-acc1457edb99",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can you explain why we need to fetch jars on every test run? In `BasePCSuite` on master, we only fetch for test suites that index sources. I believe this is adding non-trivial overhead for every `cross/test` run. I think it's important we try to keep `~cross/testOnly ...` fast",
        "createdAt" : "2020-04-08T17:50:34Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "991853e5-6731-4e84-a58c-87dc563aa083",
        "parentId" : "b52a1af4-6c8d-47e8-a433-acc1457edb99",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Mostly it was due to the fact I was doing tests with a single Scala 2.12 library on classpath previously, I can switch back.",
        "createdAt" : "2020-04-10T11:37:13Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e102c5aa-9bc0-46c4-916a-a647a1f9536e",
        "parentId" : "b52a1af4-6c8d-47e8-a433-acc1457edb99",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Changed it back to using classpath, also taking into account Dotty library:\r\nhttps://github.com/scalameta/metals/pull/1523/files#diff-713c81e0230fa147e415ec5325807f59R38-R42\r\n",
        "createdAt" : "2020-04-10T15:54:01Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,105 +1,153 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n-import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.pc.ScalaPresentationCompiler\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val scalaVersion = BuildInfoVersions.scalaVersion\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected val index = new DelegatingGlobalSymbolIndex()\n+\n+  protected val workspace = new TestingWorkspaceSearch\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n+  protected lazy val presentationCompiler: PresentationCompiler = {\n+    val binaryVersion = ScalaDependencies.createBinaryVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (binaryVersion.startsWith(\"0.\"))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val fetch = Fetch\n+      .create()\n+\n+    val allDependencies = scalaDependencies ++ extraDependencies(scalaVersion)\n+\n+    allDependencies.foreach(fetch.addDependencies(_))\n+    val libraries: Seq[Path] = fetch"
  },
  {
    "id" : "8124017d-33ac-46ca-98f1-b78cddfe4b9c",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "36de6b8c-59f2-40be-bd8e-bb0f3652c37d",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This can be replaced with an override of `munitIgnore` https://scalameta.org/munit/docs/filtering.html#ignore-entire-test-suite-based-on-a-dynamic-condition\r\n```scala\r\noverride def munitIgnore: Boolean = excludedScalaVersions(scalaVersion)\r\n```",
        "createdAt" : "2020-04-08T17:58:48Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "68eb72ea-4eb1-4c44-b2f0-4b05b1818a8b",
        "parentId" : "36de6b8c-59f2-40be-bd8e-bb0f3652c37d",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Thanks! Added here: https://github.com/scalameta/metals/pull/1523/files#diff-713c81e0230fa147e415ec5325807f59R131\r\n\r\nWonder if we should change Munit to color the ignored suites to yellow? What do you think?",
        "createdAt" : "2020-04-10T15:52:33Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,105 +1,153 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n-import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.pc.ScalaPresentationCompiler\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val scalaVersion = BuildInfoVersions.scalaVersion\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected val index = new DelegatingGlobalSymbolIndex()\n+\n+  protected val workspace = new TestingWorkspaceSearch\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n+  protected lazy val presentationCompiler: PresentationCompiler = {\n+    val binaryVersion = ScalaDependencies.createBinaryVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (binaryVersion.startsWith(\"0.\"))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val fetch = Fetch\n+      .create()\n+\n+    val allDependencies = scalaDependencies ++ extraDependencies(scalaVersion)\n+\n+    allDependencies.foreach(fetch.addDependencies(_))\n+    val libraries: Seq[Path] = fetch\n+      .fetch()\n+      .asScala\n+      .map(_.toPath())\n+\n+    val myclasspath: Seq[Path] = libraries.filterNot { path =>\n+      val filename = path.toString()\n+      filename.contains(\"scala-reflect\") ||\n+      filename.contains(\"scala-compiler\") ||\n+      filename.contains(\"scala-xml\")\n+    }\n+\n+    if (requiresJdkSources)\n+      JdkSources().foreach(jdk => index.addSourceJar(jdk))\n+    if (requiresScalaLibrarySources)\n+      indexScalaLibrary(index, scalaVersion)\n+    val indexer = new Docstrings(index)\n+    val search = new TestingSymbolSearch(\n+      ClasspathSearch.fromClasspath(myclasspath),\n+      new Docstrings(index),\n+      workspace,\n+      index\n+    )\n+\n+    val scalacOpts = scalacOptions(myclasspath)\n+\n+    new ScalaPresentationCompiler()\n+      .withSearch(search)\n+      .withConfiguration(config)\n+      .withExecutorService(executorService)\n+      .withScheduledExecutorService(executorService)\n+      .newInstance(\"\", myclasspath.asJava, scalacOpts.asJava)\n+  }\n+\n+  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n+\n+  override def afterAll(): Unit = {\n+    presentationCompiler.shutdown()\n+    RecursivelyDelete(tmp)\n+    executorService.shutdown()\n+  }\n+\n+  def testPc(name: TestOptions, ignoredScalaVersions: Set[String] = Set.empty)(\n+      fn: PresentationCompiler => Unit\n+  ): Unit = {\n+    if (excludedScalaVersions(scalaVersion)) {"
  },
  {
    "id" : "6996dc29-84b8-4b6e-ba91-5fff57aaca6b",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "fb4bdc3c-74f5-41f8-8b39-6bad6de7001c",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This can be replaced with a test transform https://scalameta.org/munit/docs/tests.html#customize-test-name-based-on-a-dynamic-condition\r\n\r\n```scala\r\n  override def munitTestTransforms = super.munitTestTransforms ++ List(\r\n    new TestTransform(\"append Scala version\", { test =>\r\n      test.withName(test.name + \"_\" + scalaVersion)\r\n    })\r\n  )\r\n```",
        "createdAt" : "2020-04-08T17:59:27Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f3a1775-9a03-4e62-974b-80f327bcd7c9",
        "parentId" : "fb4bdc3c-74f5-41f8-8b39-6bad6de7001c",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Added here: https://github.com/scalameta/metals/pull/1523/files#diff-713c81e0230fa147e415ec5325807f59R133-R146",
        "createdAt" : "2020-04-10T15:51:54Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,105 +1,153 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n-import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.pc.ScalaPresentationCompiler\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val scalaVersion = BuildInfoVersions.scalaVersion\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected val index = new DelegatingGlobalSymbolIndex()\n+\n+  protected val workspace = new TestingWorkspaceSearch\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n+  protected lazy val presentationCompiler: PresentationCompiler = {\n+    val binaryVersion = ScalaDependencies.createBinaryVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (binaryVersion.startsWith(\"0.\"))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val fetch = Fetch\n+      .create()\n+\n+    val allDependencies = scalaDependencies ++ extraDependencies(scalaVersion)\n+\n+    allDependencies.foreach(fetch.addDependencies(_))\n+    val libraries: Seq[Path] = fetch\n+      .fetch()\n+      .asScala\n+      .map(_.toPath())\n+\n+    val myclasspath: Seq[Path] = libraries.filterNot { path =>\n+      val filename = path.toString()\n+      filename.contains(\"scala-reflect\") ||\n+      filename.contains(\"scala-compiler\") ||\n+      filename.contains(\"scala-xml\")\n+    }\n+\n+    if (requiresJdkSources)\n+      JdkSources().foreach(jdk => index.addSourceJar(jdk))\n+    if (requiresScalaLibrarySources)\n+      indexScalaLibrary(index, scalaVersion)\n+    val indexer = new Docstrings(index)\n+    val search = new TestingSymbolSearch(\n+      ClasspathSearch.fromClasspath(myclasspath),\n+      new Docstrings(index),\n+      workspace,\n+      index\n+    )\n+\n+    val scalacOpts = scalacOptions(myclasspath)\n+\n+    new ScalaPresentationCompiler()\n+      .withSearch(search)\n+      .withConfiguration(config)\n+      .withExecutorService(executorService)\n+      .withScheduledExecutorService(executorService)\n+      .newInstance(\"\", myclasspath.asJava, scalacOpts.asJava)\n+  }\n+\n+  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n+\n+  override def afterAll(): Unit = {\n+    presentationCompiler.shutdown()\n+    RecursivelyDelete(tmp)\n+    executorService.shutdown()\n+  }\n+\n+  def testPc(name: TestOptions, ignoredScalaVersions: Set[String] = Set.empty)(\n+      fn: PresentationCompiler => Unit\n+  ): Unit = {\n+    if (excludedScalaVersions(scalaVersion)) {\n+      test(name.ignore) {}\n+    } else {\n+      val testOptions: TestOptions ="
  },
  {
    "id" : "c0f368a0-e0de-452a-bf2a-29f822b69217",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "239bd182-e3a3-4e39-9d8f-5d594100882e",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This can be replaced with a custom tag + test transform\r\n```scala\r\ncase class IgnoreScalaVersion(versions: String*) extends Tag(\"NoScalaVersion\")\r\n  override def munitTestTransforms = super.munitTestTransforms ++ List(\r\n    new TestTransform(\"IgnoreScalaVersion\", { test =>\r\n      val isIgnoredScalaVersion = test.tags\r\n         .collect { case IgnoreScalaVersion(versions) => versions.toSet }\r\n         .getOrElse(Set.empty)\r\n      if (isIgnoredScalaVersion(scalaVersion)) test.ignore\r\n      else test\r\n    })\r\n  )\r\n\r\ntest(\"foo\".tag(IgnoreScalaVersion(\"2.11.12\")) { ... }\r\n```",
        "createdAt" : "2020-04-08T18:02:23Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "78d7cdf8-b4b9-4727-a1be-d8bd8ad19de6",
        "parentId" : "239bd182-e3a3-4e39-9d8f-5d594100882e",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Added it here: https://github.com/scalameta/metals/pull/1523/files#diff-713c81e0230fa147e415ec5325807f59R133-R146\r\n\r\nHad to change the last part to:\r\n```scala\r\nif (isIgnoredScalaVersion(scalaVersion))\r\n        test.withTags(test.tags + munit.Ignore)\r\nelse test\r\n```",
        "createdAt" : "2020-04-10T15:51:09Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,105 +1,153 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n-import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.pc.ScalaPresentationCompiler\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val scalaVersion = BuildInfoVersions.scalaVersion\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected val index = new DelegatingGlobalSymbolIndex()\n+\n+  protected val workspace = new TestingWorkspaceSearch\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n+  protected lazy val presentationCompiler: PresentationCompiler = {\n+    val binaryVersion = ScalaDependencies.createBinaryVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (binaryVersion.startsWith(\"0.\"))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val fetch = Fetch\n+      .create()\n+\n+    val allDependencies = scalaDependencies ++ extraDependencies(scalaVersion)\n+\n+    allDependencies.foreach(fetch.addDependencies(_))\n+    val libraries: Seq[Path] = fetch\n+      .fetch()\n+      .asScala\n+      .map(_.toPath())\n+\n+    val myclasspath: Seq[Path] = libraries.filterNot { path =>\n+      val filename = path.toString()\n+      filename.contains(\"scala-reflect\") ||\n+      filename.contains(\"scala-compiler\") ||\n+      filename.contains(\"scala-xml\")\n+    }\n+\n+    if (requiresJdkSources)\n+      JdkSources().foreach(jdk => index.addSourceJar(jdk))\n+    if (requiresScalaLibrarySources)\n+      indexScalaLibrary(index, scalaVersion)\n+    val indexer = new Docstrings(index)\n+    val search = new TestingSymbolSearch(\n+      ClasspathSearch.fromClasspath(myclasspath),\n+      new Docstrings(index),\n+      workspace,\n+      index\n+    )\n+\n+    val scalacOpts = scalacOptions(myclasspath)\n+\n+    new ScalaPresentationCompiler()\n+      .withSearch(search)\n+      .withConfiguration(config)\n+      .withExecutorService(executorService)\n+      .withScheduledExecutorService(executorService)\n+      .newInstance(\"\", myclasspath.asJava, scalacOpts.asJava)\n+  }\n+\n+  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n+\n+  override def afterAll(): Unit = {\n+    presentationCompiler.shutdown()\n+    RecursivelyDelete(tmp)\n+    executorService.shutdown()\n+  }\n+\n+  def testPc(name: TestOptions, ignoredScalaVersions: Set[String] = Set.empty)(\n+      fn: PresentationCompiler => Unit\n+  ): Unit = {\n+    if (excludedScalaVersions(scalaVersion)) {\n+      test(name.ignore) {}\n+    } else {\n+      val testOptions: TestOptions =\n+        name.withName(s\"${name.name}_$scalaVersion\")\n+      val possiblyIgnored =\n+        if (ignoredScalaVersions(scalaVersion)) testOptions.ignore"
  },
  {
    "id" : "ca822e10-bb81-476d-b232-02b56ab64507",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "bf716893-400f-4c65-b012-b2f352dfb538",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think we can replace `testPc` with the default MUnit `test` if we use test transforms. See following comments.\r\n\r\nDo we need the `fn: PresentationCompiler => Unit` argument? It looks like we can access `presentationCompiler` directly\r\n\r\nAlso, what is the difference between an ignored scala version and excluded Scala version? My understanding is that `ignoredScalaVersions` is configurable per-test and `excludedScalaVersions` is configurable per-suite",
        "createdAt" : "2020-04-08T18:04:22Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "82b73df6-2a6c-4999-b1d6-ecac57c52cfa",
        "parentId" : "bf716893-400f-4c65-b012-b2f352dfb538",
        "author" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "body" : "Removed it altogether, with the additional tags that you suggested it was no longer neccessary.",
        "createdAt" : "2020-04-10T15:49:20Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "tgodzik",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/3807253?u=094831e6a696f583ddfd86d3e5923fd8545c543a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : null,
    "diffHunk" : "@@ -1,105 +1,153 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n-import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n+import scala.util.control.NonFatal\n+import munit.TestOptions\n import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.pc.ScalaPresentationCompiler\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] =\n-    ClasspathLoader\n-      .getURLs(this.getClass.getClassLoader)\n-      .map(url => Paths.get(url.toURI))\n-  val scalaLibrary: Seq[Path] = PackageIndex.scalaLibrary\n-  def extraClasspath: Seq[Path] = Nil\n-  def scalacOptions: Seq[String] = Nil\n+\n+  val executorService: ScheduledExecutorService =\n+    Executors.newSingleThreadScheduledExecutor()\n+\n+  val scalaVersion = BuildInfoVersions.scalaVersion\n+\n   def config: PresentationCompilerConfig =\n     PresentationCompilerConfigImpl().copy(\n       snippetAutoIndent = false\n     )\n-  val myclasspath: Seq[Path] = extraClasspath ++ scalaLibrary.toList\n-  val index = new DelegatingGlobalSymbolIndex(OnDemandSymbolIndex())\n-  val indexer = new Docstrings(index)\n-  val workspace = new TestingWorkspaceSearch\n-  val search = new TestingSymbolSearch(\n-    ClasspathSearch.fromClasspath(myclasspath),\n-    new Docstrings(index),\n-    workspace,\n-    index\n-  )\n-  val executorService: ScheduledExecutorService =\n-    Executors.newSingleThreadScheduledExecutor()\n-  val pc: PresentationCompiler = new ScalaPresentationCompiler()\n-    .withSearch(search)\n-    .withConfiguration(config)\n-    .withExecutorService(executorService)\n-    .withScheduledExecutorService(executorService)\n-    .newInstance(\"\", myclasspath.asJava, scalacOptions.asJava)\n-  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n \n-  override def afterAll(): Unit = {\n-    pc.shutdown()\n-    RecursivelyDelete(tmp)\n-    executorService.shutdown()\n-  }\n+  def extraDependencies(scalaVersion: String): Seq[Dependency] = Nil\n \n-  def requiresJdkSources: Boolean = false\n+  def scalacOptions(classpath: Seq[Path]): Seq[String] = Nil\n \n-  def indexJDK(): Unit = {\n-    JdkSources().foreach(jdk => index.addSourceJar(jdk))\n-  }\n+  def excludedScalaVersions: Set[String] = Set.empty\n \n-  override def munitTestTransforms: List[TestTransform] =\n-    super.munitTestTransforms :+\n-      new TestTransform(\"Add Compiler Version\", { test =>\n-        val testName =\n-          if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-            s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-          else test.name\n-        test.withName(testName)\n-      })\n-\n-  def indexScalaLibrary(): Unit = {\n-    val sources = Fetch()\n-      .addClassifiers(Classifier.sources)\n-      .addDependencies(\n-        Dependency(\n-          mod\"org.scala-lang:scala-library\",\n+  protected val index = new DelegatingGlobalSymbolIndex()\n+\n+  protected val workspace = new TestingWorkspaceSearch\n+\n+  private def indexScalaLibrary(\n+      index: GlobalSymbolIndex,\n+      scalaVersion: String\n+  ): Unit = {\n+    val sources = Fetch\n+      .create()\n+      .withClassifiers(Set(\"sources\").asJava)\n+      .withDependencies(\n+        Dependency.of(\n+          \"org.scala-lang\",\n+          \"scala-library\",\n           // NOTE(gabro): we should ideally just use BuildoInfoVersions.scalaVersion\n           // but using the 2.11 stdlib would cause a lot tests to break for little benefit.\n           // We can remove this switch once we drop support for 2.11\n-          BuildInfoVersions.scalaVersion match {\n+          scalaVersion match {\n             case v if v.startsWith(\"2.13\") => v\n             case v if v.startsWith(\"2.12\") => v\n             case _ => BuildInfoVersions.scala212\n           }\n         )\n       )\n-      .run()\n+      .fetch()\n+      .asScala\n     sources.foreach { jar => index.addSourceJar(AbsolutePath(jar)) }\n   }\n \n+  protected lazy val presentationCompiler: PresentationCompiler = {\n+    val binaryVersion = ScalaDependencies.createBinaryVersion(scalaVersion)\n+    val scalaDependencies =\n+      if (binaryVersion.startsWith(\"0.\"))\n+        ScalaDependencies.scala3(scalaVersion)\n+      else\n+        ScalaDependencies.scala2(scalaVersion)\n+\n+    val fetch = Fetch\n+      .create()\n+\n+    val allDependencies = scalaDependencies ++ extraDependencies(scalaVersion)\n+\n+    allDependencies.foreach(fetch.addDependencies(_))\n+    val libraries: Seq[Path] = fetch\n+      .fetch()\n+      .asScala\n+      .map(_.toPath())\n+\n+    val myclasspath: Seq[Path] = libraries.filterNot { path =>\n+      val filename = path.toString()\n+      filename.contains(\"scala-reflect\") ||\n+      filename.contains(\"scala-compiler\") ||\n+      filename.contains(\"scala-xml\")\n+    }\n+\n+    if (requiresJdkSources)\n+      JdkSources().foreach(jdk => index.addSourceJar(jdk))\n+    if (requiresScalaLibrarySources)\n+      indexScalaLibrary(index, scalaVersion)\n+    val indexer = new Docstrings(index)\n+    val search = new TestingSymbolSearch(\n+      ClasspathSearch.fromClasspath(myclasspath),\n+      new Docstrings(index),\n+      workspace,\n+      index\n+    )\n+\n+    val scalacOpts = scalacOptions(myclasspath)\n+\n+    new ScalaPresentationCompiler()\n+      .withSearch(search)\n+      .withConfiguration(config)\n+      .withExecutorService(executorService)\n+      .withScheduledExecutorService(executorService)\n+      .newInstance(\"\", myclasspath.asJava, scalacOpts.asJava)\n+  }\n+\n+  val tmp: AbsolutePath = AbsolutePath(Files.createTempDirectory(\"metals\"))\n+\n+  override def afterAll(): Unit = {\n+    presentationCompiler.shutdown()\n+    RecursivelyDelete(tmp)\n+    executorService.shutdown()\n+  }\n+\n+  def testPc(name: TestOptions, ignoredScalaVersions: Set[String] = Set.empty)("
  },
  {
    "id" : "bcd242f8-0976-4438-aad9-321c85607f82",
    "prId" : 1523,
    "comments" : [
      {
        "id" : "e23a6f6c-ab60-4328-be84-a1213487cfaf",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "The technique of inspecting `this.getClass.getClassLoader` to extract scala-library.jar works when you run `+cross/test`. It's significantly faster compared to using `coursier.Fetch.create()`.",
        "createdAt" : "2020-04-11T08:58:08Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : 40,
    "diffHunk" : "@@ -1,105 +1,151 @@\n package tests\n \n-import coursier._\n-import java.nio.charset.StandardCharsets\n import java.nio.file.Files\n import java.nio.file.Path\n-import java.nio.file.Paths\n+import java.util.concurrent.Executors\n+import java.util.concurrent.ScheduledExecutorService\n+import java.nio.charset.StandardCharsets\n+import coursierapi.Dependency\n+import coursierapi.Fetch\n import org.eclipse.lsp4j.MarkupContent\n import org.eclipse.lsp4j.jsonrpc.messages.{Either => JEither}\n import scala.meta.internal.jdk.CollectionConverters._\n import scala.meta.internal.metals.ClasspathSearch\n import scala.meta.internal.metals.JdkSources\n import scala.meta.internal.metals.Docstrings\n import scala.meta.internal.metals.RecursivelyDelete\n-import scala.meta.internal.mtags.BuildInfo\n-import scala.meta.internal.mtags.OnDemandSymbolIndex\n-import scala.meta.internal.mtags.ClasspathLoader\n import scala.meta.internal.pc.PresentationCompilerConfigImpl\n-import scala.meta.internal.pc.ScalaPresentationCompiler\n-import scala.meta.internal.metals.PackageIndex\n+import scala.meta.internal.mtags.GlobalSymbolIndex\n import scala.meta.io.AbsolutePath\n import scala.meta.pc.PresentationCompilerConfig\n-import scala.util.control.NonFatal\n-import java.util.concurrent.Executors\n-import java.util.concurrent.ScheduledExecutorService\n import scala.collection.Seq\n+import scala.util.control.NonFatal\n import scala.meta.pc.PresentationCompiler\n+import scala.meta.internal.pc.ScalaPresentationCompiler\n+import scala.meta.internal.metals.PackageIndex\n+import munit.Tag\n \n abstract class BasePCSuite extends BaseSuite {\n-  def thisClasspath: Seq[Path] ="
  },
  {
    "id" : "1c7d2512-0ae0-4b92-951a-108ad4681aa6",
    "prId" : 1534,
    "comments" : [
      {
        "id" : "1eff4735-6085-46ed-84f6-88b008bf548d",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "minor, but can you manually break the line after `=` so that it does not break on the type annotation?",
        "createdAt" : "2020-03-24T15:50:45Z",
        "updatedAt" : "2020-03-25T13:55:15Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6fffdcb2-721c-4751-aa99-d5bf3a3618e6",
        "parentId" : "1eff4735-6085-46ed-84f6-88b008bf548d",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "also, no need to wrap this in a `List`, you can do\r\n\r\n```scala\r\nsuper.munitTestTransforms :+ new TestTransform(...)\r\n```",
        "createdAt" : "2020-03-24T15:51:44Z",
        "updatedAt" : "2020-03-25T13:55:15Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ef5d4b7c53eb3cc408ce35d7c1b7223026636ccf",
    "line" : null,
    "diffHunk" : "@@ -70,13 +70,16 @@ abstract class BasePCSuite extends BaseSuite {\n     JdkSources().foreach(jdk => index.addSourceJar(jdk))\n   }\n \n-  override def munitNewTest(test: Test): Test = {\n-    val testName =\n-      if (isCI && BuildInfo.scalaCompilerVersion != BuildInfoVersions.scala212)\n-        s\"${BuildInfo.scalaCompilerVersion}-${test.name}\"\n-      else test.name\n-    test.withName(testName)\n-  }\n+  override def munitTestTransforms\n+      : List[TestTransform] = super.munitTestTransforms ++ List("
  }
]