[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Just a minor question: I think you want to use `LinkedList` as `Stack` since you use `pop`. Right? If so, here you should use `push`. `push` calls `addFirst`, `pop` calls `removeFirst`, while `add` calls `addLast`.\n",
    "commit": "fd6cb55b19f4f31445c454ccf8d3c39e1c801482",
    "createdAt": "2015-05-18T23:47:40Z",
    "diffHunk": "@@ -44,15 +56,56 @@ public ExecutorMemoryManager(MemoryAllocator allocator) {\n   }\n \n   /**\n+   * Returns true if allocations of the given size should go through the pooling mechanism and\n+   * false otherwise.\n+   */\n+  private boolean shouldPool(long size) {\n+    // Very small allocations are less likely to benefit from pooling.\n+    // At some point, we should explore supporting pooling for off-heap memory, but for now we'll\n+    // ignore that case in the interest of simplicity.\n+    return size >= POOLING_THRESHOLD_BYTES && allocator instanceof HeapMemoryAllocator;\n+  }\n+\n+  /**\n    * Allocates a contiguous block of memory. Note that the allocated memory is not guaranteed\n    * to be zeroed out (call `zero()` on the result if this is necessary).\n    */\n   MemoryBlock allocate(long size) throws OutOfMemoryError {\n-    return allocator.allocate(size);\n+    if (shouldPool(size)) {\n+      synchronized (this) {\n+        final LinkedList<SoftReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);\n+        if (pool != null) {\n+          while (!pool.isEmpty()) {\n+            final SoftReference<MemoryBlock> blockReference = pool.pop();\n+            final MemoryBlock memory = blockReference.get();\n+            if (memory != null) {\n+              assert (memory.size() == size);\n+              return memory;\n+            }\n+          }\n+          bufferPoolsBySize.remove(size);\n+        }\n+      }\n+      return allocator.allocate(size);\n+    } else {\n+      return allocator.allocate(size);\n+    }\n   }\n \n   void free(MemoryBlock memory) {\n-    allocator.free(memory);\n+    final long size = memory.size();\n+    if (shouldPool(size)) {\n+      synchronized (this) {\n+        LinkedList<SoftReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);\n+        if (pool == null) {\n+          pool = new LinkedList<SoftReference<MemoryBlock>>();\n+          bufferPoolsBySize.put(size, pool);\n+        }\n+        pool.add(new SoftReference<MemoryBlock>(memory));"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Java's linked list is doubly-linked, so I don't think that this makes a perf. difference or anything, which is why I was a little sloppy here.\n",
    "commit": "fd6cb55b19f4f31445c454ccf8d3c39e1c801482",
    "createdAt": "2015-05-20T01:02:42Z",
    "diffHunk": "@@ -44,15 +56,56 @@ public ExecutorMemoryManager(MemoryAllocator allocator) {\n   }\n \n   /**\n+   * Returns true if allocations of the given size should go through the pooling mechanism and\n+   * false otherwise.\n+   */\n+  private boolean shouldPool(long size) {\n+    // Very small allocations are less likely to benefit from pooling.\n+    // At some point, we should explore supporting pooling for off-heap memory, but for now we'll\n+    // ignore that case in the interest of simplicity.\n+    return size >= POOLING_THRESHOLD_BYTES && allocator instanceof HeapMemoryAllocator;\n+  }\n+\n+  /**\n    * Allocates a contiguous block of memory. Note that the allocated memory is not guaranteed\n    * to be zeroed out (call `zero()` on the result if this is necessary).\n    */\n   MemoryBlock allocate(long size) throws OutOfMemoryError {\n-    return allocator.allocate(size);\n+    if (shouldPool(size)) {\n+      synchronized (this) {\n+        final LinkedList<SoftReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);\n+        if (pool != null) {\n+          while (!pool.isEmpty()) {\n+            final SoftReference<MemoryBlock> blockReference = pool.pop();\n+            final MemoryBlock memory = blockReference.get();\n+            if (memory != null) {\n+              assert (memory.size() == size);\n+              return memory;\n+            }\n+          }\n+          bufferPoolsBySize.remove(size);\n+        }\n+      }\n+      return allocator.allocate(size);\n+    } else {\n+      return allocator.allocate(size);\n+    }\n   }\n \n   void free(MemoryBlock memory) {\n-    allocator.free(memory);\n+    final long size = memory.size();\n+    if (shouldPool(size)) {\n+      synchronized (this) {\n+        LinkedList<SoftReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);\n+        if (pool == null) {\n+          pool = new LinkedList<SoftReference<MemoryBlock>>();\n+          bufferPoolsBySize.put(size, pool);\n+        }\n+        pool.add(new SoftReference<MemoryBlock>(memory));"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "I thought there was a special reason to use pop :)\n",
    "commit": "fd6cb55b19f4f31445c454ccf8d3c39e1c801482",
    "createdAt": "2015-05-20T01:05:17Z",
    "diffHunk": "@@ -44,15 +56,56 @@ public ExecutorMemoryManager(MemoryAllocator allocator) {\n   }\n \n   /**\n+   * Returns true if allocations of the given size should go through the pooling mechanism and\n+   * false otherwise.\n+   */\n+  private boolean shouldPool(long size) {\n+    // Very small allocations are less likely to benefit from pooling.\n+    // At some point, we should explore supporting pooling for off-heap memory, but for now we'll\n+    // ignore that case in the interest of simplicity.\n+    return size >= POOLING_THRESHOLD_BYTES && allocator instanceof HeapMemoryAllocator;\n+  }\n+\n+  /**\n    * Allocates a contiguous block of memory. Note that the allocated memory is not guaranteed\n    * to be zeroed out (call `zero()` on the result if this is necessary).\n    */\n   MemoryBlock allocate(long size) throws OutOfMemoryError {\n-    return allocator.allocate(size);\n+    if (shouldPool(size)) {\n+      synchronized (this) {\n+        final LinkedList<SoftReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);\n+        if (pool != null) {\n+          while (!pool.isEmpty()) {\n+            final SoftReference<MemoryBlock> blockReference = pool.pop();\n+            final MemoryBlock memory = blockReference.get();\n+            if (memory != null) {\n+              assert (memory.size() == size);\n+              return memory;\n+            }\n+          }\n+          bufferPoolsBySize.remove(size);\n+        }\n+      }\n+      return allocator.allocate(size);\n+    } else {\n+      return allocator.allocate(size);\n+    }\n   }\n \n   void free(MemoryBlock memory) {\n-    allocator.free(memory);\n+    final long size = memory.size();\n+    if (shouldPool(size)) {\n+      synchronized (this) {\n+        LinkedList<SoftReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);\n+        if (pool == null) {\n+          pool = new LinkedList<SoftReference<MemoryBlock>>();\n+          bufferPoolsBySize.put(size, pool);\n+        }\n+        pool.add(new SoftReference<MemoryBlock>(memory));"
  }],
  "prId": 6227
}]