[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "I think this should be static.\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-10T12:05:51Z",
    "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,"
  }],
  "prId": 6738
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "We can leave this to a later followup patch if you'd like, but I think that I have some fast subarray equality checking code somewhere in the `unsafe` package, either as a test helper utility or a method in `ByteArrayMethods`; you could use that here to avoid the copy.\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-10T12:07:40Z",
    "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    4, 4, 4, 4, 4, 4, 4, 4,\n+    5, 5, 5, 5,\n+    6, 6, 6, 6};\n+\n+  public static UTF8String fromBytes(byte[] bytes) {\n+    return (bytes != null) ? new UTF8String().set(bytes) : null;\n+  }\n+\n+  public static UTF8String fromString(String str) {\n+    return (str != null) ? new UTF8String().set(str) : null;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with String.\n+   */\n+  public UTF8String set(final String str) {\n+    bytes = str.getBytes();\n+    return this;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with byte[], which should be encoded in UTF-8.\n+   */\n+  public UTF8String set(final byte[] bytes) {\n+    this.bytes = bytes;\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the number of bytes for a code point with the first byte as `b`\n+   * @param b The first byte of a code point\n+   */\n+  public int numBytes(final byte b) {\n+    final int offset = (b & 0xFF) - 192;\n+    return (offset >= 0) ? bytesOfCodePointInUTF8[offset] : 1;\n+  }\n+\n+  /**\n+   * Returns the number of code points in it.\n+   *\n+   * This is only used by Substring() when `start` is negative.\n+   */\n+  public int length() {\n+    int len = 0;\n+    for (int i = 0; i < bytes.length; i+= numBytes(bytes[i])) {\n+      len += 1;\n+    }\n+    return len;\n+  }\n+\n+  public byte[] getBytes() {\n+    return bytes;\n+  }\n+\n+  /**\n+   * Returns a substring of this.\n+   * @param start the position of first code point\n+   * @param until the position after last code point\n+   */\n+  public UTF8String slice(final int start, final int until) {\n+    if (until <= start || start >= bytes.length) {\n+      return new UTF8String();\n+    }\n+\n+    int i = 0;\n+    int c = 0;\n+    for (; i < bytes.length && c < start; i += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    int j = i;\n+    for (; j < bytes.length && c < until; j += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    return UTF8String.fromBytes(Arrays.copyOfRange(bytes, i, j));\n+  }\n+\n+  public boolean contains(final UTF8String substring) {\n+    final byte[] b = substring.getBytes();\n+    if (b.length == 0) {\n+      return true;\n+    }\n+\n+    for (int i = 0; i <= bytes.length - b.length; i++) {\n+      // TODO: Avoid copying.",
    "line": 134
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Yea let's do all the optimizations in later prs.\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-10T19:11:01Z",
    "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    4, 4, 4, 4, 4, 4, 4, 4,\n+    5, 5, 5, 5,\n+    6, 6, 6, 6};\n+\n+  public static UTF8String fromBytes(byte[] bytes) {\n+    return (bytes != null) ? new UTF8String().set(bytes) : null;\n+  }\n+\n+  public static UTF8String fromString(String str) {\n+    return (str != null) ? new UTF8String().set(str) : null;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with String.\n+   */\n+  public UTF8String set(final String str) {\n+    bytes = str.getBytes();\n+    return this;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with byte[], which should be encoded in UTF-8.\n+   */\n+  public UTF8String set(final byte[] bytes) {\n+    this.bytes = bytes;\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the number of bytes for a code point with the first byte as `b`\n+   * @param b The first byte of a code point\n+   */\n+  public int numBytes(final byte b) {\n+    final int offset = (b & 0xFF) - 192;\n+    return (offset >= 0) ? bytesOfCodePointInUTF8[offset] : 1;\n+  }\n+\n+  /**\n+   * Returns the number of code points in it.\n+   *\n+   * This is only used by Substring() when `start` is negative.\n+   */\n+  public int length() {\n+    int len = 0;\n+    for (int i = 0; i < bytes.length; i+= numBytes(bytes[i])) {\n+      len += 1;\n+    }\n+    return len;\n+  }\n+\n+  public byte[] getBytes() {\n+    return bytes;\n+  }\n+\n+  /**\n+   * Returns a substring of this.\n+   * @param start the position of first code point\n+   * @param until the position after last code point\n+   */\n+  public UTF8String slice(final int start, final int until) {\n+    if (until <= start || start >= bytes.length) {\n+      return new UTF8String();\n+    }\n+\n+    int i = 0;\n+    int c = 0;\n+    for (; i < bytes.length && c < start; i += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    int j = i;\n+    for (; j < bytes.length && c < until; j += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    return UTF8String.fromBytes(Arrays.copyOfRange(bytes, i, j));\n+  }\n+\n+  public boolean contains(final UTF8String substring) {\n+    final byte[] b = substring.getBytes();\n+    if (b.length == 0) {\n+      return true;\n+    }\n+\n+    for (int i = 0; i <= bytes.length - b.length; i++) {\n+      // TODO: Avoid copying.",
    "line": 134
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "FYI I created ticket https://issues.apache.org/jira/browse/SPARK-8301\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-11T01:28:59Z",
    "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    4, 4, 4, 4, 4, 4, 4, 4,\n+    5, 5, 5, 5,\n+    6, 6, 6, 6};\n+\n+  public static UTF8String fromBytes(byte[] bytes) {\n+    return (bytes != null) ? new UTF8String().set(bytes) : null;\n+  }\n+\n+  public static UTF8String fromString(String str) {\n+    return (str != null) ? new UTF8String().set(str) : null;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with String.\n+   */\n+  public UTF8String set(final String str) {\n+    bytes = str.getBytes();\n+    return this;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with byte[], which should be encoded in UTF-8.\n+   */\n+  public UTF8String set(final byte[] bytes) {\n+    this.bytes = bytes;\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the number of bytes for a code point with the first byte as `b`\n+   * @param b The first byte of a code point\n+   */\n+  public int numBytes(final byte b) {\n+    final int offset = (b & 0xFF) - 192;\n+    return (offset >= 0) ? bytesOfCodePointInUTF8[offset] : 1;\n+  }\n+\n+  /**\n+   * Returns the number of code points in it.\n+   *\n+   * This is only used by Substring() when `start` is negative.\n+   */\n+  public int length() {\n+    int len = 0;\n+    for (int i = 0; i < bytes.length; i+= numBytes(bytes[i])) {\n+      len += 1;\n+    }\n+    return len;\n+  }\n+\n+  public byte[] getBytes() {\n+    return bytes;\n+  }\n+\n+  /**\n+   * Returns a substring of this.\n+   * @param start the position of first code point\n+   * @param until the position after last code point\n+   */\n+  public UTF8String slice(final int start, final int until) {\n+    if (until <= start || start >= bytes.length) {\n+      return new UTF8String();\n+    }\n+\n+    int i = 0;\n+    int c = 0;\n+    for (; i < bytes.length && c < start; i += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    int j = i;\n+    for (; j < bytes.length && c < until; j += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    return UTF8String.fromBytes(Arrays.copyOfRange(bytes, i, j));\n+  }\n+\n+  public boolean contains(final UTF8String substring) {\n+    final byte[] b = substring.getBytes();\n+    if (b.length == 0) {\n+      return true;\n+    }\n+\n+    for (int i = 0; i <= bytes.length - b.length; i++) {\n+      // TODO: Avoid copying.",
    "line": 134
  }],
  "prId": 6738
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should we raise the exception?\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-10T18:26:19Z",
    "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    4, 4, 4, 4, 4, 4, 4, 4,\n+    5, 5, 5, 5,\n+    6, 6, 6, 6};\n+\n+  public static UTF8String fromBytes(byte[] bytes) {\n+    return (bytes != null) ? new UTF8String().set(bytes) : null;\n+  }\n+\n+  public static UTF8String fromString(String str) {\n+    return (str != null) ? new UTF8String().set(str) : null;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with String.\n+   */\n+  public UTF8String set(final String str) {\n+    bytes = str.getBytes();\n+    return this;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with byte[], which should be encoded in UTF-8.\n+   */\n+  public UTF8String set(final byte[] bytes) {\n+    this.bytes = bytes;\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the number of bytes for a code point with the first byte as `b`\n+   * @param b The first byte of a code point\n+   */\n+  public int numBytes(final byte b) {\n+    final int offset = (b & 0xFF) - 192;\n+    return (offset >= 0) ? bytesOfCodePointInUTF8[offset] : 1;\n+  }\n+\n+  /**\n+   * Returns the number of code points in it.\n+   *\n+   * This is only used by Substring() when `start` is negative.\n+   */\n+  public int length() {\n+    int len = 0;\n+    for (int i = 0; i < bytes.length; i+= numBytes(bytes[i])) {\n+      len += 1;\n+    }\n+    return len;\n+  }\n+\n+  public byte[] getBytes() {\n+    return bytes;\n+  }\n+\n+  /**\n+   * Returns a substring of this.\n+   * @param start the position of first code point\n+   * @param until the position after last code point\n+   */\n+  public UTF8String slice(final int start, final int until) {\n+    if (until <= start || start >= bytes.length) {\n+      return new UTF8String();\n+    }\n+\n+    int i = 0;\n+    int c = 0;\n+    for (; i < bytes.length && c < start; i += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    int j = i;\n+    for (; j < bytes.length && c < until; j += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    return UTF8String.fromBytes(Arrays.copyOfRange(bytes, i, j));\n+  }\n+\n+  public boolean contains(final UTF8String substring) {\n+    final byte[] b = substring.getBytes();\n+    if (b.length == 0) {\n+      return true;\n+    }\n+\n+    for (int i = 0; i <= bytes.length - b.length; i++) {\n+      // TODO: Avoid copying.\n+      if (bytes[i] == b[0] && Arrays.equals(Arrays.copyOfRange(bytes, i, i + b.length), b)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean startsWith(final UTF8String prefix) {\n+    final byte[] b = prefix.getBytes();\n+    // TODO: Avoid copying.\n+    return b.length > bytes.length && Arrays.equals(Arrays.copyOfRange(bytes, 0, b.length), b);\n+  }\n+\n+  public boolean endsWith(final UTF8String suffix) {\n+    final byte[] b = suffix.getBytes();\n+    return b.length > bytes.length &&\n+      Arrays.equals(Arrays.copyOfRange(bytes, bytes.length - b.length, bytes.length), b);\n+  }\n+\n+  public UTF8String toUpperCase() {\n+    return UTF8String.fromString(toString().toUpperCase());\n+  }\n+\n+  public UTF8String toLowerCase() {\n+    return UTF8String.fromString(toString().toLowerCase());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    try {\n+      return new String(bytes, \"utf-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      e.printStackTrace();\n+      return \"unsupported encoding\";"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Yea I was thinking about it --- I can convert it to an unchecked exception.\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-10T18:30:18Z",
    "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    4, 4, 4, 4, 4, 4, 4, 4,\n+    5, 5, 5, 5,\n+    6, 6, 6, 6};\n+\n+  public static UTF8String fromBytes(byte[] bytes) {\n+    return (bytes != null) ? new UTF8String().set(bytes) : null;\n+  }\n+\n+  public static UTF8String fromString(String str) {\n+    return (str != null) ? new UTF8String().set(str) : null;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with String.\n+   */\n+  public UTF8String set(final String str) {\n+    bytes = str.getBytes();\n+    return this;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with byte[], which should be encoded in UTF-8.\n+   */\n+  public UTF8String set(final byte[] bytes) {\n+    this.bytes = bytes;\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the number of bytes for a code point with the first byte as `b`\n+   * @param b The first byte of a code point\n+   */\n+  public int numBytes(final byte b) {\n+    final int offset = (b & 0xFF) - 192;\n+    return (offset >= 0) ? bytesOfCodePointInUTF8[offset] : 1;\n+  }\n+\n+  /**\n+   * Returns the number of code points in it.\n+   *\n+   * This is only used by Substring() when `start` is negative.\n+   */\n+  public int length() {\n+    int len = 0;\n+    for (int i = 0; i < bytes.length; i+= numBytes(bytes[i])) {\n+      len += 1;\n+    }\n+    return len;\n+  }\n+\n+  public byte[] getBytes() {\n+    return bytes;\n+  }\n+\n+  /**\n+   * Returns a substring of this.\n+   * @param start the position of first code point\n+   * @param until the position after last code point\n+   */\n+  public UTF8String slice(final int start, final int until) {\n+    if (until <= start || start >= bytes.length) {\n+      return new UTF8String();\n+    }\n+\n+    int i = 0;\n+    int c = 0;\n+    for (; i < bytes.length && c < start; i += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    int j = i;\n+    for (; j < bytes.length && c < until; j += numBytes(bytes[i])) {\n+      c += 1;\n+    }\n+\n+    return UTF8String.fromBytes(Arrays.copyOfRange(bytes, i, j));\n+  }\n+\n+  public boolean contains(final UTF8String substring) {\n+    final byte[] b = substring.getBytes();\n+    if (b.length == 0) {\n+      return true;\n+    }\n+\n+    for (int i = 0; i <= bytes.length - b.length; i++) {\n+      // TODO: Avoid copying.\n+      if (bytes[i] == b[0] && Arrays.equals(Arrays.copyOfRange(bytes, i, i + b.length), b)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean startsWith(final UTF8String prefix) {\n+    final byte[] b = prefix.getBytes();\n+    // TODO: Avoid copying.\n+    return b.length > bytes.length && Arrays.equals(Arrays.copyOfRange(bytes, 0, b.length), b);\n+  }\n+\n+  public boolean endsWith(final UTF8String suffix) {\n+    final byte[] b = suffix.getBytes();\n+    return b.length > bytes.length &&\n+      Arrays.equals(Arrays.copyOfRange(bytes, bytes.length - b.length, bytes.length), b);\n+  }\n+\n+  public UTF8String toUpperCase() {\n+    return UTF8String.fromString(toString().toUpperCase());\n+  }\n+\n+  public UTF8String toLowerCase() {\n+    return UTF8String.fromString(toString().toLowerCase());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    try {\n+      return new String(bytes, \"utf-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      e.printStackTrace();\n+      return \"unsupported encoding\";"
  }],
  "prId": 6738
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Could also be final, I suppose, but not a huge deal.\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-11T06:55:06Z",
    "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+import org.apache.spark.unsafe.PlatformDependent;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private static int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,",
    "line": 40
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "yup. good to be final.\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-11T07:37:37Z",
    "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+import org.apache.spark.unsafe.PlatformDependent;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private static int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,",
    "line": 40
  }],
  "prId": 6738
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "This is not portable, we should use UTF-8 here: \n\n```\ngetBytes()\nEncodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array.\n```\n",
    "commit": "562dc6e8a4cdbb483c26dd7b02577b8cb35c4921",
    "createdAt": "2015-06-11T17:03:43Z",
    "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.types;\n+\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+import javax.annotation.Nullable;\n+\n+import org.apache.spark.unsafe.PlatformDependent;\n+\n+/**\n+ * A UTF-8 String for internal Spark use.\n+ * <p>\n+ * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,\n+ * search, see http://en.wikipedia.org/wiki/UTF-8 for details.\n+ * <p>\n+ * Note: This is not designed for general use cases, should not be used outside SQL.\n+ */\n+public final class UTF8String implements Comparable<UTF8String>, Serializable {\n+\n+  @Nullable\n+  private byte[] bytes;\n+\n+  private static int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    4, 4, 4, 4, 4, 4, 4, 4,\n+    5, 5, 5, 5,\n+    6, 6, 6, 6};\n+\n+  public static UTF8String fromBytes(byte[] bytes) {\n+    return (bytes != null) ? new UTF8String().set(bytes) : null;\n+  }\n+\n+  public static UTF8String fromString(String str) {\n+    return (str != null) ? new UTF8String().set(str) : null;\n+  }\n+\n+  /**\n+   * Updates the UTF8String with String.\n+   */\n+  public UTF8String set(final String str) {\n+    bytes = str.getBytes();"
  }],
  "prId": 6738
}]