[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we should spell out the total number of pages and memory addressable with this encoding\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T08:01:49Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Done.\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T20:50:19Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page"
  }],
  "prId": 5725
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "why not just `1 << 13` ?\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T08:02:10Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Good catch; fixed.\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T20:28:07Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;"
  }],
  "prId": 5725
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "would be great to log something here\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T08:09:48Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;\n+\n+  /** Bit mask for the lower 51 bits of a long. */\n+  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;\n+\n+  /** Bit mask for the upper 13 bits of a long */\n+  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;\n+\n+  /**\n+   * Similar to an operating system's page table, this array maps page numbers into base object\n+   * pointers, allowing us to translate between the hashtable's internal 64-bit address\n+   * representation and the baseObject+offset representation which we use to support both in- and\n+   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.\n+   * When using an in-heap allocator, the entries in this map will point to pages' base objects.\n+   * Entries are added to this map as new data pages are allocated.\n+   */\n+  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];\n+\n+  /**\n+   * Bitmap for tracking free pages.\n+   */\n+  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);\n+\n+  /**\n+   * Allocator, exposed for enabling untracked allocations of temporary data structures.\n+   */\n+  public final MemoryAllocator allocator;\n+\n+  /**\n+   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods\n+   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,\n+   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.\n+   */\n+  private final boolean inHeap;\n+\n+  /**\n+   * Construct a new MemoryManager.\n+   */\n+  public MemoryManager(MemoryAllocator allocator) {\n+    this.inHeap = allocator instanceof HeapMemoryAllocator;\n+    this.allocator = allocator;\n+  }\n+\n+  /**\n+   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is\n+   * intended for allocating large blocks of memory that will be shared between operators.\n+   */\n+  public MemoryBlock allocatePage(long size) {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Agreed.  This package currently has no dependencies on `core`, so we can't use the `Logging` trait here.  Should we use the lower-level logging library directly, or just add the core dependency?\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T17:35:47Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;\n+\n+  /** Bit mask for the lower 51 bits of a long. */\n+  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;\n+\n+  /** Bit mask for the upper 13 bits of a long */\n+  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;\n+\n+  /**\n+   * Similar to an operating system's page table, this array maps page numbers into base object\n+   * pointers, allowing us to translate between the hashtable's internal 64-bit address\n+   * representation and the baseObject+offset representation which we use to support both in- and\n+   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.\n+   * When using an in-heap allocator, the entries in this map will point to pages' base objects.\n+   * Entries are added to this map as new data pages are allocated.\n+   */\n+  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];\n+\n+  /**\n+   * Bitmap for tracking free pages.\n+   */\n+  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);\n+\n+  /**\n+   * Allocator, exposed for enabling untracked allocations of temporary data structures.\n+   */\n+  public final MemoryAllocator allocator;\n+\n+  /**\n+   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods\n+   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,\n+   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.\n+   */\n+  private final boolean inHeap;\n+\n+  /**\n+   * Construct a new MemoryManager.\n+   */\n+  public MemoryManager(MemoryAllocator allocator) {\n+    this.inHeap = allocator instanceof HeapMemoryAllocator;\n+    this.allocator = allocator;\n+  }\n+\n+  /**\n+   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is\n+   * intended for allocating large blocks of memory that will be shared between operators.\n+   */\n+  public MemoryBlock allocatePage(long size) {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "We can use the lower level logging library directly, like what the network module does.\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T17:55:36Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;\n+\n+  /** Bit mask for the lower 51 bits of a long. */\n+  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;\n+\n+  /** Bit mask for the upper 13 bits of a long */\n+  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;\n+\n+  /**\n+   * Similar to an operating system's page table, this array maps page numbers into base object\n+   * pointers, allowing us to translate between the hashtable's internal 64-bit address\n+   * representation and the baseObject+offset representation which we use to support both in- and\n+   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.\n+   * When using an in-heap allocator, the entries in this map will point to pages' base objects.\n+   * Entries are added to this map as new data pages are allocated.\n+   */\n+  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];\n+\n+  /**\n+   * Bitmap for tracking free pages.\n+   */\n+  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);\n+\n+  /**\n+   * Allocator, exposed for enabling untracked allocations of temporary data structures.\n+   */\n+  public final MemoryAllocator allocator;\n+\n+  /**\n+   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods\n+   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,\n+   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.\n+   */\n+  private final boolean inHeap;\n+\n+  /**\n+   * Construct a new MemoryManager.\n+   */\n+  public MemoryManager(MemoryAllocator allocator) {\n+    this.inHeap = allocator instanceof HeapMemoryAllocator;\n+    this.allocator = allocator;\n+  }\n+\n+  /**\n+   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is\n+   * intended for allocating large blocks of memory that will be shared between operators.\n+   */\n+  public MemoryBlock allocatePage(long size) {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Done.\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T20:50:10Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;\n+\n+  /** Bit mask for the lower 51 bits of a long. */\n+  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;\n+\n+  /** Bit mask for the upper 13 bits of a long */\n+  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;\n+\n+  /**\n+   * Similar to an operating system's page table, this array maps page numbers into base object\n+   * pointers, allowing us to translate between the hashtable's internal 64-bit address\n+   * representation and the baseObject+offset representation which we use to support both in- and\n+   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.\n+   * When using an in-heap allocator, the entries in this map will point to pages' base objects.\n+   * Entries are added to this map as new data pages are allocated.\n+   */\n+  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];\n+\n+  /**\n+   * Bitmap for tracking free pages.\n+   */\n+  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);\n+\n+  /**\n+   * Allocator, exposed for enabling untracked allocations of temporary data structures.\n+   */\n+  public final MemoryAllocator allocator;\n+\n+  /**\n+   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods\n+   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,\n+   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.\n+   */\n+  private final boolean inHeap;\n+\n+  /**\n+   * Construct a new MemoryManager.\n+   */\n+  public MemoryManager(MemoryAllocator allocator) {\n+    this.inHeap = allocator instanceof HeapMemoryAllocator;\n+    this.allocator = allocator;\n+  }\n+\n+  /**\n+   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is\n+   * intended for allocating large blocks of memory that will be shared between operators.\n+   */\n+  public MemoryBlock allocatePage(long size) {"
  }],
  "prId": 5725
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "and log something here too\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T08:09:53Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;\n+\n+  /** Bit mask for the lower 51 bits of a long. */\n+  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;\n+\n+  /** Bit mask for the upper 13 bits of a long */\n+  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;\n+\n+  /**\n+   * Similar to an operating system's page table, this array maps page numbers into base object\n+   * pointers, allowing us to translate between the hashtable's internal 64-bit address\n+   * representation and the baseObject+offset representation which we use to support both in- and\n+   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.\n+   * When using an in-heap allocator, the entries in this map will point to pages' base objects.\n+   * Entries are added to this map as new data pages are allocated.\n+   */\n+  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];\n+\n+  /**\n+   * Bitmap for tracking free pages.\n+   */\n+  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);\n+\n+  /**\n+   * Allocator, exposed for enabling untracked allocations of temporary data structures.\n+   */\n+  public final MemoryAllocator allocator;\n+\n+  /**\n+   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods\n+   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,\n+   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.\n+   */\n+  private final boolean inHeap;\n+\n+  /**\n+   * Construct a new MemoryManager.\n+   */\n+  public MemoryManager(MemoryAllocator allocator) {\n+    this.inHeap = allocator instanceof HeapMemoryAllocator;\n+    this.allocator = allocator;\n+  }\n+\n+  /**\n+   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is\n+   * intended for allocating large blocks of memory that will be shared between operators.\n+   */\n+  public MemoryBlock allocatePage(long size) {\n+    if (size >= (1L << 51)) {\n+      throw new IllegalArgumentException(\"Cannot allocate a page with more than 2^51 bytes\");\n+    }\n+\n+    final int pageNumber;\n+    synchronized (this) {\n+      pageNumber = allocatedPages.nextClearBit(0);\n+      if (pageNumber >= PAGE_TABLE_SIZE) {\n+        throw new IllegalStateException(\n+          \"Have already allocated a maximum of \" + PAGE_TABLE_SIZE + \" pages\");\n+      }\n+      allocatedPages.set(pageNumber);\n+    }\n+    final MemoryBlock page = allocator.allocate(size);\n+    page.pageNumber = pageNumber;\n+    pageTable[pageNumber] = page;\n+    return page;\n+  }\n+\n+  /**\n+   * Free a block of memory allocated via {@link MemoryManager#allocatePage(long)}.\n+   */\n+  public void freePage(MemoryBlock page) {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Done.\n",
    "commit": "eeee512bd94d463f741170e904ae186e238f997c",
    "createdAt": "2015-04-28T20:50:12Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import java.util.BitSet;\n+\n+/**\n+ * Manages the lifecycle of data pages exchanged between operators.\n+ * <p>\n+ * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.\n+ * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is\n+ * addressed by the combination of a base Object reference and a 64-bit offset within that object.\n+ * This is a problem when we want to store pointers to data structures inside of other structures,\n+ * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits\n+ * to address memory, we can't just store the address of the base object since it's not guaranteed\n+ * to remain stable as the heap gets reorganized due to GC.\n+ * <p>\n+ * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap\n+ * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to\n+ * store a \"page number\" and the lower 51 bits to store an offset within this page. These page\n+ * numbers are used to index into a \"page table\" array inside of the MemoryManager in order to\n+ * retrieve the base object.\n+ */\n+public final class MemoryManager {\n+\n+  /**\n+   * The number of entries in the page table.\n+   */\n+  private static final int PAGE_TABLE_SIZE = (int) 1L << 13;\n+\n+  /** Bit mask for the lower 51 bits of a long. */\n+  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;\n+\n+  /** Bit mask for the upper 13 bits of a long */\n+  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;\n+\n+  /**\n+   * Similar to an operating system's page table, this array maps page numbers into base object\n+   * pointers, allowing us to translate between the hashtable's internal 64-bit address\n+   * representation and the baseObject+offset representation which we use to support both in- and\n+   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.\n+   * When using an in-heap allocator, the entries in this map will point to pages' base objects.\n+   * Entries are added to this map as new data pages are allocated.\n+   */\n+  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];\n+\n+  /**\n+   * Bitmap for tracking free pages.\n+   */\n+  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);\n+\n+  /**\n+   * Allocator, exposed for enabling untracked allocations of temporary data structures.\n+   */\n+  public final MemoryAllocator allocator;\n+\n+  /**\n+   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods\n+   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,\n+   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.\n+   */\n+  private final boolean inHeap;\n+\n+  /**\n+   * Construct a new MemoryManager.\n+   */\n+  public MemoryManager(MemoryAllocator allocator) {\n+    this.inHeap = allocator instanceof HeapMemoryAllocator;\n+    this.allocator = allocator;\n+  }\n+\n+  /**\n+   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is\n+   * intended for allocating large blocks of memory that will be shared between operators.\n+   */\n+  public MemoryBlock allocatePage(long size) {\n+    if (size >= (1L << 51)) {\n+      throw new IllegalArgumentException(\"Cannot allocate a page with more than 2^51 bytes\");\n+    }\n+\n+    final int pageNumber;\n+    synchronized (this) {\n+      pageNumber = allocatedPages.nextClearBit(0);\n+      if (pageNumber >= PAGE_TABLE_SIZE) {\n+        throw new IllegalStateException(\n+          \"Have already allocated a maximum of \" + PAGE_TABLE_SIZE + \" pages\");\n+      }\n+      allocatedPages.set(pageNumber);\n+    }\n+    final MemoryBlock page = allocator.allocate(size);\n+    page.pageNumber = pageNumber;\n+    pageTable[pageNumber] = page;\n+    return page;\n+  }\n+\n+  /**\n+   * Free a block of memory allocated via {@link MemoryManager#allocatePage(long)}.\n+   */\n+  public void freePage(MemoryBlock page) {"
  }],
  "prId": 5725
}]