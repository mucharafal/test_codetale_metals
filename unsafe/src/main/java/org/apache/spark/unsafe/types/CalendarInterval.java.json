[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can you declare the possible exceptions here?\n",
    "commit": "7fe9a5eb4296fa0b32913594da262ff1fdf8a40c",
    "createdAt": "2015-08-07T18:20:13Z",
    "diffHunk": "@@ -79,6 +87,152 @@ public static CalendarInterval fromString(String s) {\n     }\n   }\n \n+  public static long toLongWithRange(String fieldName,\n+      String s, long minValue, long maxValue) throws IllegalArgumentException {\n+    long result = 0;\n+    if (s != null) {\n+      result = Long.valueOf(s);\n+      if (result < minValue || result > maxValue) {\n+        throw new IllegalArgumentException(String.format(\"%s %d outside range [%d, %d]\",\n+          fieldName, result, minValue, maxValue));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse YearMonth string in form: [-]YYYY-MM\n+   *\n+   * adapted from HiveIntervalYearMonth.valueOf\n+   */\n+  public static CalendarInterval fromYearMonthString(String s) {"
  }],
  "prId": 8034
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "and here\n",
    "commit": "7fe9a5eb4296fa0b32913594da262ff1fdf8a40c",
    "createdAt": "2015-08-07T18:20:18Z",
    "diffHunk": "@@ -79,6 +87,152 @@ public static CalendarInterval fromString(String s) {\n     }\n   }\n \n+  public static long toLongWithRange(String fieldName,\n+      String s, long minValue, long maxValue) throws IllegalArgumentException {\n+    long result = 0;\n+    if (s != null) {\n+      result = Long.valueOf(s);\n+      if (result < minValue || result > maxValue) {\n+        throw new IllegalArgumentException(String.format(\"%s %d outside range [%d, %d]\",\n+          fieldName, result, minValue, maxValue));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse YearMonth string in form: [-]YYYY-MM\n+   *\n+   * adapted from HiveIntervalYearMonth.valueOf\n+   */\n+  public static CalendarInterval fromYearMonthString(String s) {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval year-month string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = yearMonthPattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match year-month format of 'y-m': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        int years = (int) toLongWithRange(\"year\", m.group(2), 0, Integer.MAX_VALUE);\n+        int months = (int) toLongWithRange(\"month\", m.group(3), 0, 11);\n+        result = new CalendarInterval(sign * (years * 12 + months), 0);\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval year-month string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse dayTime string in form: [-]d HH:mm:ss.nnnnnnnnn\n+   *\n+   * adapted from HiveIntervalDayTime.valueOf\n+   */\n+  public static CalendarInterval fromDayTimeString(String s) {"
  }],
  "prId": 8034
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Why not make `unit` Enum instead of String?\n",
    "commit": "7fe9a5eb4296fa0b32913594da262ff1fdf8a40c",
    "createdAt": "2015-10-27T15:38:55Z",
    "diffHunk": "@@ -79,6 +87,154 @@ public static CalendarInterval fromString(String s) {\n     }\n   }\n \n+  public static long toLongWithRange(String fieldName,\n+      String s, long minValue, long maxValue) throws IllegalArgumentException {\n+    long result = 0;\n+    if (s != null) {\n+      result = Long.valueOf(s);\n+      if (result < minValue || result > maxValue) {\n+        throw new IllegalArgumentException(String.format(\"%s %d outside range [%d, %d]\",\n+          fieldName, result, minValue, maxValue));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse YearMonth string in form: [-]YYYY-MM\n+   *\n+   * adapted from HiveIntervalYearMonth.valueOf\n+   */\n+  public static CalendarInterval fromYearMonthString(String s) throws IllegalArgumentException {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval year-month string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = yearMonthPattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match year-month format of 'y-m': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        int years = (int) toLongWithRange(\"year\", m.group(2), 0, Integer.MAX_VALUE);\n+        int months = (int) toLongWithRange(\"month\", m.group(3), 0, 11);\n+        result = new CalendarInterval(sign * (years * 12 + months), 0);\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval year-month string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse dayTime string in form: [-]d HH:mm:ss.nnnnnnnnn\n+   *\n+   * adapted from HiveIntervalDayTime.valueOf\n+   */\n+  public static CalendarInterval fromDayTimeString(String s) throws IllegalArgumentException {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval day-time string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = dayTimePattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match day-time format of 'd h:m:s.n': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        long days = toLongWithRange(\"day\", m.group(2), 0, Integer.MAX_VALUE);\n+        long hours = toLongWithRange(\"hour\", m.group(3), 0, 23);\n+        long minutes = toLongWithRange(\"minute\", m.group(4), 0, 59);\n+        long seconds = toLongWithRange(\"second\", m.group(5), 0, 59);\n+        // Hive allow nanosecond precision interval\n+        long nanos = toLongWithRange(\"nanosecond\", m.group(7), 0L, 999999999L);\n+        result = new CalendarInterval(0, sign * (\n+          days * MICROS_PER_DAY + hours * MICROS_PER_HOUR + minutes * MICROS_PER_MINUTE +\n+          seconds * MICROS_PER_SECOND + nanos / 1000L));\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval day-time string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  public static CalendarInterval fromSingleUnitString(String unit, String s)",
    "line": 96
  }, {
    "author": {
      "login": "MaxGekk"
    },
    "body": "This is good question. Strings spreads everywhere now. @cloud-fan How about introducing Scala enum (since the code has been moved to IntervalUtils) for interval units for now. ",
    "commit": "7fe9a5eb4296fa0b32913594da262ff1fdf8a40c",
    "createdAt": "2019-11-09T17:34:58Z",
    "diffHunk": "@@ -79,6 +87,154 @@ public static CalendarInterval fromString(String s) {\n     }\n   }\n \n+  public static long toLongWithRange(String fieldName,\n+      String s, long minValue, long maxValue) throws IllegalArgumentException {\n+    long result = 0;\n+    if (s != null) {\n+      result = Long.valueOf(s);\n+      if (result < minValue || result > maxValue) {\n+        throw new IllegalArgumentException(String.format(\"%s %d outside range [%d, %d]\",\n+          fieldName, result, minValue, maxValue));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse YearMonth string in form: [-]YYYY-MM\n+   *\n+   * adapted from HiveIntervalYearMonth.valueOf\n+   */\n+  public static CalendarInterval fromYearMonthString(String s) throws IllegalArgumentException {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval year-month string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = yearMonthPattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match year-month format of 'y-m': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        int years = (int) toLongWithRange(\"year\", m.group(2), 0, Integer.MAX_VALUE);\n+        int months = (int) toLongWithRange(\"month\", m.group(3), 0, 11);\n+        result = new CalendarInterval(sign * (years * 12 + months), 0);\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval year-month string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse dayTime string in form: [-]d HH:mm:ss.nnnnnnnnn\n+   *\n+   * adapted from HiveIntervalDayTime.valueOf\n+   */\n+  public static CalendarInterval fromDayTimeString(String s) throws IllegalArgumentException {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval day-time string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = dayTimePattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match day-time format of 'd h:m:s.n': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        long days = toLongWithRange(\"day\", m.group(2), 0, Integer.MAX_VALUE);\n+        long hours = toLongWithRange(\"hour\", m.group(3), 0, 23);\n+        long minutes = toLongWithRange(\"minute\", m.group(4), 0, 59);\n+        long seconds = toLongWithRange(\"second\", m.group(5), 0, 59);\n+        // Hive allow nanosecond precision interval\n+        long nanos = toLongWithRange(\"nanosecond\", m.group(7), 0L, 999999999L);\n+        result = new CalendarInterval(0, sign * (\n+          days * MICROS_PER_DAY + hours * MICROS_PER_HOUR + minutes * MICROS_PER_MINUTE +\n+          seconds * MICROS_PER_SECOND + nanos / 1000L));\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval day-time string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  public static CalendarInterval fromSingleUnitString(String unit, String s)",
    "line": 96
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "SGTM",
    "commit": "7fe9a5eb4296fa0b32913594da262ff1fdf8a40c",
    "createdAt": "2019-11-10T09:43:39Z",
    "diffHunk": "@@ -79,6 +87,154 @@ public static CalendarInterval fromString(String s) {\n     }\n   }\n \n+  public static long toLongWithRange(String fieldName,\n+      String s, long minValue, long maxValue) throws IllegalArgumentException {\n+    long result = 0;\n+    if (s != null) {\n+      result = Long.valueOf(s);\n+      if (result < minValue || result > maxValue) {\n+        throw new IllegalArgumentException(String.format(\"%s %d outside range [%d, %d]\",\n+          fieldName, result, minValue, maxValue));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse YearMonth string in form: [-]YYYY-MM\n+   *\n+   * adapted from HiveIntervalYearMonth.valueOf\n+   */\n+  public static CalendarInterval fromYearMonthString(String s) throws IllegalArgumentException {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval year-month string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = yearMonthPattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match year-month format of 'y-m': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        int years = (int) toLongWithRange(\"year\", m.group(2), 0, Integer.MAX_VALUE);\n+        int months = (int) toLongWithRange(\"month\", m.group(3), 0, 11);\n+        result = new CalendarInterval(sign * (years * 12 + months), 0);\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval year-month string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Parse dayTime string in form: [-]d HH:mm:ss.nnnnnnnnn\n+   *\n+   * adapted from HiveIntervalDayTime.valueOf\n+   */\n+  public static CalendarInterval fromDayTimeString(String s) throws IllegalArgumentException {\n+    CalendarInterval result = null;\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Interval day-time string was null\");\n+    }\n+    s = s.trim();\n+    Matcher m = dayTimePattern.matcher(s);\n+    if (!m.matches()) {\n+      throw new IllegalArgumentException(\n+        \"Interval string does not match day-time format of 'd h:m:s.n': \" + s);\n+    } else {\n+      try {\n+        int sign = m.group(1) != null && m.group(1).equals(\"-\") ? -1 : 1;\n+        long days = toLongWithRange(\"day\", m.group(2), 0, Integer.MAX_VALUE);\n+        long hours = toLongWithRange(\"hour\", m.group(3), 0, 23);\n+        long minutes = toLongWithRange(\"minute\", m.group(4), 0, 59);\n+        long seconds = toLongWithRange(\"second\", m.group(5), 0, 59);\n+        // Hive allow nanosecond precision interval\n+        long nanos = toLongWithRange(\"nanosecond\", m.group(7), 0L, 999999999L);\n+        result = new CalendarInterval(0, sign * (\n+          days * MICROS_PER_DAY + hours * MICROS_PER_HOUR + minutes * MICROS_PER_MINUTE +\n+          seconds * MICROS_PER_SECOND + nanos / 1000L));\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\n+          \"Error parsing interval day-time string: \" + e.getMessage(), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  public static CalendarInterval fromSingleUnitString(String unit, String s)",
    "line": 96
  }],
  "prId": 8034
}]