[{
  "comments": [{
    "author": {
      "login": "nongli"
    },
    "body": "what's the purpose of this one vs the other ones? Can we unify? I can't imagine someone caring if we hash byte by byte vs hashing the initial bytes in large chunks.\n",
    "commit": "1d7d0542553eb1d98362bf050bf5bdd0a2cc72de",
    "createdAt": "2016-01-12T00:58:16Z",
    "diffHunk": "@@ -51,16 +55,38 @@ public int hashUnsafeWords(Object base, long offset, int lengthInBytes) {\n   public static int hashUnsafeWords(Object base, long offset, int lengthInBytes, int seed) {\n     // This is based on Guava's `Murmur32_Hasher.processRemaining(ByteBuffer)` method.\n     assert (lengthInBytes % 8 == 0): \"lengthInBytes must be a multiple of 8 (word-aligned)\";\n+    int h1 = hashBytesByInt(base, offset, lengthInBytes, seed);\n+    return fmix(h1, lengthInBytes);\n+  }\n+\n+  public static int hashUnsafeBytes(Object base, long offset, int lengthInBytes, int seed) {",
    "line": 19
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "`hashUnsafeWords` requires the bytes word-aligned, and this one breaks this limitation. It's useful to hash binary type and string type.\n",
    "commit": "1d7d0542553eb1d98362bf050bf5bdd0a2cc72de",
    "createdAt": "2016-01-12T01:37:33Z",
    "diffHunk": "@@ -51,16 +55,38 @@ public int hashUnsafeWords(Object base, long offset, int lengthInBytes) {\n   public static int hashUnsafeWords(Object base, long offset, int lengthInBytes, int seed) {\n     // This is based on Guava's `Murmur32_Hasher.processRemaining(ByteBuffer)` method.\n     assert (lengthInBytes % 8 == 0): \"lengthInBytes must be a multiple of 8 (word-aligned)\";\n+    int h1 = hashBytesByInt(base, offset, lengthInBytes, seed);\n+    return fmix(h1, lengthInBytes);\n+  }\n+\n+  public static int hashUnsafeBytes(Object base, long offset, int lengthInBytes, int seed) {",
    "line": 19
  }],
  "prId": 10694
}]