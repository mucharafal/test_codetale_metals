[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "After some benchmarks, there is no performance difference between chunked copy than single `_UNSAFE.copyMemory`, agree with @srowen , single call to `_UNSAFE.copyMemory` should be enough.\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-01T18:24:01Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I was getting at something different -- does `_UNSAFE.copyMemory` work reliably with overlapping memory regions? I hope so, I imagine so. But this method's correctness still depends on it, so it's probably worth unit-testing.\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-01T18:35:56Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "@davies I don't think it was chunked this way for perf. Looking at the comment for UNSAFE_COPY_THRESHOLD, it seems to be for some other purpose. I'm not familiar with this enough to judge if we need that.\n\n@srowen I'm looking to see if I can find docs on what unsafe does but haven't found anything definitive yet. The test case you originally suggested is very similar to what I have no?\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-01T18:50:07Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Hm i don't think the copy block by block is done to improve performance. I believe it was done to allow safe points when copying a very large region.\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-01T23:54:22Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "I still have a question. Both `dstOffset` and `srcOffset` are offsets. They are not absolute addresses. Based on the values of `dstOffset` and `srcOffset`, we are unable to know if source is behind target, right?\n\nBased on the code changes, I do not understand how it works. Could anybody give me a hint? Thank you! \n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T02:44:07Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "davies"
    },
    "body": "If the dst and src are different objects, then they will not overlap, so any branch should work. In case that they are the same object, this branch make sense.\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T04:31:39Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "@davies Thank you for your explanation! The code changes look confusing for the C/C++ people, I think. Do you think we should add the comments for clarifying your point for better readability?   \n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T04:36:57Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "@davies `copyMemory` is a general function. How can we know they are from the same object or not? Like in the following function `putNewKey`, the function caller has to guarantee they do not break our hidden assumptions when calling the function `copyMemory`, right? \n\nI am just afraid the other coders might not realize we have such an assumption in this low-level general function `copyMemory`. Let me know if my concern is valid. Thanks!\n\n``` scala\n      // --- Append the key and value data to the current data page --------------------------------\n      final Object base = currentPage.getBaseObject();\n      long offset = currentPage.getBaseOffset() + pageCursor;\n      final long recordOffset = offset;\n      Platform.putInt(base, offset, keyLength + valueLength + 4);\n      Platform.putInt(base, offset + 4, keyLength);\n      offset += 8;\n      Platform.copyMemory(keyBase, keyOffset, base, offset, keyLength);\n      offset += keyLength;\n      Platform.copyMemory(valueBase, valueOffset, base, offset, valueLength);\n```\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T04:56:05Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "What's the \"hidden assumptions\"? The `src` and `dst` can be same object or not, the offset can overlap or not, we don't have a limitation for `copyMemory` right?\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T05:23:02Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "davies"
    },
    "body": "In JVM, two objects (or memory block) can't overlap each other (assuming the two offsets are in  valid range). The only case that src and dst could overlap is they are exactly the same value (pointer), so we can only compare the offsets.\n\nAfter this patch, we can use copyMemory() without worrying about the src and dst are overlapped or not, it always works.\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T05:24:36Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "uh, I see. Thank you very much!\n",
    "commit": "ebf4d10fcfcf956af2edf7e033b8da609c32eb44",
    "createdAt": "2015-12-02T05:33:53Z",
    "diffHunk": "@@ -107,12 +107,27 @@ public static void freeMemory(long address) {\n \n   public static void copyMemory(\n     Object src, long srcOffset, Object dst, long dstOffset, long length) {\n-    while (length > 0) {\n-      long size = Math.min(length, UNSAFE_COPY_THRESHOLD);\n-      _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);\n-      length -= size;\n-      srcOffset += size;\n-      dstOffset += size;\n+    // Check if dstOffset is before or after srcOffset to determine if we should copy\n+    // forward or backwards. This is necessary in case src and dst overlap.\n+    if (dstOffset < srcOffset) {",
    "line": 12
  }],
  "prId": 10068
}]