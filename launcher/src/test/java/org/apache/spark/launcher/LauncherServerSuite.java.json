[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This might be your IDE, but please don't explode (or re-order) existing imports like this. It's unnecessary noise and actually against Spark's code conventions.\n",
    "commit": "72ea2ca05a55d0cab5b8cd694df6f95fb9a0c76a",
    "createdAt": "2016-06-03T20:54:45Z",
    "diffHunk": "@@ -17,19 +17,42 @@\n \n package org.apache.spark.launcher;\n \n+import static org.junit.Assert.assertEquals;"
  }],
  "prId": 13497
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This module doesn't depend on Guava, so this would probably cause a failure (at least when using maven). With Java 7 it's pretty easy to avoid these particular Guava classes, though.\n",
    "commit": "72ea2ca05a55d0cab5b8cd694df6f95fb9a0c76a",
    "createdAt": "2016-06-03T20:57:00Z",
    "diffHunk": "@@ -17,19 +17,42 @@\n \n package org.apache.spark.launcher;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.Closeable;\n+import java.io.EOFException;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n import java.net.InetAddress;\n import java.net.Socket;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.apache.spark.launcher.LauncherProtocol.Hello;\n+import org.apache.spark.launcher.LauncherProtocol.Message;\n+import org.apache.spark.launcher.LauncherProtocol.SetAppId;\n+import org.apache.spark.launcher.LauncherProtocol.SetState;\n+import org.apache.spark.launcher.LauncherProtocol.Stop;\n+import org.apache.spark.launcher.SparkAppHandle.State;\n import org.junit.Test;\n-import static org.junit.Assert.*;\n+import org.mockito.Mockito;\n+\n+import com.google.common.collect.Lists;"
  }],
  "prId": 13497
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "style nits:\n- code is cleaner if you just static import `Mockito.*`\n- space after casts: `(LauncherServer) mock(...)`\n",
    "commit": "72ea2ca05a55d0cab5b8cd694df6f95fb9a0c76a",
    "createdAt": "2016-06-03T20:57:58Z",
    "diffHunk": "@@ -152,6 +175,102 @@ public void testTimeout() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSparkSubmitVmShutsDown() throws Exception {\n+\tLauncherServer launchServer = (LauncherServer)Mockito.mock(LauncherServer.class);"
  }],
  "prId": 13497
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This test looks very complicated. Why not:\n- create a server and a client that connects to it\n- initiate the connection (send \"Hello\")\n- close the client socket\n- verify the server socket fires the expected event\n\nThis would be very similar to `testCommunication` above until about L112. After that you just close the client socket and wait for the event on the handle.\n",
    "commit": "72ea2ca05a55d0cab5b8cd694df6f95fb9a0c76a",
    "createdAt": "2016-06-03T21:02:46Z",
    "diffHunk": "@@ -152,6 +175,102 @@ public void testTimeout() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSparkSubmitVmShutsDown() throws Exception {",
    "line": 5
  }],
  "prId": 13497
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Do you need this separate thread? Seems to me like all you need is:\n\n```\nclose(client);\nassertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\nassertEquals(SparkAppHandle.State.LOST, handle.getState());\n```\n\nThat gets rid of a bunch of code in your tests and tests just the code you're interested in.\n",
    "commit": "72ea2ca05a55d0cab5b8cd694df6f95fb9a0c76a",
    "createdAt": "2016-06-06T17:08:26Z",
    "diffHunk": "@@ -152,6 +157,69 @@ public void testTimeout() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSparkSubmitVmShutsDown() throws Exception {\n+    ChildProcAppHandle handle = LauncherServer.newAppHandle();\n+    TestClient client = null;\n+    final List<SparkAppHandle.State> expectedStateList = Arrays.asList(SparkAppHandle.State.CONNECTED, SparkAppHandle.State.LOST);\n+    final List<SparkAppHandle.State> realStateList = new ArrayList<SparkAppHandle.State>(2);\n+    final AtomicBoolean jobFinished = new AtomicBoolean(false);\n+    final BlockingQueue<SparkAppHandle.State> stateQueue = new LinkedBlockingQueue<SparkAppHandle.State>(10);\n+    final Semaphore semaphore = new Semaphore(0);\n+    try {\n+      Socket s = new Socket(InetAddress.getLoopbackAddress(),\n+        LauncherServer.getServerInstance().getPort());\n+      handle.addListener(new SparkAppHandle.Listener() {\n+        public void stateChanged(SparkAppHandle handle) {\n+          stateQueue.offer(handle.getState());\n+          semaphore.release();\n+        }\n+        public void infoChanged(SparkAppHandle handle) {\n+          semaphore.release();\n+        }\n+      });\n+      client = new TestClient(s);\n+      client.send(new Hello(handle.getSecret(), \"1.4.0\"));\n+      assertTrue(semaphore.tryAcquire(30, TimeUnit.SECONDS));\n+      // Make sure the server matched the client to the handle.\n+      assertNotNull(handle.getConnection());\n+      Thread sparkLauncherClient = new Thread() {\n+        public void run() {\n+          while (!jobFinished.get()) {\n+            SparkAppHandle.State state = SparkAppHandle.State.UNKNOWN;\n+            try {\n+              state = (SparkAppHandle.State)stateQueue.take();\n+            } catch (InterruptedException e) {\n+              Thread.currentThread().interrupt();\n+              throw new RuntimeException(e);\n+            }\n+            switch (state) {\n+              case CONNECTED:\n+                realStateList.add(state);\n+                break;\n+              case LOST:\n+                jobFinished.set(true);\n+                realStateList.add(state);\n+                break;\n+              default:\n+                throw new RuntimeException(String.format(\"Unexpected state. The should have been one of the %s.\", expectedStateList));\n+            }\n+          }\n+        }\n+      };\n+      sparkLauncherClient.start();\n+      close(client);\n+      sparkLauncherClient.join(10000L);"
  }],
  "prId": 13497
}]