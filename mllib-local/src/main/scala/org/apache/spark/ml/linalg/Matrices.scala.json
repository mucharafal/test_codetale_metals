[{
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "Writing it as `data += (i, j + startCol, v)` would yield compilation errors:\n\n```\nToo many arguments for methods +=(A)\nType mismatch, expected: (Int, Int, Double), actual: Int\n```\n\nthus here it's written as `data.+=((i, j + startCol, v))`\n",
    "commit": "f997c2b3f5c0e718dee029356eab25087e742054",
    "createdAt": "2016-09-01T07:48:53Z",
    "diffHunk": "@@ -999,7 +999,7 @@ object Matrices {\n             val data = new ArrayBuffer[(Int, Int, Double)]()\n             dnMat.foreachActive { (i, j, v) =>\n               if (v != 0.0) {\n-                data.append((i, j + startCol, v))\n+                data.+=((i, j + startCol, v))"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "You can write `data += ((i, j + startCol, v))`\nYes, I think it may be worth optimizing this because append actually expects varargs.\nThere are many more instances in the code though. I think it's reasonable to fix this everywhere. At least non-test code, and at least anything where performance could be important.\n",
    "commit": "f997c2b3f5c0e718dee029356eab25087e742054",
    "createdAt": "2016-09-01T08:04:48Z",
    "diffHunk": "@@ -999,7 +999,7 @@ object Matrices {\n             val data = new ArrayBuffer[(Int, Int, Double)]()\n             dnMat.foreachActive { (i, j, v) =>\n               if (v != 0.0) {\n-                data.append((i, j + startCol, v))\n+                data.+=((i, j + startCol, v))"
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "I don't have strong preference, but people might mis-interpret `data += ((i, j + startCol, v))` as adding a tuple of a tuple? \n",
    "commit": "f997c2b3f5c0e718dee029356eab25087e742054",
    "createdAt": "2016-09-01T08:11:41Z",
    "diffHunk": "@@ -999,7 +999,7 @@ object Matrices {\n             val data = new ArrayBuffer[(Int, Int, Double)]()\n             dnMat.foreachActive { (i, j, v) =>\n               if (v != 0.0) {\n-                data.append((i, j + startCol, v))\n+                data.+=((i, j + startCol, v))"
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "> I think it's reasonable to fix this everywhere.\n\nok let me do that -- I was conservative in fixing only these instances that were in a loop.\n",
    "commit": "f997c2b3f5c0e718dee029356eab25087e742054",
    "createdAt": "2016-09-01T08:15:16Z",
    "diffHunk": "@@ -999,7 +999,7 @@ object Matrices {\n             val data = new ArrayBuffer[(Int, Int, Double)]()\n             dnMat.foreachActive { (i, j, v) =>\n               if (v != 0.0) {\n-                data.append((i, j + startCol, v))\n+                data.+=((i, j + startCol, v))"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "() can't create a tuple of 1 element so it shouldn't be ambiguous at all. I think it's preferable to the slightly funny .+= syntax.\n",
    "commit": "f997c2b3f5c0e718dee029356eab25087e742054",
    "createdAt": "2016-09-01T08:44:19Z",
    "diffHunk": "@@ -999,7 +999,7 @@ object Matrices {\n             val data = new ArrayBuffer[(Int, Int, Double)]()\n             dnMat.foreachActive { (i, j, v) =>\n               if (v != 0.0) {\n-                data.append((i, j + startCol, v))\n+                data.+=((i, j + startCol, v))"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "You can do\n\n```\ndata += Tuple3(i, j + startCol, v)\n```\n\nprobably the most clear\n",
    "commit": "f997c2b3f5c0e718dee029356eab25087e742054",
    "createdAt": "2016-09-01T09:28:08Z",
    "diffHunk": "@@ -999,7 +999,7 @@ object Matrices {\n             val data = new ArrayBuffer[(Int, Int, Double)]()\n             dnMat.foreachActive { (i, j, v) =>\n               if (v != 0.0) {\n-                data.append((i, j + startCol, v))\n+                data.+=((i, j + startCol, v))"
  }],
  "prId": 14914
}]