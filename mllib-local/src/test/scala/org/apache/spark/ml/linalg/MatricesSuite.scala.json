[{
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "I would like to make `toDenseMatrix` as private, and we test against `toDenseRowMajor` which is more explicit. ",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-22T01:00:00Z",
    "diffHunk": "@@ -160,22 +160,385 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseMatrix(false)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Why not just make `dm2` dm1.transposed, but explicitly assign the value?  Thus, you don't need to type the value in the array for the comparison. ",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-22T01:06:29Z",
    "diffHunk": "@@ -160,22 +160,385 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)",
    "line": 20
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "I'm not sure I understand your meaning here. These are made to be two entirely different matrices anyway.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-22T22:34:29Z",
    "diffHunk": "@@ -160,22 +160,385 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)",
    "line": 20
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Can you group the tests either by `dm1` and `dm2` or by the same methods?",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T04:51:09Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))"
  }, {
    "author": {
      "login": "dbtsai"
    },
    "body": "`val dm4 = dm1.toDenseRowMajor` and `val dm7 = dm1.toDenseRowMajor` are the same.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:00:46Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "You tested `dm1.toSparseColMajor` twice.\r\n\r\nWill be nice to group them like\r\n```scala\r\nval sm1 = dm1.toSparseColMajor\r\n\r\nval sm2 = dm2.toSparseColMajor\r\n\r\nval sm3 = dm3.toSparseColMajor\r\n\r\nval sm4 = dm1.toSparseRowMajor\r\n\r\nval sm5 = dm2.toSparseRowMajor\r\n\r\nval sm6 = dm3.toSparseRowMajor\r\n\r\nval sm7 = dm1.toSparse\r\n\r\nval sm8 = dm2.toSparse\r\n\r\nval sm9 = dm3.toSparse\r\n```",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T04:59:13Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Group the tests by methods",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:03:51Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+",
    "line": 129
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "This is duplicated to `val dm4 = sm2.toDenseRowMajor`. And some of them don't have test of `toDenseColMajor`",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:05:36Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Why not `<` instead of `<=`?",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:06:51Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "ditto",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:09:55Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)"
  }, {
    "author": {
      "login": "dbtsai"
    },
    "body": "Also check compressedRowMajor.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:11:17Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "ditto.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:11:41Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Should be `=` here.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:12:31Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Should be `=` here.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:12:42Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "ditto.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:12:52Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "ditto. remove `=`",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:24:35Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "`=` is needed?",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:26:50Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "I think it's ok to leave it here since they could potentially be equal.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T06:31:49Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)"
  }, {
    "author": {
      "login": "dbtsai"
    },
    "body": "If =, dense should be preferred since it will be faster. As a result, we should only check <.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T07:06:08Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "Ok, before we broke ties with sparse, so I changed it to choose dense, and added unit tests. Also removed the = here.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T17:15:29Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "For completion, could you test `sm1. compressedColumnMajor` and `sm2. compressedRowMajor`? Thanks.",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:28:46Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)\n+\n+    val cm3 = sm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === sm2)\n+    assert(cm3.isTransposed)\n+    assert(cm3.values.equals(sm2.values))\n+    assert(cm3.getSizeInBytes <= sm2.getSizeInBytes)\n+\n+    val cm8 = sm2.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm8 === sm2)\n+    assert(!cm8.isTransposed)\n+    assert(cm8.getSizeInBytes > sm2.getSizeInBytes)\n+    assert(cm8.getSizeInBytes <= sm2.toDense.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "remove `=`?",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:29:21Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)\n+\n+    val cm3 = sm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === sm2)\n+    assert(cm3.isTransposed)\n+    assert(cm3.values.equals(sm2.values))\n+    assert(cm3.getSizeInBytes <= sm2.getSizeInBytes)\n+\n+    val cm8 = sm2.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm8 === sm2)\n+    assert(!cm8.isTransposed)\n+    assert(cm8.getSizeInBytes > sm2.getSizeInBytes)\n+    assert(cm8.getSizeInBytes <= sm2.toDense.getSizeInBytes)\n+\n+    /*\n+       sm3 = 0.0 -1.0\n+             2.0  3.0\n+            -4.0  9.0\n+     */\n+    // this should compress to a dense matrix\n+    val sm3 = new SparseMatrix(3, 2, Array(0, 2, 5), Array(1, 2, 0, 1, 2),\n+      Array(2.0, -4.0, -1.0, 3.0, 9.0))\n+\n+    // dense is optimal, and maintains column major\n+    val cm4 = sm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === sm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.getSizeInBytes <= sm3.getSizeInBytes)"
  }],
  "prId": 15628
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "remove `=`? and `sm3.compressedColumnMajor`?",
    "commit": "87dfaa06b2861ccc4bd5ca62915dea867985b391",
    "createdAt": "2017-03-24T05:30:00Z",
    "diffHunk": "@@ -160,22 +160,395 @@ class MatricesSuite extends SparkMLFunSuite {\n     assert(sparseMat.values(2) === 10.0)\n   }\n \n-  test(\"toSparse, toDense\") {\n-    val m = 3\n-    val n = 2\n-    val values = Array(1.0, 2.0, 4.0, 5.0)\n-    val allValues = Array(1.0, 2.0, 0.0, 0.0, 4.0, 5.0)\n-    val colPtrs = Array(0, 2, 4)\n-    val rowIndices = Array(0, 1, 1, 2)\n+  test(\"dense to dense\") {\n+    /*\n+      dm1 =  4.0 2.0 -8.0\n+            -1.0 7.0  4.0\n+\n+      dm2 = 5.0 -9.0  4.0\n+            1.0 -3.0 -8.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(4.0, -1.0, 2.0, 7.0, -8.0, 4.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(5.0, -9.0, 4.0, 1.0, -3.0, -8.0), isTransposed = true)\n+\n+    val dm3 = dm1.toDense\n+    assert(dm3 === dm1)\n+    assert(!dm3.isTransposed)\n+    assert(dm3.values.equals(dm1.values))\n+\n+    val dm4 = dm1.toDenseRowMajor\n+    assert(dm4 === dm1)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm5 = dm2.toDenseColMajor\n+    assert(dm5 === dm2)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array(5.0, 1.0, -9.0, -3.0, 4.0, -8.0))\n+\n+    val dm6 = dm2.toDenseRowMajor\n+    assert(dm6 === dm2)\n+    assert(dm6.isTransposed)\n+    assert(dm6.values.equals(dm2.values))\n+\n+    val dm7 = dm1.toDenseRowMajor\n+    assert(dm7 === dm1)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(4.0, 2.0, -8.0, -1.0, 7.0, 4.0))\n+\n+    val dm8 = dm1.toDenseColMajor\n+    assert(dm8 === dm1)\n+    assert(!dm8.isTransposed)\n+    assert(dm8.values.equals(dm1.values))\n+\n+    val dm9 = dm2.toDense\n+    assert(dm9 === dm2)\n+    assert(dm9.isTransposed)\n+    assert(dm9.values.equals(dm2.values))\n+  }\n \n-    val spMat1 = new SparseMatrix(m, n, colPtrs, rowIndices, values)\n-    val deMat1 = new DenseMatrix(m, n, allValues)\n+  test(\"dense to sparse\") {\n+    /*\n+      dm1 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n+\n+      dm2 = 0.0 4.0 5.0\n+            0.0 2.0 0.0\n \n-    val spMat2 = deMat1.toSparse\n-    val deMat2 = spMat1.toDense\n+      dm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val dm1 = new DenseMatrix(2, 3, Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+    val dm2 = new DenseMatrix(2, 3, Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0), isTransposed = true)\n+    val dm3 = new DenseMatrix(2, 3, Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm1 = dm1.toSparseColMajor\n+    assert(sm1 === dm1)\n+    assert(!sm1.isTransposed)\n+    assert(sm1.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm2 = dm1.toSparseRowMajor\n+    assert(sm2 === dm1)\n+    assert(sm2.isTransposed)\n+    assert(sm2.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm3 = dm2.toSparseColMajor\n+    assert(sm3 === dm2)\n+    assert(!sm3.isTransposed)\n+    assert(sm3.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm4 = dm2.toSparseRowMajor\n+    assert(sm4 === dm2)\n+    assert(sm4.isTransposed)\n+    assert(sm4.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm5 = dm3.toSparseColMajor\n+    assert(sm5 === dm3)\n+    assert(sm5.values === Array.empty[Double])\n+    assert(!sm5.isTransposed)\n+\n+    val sm6 = dm3.toSparseRowMajor\n+    assert(sm6 === dm3)\n+    assert(sm6.values === Array.empty[Double])\n+    assert(sm6.isTransposed)\n+\n+    val sm7 = dm1.toSparse\n+    assert(sm7 === dm1)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm7.isTransposed)\n+\n+    val sm8 = dm1.toSparseColMajor\n+    assert(sm8 === dm1)\n+    assert(sm8.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm8.isTransposed)\n+\n+    val sm9 = dm2.toSparseRowMajor\n+    assert(sm9 === dm2)\n+    assert(sm9.values === Array(4.0, 5.0, 2.0))\n+    assert(sm9.isTransposed)\n+\n+    val sm10 = dm2.toSparse\n+    assert(sm10 === dm2)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+  }\n+\n+  test(\"sparse to sparse\") {\n+    /*\n+      sm1 = sm2 = sm3 = sm4 = 0.0 4.0 5.0\n+                              0.0 2.0 0.0\n+      smZeros = 0.0 0.0 0.0\n+                0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 2, 4), Array(0, 1, 0, 1),\n+      Array(4.0, 2.0, 5.0, 0.0))\n+    val sm4 = new SparseMatrix(2, 3, Array(0, 2, 4), Array(1, 2, 1, 2),\n+      Array(4.0, 5.0, 2.0, 0.0), isTransposed = true)\n+    val smZeros = new SparseMatrix(2, 3, Array(0, 2, 4, 6), Array(0, 1, 0, 1, 0, 1),\n+      Array(0.0, 0.0, 0.0, 0.0, 0.0, 0.0))\n+\n+    val sm5 = sm1.toSparseRowMajor\n+    assert(sm5 === sm1)\n+    assert(sm5.isTransposed)\n+    assert(sm5.values === Array(4.0, 5.0, 2.0))\n+\n+    val sm6 = sm1.toSparseColMajor\n+    assert(sm6 === sm1)\n+    assert(!sm6.isTransposed)\n+    assert(sm6.values.equals(sm1.values))\n+\n+    val sm7 = sm2.toSparseColMajor\n+    assert(sm7 === sm2)\n+    assert(!sm7.isTransposed)\n+    assert(sm7.values === Array(4.0, 2.0, 5.0))\n+\n+    val sm8 = sm2.toSparseRowMajor\n+    assert(sm8 === sm2)\n+    assert(sm8.isTransposed)\n+    assert(sm8.values.equals(sm2.values))\n+\n+    val sm9 = sm3.toSparse\n+    assert(sm9 === sm3)\n+    assert(sm9.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm9.isTransposed)\n+\n+    val sm10 = sm3.toSparseRowMajor\n+    assert(sm10 === sm3)\n+    assert(sm10.values === Array(4.0, 5.0, 2.0))\n+    assert(sm10.isTransposed)\n+\n+    val sm11 = sm4.toSparseRowMajor\n+    assert(sm11 === sm4)\n+    assert(sm11.values === Array(4.0, 5.0, 2.0))\n+    assert(sm11.isTransposed)\n+\n+    val sm12 = sm4.toSparse\n+    assert(sm12 === sm4)\n+    assert(sm12.values === Array(4.0, 5.0, 2.0))\n+    assert(sm12.isTransposed)\n+\n+    val sm13 = smZeros.toSparse\n+    assert(sm13 === smZeros)\n+    assert(sm13.values === Array.empty[Double])\n+    assert(!sm13.isTransposed)\n+\n+    val sm14 = sm4.toSparseColMajor\n+    assert(sm14 === sm4)\n+    assert(sm14.values === Array(4.0, 2.0, 5.0))\n+    assert(!sm14.isTransposed)\n+\n+    val sm15 = smZeros.toSparseColMajor\n+    assert(sm15 === smZeros)\n+    assert(sm15.values === Array.empty[Double])\n+    assert(!sm15.isTransposed)\n+\n+    val sm16 = sm3.toSparseRowMajor\n+    assert(sm16 === sm4)\n+    assert(sm16.values === Array(4.0, 5.0, 2.0))\n+    assert(sm16.isTransposed)\n+\n+    val sm17 = smZeros.toSparseRowMajor\n+    assert(sm17 === smZeros)\n+    assert(sm17.values === Array.empty[Double])\n+    assert(sm17.isTransposed)\n+  }\n+\n+  test(\"sparse to dense\") {\n+    /*\n+      sm1 = sm2 = 0.0 4.0 5.0\n+                  0.0 2.0 0.0\n+\n+      sm3 = 0.0 0.0 0.0\n+            0.0 0.0 0.0\n+     */\n+    val sm1 = new SparseMatrix(2, 3, Array(0, 0, 2, 3), Array(0, 1, 0), Array(4.0, 2.0, 5.0))\n+    val sm2 = new SparseMatrix(2, 3, Array(0, 2, 3), Array(1, 2, 1), Array(4.0, 5.0, 2.0),\n+      isTransposed = true)\n+    val sm3 = new SparseMatrix(2, 3, Array(0, 0, 0, 0), Array.empty[Int], Array.empty[Double])\n+\n+    val dm1 = sm1.toDense\n+    assert(dm1 === sm1)\n+    assert(!dm1.isTransposed)\n+    assert(dm1.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm2 = sm1.toDenseRowMajor\n+    assert(dm2 === sm1)\n+    assert(dm2.isTransposed)\n+    assert(dm2.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm3 = sm2.toDense\n+    assert(dm3 === sm2)\n+    assert(dm3.isTransposed)\n+    assert(dm3.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm4 = sm2.toDenseRowMajor\n+    assert(dm4 === sm2)\n+    assert(dm4.isTransposed)\n+    assert(dm4.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+\n+    val dm5 = sm3.toDense\n+    assert(dm5 === sm3)\n+    assert(!dm5.isTransposed)\n+    assert(dm5.values === Array.fill(6)(0.0))\n+\n+    val dm6 = sm2.toDenseColMajor\n+    assert(dm6 === sm2)\n+    assert(!dm6.isTransposed)\n+    assert(dm6.values === Array(0.0, 0.0, 4.0, 2.0, 5.0, 0.0))\n+\n+    val dm7 = sm2.toDenseRowMajor\n+    assert(dm7 === sm2)\n+    assert(dm7.isTransposed)\n+    assert(dm7.values === Array(0.0, 4.0, 5.0, 0.0, 2.0, 0.0))\n+  }\n+\n+  test(\"compressed dense\") {\n+    /*\n+      dm1 = 1.0 0.0 0.0 0.0\n+            1.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+\n+      dm2 = 1.0 1.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a sparse matrix\n+    val dm1 = new DenseMatrix(3, 4, Array.fill(2)(1.0) ++ Array.fill(10)(0.0))\n+\n+    // optimal compression layout is row major since numRows < numCols\n+    val cm1 = dm1.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm1 === dm1)\n+    assert(cm1.isTransposed)\n+    assert(cm1.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // force compressed column major\n+    val cm2 = dm1.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === dm1)\n+    assert(!cm2.isTransposed)\n+    assert(cm2.getSizeInBytes <= dm1.getSizeInBytes)\n+\n+    // optimal compression layout for transpose is column major\n+    val dm2 = dm1.transpose\n+    val cm3 = dm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === dm2)\n+    assert(!cm3.isTransposed)\n+    assert(cm3.getSizeInBytes <= dm2.getSizeInBytes)\n+\n+    /*\n+      dm3 = 1.0 1.0 1.0 0.0\n+            1.0 1.0 0.0 0.0\n+            1.0 1.0 0.0 0.0\n+\n+      dm4 = 1.0 1.0 1.0 1.0\n+            1.0 1.0 1.0 0.0\n+            0.0 0.0 0.0 0.0\n+     */\n+    // this should compress to a dense matrix\n+    val dm3 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0))\n+    val dm4 = new DenseMatrix(3, 4, Array.fill(7)(1.0) ++ Array.fill(5)(0.0), isTransposed = true)\n+\n+    val cm4 = dm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === dm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.values.equals(dm3.values))\n+    assert(cm4.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    // force compressed row major\n+    val cm5 = dm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === dm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= dm3.getSizeInBytes)\n+\n+    val cm6 = dm4.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm6 === dm4)\n+    assert(cm6.isTransposed)\n+    assert(cm6.values.equals(dm4.values))\n+    assert(cm6.getSizeInBytes <= dm4.getSizeInBytes)\n+  }\n \n-    assert(spMat1.asBreeze === spMat2.asBreeze)\n-    assert(deMat1.asBreeze === deMat2.asBreeze)\n+  test(\"compressed sparse\") {\n+    /*\n+       sm1 = 0.0 -1.0\n+             0.0  0.0\n+            -4.0  0.0\n+             0.0  0.0\n+\n+       sm2 = 0.0 0.0 -4.0 0.0\n+            -1.0 0.0  0.0 0.0\n+     */\n+    // these should compress to sparse matrices\n+    val sm1 = new SparseMatrix(4, 2, Array(0, 1, 2), Array(2, 0), Array(-4.0, -1.0))\n+    val sm2 = sm1.transpose\n+\n+    val cm1 = sm1.compressed.asInstanceOf[SparseMatrix]\n+    // optimal is column major\n+    assert(cm1 === sm1)\n+    assert(!cm1.isTransposed)\n+    assert(cm1.values.equals(sm1.values))\n+    assert(cm1.getSizeInBytes <= sm1.getSizeInBytes)\n+\n+    val cm2 = sm1.compressedRowMajor.asInstanceOf[SparseMatrix]\n+    assert(cm2 === sm1)\n+    assert(cm2.isTransposed)\n+    // forced to be row major, so we have increased the size\n+    assert(cm2.getSizeInBytes > sm1.getSizeInBytes)\n+    assert(cm2.getSizeInBytes <= sm1.toDense.getSizeInBytes)\n+\n+    val cm3 = sm2.compressed.asInstanceOf[SparseMatrix]\n+    assert(cm3 === sm2)\n+    assert(cm3.isTransposed)\n+    assert(cm3.values.equals(sm2.values))\n+    assert(cm3.getSizeInBytes <= sm2.getSizeInBytes)\n+\n+    val cm8 = sm2.compressedColMajor.asInstanceOf[SparseMatrix]\n+    assert(cm8 === sm2)\n+    assert(!cm8.isTransposed)\n+    assert(cm8.getSizeInBytes > sm2.getSizeInBytes)\n+    assert(cm8.getSizeInBytes <= sm2.toDense.getSizeInBytes)\n+\n+    /*\n+       sm3 = 0.0 -1.0\n+             2.0  3.0\n+            -4.0  9.0\n+     */\n+    // this should compress to a dense matrix\n+    val sm3 = new SparseMatrix(3, 2, Array(0, 2, 5), Array(1, 2, 0, 1, 2),\n+      Array(2.0, -4.0, -1.0, 3.0, 9.0))\n+\n+    // dense is optimal, and maintains column major\n+    val cm4 = sm3.compressed.asInstanceOf[DenseMatrix]\n+    assert(cm4 === sm3)\n+    assert(!cm4.isTransposed)\n+    assert(cm4.getSizeInBytes <= sm3.getSizeInBytes)\n+\n+    val cm5 = sm3.compressedRowMajor.asInstanceOf[DenseMatrix]\n+    assert(cm5 === sm3)\n+    assert(cm5.isTransposed)\n+    assert(cm5.getSizeInBytes <= sm3.getSizeInBytes)"
  }],
  "prId": 15628
}]