[
  {
    "id" : "211b54de-101b-413e-ba58-895c3c5bcf70",
    "prId" : 21,
    "comments" : [
      {
        "id" : "ba40792a-2dcb-4e46-940e-ecf337048ce5",
        "parentId" : null,
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Is it 100% sure that `tpeName` is never empty? 😄 ",
        "createdAt" : "2017-11-10T15:03:40Z",
        "updatedAt" : "2017-11-10T15:03:40Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "753b1d03-9109-4561-9eb8-97c7c3f86ed7",
        "parentId" : "ba40792a-2dcb-4e46-940e-ecf337048ce5",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I tried hovering on everything and it never showed empty boxes 💃 \r\n\r\nOf course I may be wrong ^^",
        "createdAt" : "2017-11-10T15:05:06Z",
        "updatedAt" : "2017-11-10T15:05:06Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f1329985-e6a2-409b-a8ea-ef3ccbc740f4",
        "parentId" : "ba40792a-2dcb-4e46-940e-ecf337048ce5",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "I would still add a check here, if it's not an a priori known fact that `tpeName` cannot be empty.\r\n\r\nAnother question here: why did you remove the range parameter?",
        "createdAt" : "2017-11-10T15:07:31Z",
        "updatedAt" : "2017-11-10T15:07:31Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2514e0b3-0be4-47db-8085-fca82efb2675",
        "parentId" : "ba40792a-2dcb-4e46-940e-ecf337048ce5",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I didn't find an easy way to retrieve that from the PC. I admit I didn't look hard for it, because vscode seems to handle it pretty well even without it.",
        "createdAt" : "2017-11-10T15:09:01Z",
        "updatedAt" : "2017-11-10T15:09:16Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3ec30954-812a-4fb0-948e-0cb44412fe42",
        "parentId" : "ba40792a-2dcb-4e46-940e-ecf337048ce5",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "As per the check, it'd be weird that `tree.tpe.widen` would return an empty string. I suppose if it ever comes up we can handle it pretty easily :)",
        "createdAt" : "2017-11-10T15:10:46Z",
        "updatedAt" : "2017-11-10T15:10:46Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fd37abcc-d6b4-431b-8fc1-712d3cce3107",
        "parentId" : "ba40792a-2dcb-4e46-940e-ecf337048ce5",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Works great! 💯 So cool!\r\nAnd yes, I thought that without range symbols won't be highlighted correctly, but both VS Code and Atom handle it very well.",
        "createdAt" : "2017-11-10T15:36:46Z",
        "updatedAt" : "2017-11-10T15:36:46Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "122ec665a5096b2c5408dc9d9320eac87adb0549",
    "line" : 10,
    "diffHunk" : "@@ -248,15 +248,15 @@ class ScalametaLanguageServer(\n       td: TextDocumentIdentifier,\n       position: Position\n   ): Hover = {\n-    val path = Uri.toPath(td.uri).get.toRelative(cwd)\n-    symbol.hoverInformation(path, position.line, position.character) match {\n+    val path = Uri.toPath(td.uri).get\n+    compiler.typeAt(path, position.line, position.character) match {\n       case None => Hover(Nil, None)\n-      case Some((pos, denotation)) =>\n+      case Some(tpeName) =>"
  },
  {
    "id" : "ede8f92b-f906-4396-8a09-bc6a15c9362a",
    "prId" : 23,
    "comments" : [
      {
        "id" : "f21b5385-8f2c-4edd-be9c-4fa610c3aa79",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "should we also preload all existing `compilerconfig`files at launch, similarly to what we do with `semanticdb` files?",
        "createdAt" : "2017-11-14T09:21:37Z",
        "updatedAt" : "2017-11-14T20:08:40Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "329dba1a-b456-4d36-9f92-55dbdf720c07",
        "parentId" : "f21b5385-8f2c-4edd-be9c-4fa610c3aa79",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We do actually, since we call this method from loadAllSemanticdbs... method, I've renamed the method to be more descriptive.",
        "createdAt" : "2017-11-14T19:36:57Z",
        "updatedAt" : "2017-11-14T20:08:40Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f7b42059-209c-4174-a636-67dc96ae210f",
        "parentId" : "f21b5385-8f2c-4edd-be9c-4fa610c3aa79",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "NB, we should really run that method asynchronously from the initialize method since it slows down server startup.",
        "createdAt" : "2017-11-14T19:37:27Z",
        "updatedAt" : "2017-11-14T20:08:40Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9a1c0082-63ab-4acb-a4da-1f39b1816eb3",
        "parentId" : "f21b5385-8f2c-4edd-be9c-4fa610c3aa79",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Yeah, in general I think initialize should return immediately and run the rest of the work asynchronously. We can even dynamically register for capabilities when the single services finish initializing.",
        "createdAt" : "2017-11-14T21:00:10Z",
        "updatedAt" : "2017-11-14T21:00:10Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5e9272f240feb4f00bdea5ee50e2808699cd0d0e",
    "line" : 116,
    "diffHunk" : "@@ -123,14 +129,12 @@ class ScalametaLanguageServer(\n   private def onChangedFile(\n       path: AbsolutePath\n   )(fallback: AbsolutePath => Unit): Unit = {\n-    logger.info(s\"File $path changed.\")\n-    val name = path.toNIO.getFileName.toString\n-    if (name.endsWith(\".semanticdb\")) {\n-      semanticdbSubscriber.onNext(path)\n-    } else if (name.endsWith(\".compilerconfig\")) {\n-      compilerConfigSubscriber.onNext(path)\n-    } else {\n-      fallback(path)\n+    val name = PathIO.extension(path.toNIO)\n+    logger.info(s\"File $path changed, extension=$name\")\n+    name match {\n+      case \"semanticdb\" => semanticdbSubscriber.onNext(path)\n+      case \"compilerconfig\" => compilerConfigSubscriber.onNext(path)"
  },
  {
    "id" : "4d497631-ab88-4c1b-86d7-5631c3fd367f",
    "prId" : 23,
    "comments" : [
      {
        "id" : "6fbdfd88-a049-4c36-9706-95aa88560c29",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "why is the overflow strategy gone?",
        "createdAt" : "2017-11-14T09:48:02Z",
        "updatedAt" : "2017-11-14T20:08:40Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d241d13d-baf6-49f8-a3b5-e8cff222f996",
        "parentId" : "6fbdfd88-a049-4c36-9706-95aa88560c29",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I added it without knowing what it does. I think we should use the default unless we know what we're doing.",
        "createdAt" : "2017-11-14T19:34:18Z",
        "updatedAt" : "2017-11-14T20:08:40Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5e9272f240feb4f00bdea5ee50e2808699cd0d0e",
    "line" : 37,
    "diffHunk" : "@@ -47,24 +47,30 @@ class ScalametaLanguageServer(\n   val (semanticdbSubscriber, semanticdbPublisher) =\n     ScalametaLanguageServer.semanticdbStream\n   val (compilerConfigSubscriber, compilerConfigPublisher) =\n-    Observable.multicast[AbsolutePath](\n-      MulticastStrategy.Publish,\n-      OverflowStrategy.ClearBuffer(2)\n-    )\n+    Observable.multicast[AbsolutePath](MulticastStrategy.Publish)"
  },
  {
    "id" : "29d98562-4b9e-4079-b388-46f26fbc47d4",
    "prId" : 31,
    "comments" : [
      {
        "id" : "42f91fa1-17ac-49b3-b02b-b86ead576788",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Nice to get these listed out 👍 ",
        "createdAt" : "2017-11-11T16:55:24Z",
        "updatedAt" : "2017-11-12T22:22:41Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "107a984d4b9d927220b914774dfd9eb859b399c2",
    "line" : null,
    "diffHunk" : "@@ -134,133 +110,169 @@ class ScalametaLanguageServer(\n     }\n   }\n \n-  override def onChangeWatchedFiles(changes: Seq[FileEvent]): Unit =\n-    changes.foreach {\n-      case FileEvent(\n-          Uri(path),\n-          FileChangeType.Created | FileChangeType.Changed\n-          ) =>\n-        onChangedFile(path) { _ =>\n-          logger.warn(s\"Unknown file extension for path $path\")\n+  override def connect(client: LanguageClient): Unit = {\n+    this.client = client\n+  }\n+\n+  override def initialize(params: InitializeParams): CompletableFuture[InitializeResult] = CompletableFuture.completedFuture {\n+    logger.info(s\"Initialized with $cwd, ${params.getProcessId}, ${params.getRootUri}, ${params.getCapabilities}\")\n+    toCancel += scalafix.linter.subscribe()\n+    toCancel += symbol.indexer.subscribe()\n+    toCancel += compiler.onNewCompilerConfig.subscribe()\n+    loadAllSemanticdbsInWorkspace()\n+\n+    val capabilities = new ServerCapabilities\n+    capabilities.setTextDocumentSync(TextDocumentSyncKind.Full)\n+    capabilities.setDocumentFormattingProvider(true)\n+    capabilities.setDocumentSymbolProvider(true)\n+    capabilities.setHoverProvider(true)\n+    capabilities.setDefinitionProvider(true)\n+    capabilities.setCompletionProvider(new CompletionOptions(true, List(\".\").asJava))\n+\n+    new InitializeResult(capabilities)\n+  }\n+\n+  override def exit(): Unit = {}\n+\n+  override def shutdown(): CompletableFuture[Object] = CompletableFuture.completedFuture {\n+    toCancel.foreach(_.cancel())\n+    new Object\n+  }\n+\n+  override def didChangeWatchedFiles(params: DidChangeWatchedFilesParams): Unit =\n+    params.getChanges.asScala.foreach {\n+      case change: FileEvent if change.getType == FileChangeType.Created || change.getType == FileChangeType.Changed =>\n+        Uri.toPath(change.getUri).foreach { path =>\n+          onChangedFile(path) { _ =>\n+            logger.warn(s\"Unknown file extension for path $path\")\n+          }\n         }\n \n       case event =>\n         logger.info(s\"Unhandled file event: $event\")\n         ()\n     }\n \n-  override def documentFormattingRequest(\n-      td: TextDocumentIdentifier,\n-      options: FormattingOptions\n-  ): List[TextEdit] = {\n+  override def didOpen(params: DidOpenTextDocumentParams): Unit = {\n+    val document = params.getTextDocument\n+    Uri.toPath(document.getUri).foreach(p => buffers.changed(p, document.getText))\n+  }\n+\n+  override def didChange(params: DidChangeTextDocumentParams): Unit = {\n+    val document = params.getTextDocument\n+    params.getContentChanges.asScala.foreach { c =>\n+      Uri.toPath(document.getUri).foreach(p => buffers.changed(p, c.getText))\n+    }\n+  }\n+\n+  override def getTextDocumentService(): TextDocumentService = this\n+  override def getWorkspaceService(): WorkspaceService = this\n+\n+  override def formatting(params: DocumentFormattingParams) = CompletableFuture.completedFuture {\n+    val document = params.getTextDocument\n     try {\n-      val path = Uri.toPath(td.uri).get\n+      val path = Uri.toPath(document.getUri).get\n       val contents = buffers.read(path)\n-      val fullDocumentRange = Range(\n-        start = Position(0, 0),\n-        end = Position(Int.MaxValue, Int.MaxValue)\n+      val fullDocumentRange = new Range(\n+        new Position(0, 0),\n+        new Position(Int.MaxValue, Int.MaxValue)\n       )\n       val config = cwd.resolve(\".scalafmt.conf\")\n       if (Files.isRegularFile(config.toNIO)) {\n         val formattedContent =\n           scalafmt.format(contents, config.toString(), path.toString())\n-        List(TextEdit(fullDocumentRange, formattedContent))\n+        List(new TextEdit(fullDocumentRange, formattedContent)).asJava\n       } else {\n-        connection.showMessage(MessageType.Info, s\"Missing $config\")\n-        Nil\n+        client.showMessage(new MessageParams(MessageType.Info, s\"Missing $config\"))\n+        Nil.asJava\n       }\n     } catch {\n       case NonFatal(e) =>\n-        connection.showMessage(MessageType.Error, e.getMessage)\n+        client.showMessage(new MessageParams(MessageType.Error, e.getMessage))\n         logger.error(e.getMessage, e)\n-        Nil\n+        Nil.asJava\n     }\n   }\n \n-  override def onOpenTextDocument(td: TextDocumentItem): Unit =\n-    Uri.toPath(td.uri).foreach(p => buffers.changed(p, td.text))\n-\n-  override def onChangeTextDocument(\n-      td: VersionedTextDocumentIdentifier,\n-      changes: Seq[TextDocumentContentChangeEvent]\n-  ): Unit = {\n-    changes.foreach { c =>\n-      Uri.toPath(td.uri).foreach(p => buffers.changed(p, c.text))\n-    }\n-  }\n-\n-  override def documentSymbols(\n-      td: TextDocumentIdentifier\n-  ): Seq[SymbolInformation] = {\n-    val path = Uri.toPath(td.uri).get\n+  override def documentSymbol(params: DocumentSymbolParams) = CompletableFuture.completedFuture {\n+    val document = params.getTextDocument\n+    val path = Uri.toPath(document.getUri).get\n     symbol.documentSymbols(path.toRelative(cwd)).map {\n       case (position, denotation @ Denotation(_, name, signature, _)) =>\n         val location = path.toLocation(position)\n         val kind = denotation.symbolKind\n-        SymbolInformation(name, kind, location, Some(signature))\n-    }\n+        new SymbolInformation(name, kind, location, signature)\n+    }.asJava\n   }\n \n-  override def gotoDefinitionRequest(\n-      td: TextDocumentIdentifier,\n-      position: Position\n-  ): DefinitionResult = {\n-    val path = Uri.toPath(td.uri).get.toRelative(cwd)\n+  override def definition(params: TextDocumentPositionParams) = CompletableFuture.completedFuture {\n+    val document = params.getTextDocument\n+    val position = params.getPosition\n+    val path = Uri.toPath(document.getUri).get.toRelative(cwd)\n     symbol\n-      .goToDefinition(path, position.line, position.character)\n-      .fold(DefinitionResult(Nil)) { position =>\n-        DefinitionResult(\n-          cwd.resolve(position.input.syntax).toLocation(position) :: Nil\n-        )\n-      }\n+      .goToDefinition(path, position.getLine, position.getCharacter)\n+      .fold(List.empty[Location]) { position =>\n+        cwd.resolve(position.input.syntax).toLocation(position) :: Nil\n+      }.asJava\n   }\n \n-  override def onSaveTextDocument(td: TextDocumentIdentifier): Unit = {}\n+  override def completion(params: TextDocumentPositionParams) = CompletableFuture.completedFuture {\n+    val document = params.getTextDocument\n+    val position = params.getPosition\n \n-  override def completionRequest(\n-      td: TextDocumentIdentifier,\n-      position: Position\n-  ): ResultResponse = {\n     try {\n       val completions = compiler.autocomplete(\n-        Uri.toPath(td.uri).get,\n-        position.line,\n-        position.character\n+        Uri.toPath(document.getUri).get,\n+        position.getLine,\n+        position.getCharacter\n       )\n-      CompletionList(\n-        isIncomplete = false,\n-        items = completions.map {\n+      JEither.forRight(new CompletionList(\n+        false,\n+        completions.map {\n           case (signature, name) =>\n-            CompletionItem(\n-              label = name,\n-              detail = Some(signature)\n-            )\n-        }\n-      )\n+            val completionItem = new CompletionItem(name)\n+            completionItem.setDetail(signature)\n+            completionItem\n+        }.asJava\n+      ))\n     } catch {\n       case NonFatal(e) =>\n         onError(e)\n-        ShutdownResult(-1)\n+        JEither.forRight(new CompletionList(Nil.asJava))\n     }\n   }\n \n-  override def hoverRequest(\n-      td: TextDocumentIdentifier,\n-      position: Position\n-  ): Hover = {\n-    val path = Uri.toPath(td.uri).get\n-    compiler.typeAt(path, position.line, position.character) match {\n-      case None => Hover(Nil, None)\n+  override def hover(params: TextDocumentPositionParams) = CompletableFuture.completedFuture {\n+    val document = params.getTextDocument\n+    val position = params.getPosition\n+    val path = Uri.toPath(document.getUri).get\n+    compiler.typeAt(path, position.getLine, position.getCharacter) match {\n+      case None => new Hover(Nil.asJava)\n       case Some(tpeName) =>\n-        Hover(\n-          contents = List(\n-            RawMarkedString(language = \"scala\", value = tpeName)\n-          ),\n-          range = None\n+        new Hover(\n+          List(\n+            JEither.forRight[String, MarkedString](new MarkedString(\"scala\", tpeName))\n+          ).asJava\n         )\n     }\n   }\n \n+  // Unimplemented features\n+  override def codeAction(params: CodeActionParams) = ???"
  },
  {
    "id" : "d6321052-95ad-48c9-8c5f-a25a9bcede5b",
    "prId" : 34,
    "comments" : [
      {
        "id" : "ae2d2e01-143c-4b12-9f77-fe245f491651",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "What about `package a`?",
        "createdAt" : "2017-11-15T10:45:34Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c6211fe3-d684-47bf-b155-6f27adb9c75e",
        "parentId" : "ae2d2e01-143c-4b12-9f77-fe245f491651",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "It falls into the `Member` case, so it will be just its `name` `a`. \r\nThis whole `qualifiedName` method is here **only** for the packages with `Select`, because their default `name` is just the last part and I think it's useful to see the full name in the outline.",
        "createdAt" : "2017-11-15T12:42:54Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e0d8989a-c2f3-48f9-9fcf-d9447f294737",
        "parentId" : "ae2d2e01-143c-4b12-9f77-fe245f491651",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I see, nice!",
        "createdAt" : "2017-11-15T21:04:34Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f22b970a071cd204e5269d09dea51d6223971e22",
    "line" : 34,
    "diffHunk" : "@@ -200,13 +200,50 @@ class ScalametaLanguageServer(\n   override def documentSymbols(\n       td: TextDocumentIdentifier\n   ): Seq[SymbolInformation] = {\n-    val path = Uri.toPath(td.uri).get\n-    symbol.documentSymbols(path.toRelative(cwd)).map {\n-      case (position, denotation @ Denotation(_, name, signature, _)) =>\n-        val location = path.toLocation(position)\n-        val kind = denotation.symbolKind\n-        SymbolInformation(name, kind, location, Some(signature))\n+    import scala.meta._\n+\n+    // For a given node returns its closest ancestor which is a definition, declaration or a package object\n+    // NOTE: package is not considered a wrapping definition, but it could be (a subject to discuss)\n+    def wrappingDefinition(t: Tree): Option[Tree] = {\n+      if (\n+        t.is[Defn] ||\n+        t.is[Decl] ||\n+        t.is[Pkg.Object]\n+      ) Some(t)\n+      else t.parent.flatMap(wrappingDefinition)\n+    }\n+\n+    // This is needed only to unfold full package names\n+    def qualifiedName(t: Tree): Option[String] = t match {\n+      case Term.Name(name) =>\n+        Some(name)\n+      case Term.Select(qual, name) =>\n+        qualifiedName(qual).map { prefix => s\"${prefix}.${name}\" }\n+      case Pkg(sel: Term.Select, _) =>"
  },
  {
    "id" : "ff44bba0-e2eb-49bb-b75d-5560bdf31c1a",
    "prId" : 34,
    "comments" : [
      {
        "id" : "7923f93e-82eb-476e-add6-4bc56a2907cf",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Glad you found this! Took me a while to learn about it :)",
        "createdAt" : "2017-11-15T10:45:49Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ff3ad5a8-e12a-4187-86d0-93dc198d0490",
        "parentId" : "7923f93e-82eb-476e-add6-4bc56a2907cf",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "What do you mean? 😅 ",
        "createdAt" : "2017-11-15T12:43:54Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2b6309f2-5a3f-4706-bde1-78b6bd0df01d",
        "parentId" : "7923f93e-82eb-476e-add6-4bc56a2907cf",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I wasn't aware of `Member` until quite recently, always found it frustrating to handle all val/val/def/class/trait/object cases",
        "createdAt" : "2017-11-15T21:04:24Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "39e88c94-9e9c-4991-889a-58c6285eef0c",
        "parentId" : "7923f93e-82eb-476e-add6-4bc56a2907cf",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Ah, yes, it's very helpful. I just searched for whatever with `name`, when I wanted to match it with symbols from the indexer 😄 ",
        "createdAt" : "2017-11-15T21:31:22Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f22b970a071cd204e5269d09dea51d6223971e22",
    "line" : 36,
    "diffHunk" : "@@ -200,13 +200,50 @@ class ScalametaLanguageServer(\n   override def documentSymbols(\n       td: TextDocumentIdentifier\n   ): Seq[SymbolInformation] = {\n-    val path = Uri.toPath(td.uri).get\n-    symbol.documentSymbols(path.toRelative(cwd)).map {\n-      case (position, denotation @ Denotation(_, name, signature, _)) =>\n-        val location = path.toLocation(position)\n-        val kind = denotation.symbolKind\n-        SymbolInformation(name, kind, location, Some(signature))\n+    import scala.meta._\n+\n+    // For a given node returns its closest ancestor which is a definition, declaration or a package object\n+    // NOTE: package is not considered a wrapping definition, but it could be (a subject to discuss)\n+    def wrappingDefinition(t: Tree): Option[Tree] = {\n+      if (\n+        t.is[Defn] ||\n+        t.is[Decl] ||\n+        t.is[Pkg.Object]\n+      ) Some(t)\n+      else t.parent.flatMap(wrappingDefinition)\n+    }\n+\n+    // This is needed only to unfold full package names\n+    def qualifiedName(t: Tree): Option[String] = t match {\n+      case Term.Name(name) =>\n+        Some(name)\n+      case Term.Select(qual, name) =>\n+        qualifiedName(qual).map { prefix => s\"${prefix}.${name}\" }\n+      case Pkg(sel: Term.Select, _) =>\n+        qualifiedName(sel)\n+      case m: Member =>"
  },
  {
    "id" : "b1d64921-1700-4062-88f4-0f27e823e729",
    "prId" : 34,
    "comments" : [
      {
        "id" : "5b8f4b76-3779-4fef-8ead-340961ab4ae0",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "FYI `scala.meta.contrib._` adds a `.filter` on `Tree`",
        "createdAt" : "2017-11-15T21:08:20Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "28cd8458-ed09-4425-b95c-661103eb1e99",
        "parentId" : "5b8f4b76-3779-4fef-8ead-340961ab4ae0",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Thanks, I was looking for it but found after I wrote this and then forgot to change it.",
        "createdAt" : "2017-11-15T21:38:00Z",
        "updatedAt" : "2017-11-19T16:29:37Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f22b970a071cd204e5269d09dea51d6223971e22",
    "line" : 45,
    "diffHunk" : "@@ -200,13 +200,50 @@ class ScalametaLanguageServer(\n   override def documentSymbols(\n       td: TextDocumentIdentifier\n   ): Seq[SymbolInformation] = {\n-    val path = Uri.toPath(td.uri).get\n-    symbol.documentSymbols(path.toRelative(cwd)).map {\n-      case (position, denotation @ Denotation(_, name, signature, _)) =>\n-        val location = path.toLocation(position)\n-        val kind = denotation.symbolKind\n-        SymbolInformation(name, kind, location, Some(signature))\n+    import scala.meta._\n+\n+    // For a given node returns its closest ancestor which is a definition, declaration or a package object\n+    // NOTE: package is not considered a wrapping definition, but it could be (a subject to discuss)\n+    def wrappingDefinition(t: Tree): Option[Tree] = {\n+      if (\n+        t.is[Defn] ||\n+        t.is[Decl] ||\n+        t.is[Pkg.Object]\n+      ) Some(t)\n+      else t.parent.flatMap(wrappingDefinition)\n+    }\n+\n+    // This is needed only to unfold full package names\n+    def qualifiedName(t: Tree): Option[String] = t match {\n+      case Term.Name(name) =>\n+        Some(name)\n+      case Term.Select(qual, name) =>\n+        qualifiedName(qual).map { prefix => s\"${prefix}.${name}\" }\n+      case Pkg(sel: Term.Select, _) =>\n+        qualifiedName(sel)\n+      case m: Member =>\n+        Some(m.name.value)\n+      case _ => None\n     }\n+\n+    val path = Uri.toPath(td.uri).get\n+    val contents = buffers.read(path)\n+    for {\n+      tree <- contents.parse[Source].toOption.toList\n+      node <- tree.collect {"
  },
  {
    "id" : "94e229ed-7293-4e0a-bc70-1e7010b2cf05",
    "prId" : 53,
    "comments" : [
      {
        "id" : "de8cd31a-2fa9-4884-811f-031884eb935a",
        "parentId" : null,
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "@olafurpg I think something wrong is happening here. Server shouldn't send a shutdown response on completion request failure.",
        "createdAt" : "2017-11-23T21:34:14Z",
        "updatedAt" : "2017-11-23T21:46:40Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0daadf2f-c8d1-44e0-bdd5-5d5a498bc8ab",
        "parentId" : "de8cd31a-2fa9-4884-811f-031884eb935a",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "lol, no idea how that got there. feel free to remove the whole try/catch, errors get caught and logged on request now.",
        "createdAt" : "2017-11-23T21:41:18Z",
        "updatedAt" : "2017-11-23T21:46:40Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "363808f7-6b5c-4760-af02-5bfa19e6a23b",
        "parentId" : "de8cd31a-2fa9-4884-811f-031884eb935a",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Done in f3d9342 (+ same in `documentFormattingRequest`)",
        "createdAt" : "2017-11-23T21:47:39Z",
        "updatedAt" : "2017-11-23T21:47:39Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f3d9342b4a408f9fd03ae85e14c26edc0e22b773",
    "line" : null,
    "diffHunk" : "@@ -282,7 +282,8 @@ class ScalametaLanguageServer(\n     } catch {\n       case NonFatal(e) =>\n         onError(e)\n-        ShutdownResult(-1)\n+        // FIXME: server shouldn't send shutdown response if there was no shutdown request\n+        ShutdownResult()"
  },
  {
    "id" : "8f76430a-528c-49c3-afcf-37b49af199c1",
    "prId" : 71,
    "comments" : [
      {
        "id" : "fe5efe75-6f4d-4b13-aef6-329e229f9ab3",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "_.toDb(sourcePath = None) or just add a default of None and call _.toDb?\r\n_.toDb(None) has that same confusing quality as boolean parameters do.",
        "createdAt" : "2017-11-28T21:52:42Z",
        "updatedAt" : "2017-11-29T07:02:11Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "365c6e95ebfe230b3ab154f12e2d85bab13e5136",
    "line" : null,
    "diffHunk" : "@@ -51,39 +54,38 @@ class ScalametaLanguageServer(\n )(implicit s: Scheduler)\n     extends LanguageServer(lspIn, lspOut) {\n   implicit val cwd: AbsolutePath = config.cwd\n-  val (semanticdbSubscriber, semanticdbPublisher) =\n+  val (fileSystemSemanticdbSubscriber, fileSystemSemanticdbsPublisher) =\n     ScalametaLanguageServer.semanticdbStream(cwd)\n   val (compilerConfigSubscriber, compilerConfigPublisher) =\n-    Observable.multicast[AbsolutePath](MulticastStrategy.Publish)\n-  def onError(e: Throwable): Unit = {\n-    logger.error(e.getMessage, e)\n-  }\n+    ScalametaLanguageServer.compilerConfigStream(cwd)\n   val buffers: Buffers = Buffers()\n-  val scalac = new ScalacProvider(config, compilerConfigPublisher)\n-  val databasePublisher: Observable[Database] = Observable.merge(\n-    semanticdbPublisher.doOnError(onError),\n-    scalac.documentPublisher.map(doc => Database(doc :: Nil))\n-  )\n-  val symbolIndexer: SymbolIndex = SymbolIndex(\n-    cwd,\n-    connection,\n-    buffers\n-  )\n-  val onIndexDatabase: Observable[Effects.IndexSemanticdb] =\n-    databasePublisher.map { db =>\n-      symbolIndexer.indexDatabase(db)\n-      Effects.IndexSemanticdb\n-    }\n-  val scalafix: Linter = new Linter(\n-    cwd,\n-    stdout,\n-    connection,\n-    semanticdbPublisher.map(_.toDb(None)).doOnError(onError)\n-  )\n+  val scalac: ScalacProvider = new ScalacProvider(config)\n+  val symbolIndexer: SymbolIndex = SymbolIndex(cwd, connection, buffers, config)\n+  val scalafix: Linter = new Linter(cwd, stdout, connection)\n+  val metaSemanticdbs: Observable[semanticdb.Database] =\n+    fileSystemSemanticdbsPublisher.map(_.toDb(None))"
  },
  {
    "id" : "97b4482e-150b-469a-9497-44c52e93858f",
    "prId" : 71,
    "comments" : [
      {
        "id" : "58265b7a-1a8f-47c9-a603-f5770cfd593b",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "Option[Cancelable] instead of null?",
        "createdAt" : "2017-11-28T21:55:22Z",
        "updatedAt" : "2017-11-29T07:02:11Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "365c6e95ebfe230b3ab154f12e2d85bab13e5136",
    "line" : null,
    "diffHunk" : "@@ -51,39 +54,38 @@ class ScalametaLanguageServer(\n )(implicit s: Scheduler)\n     extends LanguageServer(lspIn, lspOut) {\n   implicit val cwd: AbsolutePath = config.cwd\n-  val (semanticdbSubscriber, semanticdbPublisher) =\n+  val (fileSystemSemanticdbSubscriber, fileSystemSemanticdbsPublisher) =\n     ScalametaLanguageServer.semanticdbStream(cwd)\n   val (compilerConfigSubscriber, compilerConfigPublisher) =\n-    Observable.multicast[AbsolutePath](MulticastStrategy.Publish)\n-  def onError(e: Throwable): Unit = {\n-    logger.error(e.getMessage, e)\n-  }\n+    ScalametaLanguageServer.compilerConfigStream(cwd)\n   val buffers: Buffers = Buffers()\n-  val scalac = new ScalacProvider(config, compilerConfigPublisher)\n-  val databasePublisher: Observable[Database] = Observable.merge(\n-    semanticdbPublisher.doOnError(onError),\n-    scalac.documentPublisher.map(doc => Database(doc :: Nil))\n-  )\n-  val symbolIndexer: SymbolIndex = SymbolIndex(\n-    cwd,\n-    connection,\n-    buffers\n-  )\n-  val onIndexDatabase: Observable[Effects.IndexSemanticdb] =\n-    databasePublisher.map { db =>\n-      symbolIndexer.indexDatabase(db)\n-      Effects.IndexSemanticdb\n-    }\n-  val scalafix: Linter = new Linter(\n-    cwd,\n-    stdout,\n-    connection,\n-    semanticdbPublisher.map(_.toDb(None)).doOnError(onError)\n-  )\n+  val scalac: ScalacProvider = new ScalacProvider(config)\n+  val symbolIndexer: SymbolIndex = SymbolIndex(cwd, connection, buffers, config)\n+  val scalafix: Linter = new Linter(cwd, stdout, connection)\n+  val metaSemanticdbs: Observable[semanticdb.Database] =\n+    fileSystemSemanticdbsPublisher.map(_.toDb(None))\n   val scalafmt: Formatter =\n     if (config.setupScalafmt) Formatter.classloadScalafmt(\"1.3.0\")\n     else Formatter.noop\n-  private val toCancel = ListBuffer.empty[Cancelable]\n+\n+  // Effects\n+  val indexedFileSystemSemanticdbs: Observable[Effects.IndexSemanticdb] =\n+    fileSystemSemanticdbsPublisher.map(symbolIndexer.indexDatabase)\n+  val indexedDependencyClasspath: Observable[Effects.IndexSourcesClasspath] =\n+    compilerConfigPublisher.map(\n+      c => symbolIndexer.indexDependencyClasspath(c.sourceJars)\n+    )\n+  val installedCompilers: Observable[Effects.InstallPresentationCompiler] =\n+    compilerConfigPublisher.map(scalac.loadNewCompilerGlobals)\n+  val scalafixNotifications: Observable[Effects.PublishLinterDiagnostics] =\n+    metaSemanticdbs.map(scalafix.reportLinterMessages)\n+  private var cancelEffects: Cancelable = _"
  },
  {
    "id" : "642cd0db-263e-4649-9a6e-7060d59298da",
    "prId" : 71,
    "comments" : [
      {
        "id" : "7cb0934c-5d75-420d-ace4-4ace5041c112",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "cc/ @alexandru can you perhaps explain the difference between `Observable.merge[T](Observable*).subscribe()` and `List[Observable[T])].map(_.subscribe())`? Our tests passed with List but fail with merge, intuitively I would expect them to behave similarly.",
        "createdAt" : "2017-11-29T07:00:23Z",
        "updatedAt" : "2017-11-29T07:02:11Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6e28bcf9-ba07-4651-9e20-3c928b11dd76",
        "parentId" : "7cb0934c-5d75-420d-ace4-4ace5041c112",
        "author" : {
          "login" : "alexandru",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11753?u=05613413a73809db8736a252e169de025b392460&v=4"
        },
        "body" : "Don't know what your test is doing, but one thing to be aware of is that `merge` introduces a buffer between the observables pushing the events and the subscriber. And in testing this could mean extra async boundaries, because the consumer is no longer consuming from the same thread as the producers.",
        "createdAt" : "2017-11-29T07:07:30Z",
        "updatedAt" : "2017-11-29T07:09:04Z",
        "lastEditedBy" : {
          "login" : "alexandru",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11753?u=05613413a73809db8736a252e169de025b392460&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "14a77de3-4dbf-4075-a58a-949c31eaf7fb",
        "parentId" : "7cb0934c-5d75-420d-ace4-4ace5041c112",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Interesting, thanks for the explanation. In our tests we use `TestScheduler` and `tickOne` as much as possible https://github.com/scalameta/language-server/blob/617d8644922f379f0d0a874c679aaa04347c92f5/metaserver/src/test/scala/tests/search/SymbolIndexTest.scala#L47  Looking at the logs, it seems the ordering of events is slightly different with/without merge.\r\n\r\nCheers 🍻 ",
        "createdAt" : "2017-11-29T07:14:05Z",
        "updatedAt" : "2017-11-29T07:14:05Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5631b0ae-7ee3-4218-ade7-fa6a43799af8",
        "parentId" : "7cb0934c-5d75-420d-ace4-4ace5041c112",
        "author" : {
          "login" : "alexandru",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11753?u=05613413a73809db8736a252e169de025b392460&v=4"
        },
        "body" : "Ah yes, so ordering can be a problem — `merge` is non-deterministic, creating a race between the participating producers.",
        "createdAt" : "2017-11-29T07:17:04Z",
        "updatedAt" : "2017-11-29T07:17:04Z",
        "lastEditedBy" : {
          "login" : "alexandru",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11753?u=05613413a73809db8736a252e169de025b392460&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c81e02b-0894-4bbe-bfb8-fe5949424d59",
        "parentId" : "7cb0934c-5d75-420d-ace4-4ace5041c112",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Our tests don't rely on ordering as far I can tell, but I'll need closer look to verify.\r\n\r\nUnderstanding `merge` better will help me keep an eye out for this in the future. So far Observable[T] has been amazing, this PR was a decent refactoring and all tests passed on first compile 😄  `.merge` causing the tests to fail came as a surprise however, but I wouldn't be surprised if the tests need a refactoring too!",
        "createdAt" : "2017-11-29T07:31:46Z",
        "updatedAt" : "2017-11-29T07:31:46Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "365c6e95ebfe230b3ab154f12e2d85bab13e5136",
    "line" : null,
    "diffHunk" : "@@ -79,8 +79,8 @@ class ScalametaLanguageServer(\n     compilerConfigPublisher.map(scalac.loadNewCompilerGlobals)\n   val scalafixNotifications: Observable[Effects.PublishLinterDiagnostics] =\n     metaSemanticdbs.map(scalafix.reportLinterMessages)\n-  private var cancelEffects = Option.empty[Cancelable]\n-  val effects: Observable[Effects] = Observable.merge("
  },
  {
    "id" : "bf47d43c-0b3f-47c9-9152-39aebd07f58c",
    "prId" : 78,
    "comments" : [
      {
        "id" : "6f3e183a-a09a-4b5e-ae8a-f70546eb9495",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "🎉 ",
        "createdAt" : "2017-12-01T20:32:30Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : 51,
    "diffHunk" : "@@ -111,6 +112,7 @@ class ScalametaLanguageServer(\n         )\n       ),\n       definitionProvider = true,\n+      referencesProvider = true,"
  },
  {
    "id" : "0c8968c3-e1aa-480e-b188-d51c9af21a30",
    "prId" : 78,
    "comments" : [
      {
        "id" : "ae7a040c-e63a-4dcd-b364-78cb03c09660",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can we move this logic to a `search.ReferenceProvider.references` method for consistency with SignatureHelp/Completion?",
        "createdAt" : "2017-12-02T12:51:44Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be839c11-5680-4bc8-94e3-c653e6f34fff",
        "parentId" : "ae7a040c-e63a-4dcd-b364-78cb03c09660",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Let's move this to separate PR.",
        "createdAt" : "2017-12-02T22:41:52Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b0a8cdd1-903d-430f-9c51-7ac41144687c",
        "parentId" : "ae7a040c-e63a-4dcd-b364-78cb03c09660",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Done in 71da2fa975b8fb36cd888c23d0a8b0214a68e679. I'm not sure I got it right though..",
        "createdAt" : "2017-12-02T23:31:45Z",
        "updatedAt" : "2017-12-02T23:31:45Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -242,9 +244,37 @@ class ScalametaLanguageServer(\n       position: Position\n   ): DefinitionResult = {\n     val path = Uri.toPath(td.uri).get\n-    symbolIndexer\n-      .goToDefinition(path, position.line, position.character)\n-      .getOrElse(DefinitionResult(Nil))\n+    val locations = for {\n+      symbol <- symbolIndexer.findSymbol(\n+        path,\n+        position.line,\n+        position.character\n+      )\n+      data <- symbolIndexer.definitionData(symbol)\n+      location <- symbolIndexer.definitionLocation(data)\n+    } yield symbolIndexer.nonJarLocation(location)\n+    DefinitionResult(locations.toList)\n+  }\n+\n+  override def referencesRequest(\n+      td: TextDocumentIdentifier,\n+      position: Position,\n+      context: ReferenceContext\n+  ): ReferencesResult = {\n+    val path = Uri.toPath(td.uri).get\n+    val locations = for {"
  },
  {
    "id" : "4b7ca9c1-4716-4dd8-b361-0864922eb652",
    "prId" : 78,
    "comments" : [
      {
        "id" : "e578685e-e028-4175-8401-d2c0a5d5b3fd",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We should create nonjar uris for all references, otherwise those don't appear in the results. However, we currently only index definitions positions in mtags so I don't think we'll have references to jar uris besides definitions.",
        "createdAt" : "2017-12-02T12:53:13Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b6e4ed74-abb3-4851-9e3a-8f3f64c6932d",
        "parentId" : "e578685e-e028-4175-8401-d2c0a5d5b3fd",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "There's a different problem here: \r\n1. If you have `List` mentioned in your code and call find-references, you will get just references in _your code_\r\n2. Then if you call go-to-definition, it will create a file in `target/sources/`\r\n3. Now if you call find-references again, mentions of `List` in that created source will also be among the results.\r\n\r\nThis happens because LSP AFAIK doesn't have a concept of source directories, for it all files of the given language scope in the workspace are project sources. So those files we will create in `target/sources` will be added to the mix.",
        "createdAt" : "2017-12-02T17:09:24Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2135bd9b-0325-4953-abb9-081f7ad6ca73",
        "parentId" : "e578685e-e028-4175-8401-d2c0a5d5b3fd",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think we have two options here\r\n\r\n- create source files in target/source/* in references\r\n- ignore references in jar:file uris\r\n\r\nI lean towards the second option.",
        "createdAt" : "2017-12-02T17:23:17Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "afbdf68f-3020-407b-bbb2-d7d4c3e79c3a",
        "parentId" : "e578685e-e028-4175-8401-d2c0a5d5b3fd",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Me too",
        "createdAt" : "2017-12-02T17:29:07Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "76939122-b2e7-43a7-a1fd-a210c4d1624c",
        "parentId" : "e578685e-e028-4175-8401-d2c0a5d5b3fd",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can we update the comment to reflect that we intentionally skip jar:file uris?",
        "createdAt" : "2017-12-02T22:40:55Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3cd4ed78-5425-4def-a9a2-e1eae33c154a",
        "parentId" : "e578685e-e028-4175-8401-d2c0a5d5b3fd",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Done in 36123b8bd71107152b187e2f607e2006afd7a6b9",
        "createdAt" : "2017-12-02T23:31:21Z",
        "updatedAt" : "2017-12-02T23:31:21Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -242,9 +244,37 @@ class ScalametaLanguageServer(\n       position: Position\n   ): DefinitionResult = {\n     val path = Uri.toPath(td.uri).get\n-    symbolIndexer\n-      .goToDefinition(path, position.line, position.character)\n-      .getOrElse(DefinitionResult(Nil))\n+    val locations = for {\n+      symbol <- symbolIndexer.findSymbol(\n+        path,\n+        position.line,\n+        position.character\n+      )\n+      data <- symbolIndexer.definitionData(symbol)\n+      location <- symbolIndexer.definitionLocation(data)\n+    } yield symbolIndexer.nonJarLocation(location)\n+    DefinitionResult(locations.toList)\n+  }\n+\n+  override def referencesRequest(\n+      td: TextDocumentIdentifier,\n+      position: Position,\n+      context: ReferenceContext\n+  ): ReferencesResult = {\n+    val path = Uri.toPath(td.uri).get\n+    val locations = for {\n+      symbol <- symbolIndexer\n+        .findSymbol(path, position.line, position.character)\n+        .toList\n+      data <- symbolIndexer.referencesData(symbol)\n+      location <- symbolIndexer.referencesLocations(\n+        data,\n+        context.includeDeclaration\n+      )\n+    } yield location\n+    // TODO(alexey) should it return references to the jars where symbol is defined? or should such references be filtered out instead?"
  },
  {
    "id" : "d51292d3-b792-486f-b464-a0fca57ebc3d",
    "prId" : 93,
    "comments" : [
      {
        "id" : "1d7afbc7-7a91-4660-88c7-00221baceec5",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Thanks for moving this to the new *Provider structure, I was gonna nag you about that but you beat me to it and fixed it already 😄 ",
        "createdAt" : "2017-12-04T07:02:58Z",
        "updatedAt" : "2017-12-04T23:49:22Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7b17cbf33208eb27890af0e9b1a6a7b9016afbcb",
    "line" : null,
    "diffHunk" : "@@ -189,58 +189,12 @@ class ScalametaLanguageServer(\n \n   override def documentSymbols(\n       td: TextDocumentIdentifier\n-  ): Seq[SymbolInformation] = {\n-    import scala.meta._\n-\n-    // For a given node returns its closest ancestor which is a definition, declaration or a package object\n-    // NOTE: package is not considered a wrapping definition, but it could be (a subject to discuss)\n-    def wrappingDefinition(t: Tree): Option[Tree] = {\n-      if (t.is[Defn] ||\n-        t.is[Decl] ||\n-        t.is[Pkg.Object]) Some(t)\n-      else t.parent.flatMap(wrappingDefinition)\n-    }\n-\n-    def parentMember(t: Tree): Option[Tree] = {\n-      if (t.is[Member.Term] || t.is[Member.Type]) Some(t)\n-      else t.parent.flatMap(parentMember)\n-    }\n-\n-    // This is needed only to unfold full package names\n-    def qualifiedName(t: Tree): Option[String] = t match {\n-      case Term.Name(name) =>\n-        Some(name)\n-      case Term.Select(qual, name) =>\n-        qualifiedName(qual).map { prefix =>\n-          s\"${prefix}.${name}\"\n-        }\n-      case Pkg(sel: Term.Select, _) =>\n-        qualifiedName(sel)\n-      case m: Member =>\n-        Some(m.name.value)\n-      case _ => None\n-    }\n-\n+  ): List[SymbolInformation] = {\n     val path = Uri.toPath(td.uri).get\n-    val contents = buffers.read(path)\n-    for {\n-      tree <- contents.parse[Source].toOption.toList\n-      node <- tree.collect {\n-        case n if n.is[Member.Type] || n.is[Member.Term] => n\n-      }\n-      name <- qualifiedName(node)\n-      // Package as a wrapping definition for itself:\n-      defn <- if (node.is[Pkg]) Some(node) else wrappingDefinition(node)\n-    } yield\n-      SymbolInformation(\n-        name,\n-        defn.symbolKind,\n-        path.toLocation(defn.pos),\n-        defn.parent\n-          .flatMap(parentMember)\n-          .flatMap(wrappingDefinition)\n-          .flatMap(qualifiedName)\n-      )\n+    buffers.source(path) match {\n+      case Some(source) => OutlineProvider.documentSymbols(path, source)"
  },
  {
    "id" : "f15002e4-16bc-4e86-9949-d13f83ef40ca",
    "prId" : 100,
    "comments" : [
      {
        "id" : "ee839e96-c5da-42b5-8453-5141d349e432",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think we should model didChange/onOpen as streams of some `Document[BufferChanged(uri: URI, contents: String)]`. Tuples are quite annoying to work with, it's not clear for example what the third String field is.",
        "createdAt" : "2017-12-08T22:17:29Z",
        "updatedAt" : "2017-12-09T10:50:59Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b363deef-5313-49cc-835a-67302b3f3a38",
        "parentId" : "ee839e96-c5da-42b5-8453-5141d349e432",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I did it this way just because it was easier to retrieve the compiler in `didChange` (and consistent to the rest). We can surely introduce an intermediate data structure that is not a tuple.",
        "createdAt" : "2017-12-09T10:53:34Z",
        "updatedAt" : "2017-12-09T10:53:35Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c31555716bcfd52dabfb0b643423e255d5a5badd",
    "line" : null,
    "diffHunk" : "@@ -304,6 +318,16 @@ object ScalametaLanguageServer extends LazyLogging {\n     subscriber -> semanticdbPublisher\n   }\n \n+  def interactiveSemanticdbStream(\n+      implicit scheduler: Scheduler\n+  ): (Observer.Sync[(Global, VersionedTextDocumentIdentifier, String)], Observable[semanticdb.Database]) = {"
  },
  {
    "id" : "8de27c71-16e3-45ff-aab2-f508397751e6",
    "prId" : 107,
    "comments" : [
      {
        "id" : "aab0d5cf-e81a-462f-b507-9a3afa9f65fc",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Did you remove this entirely because you think there's a better approach? Otherwise just commenting/removing the code that invokes this should be enough.",
        "createdAt" : "2017-12-10T09:28:32Z",
        "updatedAt" : "2017-12-10T09:30:13Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "83a1ce86-e841-437d-834c-63a6c54ef45c",
        "parentId" : "aab0d5cf-e81a-462f-b507-9a3afa9f65fc",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think There may be a better way to model this as a stream from the notifications, want to experiment with it today ",
        "createdAt" : "2017-12-10T10:23:24Z",
        "updatedAt" : "2017-12-10T10:23:24Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8686acbbbf95638d9c9514595fa166feb3b5e3ba",
    "line" : 133,
    "diffHunk" : "@@ -325,21 +318,6 @@ object ScalametaLanguageServer extends LazyLogging {\n     subscriber -> semanticdbPublisher\n   }\n \n-  def interactiveSemanticdbStream(cwd: AbsolutePath)("
  },
  {
    "id" : "58b24f83-883e-47f4-8de7-69d10469042c",
    "prId" : 131,
    "comments" : [
      {
        "id" : "2177b132-6bb9-4fe5-9b10-b6f0ca217d26",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "if somebody knows a better way of recursively deleting a directory with Java NIO, please let me know!",
        "createdAt" : "2017-12-15T11:14:50Z",
        "updatedAt" : "2017-12-15T11:25:20Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "81a46a6b-2d49-4a40-9223-53bf5bdcc12c",
        "parentId" : "2177b132-6bb9-4fe5-9b10-b6f0ca217d26",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "This is the best way to do it IMO :) It should be verbose!",
        "createdAt" : "2017-12-15T11:41:03Z",
        "updatedAt" : "2017-12-15T11:43:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c9893b41-a735-419d-b34d-927c18bf0794",
        "parentId" : "2177b132-6bb9-4fe5-9b10-b6f0ca217d26",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "On a more serious note, this might merit inclusion in `org.langmeta.io.FileIO` where we have similar utils ",
        "createdAt" : "2017-12-15T11:41:41Z",
        "updatedAt" : "2017-12-15T11:43:33Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "867e5b2b0a081dfb481be2a14c9b7bffa47a2d98",
    "line" : 66,
    "diffHunk" : "@@ -323,6 +343,18 @@ object ScalametaLanguageServer extends LazyLogging {\n     path\n   }\n \n+  def clearCacheDirectory(): Unit ="
  },
  {
    "id" : "16582460-77fd-4d05-ac8b-b7a472526c9e",
    "prId" : 131,
    "comments" : [
      {
        "id" : "e7bf0c42-c445-44d8-9fc2-835c3689ecd7",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "we currently clear the index, but we don't trigger re-indexing. I think it's fine for debugging to have this level of granularity, but we may want to add a separate command for triggering re-indexing.",
        "createdAt" : "2017-12-15T11:15:52Z",
        "updatedAt" : "2017-12-15T11:25:20Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "867e5b2b0a081dfb481be2a14c9b7bffa47a2d98",
    "line" : null,
    "diffHunk" : "@@ -289,6 +300,15 @@ class ScalametaLanguageServer(\n     sourceChangeSubscriber.onNext(input)\n   }\n \n+  override def executeCommand(request: WorkspaceExecuteCommandRequest) = Task {\n+    import WorkspaceCommand._\n+    WorkspaceCommand.withNameOption(request.params.command).map {\n+      case ClearIndexCache =>\n+        logger.info(\"Clearing the index cache\")\n+        ScalametaLanguageServer.clearCacheDirectory()"
  },
  {
    "id" : "2a2f1700-92f1-4265-96a6-79d8df9a08f0",
    "prId" : 131,
    "comments" : [
      {
        "id" : "318498fe-5775-45e1-8337-16e33bf2c485",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "the server declares which messages it responds to, but that doesn't prevent the VSCode client to send arbitrary messages, so we log an error to help debugging typos and other mistakes.",
        "createdAt" : "2017-12-15T11:18:57Z",
        "updatedAt" : "2017-12-15T11:25:20Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "867e5b2b0a081dfb481be2a14c9b7bffa47a2d98",
    "line" : null,
    "diffHunk" : "@@ -289,6 +300,15 @@ class ScalametaLanguageServer(\n     sourceChangeSubscriber.onNext(input)\n   }\n \n+  override def executeCommand(request: WorkspaceExecuteCommandRequest) = Task {\n+    import WorkspaceCommand._\n+    WorkspaceCommand.withNameOption(request.params.command).map {\n+      case ClearIndexCache =>\n+        logger.info(\"Clearing the index cache\")\n+        ScalametaLanguageServer.clearCacheDirectory()\n+    }.getOrElse(logger.error(s\"Unknown command ${request.params.command}\"))"
  },
  {
    "id" : "7c59c828-38e3-43af-89be-9f37f14e0d7e",
    "prId" : 157,
    "comments" : [
      {
        "id" : "f7f47c0a-2601-4a20-a801-9286ac064ca6",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "\\o/",
        "createdAt" : "2017-12-23T15:36:40Z",
        "updatedAt" : "2017-12-23T20:00:10Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02644898b8f2599b71ec40803a680168214c8fd9",
    "line" : 14,
    "diffHunk" : "@@ -291,15 +291,13 @@ class ScalametaLanguageServer(\n \n   override def hover(\n       request: TextDocumentHoverRequest\n-  ): Task[Hover] = withPC {\n-    scalac.getCompiler(request.params.textDocument) match {\n-      case Some(g) =>\n-        HoverProvider.hover(\n-          g,\n-          toPoint(request.params.textDocument, request.params.position)\n-        )\n-      case None => HoverProvider.empty\n-    }\n+  ): Task[Hover] = Task {\n+    HoverProvider.hover("
  },
  {
    "id" : "101c44e3-c8b9-4adf-b506-8a047aa2621f",
    "prId" : 158,
    "comments" : [
      {
        "id" : "22e90b4f-19cd-488c-a188-ebfa84fa1e7a",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "this is where I bootstrap the configuration, to make sure the observable is never empty. Not super elegant, but it works.",
        "createdAt" : "2017-12-23T15:58:45Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "affa2ea127de9483cd4eeda3dfcfcb3bb80a4322",
    "line" : null,
    "diffHunk" : "@@ -435,6 +414,18 @@ object ScalametaLanguageServer extends LazyLogging {\n     subscriber -> semanticdbPublisher\n   }\n \n+  def configurationStream(connection: Connection)(\n+    implicit scheduler: Scheduler\n+  ): (Observer.Sync[JsValue], Observable[Configuration]) = {\n+    val (subscriber, publisher) = multicast[JsValue]\n+    val configurationPublisher = publisher\n+      .map(json => (json \\ \"scalameta\").as[Configuration])\n+      .doOnNext(conf => logger.info(s\"Configuration updated $conf\"))\n+      .doOnError(e => connection.showMessage(MessageType.Error, e.getMessage))\n+    subscriber.onNext(Json.toJson(Configuration()))"
  },
  {
    "id" : "f7e24228-2f45-4046-95fb-4c60c7474380",
    "prId" : 158,
    "comments" : [
      {
        "id" : "208747cd-2c49-42c6-9d32-6bd3e5e619e1",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "Why do we have connection here as well as lspIn and lspOut passed in?  I thought connection was just a wrapper around lspIn and lspOut.",
        "createdAt" : "2017-12-23T16:13:46Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8fb8852d-546d-4488-9204-b4245f4715d5",
        "parentId" : "208747cd-2c49-42c6-9d32-6bd3e5e619e1",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "connection has higher level methods such as `showMessage`.\r\n\r\n`lspIn` and `lspOut` are just used to initialize it (via the `LanguageServer` constructor)",
        "createdAt" : "2017-12-23T16:15:27Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "affa2ea127de9483cd4eeda3dfcfcb3bb80a4322",
    "line" : 56,
    "diffHunk" : "@@ -103,19 +90,19 @@ class ScalametaLanguageServer(\n       MulticastStrategy.Publish,\n       OverflowStrategy.DropOld(2)\n     )\n+  val (configurationSubscriber, configurationPublisher) =\n+    ScalametaLanguageServer.configurationStream(connection)"
  },
  {
    "id" : "a5f3aa4a-221f-4b91-817a-10c93f368221",
    "prId" : 158,
    "comments" : [
      {
        "id" : "52ee8706-42b4-45cc-b922-9a8a2188b041",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : " What does this actually do?  I poked around the code and couldn’t figure it out.",
        "createdAt" : "2017-12-23T16:33:48Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6694f859-df63-45dd-ad0b-d5ab8f959a94",
        "parentId" : "52ee8706-42b4-45cc-b922-9a8a2188b041",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "`onChangeConfiguration` is invoked whenever the client updates the settings. This line publishes the new value onto the Observable.",
        "createdAt" : "2017-12-23T16:35:23Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4853c057-90d0-44dc-bf90-9f0e5de792aa",
        "parentId" : "52ee8706-42b4-45cc-b922-9a8a2188b041",
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "Just tracked that down.  Thanks for the confirmation.",
        "createdAt" : "2017-12-23T16:40:02Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74d68058-3834-49c1-9883-9aae199941a9",
        "parentId" : "52ee8706-42b4-45cc-b922-9a8a2188b041",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "Ideally we will change the implementation to directly use Observables for notifications.\r\n\r\nI.e. instead of having callbacks, we would just subscribe to the appropriate observables.",
        "createdAt" : "2017-12-23T16:41:32Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aa340aa6-db33-49af-b60f-0850e3c6d71c",
        "parentId" : "52ee8706-42b4-45cc-b922-9a8a2188b041",
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2017-12-23T17:38:17Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "affa2ea127de9483cd4eeda3dfcfcb3bb80a4322",
    "line" : null,
    "diffHunk" : "@@ -228,20 +213,14 @@ class ScalametaLanguageServer(\n         ()\n     }\n \n-  override def onChangeConfiguration(settings: JsValue): Unit = {\n-    (settings \\ \"scalameta\").validate[Configuration] match {\n-      case JsSuccess(value, _) =>\n-        logger.info(s\"Configuration changed $value\")\n-      case JsError(error) =>\n-        logger.error(s\"Can't decode configuration: $error\")\n-    }\n-  }\n+  override def onChangeConfiguration(settings: JsValue): Unit =\n+    configurationSubscriber.onNext(settings)"
  },
  {
    "id" : "fbf9a8b3-4c39-48c8-b84c-62ffe9abf8ec",
    "prId" : 158,
    "comments" : [
      {
        "id" : "0f7bcf17-72dc-4d71-b87d-3f9761cd96bc",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Resolve",
        "createdAt" : "2017-12-29T15:39:53Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ac288f9b-345e-46ef-8883-f91e89494696",
        "parentId" : "0f7bcf17-72dc-4d71-b87d-3f9761cd96bc",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "wooops, that's what happens when I work in a rush...",
        "createdAt" : "2017-12-30T11:54:55Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "affa2ea127de9483cd4eeda3dfcfcb3bb80a4322",
    "line" : null,
    "diffHunk" : "@@ -293,20 +274,32 @@ class ScalametaLanguageServer(\n \n   override def formatting(\n       request: TextDocumentFormattingRequest\n-  ): Task[DocumentFormattingResult] = Task {\n+  ): Task[DocumentFormattingResult] = {\n     val uri = Uri(request.params.textDocument)\n-    DocumentFormattingProvider.format(uri.toInput(buffers), scalafmt, cwd)\n+    documentFormattingProvider.format(uri.toInput(buffers))\n   }\n \n   override def hover(\n       request: TextDocumentHoverRequest\n+<<<<<<< HEAD"
  },
  {
    "id" : "645220d0-0f4d-4303-85b4-f943e8334a78",
    "prId" : 158,
    "comments" : [
      {
        "id" : "3752e6b7-cb2e-441a-9e84-55865bae41ea",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think Observable stops on the first error so this is not enough to continue streaming configuration. I tried\r\n```scala\r\n    import monix.execution.Scheduler.Implicits.global\r\n    val o = Observable\r\n      .fromIterable(1.to(10))\r\n      .map {\r\n        case 5 => sys.error(\"5\")\r\n        case n => n + 1\r\n      }\r\n      .doOnError(e => println(s\"EREEEEEEEEEE $e\"))\r\n    o.foreach(println)\r\n```\r\nand it prints out\r\n\r\n```\r\n2\r\n3\r\n4\r\n5\r\nEREEEEEEEEEE java.lang.RuntimeException: 5\r\n```\r\n\r\nI think it's best to avoid exceptions and do something like this instead\r\n```scala\r\n    import monix.execution.Scheduler.Implicits.global\r\n    val o = Observable\r\n      .fromIterable(1.to(10))\r\n      .map {\r\n        case 5 => Left(5)\r\n        case n => Right(n)\r\n      }\r\n      .doOnNext {\r\n        case Left(err) => println(s\"FAIL $err\")\r\n        case _ => ()\r\n      }\r\n      .collect {\r\n        case Right(x) => x\r\n      }\r\n    o.foreach(println)\r\n```\r\n\r\nwhich prints\r\n```\r\n1\r\n2\r\n3\r\n4\r\nFAIL 5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n```\r\n\r\nAlternatively, \r\n\r\n```scala\r\n    val o = Observable\r\n      .fromIterable(1.to(10))\r\n      .liftByOperator[Int] { out =>\r\n        new Subscriber[Int] {\r\n          override implicit def scheduler: Scheduler = out.scheduler\r\n          override def onError(ex: Throwable): Unit = out.onError(ex)\r\n          override def onComplete(): Unit = out.onComplete()\r\n          override def onNext(elem: Int): Future[Ack] = elem match {\r\n            case 5 =>\r\n              println(\"FAIL 5\")\r\n              Ack.Continue\r\n            case n =>\r\n              out.onNext(n)\r\n          }\r\n        }\r\n      }\r\n    o.foreach(println)\r\n```\r\nwhich prints the same.",
        "createdAt" : "2017-12-29T16:11:31Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "31b20975-ad97-4d04-aba1-d42b87d597f3",
        "parentId" : "3752e6b7-cb2e-441a-9e84-55865bae41ea",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "very nice catch, thank you!",
        "createdAt" : "2017-12-30T11:55:34Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "affa2ea127de9483cd4eeda3dfcfcb3bb80a4322",
    "line" : null,
    "diffHunk" : "@@ -449,6 +442,18 @@ object ScalametaLanguageServer extends LazyLogging {\n     subscriber -> semanticdbPublisher\n   }\n \n+  def configurationStream(connection: Connection)(\n+    implicit scheduler: Scheduler\n+  ): (Observer.Sync[JsValue], Observable[Configuration]) = {\n+    val (subscriber, publisher) = multicast[JsValue]\n+    val configurationPublisher = publisher\n+      .map(json => (json \\ \"scalameta\").as[Configuration])\n+      .doOnNext(conf => logger.info(s\"Configuration updated $conf\"))\n+      .doOnError(e => connection.showMessage(MessageType.Error, e.getMessage))"
  },
  {
    "id" : "57fc3097-421a-45be-a544-e53142a42749",
    "prId" : 158,
    "comments" : [
      {
        "id" : "2a0e8272-55e4-4ab4-b681-5f0ec1419637",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I feel like this pattern might be missing a combinator in Monix, something like `onNext`\r\n\r\n```scala\r\n  implicit class XtensionObservable[A](val o: Observable[A]) extends AnyVal {\r\n    def onNext[B](f: (Subscriber[B], A) => Future[Ack]): Observable[B] = {\r\n      o.liftByOperator[B] { out =>\r\n        new Subscriber[A] {\r\n          override implicit def scheduler: Scheduler = out.scheduler\r\n          override def onError(ex: Throwable): Unit = out.onError(ex)\r\n          override def onComplete(): Unit = out.onComplete()\r\n          override def onNext(elem: A): Future[Ack] = f(out, elem)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  test(\"onNext\") {\r\n    import monix.execution.Scheduler.Implicits.global\r\n    val o = Observable\r\n      .fromIterable(1.to(10))\r\n      .onNext[Int] { (out, elem) =>\r\n        elem match {\r\n          case 5 =>\r\n            println(\"FAIL 5\")\r\n            Ack.Continue\r\n          case n =>\r\n            out.onNext(n)\r\n        }\r\n      }\r\n    o.foreach(println)\r\n  }\r\n```",
        "createdAt" : "2017-12-30T13:03:17Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6a0ca0a6-cd86-4914-9f3a-6521861d329b",
        "parentId" : "2a0e8272-55e4-4ab4-b681-5f0ec1419637",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "yeah, I felt the same. I've tried playing around with `onErrorHandle` and similar, but I couldn't find a combinator that suits it.",
        "createdAt" : "2017-12-30T22:01:28Z",
        "updatedAt" : "2018-01-02T19:54:18Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "affa2ea127de9483cd4eeda3dfcfcb3bb80a4322",
    "line" : null,
    "diffHunk" : "@@ -434,9 +436,17 @@ object ScalametaLanguageServer extends LazyLogging {\n   ): (Observer.Sync[JsValue], Observable[Configuration]) = {\n     val (subscriber, publisher) = multicast[JsValue]\n     val configurationPublisher = publisher\n-      .map(json => (json \\ \"scalameta\").as[Configuration])\n-      .doOnNext(conf => logger.info(s\"Configuration updated $conf\"))\n-      .doOnError(e => connection.showMessage(MessageType.Error, e.getMessage))\n+      .map(json => (json \\ \"scalameta\").validate[Configuration])\n+      .doOnNext {"
  },
  {
    "id" : "4a889b2b-cfc3-433b-b2dd-b552f1723907",
    "prId" : 164,
    "comments" : [
      {
        "id" : "023424f2-8408-4b5c-bfc3-4f30b24efa4b",
        "parentId" : null,
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "`ScalametaLanguageServices`?",
        "createdAt" : "2018-01-04T04:36:17Z",
        "updatedAt" : "2018-01-04T21:40:31Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "79b77d7a-d1c9-4fa2-a99e-84d845a23f43",
        "parentId" : "023424f2-8408-4b5c-bfc3-4f30b24efa4b",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2018-01-04T20:34:45Z",
        "updatedAt" : "2018-01-04T21:41:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91848703d00af951b1f55d62236ec4f5ae50851b",
    "line" : null,
    "diffHunk" : "@@ -69,23 +38,22 @@ import org.langmeta.io.AbsolutePath\n import org.langmeta.languageserver.InputEnrichments._\n import org.langmeta.semanticdb\n import play.api.libs.json.JsError\n+import play.api.libs.json.JsNull\n import play.api.libs.json.JsSuccess\n import play.api.libs.json.JsValue\n \n class ScalametaLanguageServer("
  },
  {
    "id" : "a01313d7-e812-4bfd-ba4f-a753b06850be",
    "prId" : 164,
    "comments" : [
      {
        "id" : "a9b9dbec-131e-417d-ab52-6d0223df2955",
        "parentId" : null,
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "👍 for explicit error propagation!",
        "createdAt" : "2018-01-04T04:37:11Z",
        "updatedAt" : "2018-01-04T21:40:31Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5054f6a0-e245-47b7-a02e-ce721257802d",
        "parentId" : "a9b9dbec-131e-417d-ab52-6d0223df2955",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I feel like we're missing a non-Task utility that returns only `Either[Response.Error, A]`. I also  noticed that `invalidParams` responses don't appear in the vscode UI, so we need to adapt our error responses so they become user-facing.",
        "createdAt" : "2018-01-04T20:36:18Z",
        "updatedAt" : "2018-01-04T21:41:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91848703d00af951b1f55d62236ec4f5ae50851b",
    "line" : null,
    "diffHunk" : "@@ -153,16 +120,12 @@ class ScalametaLanguageServer(\n     publishDiagnostics,\n   )\n \n-  private def loadAllRelevantFilesInThisWorkspace(): Unit = {\n-    Workspace.initialize(cwd) { path =>\n-      onChangedFile(path)(_ => ())\n-    }\n-  }\n-\n-  override def initialize(\n-      request: InitializeParams\n-  ): Task[InitializeResult] = Task {\n-    logger.info(s\"Initialized with $cwd, $request\")\n+  // TODO(olafur): make it easier to invoke fluid services from tests\n+  def initialize(\n+      params: InitializeParams\n+  ): Task[Either[Response.Error, InitializeResult]] = {"
  },
  {
    "id" : "4d0a6a1a-ddbe-4231-9e29-301048460212",
    "prId" : 164,
    "comments" : [
      {
        "id" : "43558138-8142-4b2e-bfda-5bbd2f89f08d",
        "parentId" : null,
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "`JsValue` here and in other places means that the payload is irrelevant, right?",
        "createdAt" : "2018-01-04T04:37:57Z",
        "updatedAt" : "2018-01-04T21:40:31Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ce7b171d-cc17-4c6e-bc67-fbc1dfc5be53",
        "parentId" : "43558138-8142-4b2e-bfda-5bbd2f89f08d",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I think this is wrong, to some degree: some requests are expected to return `null` in the success case, like this one (`shutdown`), and I would use `JsNull.type` explicitly to make sure we are not returning a value. In this case `shutdown` also takes no parameters, so `JsNull.type` is probably appropriate for the request params too.\r\n\r\nIn other cases `JsValue` is appropriate because the request params is of type `any`, like the `DidChangeConfiguration` notification.",
        "createdAt" : "2018-01-04T09:42:44Z",
        "updatedAt" : "2018-01-04T21:40:31Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "81ff6c7b-6533-40ea-a961-ca23ad6ac6e2",
        "parentId" : "43558138-8142-4b2e-bfda-5bbd2f89f08d",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "In circe there is not JsNull.type. I tried JsNull.type but the implicit resolution failed (no idea why) so I used JsValue instead.\r\n\r\nNote that empty params fields are converted to a `Json.Null` so there is no way to distinguish empty params vs. `\"params\" : null`",
        "createdAt" : "2018-01-04T21:04:23Z",
        "updatedAt" : "2018-01-04T21:41:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91848703d00af951b1f55d62236ec4f5ae50851b",
    "line" : null,
    "diffHunk" : "@@ -189,202 +152,237 @@ class ScalametaLanguageServer(\n       renameProvider = true,\n       codeActionProvider = true\n     )\n-    InitializeResult(capabilities)\n+    Task(Right(InitializeResult(capabilities)))\n   }\n \n-  override def shutdown(): Task[ShutdownResult] = Task {\n+  // TODO(olafur): make it easier to invoke fluid services from tests\n+  def shutdown(): Unit = {\n     logger.info(\"Shutting down...\")\n     cancelEffects.foreach(_.cancel())\n-    connection.cancelAllActiveRequests()\n-    ShutdownResult()\n   }\n \n-  private def onChangedFile(\n-      path: AbsolutePath\n-  )(fallback: AbsolutePath => Unit): Unit = {\n-    val name = PathIO.extension(path.toNIO)\n-    logger.info(s\"File $path changed, extension=$name\")\n-    name match {\n-      case \"semanticdb\" => fileSystemSemanticdbSubscriber.onNext(path)\n-      case \"compilerconfig\" => compilerConfigSubscriber.onNext(path)\n-      case _ => fallback(path)\n+  val services: Services = Services.empty\n+    .requestAsync[InitializeParams, InitializeResult](\"initialize\") { params =>\n+      initialize(params)\n     }\n-  }\n-\n-  override def onChangeWatchedFiles(changes: Seq[FileEvent]): Unit =\n-    changes.foreach {\n-      case FileEvent(\n-          Uri(path),\n-          FileChangeType.Created | FileChangeType.Changed\n-          ) =>\n-        onChangedFile(path.toAbsolutePath) { _ =>\n-          logger.warn(s\"Unknown file extension for path $path\")\n+    .request[JsValue, JsValue](\"shutdown\") { _ =>"
  },
  {
    "id" : "d8d32bcb-f961-4a03-936d-6901d13812de",
    "prId" : 164,
    "comments" : [
      {
        "id" : "20bec9fd-f58d-408e-8847-d5ad287076c8",
        "parentId" : null,
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "How hard would it be to implement the spec that says \"The server should exit with success code 0 if the shutdown request has been received before; otherwise with error code 1\" (https://microsoft.github.io/language-server-protocol/specification#exit).",
        "createdAt" : "2018-01-04T04:40:43Z",
        "updatedAt" : "2018-01-04T21:40:31Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "16173612-83ca-4728-84b6-ceca3b3814d3",
        "parentId" : "20bec9fd-f58d-408e-8847-d5ad287076c8",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Easy, we can use an Atomic boolean to determine if shutdown has been received. Done.",
        "createdAt" : "2018-01-04T21:06:24Z",
        "updatedAt" : "2018-01-04T21:41:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91848703d00af951b1f55d62236ec4f5ae50851b",
    "line" : null,
    "diffHunk" : "@@ -189,202 +152,237 @@ class ScalametaLanguageServer(\n       renameProvider = true,\n       codeActionProvider = true\n     )\n-    InitializeResult(capabilities)\n+    Task(Right(InitializeResult(capabilities)))\n   }\n \n-  override def shutdown(): Task[ShutdownResult] = Task {\n+  // TODO(olafur): make it easier to invoke fluid services from tests\n+  def shutdown(): Unit = {\n     logger.info(\"Shutting down...\")\n     cancelEffects.foreach(_.cancel())\n-    connection.cancelAllActiveRequests()\n-    ShutdownResult()\n   }\n \n-  private def onChangedFile(\n-      path: AbsolutePath\n-  )(fallback: AbsolutePath => Unit): Unit = {\n-    val name = PathIO.extension(path.toNIO)\n-    logger.info(s\"File $path changed, extension=$name\")\n-    name match {\n-      case \"semanticdb\" => fileSystemSemanticdbSubscriber.onNext(path)\n-      case \"compilerconfig\" => compilerConfigSubscriber.onNext(path)\n-      case _ => fallback(path)\n+  val services: Services = Services.empty\n+    .requestAsync[InitializeParams, InitializeResult](\"initialize\") { params =>\n+      initialize(params)\n     }\n-  }\n-\n-  override def onChangeWatchedFiles(changes: Seq[FileEvent]): Unit =\n-    changes.foreach {\n-      case FileEvent(\n-          Uri(path),\n-          FileChangeType.Created | FileChangeType.Changed\n-          ) =>\n-        onChangedFile(path.toAbsolutePath) { _ =>\n-          logger.warn(s\"Unknown file extension for path $path\")\n+    .request[JsValue, JsValue](\"shutdown\") { _ =>\n+      shutdown()\n+      JsNull\n+    }\n+    .notification[JsValue](\"exit\") { _ =>"
  },
  {
    "id" : "7a89c047-a0b5-44c7-8017-fd833d75fe34",
    "prId" : 164,
    "comments" : [
      {
        "id" : "336ec4a6-42d8-4b83-85dd-09af56c2bd0c",
        "parentId" : null,
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "What's the difference between `request` and `requestAsync`? Looks like the former method simply delegates to the latter?",
        "createdAt" : "2018-01-04T04:42:04Z",
        "updatedAt" : "2018-01-04T21:40:31Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1e9cf8d2-a006-439f-a04b-4080e143770b",
        "parentId" : "336ec4a6-42d8-4b83-85dd-09af56c2bd0c",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Yes, the former delegates, I made the distinction to reduce ceremony in adding new handlers. All handlers are currently synchronous except the codeActions handler that is truly asynchronous since it does a workspaceEdit roundtrip.",
        "createdAt" : "2018-01-04T21:07:52Z",
        "updatedAt" : "2018-01-04T21:41:50Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91848703d00af951b1f55d62236ec4f5ae50851b",
    "line" : null,
    "diffHunk" : "@@ -189,202 +152,237 @@ class ScalametaLanguageServer(\n       renameProvider = true,\n       codeActionProvider = true\n     )\n-    InitializeResult(capabilities)\n+    Task(Right(InitializeResult(capabilities)))\n   }\n \n-  override def shutdown(): Task[ShutdownResult] = Task {\n+  // TODO(olafur): make it easier to invoke fluid services from tests\n+  def shutdown(): Unit = {\n     logger.info(\"Shutting down...\")\n     cancelEffects.foreach(_.cancel())\n-    connection.cancelAllActiveRequests()\n-    ShutdownResult()\n   }\n \n-  private def onChangedFile(\n-      path: AbsolutePath\n-  )(fallback: AbsolutePath => Unit): Unit = {\n-    val name = PathIO.extension(path.toNIO)\n-    logger.info(s\"File $path changed, extension=$name\")\n-    name match {\n-      case \"semanticdb\" => fileSystemSemanticdbSubscriber.onNext(path)\n-      case \"compilerconfig\" => compilerConfigSubscriber.onNext(path)\n-      case _ => fallback(path)\n+  val services: Services = Services.empty\n+    .requestAsync[InitializeParams, InitializeResult](\"initialize\") { params =>\n+      initialize(params)\n     }\n-  }\n-\n-  override def onChangeWatchedFiles(changes: Seq[FileEvent]): Unit =\n-    changes.foreach {\n-      case FileEvent(\n-          Uri(path),\n-          FileChangeType.Created | FileChangeType.Changed\n-          ) =>\n-        onChangedFile(path.toAbsolutePath) { _ =>\n-          logger.warn(s\"Unknown file extension for path $path\")\n+    .request[JsValue, JsValue](\"shutdown\") { _ =>\n+      shutdown()\n+      JsNull\n+    }\n+    .notification[JsValue](\"exit\") { _ =>\n+      logger.info(\"exit(0)\")\n+      sys.exit(0)\n+    }\n+    .requestAsync[TextDocumentPositionParams, CompletionList]("
  },
  {
    "id" : "f8d7b8a9-7847-43e8-9d1a-3b6f4fc91c00",
    "prId" : 165,
    "comments" : [
      {
        "id" : "b4be093c-c62f-4698-a3d1-9fc25a7d9b22",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2018-01-04T16:15:06Z",
        "updatedAt" : "2018-01-04T17:49:21Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9924498af0dea2182e425f6b31e51a7db3c97ff7",
    "line" : 55,
    "diffHunk" : "@@ -14,44 +11,15 @@ import scala.concurrent.duration.FiniteDuration\n import scala.meta.languageserver.compiler.CompilerConfig\n import scala.meta.languageserver.compiler.Cursor\n import scala.meta.languageserver.compiler.ScalacProvider\n+import scala.meta.languageserver.protocol.LanguageClient\n+import scala.meta.languageserver.protocol.Response\n+import scala.meta.languageserver.protocol.Services\n import scala.meta.languageserver.providers._\n import scala.meta.languageserver.refactoring.OrganizeImports\n import scala.meta.languageserver.search.SymbolIndex\n-import scala.meta.languageserver.PlayJsonEnrichments._\n import com.typesafe.scalalogging.LazyLogging\n import io.github.soc.directories.ProjectDirectories\n-import langserver.core.Connection\n-import langserver.core.LanguageServer\n-import langserver.messages.CodeActionRequest\n-import langserver.messages.CodeActionResult\n-import langserver.messages.CompletionList\n-import langserver.messages.CompletionOptions\n-import langserver.messages.DefinitionResult\n-import langserver.messages.DocumentFormattingResult\n-import langserver.messages.DocumentHighlightResult\n-import langserver.messages.DocumentSymbolParams\n-import langserver.messages.DocumentSymbolResult\n-import langserver.messages.ExecuteCommandOptions\n-import langserver.messages.Hover\n-import langserver.messages.InitializeParams\n-import langserver.messages.InitializeResult\n-import langserver.messages.ReferencesResult\n-import langserver.messages.RenameResult\n-import langserver.messages.ServerCapabilities\n-import langserver.messages.ShutdownResult\n-import langserver.messages.SignatureHelpOptions\n-import langserver.messages.SignatureHelpResult\n-import langserver.messages.TextDocumentCompletionRequest\n-import langserver.messages.TextDocumentDefinitionRequest\n-import langserver.messages.TextDocumentDocumentHighlightRequest\n-import langserver.messages.TextDocumentFormattingRequest\n-import langserver.messages.TextDocumentHoverRequest\n-import langserver.messages.TextDocumentReferencesRequest\n-import langserver.messages.TextDocumentRenameRequest\n-import langserver.messages.TextDocumentSignatureHelpRequest\n-import langserver.messages.WorkspaceExecuteCommandRequest\n-import langserver.messages.WorkspaceSymbolRequest\n-import langserver.messages.WorkspaceSymbolResult\n+import langserver.messages._"
  },
  {
    "id" : "f1977c98-88af-4fb9-b680-f4863c4d2a80",
    "prId" : 165,
    "comments" : [
      {
        "id" : "7cb37aca-3146-455a-90ff-6df72b56246c",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "Commented out code",
        "createdAt" : "2018-01-04T16:16:23Z",
        "updatedAt" : "2018-01-04T17:49:21Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "609fe17c-44c3-4de9-a716-ed3e2861dfed",
        "parentId" : "7cb37aca-3146-455a-90ff-6df72b56246c",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "ah, thanks, fixed.\r\n  ",
        "createdAt" : "2018-01-04T16:17:22Z",
        "updatedAt" : "2018-01-04T17:49:21Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9924498af0dea2182e425f6b31e51a7db3c97ff7",
    "line" : null,
    "diffHunk" : "@@ -189,202 +148,237 @@ class ScalametaLanguageServer(\n       renameProvider = true,\n       codeActionProvider = true\n     )\n-    InitializeResult(capabilities)\n+    Task(Right(InitializeResult(capabilities)))\n   }\n \n-  override def shutdown(): Task[ShutdownResult] = Task {\n+  // TODO(olafur): make it easier to invoke fluid services from tests\n+  def shutdown(): Unit = {\n     logger.info(\"Shutting down...\")\n     cancelEffects.foreach(_.cancel())\n-    connection.cancelAllActiveRequests()\n-    ShutdownResult()\n   }\n \n-  private def onChangedFile(\n-      path: AbsolutePath\n-  )(fallback: AbsolutePath => Unit): Unit = {\n-    val name = PathIO.extension(path.toNIO)\n-    logger.info(s\"File $path changed, extension=$name\")\n-    name match {\n-      case \"semanticdb\" => fileSystemSemanticdbSubscriber.onNext(path)\n-      case \"compilerconfig\" => compilerConfigSubscriber.onNext(path)\n-      case _ => fallback(path)\n+  val services: Services = Services.empty\n+    .requestAsync[InitializeParams, InitializeResult](\"initialize\") { params =>\n+      initialize(params)\n     }\n-  }\n-\n-  override def onChangeWatchedFiles(changes: Seq[FileEvent]): Unit =\n-    changes.foreach {\n-      case FileEvent(\n-          Uri(path),\n-          FileChangeType.Created | FileChangeType.Changed\n-          ) =>\n-        onChangedFile(path.toAbsolutePath) { _ =>\n-          logger.warn(s\"Unknown file extension for path $path\")\n+    .request[Json, Json](\"shutdown\") { _ =>\n+      shutdown()\n+      Json.Null\n+    }\n+    .notification[Json](\"exit\") { _ =>\n+      logger.info(\"exit(0)\")\n+      sys.exit(0)\n+    }\n+    .requestAsync[TextDocumentPositionParams, CompletionList](\n+      \"textDocument/completion\"\n+    ) { params =>\n+      withPC {\n+        logger.info(\"completion\")\n+        scalacProvider.getCompiler(params.textDocument) match {\n+          case Some(g) =>\n+            CompletionProvider.completions(\n+              g,\n+              toCursor(params.textDocument, params.position)\n+            )\n+          case None => CompletionProvider.empty\n         }\n-\n-      case event =>\n-        logger.warn(s\"Unhandled file event: $event\")\n-        ()\n+      }\n     }\n-\n-  override def onChangeConfiguration(settings: JsValue): Unit = {\n-    (settings \\ \"scalameta\").validate[Configuration] match {\n-      case err: JsError =>\n-        connection.showMessage(MessageType.Error, err.show)\n-      case JsSuccess(conf, _) =>\n-        logger.info(s\"Configuration updated $conf\")\n-        configurationSubscriber.onNext(conf)\n+    .request[TextDocumentPositionParams, List[Location]](\n+      \"textDocument/definition\"\n+    ) { params =>\n+      DefinitionProvider.definition(\n+        symbolIndex,\n+        Uri(params.textDocument.uri),\n+        params.position,\n+        tempSourcesDir\n+      )\n     }\n-  }\n-\n-  override def completion(\n-      request: TextDocumentCompletionRequest\n-  ): Task[CompletionList] = withPC {\n-    logger.info(\"completion\")\n-    scalacProvider.getCompiler(request.params.textDocument) match {\n-      case Some(g) =>\n-        CompletionProvider.completions(\n-          g,\n-          toPoint(request.params.textDocument, request.params.position)\n-        )\n-      case None => CompletionProvider.empty\n+    .request[CodeActionParams, List[Command]](\n+      \"textDocument/codeAction\"\n+    ) { params =>\n+      CodeActionProvider.codeActions(params)\n     }\n-  }\n-\n-  override def codeAction(request: CodeActionRequest): Task[CodeActionResult] =\n-    Task {\n-      CodeActionProvider.codeActions(request)\n+    .notification[DidCloseTextDocumentParams](\n+      \"textDocument/didClose\"\n+    ) { params =>\n+      buffers.closed(Uri(params.textDocument))\n+      ()\n     }\n-\n-  override def definition(\n-      request: TextDocumentDefinitionRequest\n-  ): Task[DefinitionResult] = Task {\n-    DefinitionProvider.definition(\n-      symbolIndex,\n-      Uri(request.params.textDocument.uri),\n-      request.params.position,\n-      tempSourcesDir\n-    )\n-  }\n-\n-  override def documentHighlight(\n-      request: TextDocumentDocumentHighlightRequest\n-  ): Task[DocumentHighlightResult] = Task {\n-    DocumentHighlightProvider.highlight(\n-      symbolIndex,\n-      Uri(request.params.textDocument.uri),\n-      request.params.position\n-    )\n-  }\n-\n-  override def documentSymbol(\n-      request: DocumentSymbolParams\n-  ): Task[DocumentSymbolResult] = Task {\n-    val uri = Uri(request.textDocument.uri)\n-    buffers.source(uri) match {\n-      case Some(source) => DocumentSymbolProvider.documentSymbols(uri, source)\n-      case None => DocumentSymbolProvider.empty\n+    .notification[DidOpenTextDocumentParams](\n+      \"textDocument/didOpen\"\n+    ) { params =>\n+      val input =\n+        Input.VirtualFile(params.textDocument.uri, params.textDocument.text)\n+      buffers.changed(input)\n+      sourceChangeSubscriber.onNext(input)\n+      ()\n     }\n-  }\n-\n-  override def formatting(\n-      request: TextDocumentFormattingRequest\n-  ): Task[DocumentFormattingResult] = {\n-    val uri = Uri(request.params.textDocument)\n-    documentFormattingProvider.format(uri.toInput(buffers))\n-  }\n-\n-  override def hover(\n-      request: TextDocumentHoverRequest\n-  ): Task[Hover] = Task {\n-    HoverProvider.hover(\n-      symbolIndex,\n-      Uri(request.params.textDocument),\n-      request.params.position.line,\n-      request.params.position.character\n-    )\n-  }\n-\n-  override def references(\n-      request: TextDocumentReferencesRequest\n-  ): Task[ReferencesResult] = Task {\n-    ReferencesProvider.references(\n-      symbolIndex,\n-      Uri(request.params.textDocument.uri),\n-      request.params.position,\n-      request.params.context\n-    )\n-  }\n-\n-  override def rename(request: TextDocumentRenameRequest): Task[RenameResult] =\n-    Task {\n-      RenameProvider.rename(request, symbolIndex, connection)\n+    .notification[DidChangeTextDocumentParams](\n+      \"textDocument/didChange\"\n+    ) { params =>\n+      val changes = params.contentChanges\n+      require(changes.length == 1, s\"Expected one change, got $changes\")\n+      val input = Input.VirtualFile(params.textDocument.uri, changes.head.text)\n+      buffers.changed(input)\n+      sourceChangeSubscriber.onNext(input)\n+      ()\n     }\n-\n-  override def signatureHelp(\n-      request: TextDocumentSignatureHelpRequest\n-  ): Task[SignatureHelpResult] = Task {\n-    scalacProvider.getCompiler(request.params.textDocument) match {\n-      case Some(g) =>\n-        SignatureHelpProvider.signatureHelp(\n-          g,\n-          toPoint(request.params.textDocument, request.params.position)\n-        )\n-      case None => SignatureHelpProvider.empty\n+    .notification[DidSaveTextDocumentParams](\n+      \"textDocument/didSave\"\n+    ) { params =>\n+      ()\n     }\n-  }\n-\n-  override def onOpenTextDocument(td: TextDocumentItem): Unit = {\n-    val input = Input.VirtualFile(td.uri, td.text)\n-    buffers.changed(input)\n-    sourceChangeSubscriber.onNext(input)\n-  }\n-\n-  override def executeCommand(\n-      request: WorkspaceExecuteCommandRequest\n-  ): Task[Unit] = Task {\n-    import WorkspaceCommand._\n-    WorkspaceCommand\n-      .withNameOption(request.params.command)\n-      .fold(logger.error(s\"Unknown command ${request.params.command}\")) {\n-        case ClearIndexCache =>\n+    .notification[DidChangeConfigurationParams](\n+      \"workspace/didChangeConfiguration\"\n+    ) { params =>\n+      params.settings.hcursor.downField(\"scalameta\").as[Configuration]// match {\n+      //   case Left(err) =>\n+      //     client.showMessage(MessageType.Error, err.show)\n+      //   case Right(conf) =>\n+      //     logger.info(s\"Configuration updated $conf\")\n+      //     configurationSubscriber.onNext(conf)\n+      // }"
  },
  {
    "id" : "aa14eb3f-f51f-4415-b4d2-693e85cd695c",
    "prId" : 165,
    "comments" : [
      {
        "id" : "1b4494db-0bad-4e75-82a7-e12e4e82e285",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "Doesn’t logger.warn already return unit?",
        "createdAt" : "2018-01-04T16:17:08Z",
        "updatedAt" : "2018-01-04T17:49:21Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cb680072-7d92-44ef-8d6d-ae04e02923f2",
        "parentId" : "1b4494db-0bad-4e75-82a7-e12e4e82e285",
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "I think so, but you better add this comment to @olafurpg's PR. This is just based on it.",
        "createdAt" : "2018-01-04T16:20:16Z",
        "updatedAt" : "2018-01-04T17:49:21Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9924498af0dea2182e425f6b31e51a7db3c97ff7",
    "line" : 398,
    "diffHunk" : "@@ -189,202 +148,237 @@ class ScalametaLanguageServer(\n       renameProvider = true,\n       codeActionProvider = true\n     )\n-    InitializeResult(capabilities)\n+    Task(Right(InitializeResult(capabilities)))\n   }\n \n-  override def shutdown(): Task[ShutdownResult] = Task {\n+  // TODO(olafur): make it easier to invoke fluid services from tests\n+  def shutdown(): Unit = {\n     logger.info(\"Shutting down...\")\n     cancelEffects.foreach(_.cancel())\n-    connection.cancelAllActiveRequests()\n-    ShutdownResult()\n   }\n \n-  private def onChangedFile(\n-      path: AbsolutePath\n-  )(fallback: AbsolutePath => Unit): Unit = {\n-    val name = PathIO.extension(path.toNIO)\n-    logger.info(s\"File $path changed, extension=$name\")\n-    name match {\n-      case \"semanticdb\" => fileSystemSemanticdbSubscriber.onNext(path)\n-      case \"compilerconfig\" => compilerConfigSubscriber.onNext(path)\n-      case _ => fallback(path)\n+  val services: Services = Services.empty\n+    .requestAsync[InitializeParams, InitializeResult](\"initialize\") { params =>\n+      initialize(params)\n     }\n-  }\n-\n-  override def onChangeWatchedFiles(changes: Seq[FileEvent]): Unit =\n-    changes.foreach {\n-      case FileEvent(\n-          Uri(path),\n-          FileChangeType.Created | FileChangeType.Changed\n-          ) =>\n-        onChangedFile(path.toAbsolutePath) { _ =>\n-          logger.warn(s\"Unknown file extension for path $path\")\n+    .request[Json, Json](\"shutdown\") { _ =>\n+      shutdown()\n+      Json.Null\n+    }\n+    .notification[Json](\"exit\") { _ =>\n+      logger.info(\"exit(0)\")\n+      sys.exit(0)\n+    }\n+    .requestAsync[TextDocumentPositionParams, CompletionList](\n+      \"textDocument/completion\"\n+    ) { params =>\n+      withPC {\n+        logger.info(\"completion\")\n+        scalacProvider.getCompiler(params.textDocument) match {\n+          case Some(g) =>\n+            CompletionProvider.completions(\n+              g,\n+              toCursor(params.textDocument, params.position)\n+            )\n+          case None => CompletionProvider.empty\n         }\n-\n-      case event =>\n-        logger.warn(s\"Unhandled file event: $event\")\n-        ()\n+      }\n     }\n-\n-  override def onChangeConfiguration(settings: JsValue): Unit = {\n-    (settings \\ \"scalameta\").validate[Configuration] match {\n-      case err: JsError =>\n-        connection.showMessage(MessageType.Error, err.show)\n-      case JsSuccess(conf, _) =>\n-        logger.info(s\"Configuration updated $conf\")\n-        configurationSubscriber.onNext(conf)\n+    .request[TextDocumentPositionParams, List[Location]](\n+      \"textDocument/definition\"\n+    ) { params =>\n+      DefinitionProvider.definition(\n+        symbolIndex,\n+        Uri(params.textDocument.uri),\n+        params.position,\n+        tempSourcesDir\n+      )\n     }\n-  }\n-\n-  override def completion(\n-      request: TextDocumentCompletionRequest\n-  ): Task[CompletionList] = withPC {\n-    logger.info(\"completion\")\n-    scalacProvider.getCompiler(request.params.textDocument) match {\n-      case Some(g) =>\n-        CompletionProvider.completions(\n-          g,\n-          toPoint(request.params.textDocument, request.params.position)\n-        )\n-      case None => CompletionProvider.empty\n+    .request[CodeActionParams, List[Command]](\n+      \"textDocument/codeAction\"\n+    ) { params =>\n+      CodeActionProvider.codeActions(params)\n     }\n-  }\n-\n-  override def codeAction(request: CodeActionRequest): Task[CodeActionResult] =\n-    Task {\n-      CodeActionProvider.codeActions(request)\n+    .notification[DidCloseTextDocumentParams](\n+      \"textDocument/didClose\"\n+    ) { params =>\n+      buffers.closed(Uri(params.textDocument))\n+      ()\n     }\n-\n-  override def definition(\n-      request: TextDocumentDefinitionRequest\n-  ): Task[DefinitionResult] = Task {\n-    DefinitionProvider.definition(\n-      symbolIndex,\n-      Uri(request.params.textDocument.uri),\n-      request.params.position,\n-      tempSourcesDir\n-    )\n-  }\n-\n-  override def documentHighlight(\n-      request: TextDocumentDocumentHighlightRequest\n-  ): Task[DocumentHighlightResult] = Task {\n-    DocumentHighlightProvider.highlight(\n-      symbolIndex,\n-      Uri(request.params.textDocument.uri),\n-      request.params.position\n-    )\n-  }\n-\n-  override def documentSymbol(\n-      request: DocumentSymbolParams\n-  ): Task[DocumentSymbolResult] = Task {\n-    val uri = Uri(request.textDocument.uri)\n-    buffers.source(uri) match {\n-      case Some(source) => DocumentSymbolProvider.documentSymbols(uri, source)\n-      case None => DocumentSymbolProvider.empty\n+    .notification[DidOpenTextDocumentParams](\n+      \"textDocument/didOpen\"\n+    ) { params =>\n+      val input =\n+        Input.VirtualFile(params.textDocument.uri, params.textDocument.text)\n+      buffers.changed(input)\n+      sourceChangeSubscriber.onNext(input)\n+      ()\n     }\n-  }\n-\n-  override def formatting(\n-      request: TextDocumentFormattingRequest\n-  ): Task[DocumentFormattingResult] = {\n-    val uri = Uri(request.params.textDocument)\n-    documentFormattingProvider.format(uri.toInput(buffers))\n-  }\n-\n-  override def hover(\n-      request: TextDocumentHoverRequest\n-  ): Task[Hover] = Task {\n-    HoverProvider.hover(\n-      symbolIndex,\n-      Uri(request.params.textDocument),\n-      request.params.position.line,\n-      request.params.position.character\n-    )\n-  }\n-\n-  override def references(\n-      request: TextDocumentReferencesRequest\n-  ): Task[ReferencesResult] = Task {\n-    ReferencesProvider.references(\n-      symbolIndex,\n-      Uri(request.params.textDocument.uri),\n-      request.params.position,\n-      request.params.context\n-    )\n-  }\n-\n-  override def rename(request: TextDocumentRenameRequest): Task[RenameResult] =\n-    Task {\n-      RenameProvider.rename(request, symbolIndex, connection)\n+    .notification[DidChangeTextDocumentParams](\n+      \"textDocument/didChange\"\n+    ) { params =>\n+      val changes = params.contentChanges\n+      require(changes.length == 1, s\"Expected one change, got $changes\")\n+      val input = Input.VirtualFile(params.textDocument.uri, changes.head.text)\n+      buffers.changed(input)\n+      sourceChangeSubscriber.onNext(input)\n+      ()\n     }\n-\n-  override def signatureHelp(\n-      request: TextDocumentSignatureHelpRequest\n-  ): Task[SignatureHelpResult] = Task {\n-    scalacProvider.getCompiler(request.params.textDocument) match {\n-      case Some(g) =>\n-        SignatureHelpProvider.signatureHelp(\n-          g,\n-          toPoint(request.params.textDocument, request.params.position)\n-        )\n-      case None => SignatureHelpProvider.empty\n+    .notification[DidSaveTextDocumentParams](\n+      \"textDocument/didSave\"\n+    ) { params =>\n+      ()\n     }\n-  }\n-\n-  override def onOpenTextDocument(td: TextDocumentItem): Unit = {\n-    val input = Input.VirtualFile(td.uri, td.text)\n-    buffers.changed(input)\n-    sourceChangeSubscriber.onNext(input)\n-  }\n-\n-  override def executeCommand(\n-      request: WorkspaceExecuteCommandRequest\n-  ): Task[Unit] = Task {\n-    import WorkspaceCommand._\n-    WorkspaceCommand\n-      .withNameOption(request.params.command)\n-      .fold(logger.error(s\"Unknown command ${request.params.command}\")) {\n-        case ClearIndexCache =>\n+    .notification[DidChangeConfigurationParams](\n+      \"workspace/didChangeConfiguration\"\n+    ) { params =>\n+      params.settings.hcursor.downField(\"scalameta\").as[Configuration]// match {\n+      //   case Left(err) =>\n+      //     client.showMessage(MessageType.Error, err.show)\n+      //   case Right(conf) =>\n+      //     logger.info(s\"Configuration updated $conf\")\n+      //     configurationSubscriber.onNext(conf)\n+      // }\n+    }\n+    .notification[DidChangeWatchedFilesParams](\n+      \"workspace/didChangeWatchedFiles\"\n+    ) { params =>\n+      params.changes.foreach {\n+        case FileEvent(\n+            Uri(path),\n+            FileChangeType.Created | FileChangeType.Changed\n+            ) =>\n+          onChangedFile(path.toAbsolutePath) { _ =>\n+            logger.warn(s\"Unknown file extension for path $path\")\n+          }\n+\n+        case event =>\n+          logger.warn(s\"Unhandled file event: $event\")\n+          ()"
  }
]