[
  {
    "id" : "a0ea6e75-1d22-42ce-abd7-5efa86c27e2f",
    "prId" : 71,
    "comments" : [
      {
        "id" : "7b23d3d2-ec36-4d13-8a71-e66394f5f52a",
        "parentId" : null,
        "author" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "body" : "out of date comment",
        "createdAt" : "2017-11-28T22:00:36Z",
        "updatedAt" : "2017-11-29T07:02:11Z",
        "lastEditedBy" : {
          "login" : "ShaneDelmore",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/4604933?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "365c6e95ebfe230b3ab154f12e2d85bab13e5136",
    "line" : null,
    "diffHunk" : "@@ -99,10 +110,46 @@ class SymbolIndex(\n       DefinitionResult(location :: Nil)\n     }\n   }\n+  // NOTE(olafur) this probably belongs somewhere else than Compiler, see\n+  // https://github.com/scalameta/language-server/issues/48"
  },
  {
    "id" : "4f1207c3-b117-4ffb-860c-c9c6df635951",
    "prId" : 78,
    "comments" : [
      {
        "id" : "f12a9f8e-2c74-4b02-9953-9c300e0f7756",
        "parentId" : null,
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "@olafurpg could you take a look at this piece of code? I'm probably doing it wrong, but this way I think we won't get references from the index because it stores only global symbols, i.e. not their usage which is what we want for references. \r\n\r\nCurrently I get _some_ references only for fields/parameters. `User` for example doesn't give any results.",
        "createdAt" : "2017-11-29T23:02:25Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e82d6db-c40a-48a8-b92e-ba3964adeb85",
        "parentId" : "f12a9f8e-2c74-4b02-9953-9c300e0f7756",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Could it be that you're missing fallback symbols with `alternatives(symbol)`? `example.User#` is the type symbol and `example.User.` is the companion object term symbol. They refer to different things, but if the term companion is synthetic then you need to fallback to it's type symbol.\r\n\r\nWe probably need to refine the `alternatives` method since definition and references have different rules for how alternatives are computed, but for now I guess it's fine to use the same implementation.\r\n\r\nThe index currently stores all definitions and references to all symbols. Soon we'll probably stop storing definitions for global symbols and references to local symbols since those can easily be computed on the fly from a `Document`.",
        "createdAt" : "2017-11-30T07:31:41Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -111,6 +112,21 @@ class SymbolIndex(\n     }\n   }\n \n+  /** Returns the definition position of the symbol at the given position */\n+  def references(\n+      path: AbsolutePath,\n+      line: Int,\n+      column: Int\n+  ): ReferencesResult = {\n+    val locations = for {\n+      symbol <- findSymbol(path, line, column).toSeq\n+      (uri, ranges) <- symbol.references\n+      range <- ranges.ranges\n+    } yield i.Position(uri, Some(range)).toLocation"
  },
  {
    "id" : "dc4da9c4-aa82-46c2-b27a-0db5753b4e6d",
    "prId" : 78,
    "comments" : [
      {
        "id" : "04e711a5-f310-47a3-8c1c-f3ca209126b5",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Note that `findSymbol` guards against symbols that have no definition, we should probably move that filter into the `definition` implementation.",
        "createdAt" : "2017-11-30T07:32:16Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -111,6 +112,21 @@ class SymbolIndex(\n     }\n   }\n \n+  /** Returns the definition position of the symbol at the given position */\n+  def references(\n+      path: AbsolutePath,\n+      line: Int,\n+      column: Int\n+  ): ReferencesResult = {\n+    val locations = for {\n+      symbol <- findSymbol(path, line, column).toSeq"
  },
  {
    "id" : "056311e1-6d86-4366-9b0a-4aa9457037f4",
    "prId" : 78,
    "comments" : [
      {
        "id" : "d4029e4c-f113-42d4-a9ae-6fd4d463d597",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Makes sense!",
        "createdAt" : "2017-12-01T20:33:42Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : 82,
    "diffHunk" : "@@ -49,66 +50,94 @@ class SymbolIndex(\n   private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n     new ConcurrentHashMap[AbsolutePath, Unit]()\n \n-  /** Returns a symbol at the given location with a non-empty definition */\n-  def findSymbol(\n+  /** Returns a ResolvedName at the given location */\n+  def resolveName(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[SymbolData] = {\n-    logger.info(s\"findSymbol at $path:$line:$column\")\n+  ): Option[ResolvedName] = {\n+    logger.info(s\"resolveName at $path:$line:$column\")\n     for {\n-      document <- documents.getDocument(path.toNIO.toUri)\n+      document <- documentIndex.getDocument(path.toNIO.toUri)\n       _ = logger.info(s\"Found document for $path\")\n       _ <- isFreshSemanticdb(path, document)\n       input = Input.VirtualFile(document.filename, document.contents)\n       _ = logger.info(s\"Document for $path is fresh\")\n       name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), sym, _) if {\n-              val pos = input.toIndexRange(position.start, position.end)\n-              logger.info(\n-                s\"$sym at ${document.filename\n-                  .replaceFirst(\".*/\", \"\")}:${pos.startLine}:${pos.startColumn}-${pos.endLine}:${pos.endColumn}\"\n-              )\n-              pos.startLine <= line &&\n-              pos.startColumn <= column &&\n-              pos.endLine >= line &&\n-              pos.endColumn >= column\n-            } =>\n-          name\n-      }\n-      msym = Symbol(name.symbol)\n-      _ = logger.info(s\"Found matching symbol $msym\")\n-      symbol <- symbols.get(name.symbol).orElse {\n-        val alts = alternatives(msym)\n-        logger.info(s\"Trying alternatives: ${alts.mkString(\" | \")}\")\n-        alts.collectFirst { case symbols(alternative) => alternative }\n+        case name @ ResolvedName(Some(position), symbol, _) if {\n+          val range = input.toIndexRange(position.start, position.end)\n+          logger.debug(s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\")\n+          range.contains(line, column)\n+        } => name\n       }\n-      _ = logger.info(\n-        s\"Found matching symbol index ${symbol.name}: ${symbol.signature}\"\n-      )\n-    } yield symbol\n+    } yield name\n   }\n \n-  /** Returns the definition position of the symbol at the given position */\n-  def goToDefinition(\n+  /** Returns a symbol at the given location */\n+  def findSymbol(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[DefinitionResult] = {\n+  ): Option[Symbol] = {"
  },
  {
    "id" : "1633e5a4-2674-4729-9302-f274895862b0",
    "prId" : 78,
    "comments" : [
      {
        "id" : "c62cc19b-5406-4731-ad7b-5a6017baa425",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We should turn this into a `Symbol => List[Symbol]`. For references we can check if a type symbol has a companion object that has references but no definition, that would help cases like this\r\n\r\n<img width=\"360\" alt=\"screen shot 2017-12-01 at 21 36 28\" src=\"https://user-images.githubusercontent.com/1408093/33502295-d49871c2-d6df-11e7-931a-88042e7749fc.png\">\r\n\r\nwhere `User(\"\", 1)` is not listed as a references because `User` is the synthetic companion object.",
        "createdAt" : "2017-12-02T00:09:35Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "18b2b5fd-59e4-43c0-a240-28ca2e0a62f4",
        "parentId" : "c62cc19b-5406-4731-ad7b-5a6017baa425",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "hmmm, references on `<<User>>(\"\", 1)` shows the `class <<User>>` but not the other way around ðŸ¤” ",
        "createdAt" : "2017-12-02T00:25:44Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f1be9884-74b9-48a2-91d7-80015b61b035",
        "parentId" : "c62cc19b-5406-4731-ad7b-5a6017baa425",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Yes, same asymmetry with `apply`/`copy` parameters.\r\nP.S. btw, this method disappeared in later refactoring",
        "createdAt" : "2017-12-02T23:30:33Z",
        "updatedAt" : "2017-12-02T23:31:10Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -49,66 +50,94 @@ class SymbolIndex(\n   private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n     new ConcurrentHashMap[AbsolutePath, Unit]()\n \n-  /** Returns a symbol at the given location with a non-empty definition */\n-  def findSymbol(\n+  /** Returns a ResolvedName at the given location */\n+  def resolveName(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[SymbolData] = {\n-    logger.info(s\"findSymbol at $path:$line:$column\")\n+  ): Option[ResolvedName] = {\n+    logger.info(s\"resolveName at $path:$line:$column\")\n     for {\n-      document <- documents.getDocument(path.toNIO.toUri)\n+      document <- documentIndex.getDocument(path.toNIO.toUri)\n       _ = logger.info(s\"Found document for $path\")\n       _ <- isFreshSemanticdb(path, document)\n       input = Input.VirtualFile(document.filename, document.contents)\n       _ = logger.info(s\"Document for $path is fresh\")\n       name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), sym, _) if {\n-              val pos = input.toIndexRange(position.start, position.end)\n-              logger.info(\n-                s\"$sym at ${document.filename\n-                  .replaceFirst(\".*/\", \"\")}:${pos.startLine}:${pos.startColumn}-${pos.endLine}:${pos.endColumn}\"\n-              )\n-              pos.startLine <= line &&\n-              pos.startColumn <= column &&\n-              pos.endLine >= line &&\n-              pos.endColumn >= column\n-            } =>\n-          name\n-      }\n-      msym = Symbol(name.symbol)\n-      _ = logger.info(s\"Found matching symbol $msym\")\n-      symbol <- symbols.get(name.symbol).orElse {\n-        val alts = alternatives(msym)\n-        logger.info(s\"Trying alternatives: ${alts.mkString(\" | \")}\")\n-        alts.collectFirst { case symbols(alternative) => alternative }\n+        case name @ ResolvedName(Some(position), symbol, _) if {\n+          val range = input.toIndexRange(position.start, position.end)\n+          logger.debug(s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\")\n+          range.contains(line, column)\n+        } => name\n       }\n-      _ = logger.info(\n-        s\"Found matching symbol index ${symbol.name}: ${symbol.signature}\"\n-      )\n-    } yield symbol\n+    } yield name\n   }\n \n-  /** Returns the definition position of the symbol at the given position */\n-  def goToDefinition(\n+  /** Returns a symbol at the given location */\n+  def findSymbol(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[DefinitionResult] = {\n+  ): Option[Symbol] = {\n     for {\n-      symbol <- findSymbol(path, line, column)\n-      definition <- symbol.definition\n-    } yield {\n-      val nonJarDefinition: Position =\n-        if (definition.uri.startsWith(\"jar:file\")) {\n-          definition.withUri(\n-            createFileInWorkspaceTarget(URI.create(definition.uri)).toString\n-          )\n-        } else definition\n-      logger.info(s\"Found definition $nonJarDefinition\")\n-      val location = nonJarDefinition.toLocation\n-      DefinitionResult(location :: Nil)\n-    }\n+      name <- resolveName(path, line, column)\n+      symbol = Symbol(name.symbol)\n+      _ = logger.info(s\"Matching symbol ${symbol}\")\n+    } yield symbol\n+  }\n+\n+  /** Returns symbol index data for the given symbol and optionally its alternatives */\n+  def getSymbolData(\n+    symbol: Symbol,\n+    withAlternatives: Boolean = false"
  },
  {
    "id" : "e1feed56-b8a3-450f-92c9-acde8ead66e6",
    "prId" : 78,
    "comments" : [
      {
        "id" : "979ef556-c592-4df5-a466-7294ed7f10c2",
        "parentId" : null,
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "@olafurpg note that I removed this `companion`. Was it there for a good reason? If I'm not mistaken, this would redirect `Foo.apply` just to the companion object (if it doesn't have this `apply` defined explicitly).",
        "createdAt" : "2017-12-02T03:26:22Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : 190,
    "diffHunk" : "@@ -220,47 +267,81 @@ class SymbolIndex(\n     }\n   }\n \n-  /** Returns a list of fallback symbols that can act instead of given symbol. */\n-  private def alternatives(symbol: Symbol): List[Symbol] =\n-    symbol match {\n+  // TODO(alexey) this is not index specific and could be moved somewhere else (like Symbol-ops)\n+  case object alternatives {\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    // TODO(alexey) review this list\n+    def forReferences(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopyParams\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    def forDefinition(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopy,\n+        caseClassApplyOrCopyParams,\n+        methodToTerm\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** If `case class A(a: Int)` and there is no companion object, resolve\n+     * `A` in `A(1)` to the class definition.\n+     */\n+    val caseClassCompanionToType: PartialFunction[Symbol, Symbol] = {\n       case Symbol.Global(owner, Signature.Term(name)) =>\n-        // If `case class A(a: Int)` and there is no companion object, resolve\n-        // `A` in `A(1)` to the class definition.\n-        Symbol.Global(owner, Signature.Type(name)) :: Nil\n-      case Symbol.Multi(ss) =>\n-        // If `import a.B` where `case class B()`, then\n-        // resolve to either symbol, whichever has a definition.\n-        ss\n-      case Symbol.Global(\n-          companion @ Symbol.Global(owner, signature),\n-          Signature.Method(\"apply\" | \"copy\", _)\n-          ) =>\n-        // If `case class Foo(a: Int)`, then resolve\n-        // `apply` in `Foo.apply(1)`, and\n-        // `copy` in `Foo(1).copy(a = 2)`\n-        // to the `Foo` class definition.\n-        companion :: Symbol.Global(owner, Signature.Type(signature.name)) :: Nil"
  },
  {
    "id" : "96a089e2-797f-4c6d-a2ff-de8e75c82fa4",
    "prId" : 78,
    "comments" : [
      {
        "id" : "de6a7778-59e1-4f94-94b7-02a0f1406166",
        "parentId" : null,
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "There's an issue with it:\r\n\r\n```\r\ncase class User(name: String, age: Int)\r\n\r\nobject User {\r\n  def apply(name: String): User = <<User>>(name, 2)\r\n}\r\n```\r\n\r\nGo-to-definition on the selected `User(name, 2)` will redirect to the companion object. Can we workaround it somehow?",
        "createdAt" : "2017-12-02T03:30:20Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b40576c6-188b-4b90-bc7c-e698e1fa8406",
        "parentId" : "de6a7778-59e1-4f94-94b7-02a0f1406166",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Yes we can work around that but it will require a bit of work :) what we need to do is to refine the `indexDocument` method to look into the \"Synthetics\" section for `.apply`. I propose we get this PR merged in as soon as we have tests covering basic cases and then we refine the details in future PRs.",
        "createdAt" : "2017-12-02T13:02:52Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -220,47 +267,81 @@ class SymbolIndex(\n     }\n   }\n \n-  /** Returns a list of fallback symbols that can act instead of given symbol. */\n-  private def alternatives(symbol: Symbol): List[Symbol] =\n-    symbol match {\n+  // TODO(alexey) this is not index specific and could be moved somewhere else (like Symbol-ops)\n+  case object alternatives {\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    // TODO(alexey) review this list\n+    def forReferences(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopyParams\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    def forDefinition(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopy,\n+        caseClassApplyOrCopyParams,\n+        methodToTerm\n+      ).flatMap { _.lift(symbol) }\n+    }"
  },
  {
    "id" : "942e6aca-93ed-4038-9ecd-68f762cc680f",
    "prId" : 78,
    "comments" : [
      {
        "id" : "f4d6f030-2810-442e-8c2b-0f84da788956",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We can make this an enrichment method in ScalametaEnrichments or create an `ops` object with lots of static methods. I personally lean towards enrichment methods for consistency with what we're already doing, what do y'all think? ",
        "createdAt" : "2017-12-02T12:54:06Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb1d4923-3176-4616-84c6-7633487c2b6c",
        "parentId" : "f4d6f030-2810-442e-8c2b-0f84da788956",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Yep, when I said \"ops\" I actually meant \"enrichment methods\" (is it an established term?). The only doubt I had here is that `ScalametaEnrichments` is named like it's just about enrichments for the Scalameta types. Analogously to `langserver.InputEnrichments`. So should I still add it to `ScalametaEnrichments` or create a new `IndexDataEnrichments` or something?",
        "createdAt" : "2017-12-02T17:15:48Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "21681f55-14c8-4a22-91b4-ab9cd8c51077",
        "parentId" : "f4d6f030-2810-442e-8c2b-0f84da788956",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I think it makes sense to have only one `Enrichments` object where we keep all enrichments, that should make it easy to know \"what import do I need?\". We can call the object `syntax` fwiw. InputEnrichments should probably be turned into an object with a vanilla method, it's there only because it needs access to a package private method on Input. The enrichment method can be moved to the single enrichment method, wdyt?",
        "createdAt" : "2017-12-02T17:21:19Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6274fe15-2062-4e53-9dc7-4efb3c17c725",
        "parentId" : "f4d6f030-2810-442e-8c2b-0f84da788956",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "I like this approach ðŸ‘Œ ",
        "createdAt" : "2017-12-02T17:30:44Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dde3d209-cec9-41e6-b326-9f0171bee7e8",
        "parentId" : "f4d6f030-2810-442e-8c2b-0f84da788956",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Let's move this refactoring to a separate PR",
        "createdAt" : "2017-12-02T22:41:29Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab1c95c9-ea8d-47fd-945d-d0c09a54347d",
        "parentId" : "f4d6f030-2810-442e-8c2b-0f84da788956",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Done in b94b0b621b450786111c3d227d2ed8a827a5889c. Actually this method disappeared.",
        "createdAt" : "2017-12-02T23:29:37Z",
        "updatedAt" : "2017-12-02T23:29:37Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -49,66 +50,107 @@ class SymbolIndex(\n   private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n     new ConcurrentHashMap[AbsolutePath, Unit]()\n \n-  /** Returns a symbol at the given location with a non-empty definition */\n-  def findSymbol(\n+  /** Returns a ResolvedName at the given location */\n+  def resolveName(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[SymbolData] = {\n-    logger.info(s\"findSymbol at $path:$line:$column\")\n+  ): Option[ResolvedName] = {\n+    logger.info(s\"resolveName at $path:$line:$column\")\n     for {\n-      document <- documents.getDocument(path.toNIO.toUri)\n+      document <- documentIndex.getDocument(path.toNIO.toUri)\n       _ = logger.info(s\"Found document for $path\")\n       _ <- isFreshSemanticdb(path, document)\n       input = Input.VirtualFile(document.filename, document.contents)\n       _ = logger.info(s\"Document for $path is fresh\")\n       name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), sym, _) if {\n-              val pos = input.toIndexRange(position.start, position.end)\n-              logger.info(\n-                s\"$sym at ${document.filename\n-                  .replaceFirst(\".*/\", \"\")}:${pos.startLine}:${pos.startColumn}-${pos.endLine}:${pos.endColumn}\"\n+        case name @ ResolvedName(Some(position), symbol, _) if {\n+              val range = input.toIndexRange(position.start, position.end)\n+              logger.debug(\n+                s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\"\n               )\n-              pos.startLine <= line &&\n-              pos.startColumn <= column &&\n-              pos.endLine >= line &&\n-              pos.endColumn >= column\n+              range.contains(line, column)\n             } =>\n           name\n       }\n-      msym = Symbol(name.symbol)\n-      _ = logger.info(s\"Found matching symbol $msym\")\n-      symbol <- symbols.get(name.symbol).orElse {\n-        val alts = alternatives(msym)\n-        logger.info(s\"Trying alternatives: ${alts.mkString(\" | \")}\")\n-        alts.collectFirst { case symbols(alternative) => alternative }\n-      }\n-      _ = logger.info(\n-        s\"Found matching symbol index ${symbol.name}: ${symbol.signature}\"\n-      )\n-    } yield symbol\n+    } yield name\n   }\n \n-  /** Returns the definition position of the symbol at the given position */\n-  def goToDefinition(\n+  /** Returns a symbol at the given location */\n+  def findSymbol(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[DefinitionResult] = {\n+  ): Option[Symbol] = {\n     for {\n-      symbol <- findSymbol(path, line, column)\n-      definition <- symbol.definition\n-    } yield {\n-      val nonJarDefinition: Position =\n-        if (definition.uri.startsWith(\"jar:file\")) {\n-          definition.withUri(\n-            createFileInWorkspaceTarget(URI.create(definition.uri)).toString\n-          )\n-        } else definition\n-      logger.info(s\"Found definition $nonJarDefinition\")\n-      val location = nonJarDefinition.toLocation\n-      DefinitionResult(location :: Nil)\n-    }\n+      name <- resolveName(path, line, column)\n+      symbol = Symbol(name.symbol)\n+      _ = logger.info(s\"Matching symbol ${symbol}\")\n+    } yield symbol\n+  }\n+\n+  /** Returns symbol definition data from the index taking into account relevant alternatives */\n+  def definitionData(\n+      symbol: Symbol\n+  ): Option[SymbolData] = {\n+    (symbol :: alternatives.forDefinition(symbol))\n+      .collectFirst {\n+        case symbolIndexer(data) if data.definition.nonEmpty =>\n+          logger.info(s\"Found definition symbol ${data.symbol}\")\n+          data\n+      }\n+  }\n+\n+  /** Returns the definition location of the given symbol index data\n+   * @param symbolData symbol data retrieved with [[definitionData]]\n+   */\n+  // TODO(alexey) this is not index-specific and should be moved to some SymbolData-ops"
  },
  {
    "id" : "a13214db-2c2d-46de-8dd6-dd53b4a6ee3e",
    "prId" : 78,
    "comments" : [
      {
        "id" : "0ec9e7e7-1497-43b6-a9ea-1114d5f1fa36",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Ditto, we can turn this into an enrichment method on SymbolData.",
        "createdAt" : "2017-12-02T12:54:41Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47842057-1abb-4bf9-92a1-bb0195c99cd0",
        "parentId" : "0ec9e7e7-1497-43b6-a9ea-1114d5f1fa36",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We can leave this to a separate PR and leave comment here.",
        "createdAt" : "2017-12-02T22:41:16Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "86f13ca8-615f-455c-933e-bac4df14a73d",
        "parentId" : "0ec9e7e7-1497-43b6-a9ea-1114d5f1fa36",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Done in b94b0b621b450786111c3d227d2ed8a827a5889c (sorry, I was already in process)",
        "createdAt" : "2017-12-02T23:29:01Z",
        "updatedAt" : "2017-12-02T23:29:01Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -49,66 +50,107 @@ class SymbolIndex(\n   private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n     new ConcurrentHashMap[AbsolutePath, Unit]()\n \n-  /** Returns a symbol at the given location with a non-empty definition */\n-  def findSymbol(\n+  /** Returns a ResolvedName at the given location */\n+  def resolveName(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[SymbolData] = {\n-    logger.info(s\"findSymbol at $path:$line:$column\")\n+  ): Option[ResolvedName] = {\n+    logger.info(s\"resolveName at $path:$line:$column\")\n     for {\n-      document <- documents.getDocument(path.toNIO.toUri)\n+      document <- documentIndex.getDocument(path.toNIO.toUri)\n       _ = logger.info(s\"Found document for $path\")\n       _ <- isFreshSemanticdb(path, document)\n       input = Input.VirtualFile(document.filename, document.contents)\n       _ = logger.info(s\"Document for $path is fresh\")\n       name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), sym, _) if {\n-              val pos = input.toIndexRange(position.start, position.end)\n-              logger.info(\n-                s\"$sym at ${document.filename\n-                  .replaceFirst(\".*/\", \"\")}:${pos.startLine}:${pos.startColumn}-${pos.endLine}:${pos.endColumn}\"\n+        case name @ ResolvedName(Some(position), symbol, _) if {\n+              val range = input.toIndexRange(position.start, position.end)\n+              logger.debug(\n+                s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\"\n               )\n-              pos.startLine <= line &&\n-              pos.startColumn <= column &&\n-              pos.endLine >= line &&\n-              pos.endColumn >= column\n+              range.contains(line, column)\n             } =>\n           name\n       }\n-      msym = Symbol(name.symbol)\n-      _ = logger.info(s\"Found matching symbol $msym\")\n-      symbol <- symbols.get(name.symbol).orElse {\n-        val alts = alternatives(msym)\n-        logger.info(s\"Trying alternatives: ${alts.mkString(\" | \")}\")\n-        alts.collectFirst { case symbols(alternative) => alternative }\n-      }\n-      _ = logger.info(\n-        s\"Found matching symbol index ${symbol.name}: ${symbol.signature}\"\n-      )\n-    } yield symbol\n+    } yield name\n   }\n \n-  /** Returns the definition position of the symbol at the given position */\n-  def goToDefinition(\n+  /** Returns a symbol at the given location */\n+  def findSymbol(\n       path: AbsolutePath,\n       line: Int,\n       column: Int\n-  ): Option[DefinitionResult] = {\n+  ): Option[Symbol] = {\n     for {\n-      symbol <- findSymbol(path, line, column)\n-      definition <- symbol.definition\n-    } yield {\n-      val nonJarDefinition: Position =\n-        if (definition.uri.startsWith(\"jar:file\")) {\n-          definition.withUri(\n-            createFileInWorkspaceTarget(URI.create(definition.uri)).toString\n-          )\n-        } else definition\n-      logger.info(s\"Found definition $nonJarDefinition\")\n-      val location = nonJarDefinition.toLocation\n-      DefinitionResult(location :: Nil)\n-    }\n+      name <- resolveName(path, line, column)\n+      symbol = Symbol(name.symbol)\n+      _ = logger.info(s\"Matching symbol ${symbol}\")\n+    } yield symbol\n+  }\n+\n+  /** Returns symbol definition data from the index taking into account relevant alternatives */\n+  def definitionData(\n+      symbol: Symbol\n+  ): Option[SymbolData] = {\n+    (symbol :: alternatives.forDefinition(symbol))\n+      .collectFirst {\n+        case symbolIndexer(data) if data.definition.nonEmpty =>\n+          logger.info(s\"Found definition symbol ${data.symbol}\")\n+          data\n+      }\n+  }\n+\n+  /** Returns the definition location of the given symbol index data\n+   * @param symbolData symbol data retrieved with [[definitionData]]\n+   */\n+  // TODO(alexey) this is not index-specific and should be moved to some SymbolData-ops\n+  def definitionLocation(\n+      symbolData: SymbolData\n+  ): Option[l.Location] = {\n+    for {\n+      i.Position(uri, Some(range)) <- symbolData.definition\n+      _ = logger.info(\n+        s\"Found definition ${uri.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbolData.symbol}\"\n+      )\n+    } yield l.Location(uri, range.toRange)\n+  }\n+\n+  /** Returns symbol references data from the index taking into account relevant alternatives */\n+  def referencesData(\n+      symbol: Symbol\n+  ): List[SymbolData] = {\n+    (symbol :: alternatives.forReferences(symbol))\n+      .collect {\n+        case symbolIndexer(data) =>\n+          if (data.symbol != symbol.syntax)\n+            logger.info(s\"Adding alternative references ${data.symbol}\")\n+          data\n+      }\n+  }\n+\n+  /** Returns references locations for the given symbol index data\n+   * @param symbolData symbol data retrieved with [[referencesData]]\n+   * @param withDefinition if set to `true` will include symbol definition location\n+   */\n+  // TODO(alexey) this is not index-specific and should be moved to some SymbolData-ops"
  },
  {
    "id" : "f3842056-aad1-4ad7-b413-2a1c59e5650a",
    "prId" : 78,
    "comments" : [
      {
        "id" : "ada16ad7-8242-45e6-9ab1-2bed19431a88",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "why case object instead of object?",
        "createdAt" : "2017-12-02T12:55:41Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dae76874-6288-4ae0-b313-e3446edf36a6",
        "parentId" : "ada16ad7-8242-45e6-9ab1-2bed19431a88",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We can turn these into extension methods on Symbol",
        "createdAt" : "2017-12-02T13:14:58Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "db63488f-ba29-442b-9394-84f5d5b06e11",
        "parentId" : "ada16ad7-8242-45e6-9ab1-2bed19431a88",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "> why case object instead of object?\r\n\r\nNo good reason for this case. Just a habit, I usually make all objects `case object`s. Is there a general reason not to?",
        "createdAt" : "2017-12-02T17:20:34Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "163d973c-d9e2-4738-95b1-019b902bad65",
        "parentId" : "ada16ad7-8242-45e6-9ab1-2bed19431a88",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "When I see `case object` I read \"pattern match on this object\", so if you don't match on it then I'd leave it non-case",
        "createdAt" : "2017-12-02T17:26:10Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1214564d-3ed6-48e8-92fa-170a26db1bae",
        "parentId" : "ada16ad7-8242-45e6-9ab1-2bed19431a88",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "OK, I'll change it. (but I think that adding `case` doesn't change anything in respect to pattern matching on an object)",
        "createdAt" : "2017-12-02T17:32:28Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3327ba4c-26cb-4447-910e-e8c02e9dcafe",
        "parentId" : "ada16ad7-8242-45e6-9ab1-2bed19431a88",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "The object disappeared in ae723fd208632e4ddb613a920370c010807dc1ee",
        "createdAt" : "2017-12-02T23:28:14Z",
        "updatedAt" : "2017-12-02T23:28:15Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -220,47 +267,81 @@ class SymbolIndex(\n     }\n   }\n \n-  /** Returns a list of fallback symbols that can act instead of given symbol. */\n-  private def alternatives(symbol: Symbol): List[Symbol] =\n-    symbol match {\n+  // TODO(alexey) this is not index specific and could be moved somewhere else (like Symbol-ops)\n+  case object alternatives {"
  },
  {
    "id" : "d9f9cc93-c23c-4ac2-8a06-451d8d37fc7f",
    "prId" : 78,
    "comments" : [
      {
        "id" : "1c84611a-6093-47d7-a1a8-cdeff86c8ac6",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "mtags doesn't index jvm signatures of methods, it treats them as vals. This fails for overloaded methods (as in, we may jump to wrong overload) but otherwise it works OK. Here we fallback to the `val` term for a `def` with multiple params.\r\n```scala\r\ndef add(a: Int, b: Int): Int // symbol: add(I;I)I.\r\nval add // symbol: add.\r\n```",
        "createdAt" : "2017-12-02T13:04:59Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "55cb7830-7340-41fe-b06c-26afb0b33da2",
        "parentId" : "1c84611a-6093-47d7-a1a8-cdeff86c8ac6",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "I see now. What about `apply`/`copy` is it some special case? Because their signatures are stored in the index: `_root_.a.User.apply(Ljava/lang/String;I)La/User;.`, right?",
        "createdAt" : "2017-12-02T17:23:29Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c7e556e-0af3-438f-9e63-7d4bb0857d37",
        "parentId" : "1c84611a-6093-47d7-a1a8-cdeff86c8ac6",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "apply/copy are also special but different because they are synthesized by the compiler for case classes so they have no position, in those cases we fallback to the companion/type symbols if those have positions. We should still store the exact copy/apply signatures in the index",
        "createdAt" : "2017-12-02T17:25:25Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "748e0a3b-3240-49a7-9214-33d87d5da0e6",
        "parentId" : "1c84611a-6093-47d7-a1a8-cdeff86c8ac6",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can we update this comment?",
        "createdAt" : "2017-12-02T22:39:07Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "46c3fd0f-eeb6-4a3e-ad3e-d3437e5086a9",
        "parentId" : "1c84611a-6093-47d7-a1a8-cdeff86c8ac6",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Fixed in ae723fd208632e4ddb613a920370c010807dc1ee",
        "createdAt" : "2017-12-02T23:27:45Z",
        "updatedAt" : "2017-12-02T23:27:45Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -220,47 +267,81 @@ class SymbolIndex(\n     }\n   }\n \n-  /** Returns a list of fallback symbols that can act instead of given symbol. */\n-  private def alternatives(symbol: Symbol): List[Symbol] =\n-    symbol match {\n+  // TODO(alexey) this is not index specific and could be moved somewhere else (like Symbol-ops)\n+  case object alternatives {\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    // TODO(alexey) review this list\n+    def forReferences(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopyParams\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    def forDefinition(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopy,\n+        caseClassApplyOrCopyParams,\n+        methodToTerm\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** If `case class A(a: Int)` and there is no companion object, resolve\n+     * `A` in `A(1)` to the class definition.\n+     */\n+    val caseClassCompanionToType: PartialFunction[Symbol, Symbol] = {\n       case Symbol.Global(owner, Signature.Term(name)) =>\n-        // If `case class A(a: Int)` and there is no companion object, resolve\n-        // `A` in `A(1)` to the class definition.\n-        Symbol.Global(owner, Signature.Type(name)) :: Nil\n-      case Symbol.Multi(ss) =>\n-        // If `import a.B` where `case class B()`, then\n-        // resolve to either symbol, whichever has a definition.\n-        ss\n-      case Symbol.Global(\n-          companion @ Symbol.Global(owner, signature),\n-          Signature.Method(\"apply\" | \"copy\", _)\n-          ) =>\n-        // If `case class Foo(a: Int)`, then resolve\n-        // `apply` in `Foo.apply(1)`, and\n-        // `copy` in `Foo(1).copy(a = 2)`\n-        // to the `Foo` class definition.\n-        companion :: Symbol.Global(owner, Signature.Type(signature.name)) :: Nil\n-      case Symbol.Global(owner, Signature.Method(name, _)) =>\n-        Symbol.Global(owner, Signature.Term(name)) :: Nil\n+        Symbol.Global(owner, Signature.Type(name))\n+    }\n+\n+    /** If `case class Foo(a: Int)`, then resolve\n+     * `a` in `Foo.apply(a = 1)`, and\n+     * `a` in `Foo(1).copy(a = 2)`\n+     * to the `Foo.a` primary constructor definition.\n+     */\n+    val caseClassApplyOrCopyParams: PartialFunction[Symbol, Symbol] = {\n       case Symbol.Global(\n           Symbol.Global(\n             Symbol.Global(owner, signature),\n             Signature.Method(\"copy\" | \"apply\", _)\n           ),\n           param: Signature.TermParameter\n           ) =>\n-        // If `case class Foo(a: Int)`, then resolve\n-        // `a` in `Foo.apply(a = 1)`, and\n-        // `a` in `Foo(1).copy(a = 2)`\n-        // to the `Foo.a` primary constructor definition.\n         Symbol.Global(\n           Symbol.Global(owner, Signature.Type(signature.name)),\n           param\n-        ) :: Nil\n-      case _ =>\n-        logger.info(s\"Found no alternative for ${symbol.structure}\")\n-        Nil\n+        )\n+    }\n+\n+    /** If `case class Foo(a: Int)`, then resolve\n+     * `apply` in `Foo.apply(1)`, and\n+     * `copy` in `Foo(1).copy(a = 2)`\n+     * to the `Foo` class definition.\n+     */\n+    val caseClassApplyOrCopy: PartialFunction[Symbol, Symbol] = {\n+      case Symbol.Global(\n+          Symbol.Global(owner, signature),\n+          Signature.Method(\"apply\" | \"copy\", _)\n+          ) =>\n+        Symbol.Global(owner, Signature.Type(signature.name))\n+    }\n+\n+    // FIXME(alexey) I'm not sure what this transformation does"
  },
  {
    "id" : "2015b8a7-2d3e-4e3d-8593-e776cad9903b",
    "prId" : 78,
    "comments" : [
      {
        "id" : "80be0583-b382-41e0-a6f1-a865d12f6eb0",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "We can turn this into an extension method.",
        "createdAt" : "2017-12-02T13:06:27Z",
        "updatedAt" : "2017-12-02T23:22:47Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "386fc2fd-e43d-44c4-9f29-c12ee8c02d6c",
        "parentId" : "80be0583-b382-41e0-a6f1-a865d12f6eb0",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "Done in 36123b8bd71107152b187e2f607e2006afd7a6b9, although I don't like how it turned out. It uses `createFileInWorkspaceTarget` which needs `cwd`. IMO extension methods that needs too much context are not so nice. Anyway, we can move it around later.",
        "createdAt" : "2017-12-02T23:27:20Z",
        "updatedAt" : "2017-12-02T23:27:20Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c647a84-5dcd-4d57-a58f-7bf9e68023fc",
        "parentId" : "80be0583-b382-41e0-a6f1-a865d12f6eb0",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I agree an extension method should not require too much context, and should actually not do I/O either. It's fine for now however",
        "createdAt" : "2017-12-02T23:30:52Z",
        "updatedAt" : "2017-12-02T23:30:52Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "71da2fa975b8fb36cd888c23d0a8b0214a68e679",
    "line" : null,
    "diffHunk" : "@@ -220,47 +267,81 @@ class SymbolIndex(\n     }\n   }\n \n-  /** Returns a list of fallback symbols that can act instead of given symbol. */\n-  private def alternatives(symbol: Symbol): List[Symbol] =\n-    symbol match {\n+  // TODO(alexey) this is not index specific and could be moved somewhere else (like Symbol-ops)\n+  case object alternatives {\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    // TODO(alexey) review this list\n+    def forReferences(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopyParams\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** Returns a list of fallback symbols that can act instead of given symbol. */\n+    def forDefinition(symbol: Symbol): List[Symbol] = {\n+      List(\n+        caseClassCompanionToType,\n+        caseClassApplyOrCopy,\n+        caseClassApplyOrCopyParams,\n+        methodToTerm\n+      ).flatMap { _.lift(symbol) }\n+    }\n+\n+    /** If `case class A(a: Int)` and there is no companion object, resolve\n+     * `A` in `A(1)` to the class definition.\n+     */\n+    val caseClassCompanionToType: PartialFunction[Symbol, Symbol] = {\n       case Symbol.Global(owner, Signature.Term(name)) =>\n-        // If `case class A(a: Int)` and there is no companion object, resolve\n-        // `A` in `A(1)` to the class definition.\n-        Symbol.Global(owner, Signature.Type(name)) :: Nil\n-      case Symbol.Multi(ss) =>\n-        // If `import a.B` where `case class B()`, then\n-        // resolve to either symbol, whichever has a definition.\n-        ss\n-      case Symbol.Global(\n-          companion @ Symbol.Global(owner, signature),\n-          Signature.Method(\"apply\" | \"copy\", _)\n-          ) =>\n-        // If `case class Foo(a: Int)`, then resolve\n-        // `apply` in `Foo.apply(1)`, and\n-        // `copy` in `Foo(1).copy(a = 2)`\n-        // to the `Foo` class definition.\n-        companion :: Symbol.Global(owner, Signature.Type(signature.name)) :: Nil\n-      case Symbol.Global(owner, Signature.Method(name, _)) =>\n-        Symbol.Global(owner, Signature.Term(name)) :: Nil\n+        Symbol.Global(owner, Signature.Type(name))\n+    }\n+\n+    /** If `case class Foo(a: Int)`, then resolve\n+     * `a` in `Foo.apply(a = 1)`, and\n+     * `a` in `Foo(1).copy(a = 2)`\n+     * to the `Foo.a` primary constructor definition.\n+     */\n+    val caseClassApplyOrCopyParams: PartialFunction[Symbol, Symbol] = {\n       case Symbol.Global(\n           Symbol.Global(\n             Symbol.Global(owner, signature),\n             Signature.Method(\"copy\" | \"apply\", _)\n           ),\n           param: Signature.TermParameter\n           ) =>\n-        // If `case class Foo(a: Int)`, then resolve\n-        // `a` in `Foo.apply(a = 1)`, and\n-        // `a` in `Foo(1).copy(a = 2)`\n-        // to the `Foo.a` primary constructor definition.\n         Symbol.Global(\n           Symbol.Global(owner, Signature.Type(signature.name)),\n           param\n-        ) :: Nil\n-      case _ =>\n-        logger.info(s\"Found no alternative for ${symbol.structure}\")\n-        Nil\n+        )\n+    }\n+\n+    /** If `case class Foo(a: Int)`, then resolve\n+     * `apply` in `Foo.apply(1)`, and\n+     * `copy` in `Foo(1).copy(a = 2)`\n+     * to the `Foo` class definition.\n+     */\n+    val caseClassApplyOrCopy: PartialFunction[Symbol, Symbol] = {\n+      case Symbol.Global(\n+          Symbol.Global(owner, signature),\n+          Signature.Method(\"apply\" | \"copy\", _)\n+          ) =>\n+        Symbol.Global(owner, Signature.Type(signature.name))\n+    }\n+\n+    // FIXME(alexey) I'm not sure what this transformation does\n+    val methodToTerm: PartialFunction[Symbol, Symbol] = {\n+      case Symbol.Global(owner, Signature.Method(name, _)) =>\n+        Symbol.Global(owner, Signature.Term(name))\n     }\n+  }\n+\n+  /** A workaround for positions referring to jars */\n+  def nonJarLocation(loc: l.Location): l.Location = {"
  },
  {
    "id" : "c673d0ef-06e0-4c65-b986-9a4309e6ee9d",
    "prId" : 94,
    "comments" : [
      {
        "id" : "fdf65390-00d3-48d5-a0b8-26a58669d835",
        "parentId" : null,
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "@olafurpg What do you think about turning SymbolIndex into a small trait with a curated list of methods? If you're on board with that, I can submit a pull request with just this change right away.",
        "createdAt" : "2017-12-04T16:12:27Z",
        "updatedAt" : "2017-12-04T16:12:27Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6fbef8de-fe13-410e-ae28-256c9e97e8e0",
        "parentId" : "fdf65390-00d3-48d5-a0b8-26a58669d835",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "I like it, that's a great first step ðŸ‘",
        "createdAt" : "2017-12-04T16:16:58Z",
        "updatedAt" : "2017-12-04T16:16:58Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a7ced027393b3dfbcf886dacedbf8d6c1f6df97b",
    "line" : 240,
    "diffHunk" : "@@ -1,256 +1,55 @@\n package scala.meta.languageserver.search\n \n-import java.net.URI\n-import java.nio.charset.StandardCharsets\n-import java.nio.file.Files\n-import java.nio.file.Paths\n-import java.util.concurrent.ConcurrentHashMap\n import scala.meta.languageserver.Buffers\n import scala.meta.languageserver.Effects\n-import scala.meta.languageserver.ScalametaEnrichments._\n+import scala.meta.languageserver.InMemory\n import scala.meta.languageserver.ServerConfig\n-import scala.meta.languageserver.compiler.CompilerConfig\n-import scala.meta.languageserver.mtags.Mtags\n-import scala.meta.languageserver.ScalametaLanguageServer.cacheDirectory\n-import scala.meta.languageserver.storage.LevelDBMap\n-import scala.meta.languageserver.{index => i}\n-import `scala`.meta.languageserver.index.Position\n-import `scala`.meta.languageserver.index.SymbolData\n-import com.typesafe.scalalogging.LazyLogging\n-import langserver.{types => l}\n+import scala.meta.languageserver.Sqlite\n+import scala.meta.languageserver.index.SymbolData\n import langserver.core.Notifications\n-import langserver.messages.DefinitionResult\n-import langserver.messages.ReferencesResult\n-import langserver.messages.DocumentSymbolResult\n-import org.langmeta.inputs.Input\n-import org.langmeta.internal.io.FileIO\n-import org.langmeta.internal.semanticdb.schema.Database\n-import org.langmeta.internal.semanticdb.schema.Document\n-import org.langmeta.internal.semanticdb.schema.ResolvedName\n import org.langmeta.internal.semanticdb.{schema => s}\n import org.langmeta.io.AbsolutePath\n-import org.langmeta.io.RelativePath\n-import org.langmeta.languageserver.InputEnrichments._\n-import org.langmeta.semanticdb.Signature\n import org.langmeta.semanticdb.Symbol\n \n /**\n  * A high-level wrapper around [[DocumentIndex]] and [[SymbolIndexer]].\n  *\n  * Can respond to high-level queries like \"go to definition\" and \"find references\".\n  */\n-class SymbolIndex(\n-    val symbolIndexer: SymbolIndexer,\n-    val documentIndex: DocumentIndex,\n-    cwd: AbsolutePath,\n-    notifications: Notifications,\n-    buffers: Buffers,\n-    serverConfig: ServerConfig,\n-) extends LazyLogging {\n-  private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n-    new ConcurrentHashMap[AbsolutePath, Unit]()\n-\n-  /** Returns a ResolvedName at the given location */\n-  def resolveName(\n-      path: AbsolutePath,\n-      line: Int,\n-      column: Int\n-  ): Option[ResolvedName] = {\n-    logger.info(s\"resolveName at $path:$line:$column\")\n-    for {\n-      document <- documentIndex.getDocument(path.toNIO.toUri)\n-      _ = logger.info(s\"Found document for $path\")\n-      _ <- isFreshSemanticdb(path, document)\n-      input = Input.VirtualFile(document.filename, document.contents)\n-      _ = logger.info(s\"Document for $path is fresh\")\n-      name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), symbol, _) if {\n-              val range = input.toIndexRange(position.start, position.end)\n-              logger.debug(\n-                s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\"\n-              )\n-              range.contains(line, column)\n-            } =>\n-          name\n-      }\n-    } yield name\n-  }\n-\n-  /** Returns a symbol at the given location */\n-  def findSymbol(\n-      path: AbsolutePath,\n-      line: Int,\n-      column: Int\n-  ): Option[Symbol] = {\n-    for {\n-      name <- resolveName(path, line, column)\n-      symbol = Symbol(name.symbol)\n-      _ = logger.info(s\"Matching symbol ${symbol}\")\n-    } yield symbol\n-  }\n-\n-  /** Returns symbol definition data from the index taking into account relevant alternatives */\n-  def definitionData(\n-      symbol: Symbol\n-  ): Option[SymbolData] = {\n-    (symbol :: symbol.definitionAlternative)\n-      .collectFirst {\n-        case symbolIndexer(data) if data.definition.nonEmpty =>\n-          logger.info(s\"Found definition symbol ${data.symbol}\")\n-          data\n-      }\n-  }\n-\n-  /** Returns symbol references data from the index taking into account relevant alternatives */\n-  def referencesData(\n-      symbol: Symbol\n-  ): List[SymbolData] = {\n-    (symbol :: symbol.referenceAlternatives)\n-      .collect {\n-        case symbolIndexer(data) =>\n-          if (data.symbol != symbol.syntax)\n-            logger.info(s\"Adding alternative references ${data.symbol}\")\n-          data\n-      }\n-  }\n-\n-  def indexDependencyClasspath(\n-      sourceJars: List[AbsolutePath]\n-  ): Effects.IndexSourcesClasspath = {\n-    if (!serverConfig.indexClasspath) Effects.IndexSourcesClasspath\n-    else {\n-      val sourceJarsWithJDK =\n-        if (serverConfig.indexJDK)\n-          CompilerConfig.jdkSources.fold(sourceJars)(_ :: sourceJars)\n-        else sourceJars\n-      val buf = List.newBuilder[AbsolutePath]\n-      sourceJarsWithJDK.foreach { jar =>\n-        // ensure we only index each jar once even under race conditions.\n-        // race conditions are not unlikely since multiple .compilerconfig\n-        // are typically created at the same time for each project/configuration\n-        // combination. Duplicate tasks are expensive, for example we don't want\n-        // to index the JDK twice on first startup.\n-        indexedJars.computeIfAbsent(jar, _ => buf += jar)\n-      }\n-      val sourceJarsToIndex = buf.result()\n-      // Acquire a lock on the leveldb cache only during indexing.\n-      LevelDBMap.withDB(cacheDirectory.resolve(\"leveldb\").toFile) { db =>\n-        sourceJarsToIndex.foreach { path =>\n-          logger.info(s\"Indexing classpath entry $path...\")\n-          val database = db.getOrElseUpdate[AbsolutePath, Database](path, {\n-            () =>\n-              Mtags.indexDatabase(path :: Nil)\n-          })\n-          indexDatabase(database)\n-        }\n-      }\n-      Effects.IndexSourcesClasspath\n-    }\n-  }\n-\n-  /** Register this Database to symbol indexer. */\n-  def indexDatabase(document: s.Database): Effects.IndexSemanticdb = {\n-    document.documents.foreach(indexDocument)\n-    Effects.IndexSemanticdb\n-  }\n-\n-  /**\n-   *\n-   * Register this Document to symbol indexer.\n-   *\n-   * Indexes definitions, denotations and references in this document.\n-   *\n-   * @param document Must respect the following conventions:\n-   *                 - filename must be a URI\n-   *                 - names must be sorted\n-   */\n-  def indexDocument(document: s.Document): Effects.IndexSemanticdb = {\n-    val input = Input.VirtualFile(document.filename, document.contents)\n-    // what do we put as the uri?\n-    val uri = URI.create(document.filename)\n-    documentIndex.putDocument(uri, document)\n-    document.names.foreach {\n-      // TODO(olafur) handle local symbols on the fly from a `Document` in go-to-definition\n-      // local symbols don't need to be indexed globally, by skipping them we should\n-      // def isLocalSymbol(sym: String): Boolean =\n-      // !sym.endsWith(\".\") &&\n-      //     !sym.endsWith(\"#\") &&\n-      //     !sym.endsWith(\")\")\n-      // be able to minimize the size of the global index significantly.\n-      //      case s.ResolvedName(_, sym, _) if isLocalSymbol(sym) => // Do nothing, local symbol.\n-      case s.ResolvedName(Some(s.Position(start, end)), sym, true) =>\n-        symbolIndexer.addDefinition(\n-          sym,\n-          i.Position(document.filename, Some(input.toIndexRange(start, end)))\n-        )\n-      case s.ResolvedName(Some(s.Position(start, end)), sym, false) =>\n-        symbolIndexer.addReference(\n-          document.filename,\n-          input.toIndexRange(start, end),\n-          sym\n-        )\n-      case _ =>\n-    }\n-    document.symbols.foreach {\n-      case s.ResolvedSymbol(sym, Some(denot)) =>\n-        symbolIndexer.addDenotation(\n-          sym,\n-          denot.flags,\n-          denot.name,\n-          denot.signature\n-        )\n-      case _ =>\n-    }\n-    Effects.IndexSemanticdb\n-  }\n-\n-  /**\n-   * Returns false this this document is stale.\n-   *\n-   * A document is considered stale if it's off-sync with the contents in [[buffers]].\n-   */\n-  private def isFreshSemanticdb(\n-      path: AbsolutePath,\n-      document: Document\n-  ): Option[Unit] = {\n-    val ok = Option(())\n-    val s = buffers.read(path)\n-    if (s == document.contents) ok\n-    else {\n-      // NOTE(olafur) it may be a bit annoying to bail on a single character\n-      // edit in the file. In the future, we can try more to make sense of\n-      // partially fresh files using something like edit distance.\n-      notifications.showMessage(\n-        l.MessageType.Warning,\n-        \"Please recompile for up-to-date information\"\n-      )\n-      None\n-    }\n-  }\n-\n+trait SymbolIndex {\n+  def findSymbol(path: AbsolutePath, line: Int, column: Int): Option[Symbol]\n+  def definitionData(symbol: Symbol): Option[SymbolData]\n+  def referencesData(symbol: Symbol): List[SymbolData]\n+  def indexDependencyClasspath(sourceJars: List[AbsolutePath]): Effects.IndexSourcesClasspath\n+  def indexDatabase(document: s.Database): Effects.IndexSemanticdb\n }"
  },
  {
    "id" : "794f758c-e5db-47b7-8ec6-c7a1d16e7950",
    "prId" : 116,
    "comments" : [
      {
        "id" : "f1500392-b447-4071-be67-72951c07940a",
        "parentId" : null,
        "author" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "body" : "ðŸŽ‰ ",
        "createdAt" : "2017-12-12T15:47:48Z",
        "updatedAt" : "2017-12-14T16:33:49Z",
        "lastEditedBy" : {
          "login" : "gabro",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/691940?u=5aaf176f5da60764f857b8f8c6842217f737627f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e62556cb-9e71-40c2-82e5-809e901178d9",
        "parentId" : "f1500392-b447-4071-be67-72951c07940a",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "hehe guess that one wasn't very popular ðŸ˜… ",
        "createdAt" : "2017-12-12T15:56:42Z",
        "updatedAt" : "2017-12-14T16:33:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cb57161c-209d-4525-99e8-9b68cb4a2da9",
        "parentId" : "f1500392-b447-4071-be67-72951c07940a",
        "author" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "body" : "@olafurpg just check https://github.com/laughedelic/atom-ide-scala/issues/20 and https://github.com/laughedelic/atom-ide-scala/pull/22 ðŸ˜‰ ",
        "createdAt" : "2017-12-12T15:59:44Z",
        "updatedAt" : "2017-12-14T16:33:49Z",
        "lastEditedBy" : {
          "login" : "laughedelic",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/766656?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e486a926-330c-490e-b879-663895904280",
        "parentId" : "f1500392-b447-4071-be67-72951c07940a",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : ":joy: @laughedelic ",
        "createdAt" : "2017-12-12T16:39:40Z",
        "updatedAt" : "2017-12-14T16:33:49Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2ad41c2943b988f4013b1b0d29478092b349360a",
    "line" : 4,
    "diffHunk" : "@@ -60,13 +60,11 @@ class SymbolIndex(\n     for {\n       document <- documentIndex.getDocument(path.toNIO.toUri)\n       _ = logger.info(s\"Found document for $path\")\n-      _ <- isFreshSemanticdb(path, document)"
  },
  {
    "id" : "64382f01-4cd2-466e-b753-461a3d236770",
    "prId" : 132,
    "comments" : [
      {
        "id" : "4301c31f-7e46-4d26-9ab2-3e3c6541dd5b",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "If you rebase on top of master then s/AbsolutePath/Uri",
        "createdAt" : "2017-12-16T09:22:51Z",
        "updatedAt" : "2017-12-17T08:08:35Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e5b788f0-69e3-4c79-9080-70abd2dcb5ec",
        "parentId" : "4301c31f-7e46-4d26-9ab2-3e3c6541dd5b",
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2017-12-17T02:30:16Z",
        "updatedAt" : "2017-12-17T08:08:35Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a1110f2f43ba9c63cdfb6ee4e3a2d756c6f2b37b",
    "line" : null,
    "diffHunk" : "@@ -1,223 +1,39 @@\n package scala.meta.languageserver.search\n \n-import java.net.URI\n-import java.nio.charset.StandardCharsets\n-import java.nio.file.Files\n-import java.nio.file.Paths\n-import java.util.concurrent.ConcurrentHashMap\n import scala.meta.languageserver.Buffers\n import scala.meta.languageserver.Effects\n-import scala.meta.languageserver.ScalametaEnrichments._\n import scala.meta.languageserver.ServerConfig\n-import scala.meta.languageserver.compiler.CompilerConfig\n-import scala.meta.languageserver.mtags.Mtags\n-import scala.meta.languageserver.ScalametaLanguageServer.cacheDirectory\n-import scala.meta.languageserver.storage.LevelDBMap\n-import scala.meta.languageserver.{index => i}\n-import `scala`.meta.languageserver.index.Position\n-import `scala`.meta.languageserver.index.SymbolData\n-import com.typesafe.scalalogging.LazyLogging\n-import langserver.{types => l}\n+import scala.meta.languageserver.index.SymbolData\n import langserver.core.Notifications\n-import langserver.messages.DefinitionResult\n-import langserver.messages.ReferencesResult\n-import langserver.messages.DocumentSymbolResult\n-import org.langmeta.inputs.Input\n-import org.langmeta.internal.io.FileIO\n-import org.langmeta.internal.semanticdb.schema.Database\n-import org.langmeta.internal.semanticdb.schema.Document\n-import org.langmeta.internal.semanticdb.schema.ResolvedName\n import org.langmeta.internal.semanticdb.{schema => s}\n import org.langmeta.io.AbsolutePath\n-import org.langmeta.io.RelativePath\n-import org.langmeta.languageserver.InputEnrichments._\n-import org.langmeta.semanticdb.Signature\n import org.langmeta.semanticdb.Symbol\n \n /**\n  * A high-level wrapper around [[DocumentIndex]] and [[SymbolIndexer]].\n  *\n  * Can respond to high-level queries like \"go to definition\" and \"find references\".\n  */\n-class SymbolIndex(\n-    val symbolIndexer: SymbolIndexer,\n-    val documentIndex: DocumentIndex,\n-    cwd: AbsolutePath,\n-    notifications: Notifications,\n-    buffers: Buffers,\n-    serverConfig: ServerConfig,\n-) extends LazyLogging {\n-  private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n-    new ConcurrentHashMap[AbsolutePath, Unit]()\n-\n-  /** Returns a ResolvedName at the given location */\n-  def resolveName(\n-      path: AbsolutePath,\n-      line: Int,\n-      column: Int\n-  ): Option[ResolvedName] = {\n-    logger.info(s\"resolveName at $path:$line:$column\")\n-    for {\n-      document <- documentIndex.getDocument(path.toNIO.toUri)\n-      _ = logger.info(s\"Found document for $path\")\n-      input = Input.VirtualFile(document.filename, document.contents)\n-      name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), symbol, _) if {\n-              val range = input.toIndexRange(position.start, position.end)\n-              logger.trace(\n-                s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\"\n-              )\n-              range.contains(line, column)\n-            } =>\n-          name\n-      }\n-    } yield name\n-  }\n-\n-  /** Returns a symbol at the given location */\n-  def findSymbol(\n-      path: AbsolutePath,\n-      line: Int,\n-      column: Int\n-  ): Option[Symbol] = {\n-    for {\n-      name <- resolveName(path, line, column)\n-      symbol = Symbol(name.symbol)\n-      _ = logger.info(s\"Matching symbol ${symbol}\")\n-    } yield symbol\n-  }\n-\n-  /** Returns symbol definition data from the index taking into account relevant alternatives */\n-  def definitionData(\n-      symbol: Symbol\n-  ): Option[SymbolData] = {\n-    (symbol :: symbol.definitionAlternative)\n-      .collectFirst {\n-        case symbolIndexer(data) if data.definition.nonEmpty =>\n-          logger.info(s\"Found definition symbol ${data.symbol}\")\n-          data\n-      }\n-  }\n-\n-  /** Returns symbol references data from the index taking into account relevant alternatives */\n-  def referencesData(\n-      symbol: Symbol\n-  ): List[SymbolData] = {\n-    (symbol :: symbol.referenceAlternatives)\n-      .collect {\n-        case symbolIndexer(data) =>\n-          if (data.symbol != symbol.syntax)\n-            logger.info(s\"Adding alternative references ${data.symbol}\")\n-          data\n-      }\n-  }\n-\n+trait SymbolIndex {\n+  def findSymbol(path: AbsolutePath, line: Int, column: Int): Option[Symbol]"
  },
  {
    "id" : "e2e77831-6f0a-4112-b1f3-e979b7226bc6",
    "prId" : 132,
    "comments" : [
      {
        "id" : "a9eccf64-a91c-4dc6-9057-b8603ad1b65d",
        "parentId" : null,
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Can we move the docstrings from the in-memory index to here?",
        "createdAt" : "2017-12-16T09:23:43Z",
        "updatedAt" : "2017-12-17T08:08:35Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3168cf8e-3e05-4d9c-a001-bfc7dc9dfe50",
        "parentId" : "a9eccf64-a91c-4dc6-9057-b8603ad1b65d",
        "author" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2017-12-17T02:30:21Z",
        "updatedAt" : "2017-12-17T08:08:35Z",
        "lastEditedBy" : {
          "login" : "xeno-by",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/609152?u=20bb3a58b554d0984a33eaa519c5cf3fd09e88fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a1110f2f43ba9c63cdfb6ee4e3a2d756c6f2b37b",
    "line" : null,
    "diffHunk" : "@@ -1,223 +1,39 @@\n package scala.meta.languageserver.search\n \n-import java.net.URI\n-import java.nio.charset.StandardCharsets\n-import java.nio.file.Files\n-import java.nio.file.Paths\n-import java.util.concurrent.ConcurrentHashMap\n import scala.meta.languageserver.Buffers\n import scala.meta.languageserver.Effects\n-import scala.meta.languageserver.ScalametaEnrichments._\n import scala.meta.languageserver.ServerConfig\n-import scala.meta.languageserver.compiler.CompilerConfig\n-import scala.meta.languageserver.mtags.Mtags\n-import scala.meta.languageserver.ScalametaLanguageServer.cacheDirectory\n-import scala.meta.languageserver.storage.LevelDBMap\n-import scala.meta.languageserver.{index => i}\n-import `scala`.meta.languageserver.index.Position\n-import `scala`.meta.languageserver.index.SymbolData\n-import com.typesafe.scalalogging.LazyLogging\n-import langserver.{types => l}\n+import scala.meta.languageserver.index.SymbolData\n import langserver.core.Notifications\n-import langserver.messages.DefinitionResult\n-import langserver.messages.ReferencesResult\n-import langserver.messages.DocumentSymbolResult\n-import org.langmeta.inputs.Input\n-import org.langmeta.internal.io.FileIO\n-import org.langmeta.internal.semanticdb.schema.Database\n-import org.langmeta.internal.semanticdb.schema.Document\n-import org.langmeta.internal.semanticdb.schema.ResolvedName\n import org.langmeta.internal.semanticdb.{schema => s}\n import org.langmeta.io.AbsolutePath\n-import org.langmeta.io.RelativePath\n-import org.langmeta.languageserver.InputEnrichments._\n-import org.langmeta.semanticdb.Signature\n import org.langmeta.semanticdb.Symbol\n \n /**\n  * A high-level wrapper around [[DocumentIndex]] and [[SymbolIndexer]].\n  *\n  * Can respond to high-level queries like \"go to definition\" and \"find references\".\n  */\n-class SymbolIndex(\n-    val symbolIndexer: SymbolIndexer,\n-    val documentIndex: DocumentIndex,\n-    cwd: AbsolutePath,\n-    notifications: Notifications,\n-    buffers: Buffers,\n-    serverConfig: ServerConfig,\n-) extends LazyLogging {\n-  private val indexedJars: ConcurrentHashMap[AbsolutePath, Unit] =\n-    new ConcurrentHashMap[AbsolutePath, Unit]()\n-\n-  /** Returns a ResolvedName at the given location */\n-  def resolveName(\n-      path: AbsolutePath,\n-      line: Int,\n-      column: Int\n-  ): Option[ResolvedName] = {\n-    logger.info(s\"resolveName at $path:$line:$column\")\n-    for {\n-      document <- documentIndex.getDocument(path.toNIO.toUri)\n-      _ = logger.info(s\"Found document for $path\")\n-      input = Input.VirtualFile(document.filename, document.contents)\n-      name <- document.names.collectFirst {\n-        case name @ ResolvedName(Some(position), symbol, _) if {\n-              val range = input.toIndexRange(position.start, position.end)\n-              logger.trace(\n-                s\"${document.filename.replaceFirst(\".*/\", \"\")} [${range.pretty}] ${symbol}\"\n-              )\n-              range.contains(line, column)\n-            } =>\n-          name\n-      }\n-    } yield name\n-  }\n-\n-  /** Returns a symbol at the given location */\n-  def findSymbol(\n-      path: AbsolutePath,\n-      line: Int,\n-      column: Int\n-  ): Option[Symbol] = {\n-    for {\n-      name <- resolveName(path, line, column)\n-      symbol = Symbol(name.symbol)\n-      _ = logger.info(s\"Matching symbol ${symbol}\")\n-    } yield symbol\n-  }\n-\n-  /** Returns symbol definition data from the index taking into account relevant alternatives */\n-  def definitionData(\n-      symbol: Symbol\n-  ): Option[SymbolData] = {\n-    (symbol :: symbol.definitionAlternative)\n-      .collectFirst {\n-        case symbolIndexer(data) if data.definition.nonEmpty =>\n-          logger.info(s\"Found definition symbol ${data.symbol}\")\n-          data\n-      }\n-  }\n-\n-  /** Returns symbol references data from the index taking into account relevant alternatives */\n-  def referencesData(\n-      symbol: Symbol\n-  ): List[SymbolData] = {\n-    (symbol :: symbol.referenceAlternatives)\n-      .collect {\n-        case symbolIndexer(data) =>\n-          if (data.symbol != symbol.syntax)\n-            logger.info(s\"Adding alternative references ${data.symbol}\")\n-          data\n-      }\n-  }\n-\n+trait SymbolIndex {\n+  def findSymbol(path: AbsolutePath, line: Int, column: Int): Option[Symbol]\n+  def definitionData(symbol: Symbol): Option[SymbolData]\n+  def referencesData(symbol: Symbol): List[SymbolData]\n   def indexDependencyClasspath(\n       sourceJars: List[AbsolutePath]\n-  ): Effects.IndexSourcesClasspath = {\n-    if (!serverConfig.indexClasspath) Effects.IndexSourcesClasspath\n-    else {\n-      val sourceJarsWithJDK =\n-        if (serverConfig.indexJDK)\n-          CompilerConfig.jdkSources.fold(sourceJars)(_ :: sourceJars)\n-        else sourceJars\n-      val buf = List.newBuilder[AbsolutePath]\n-      sourceJarsWithJDK.foreach { jar =>\n-        // ensure we only index each jar once even under race conditions.\n-        // race conditions are not unlikely since multiple .compilerconfig\n-        // are typically created at the same time for each project/configuration\n-        // combination. Duplicate tasks are expensive, for example we don't want\n-        // to index the JDK twice on first startup.\n-        indexedJars.computeIfAbsent(jar, _ => buf += jar)\n-      }\n-      val sourceJarsToIndex = buf.result()\n-      // Acquire a lock on the leveldb cache only during indexing.\n-      LevelDBMap.withDB(cacheDirectory.resolve(\"leveldb\").toFile) { db =>\n-        sourceJarsToIndex.foreach { path =>\n-          logger.info(s\"Indexing classpath entry $path...\")\n-          val database = db.getOrElseUpdate[AbsolutePath, Database](path, {\n-            () =>\n-              Mtags.indexDatabase(path :: Nil)\n-          })\n-          indexDatabase(database)\n-        }\n-      }\n-      Effects.IndexSourcesClasspath\n-    }\n-  }\n-\n-  /** Register this Database to symbol indexer. */\n-  def indexDatabase(document: s.Database): Effects.IndexSemanticdb = {\n-    document.documents.foreach(indexDocument)\n-    Effects.IndexSemanticdb\n-  }\n-\n-  /**\n-   *\n-   * Register this Document to symbol indexer.\n-   *\n-   * Indexes definitions, denotations and references in this document.\n-   *\n-   * @param document Must respect the following conventions:\n-   *                 - filename must be a URI\n-   *                 - names must be sorted\n-   */\n-  def indexDocument(document: s.Document): Effects.IndexSemanticdb = {\n-    val input = Input.VirtualFile(document.filename, document.contents)\n-    // what do we put as the uri?\n-    val uri = URI.create(document.filename)\n-    documentIndex.putDocument(uri, document)\n-    document.names.foreach {\n-      // TODO(olafur) handle local symbols on the fly from a `Document` in go-to-definition\n-      // local symbols don't need to be indexed globally, by skipping them we should\n-      // def isLocalSymbol(sym: String): Boolean =\n-      // !sym.endsWith(\".\") &&\n-      //     !sym.endsWith(\"#\") &&\n-      //     !sym.endsWith(\")\")\n-      // be able to minimize the size of the global index significantly.\n-      //      case s.ResolvedName(_, sym, _) if isLocalSymbol(sym) => // Do nothing, local symbol.\n-      case s.ResolvedName(Some(s.Position(start, end)), sym, true) =>\n-        symbolIndexer.addDefinition(\n-          sym,\n-          i.Position(document.filename, Some(input.toIndexRange(start, end)))\n-        )\n-      case s.ResolvedName(Some(s.Position(start, end)), sym, false) =>\n-        symbolIndexer.addReference(\n-          document.filename,\n-          input.toIndexRange(start, end),\n-          sym\n-        )\n-      case _ =>\n-    }\n-    document.symbols.foreach {\n-      case s.ResolvedSymbol(sym, Some(denot)) =>\n-        symbolIndexer.addDenotation(\n-          sym,\n-          denot.flags,\n-          denot.name,\n-          denot.signature\n-        )\n-      case _ =>\n-    }\n-    Effects.IndexSemanticdb\n-  }\n-\n+  ): Effects.IndexSourcesClasspath\n+  def indexDatabase(document: s.Database): Effects.IndexSemanticdb"
  }
]