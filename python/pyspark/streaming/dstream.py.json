[{
  "comments": [{
    "author": {
      "login": "giwa"
    },
    "body": "I am not sure print_ is needed for PythonSparkStreaming.\nPlease remove \"(label)\"\n\n```\ngetattr(self._jdstream, \"print\")(label)\n```\n\nI put this input parameter for debugging purpose to make sure which print is called when I use many print operation.\ne.g\n\n```\n-------------------------------------------\nTime: 123456789\n-------------------------------------------\ncalled after reduce\n(\"a\", 1)\n(\"b\", 22)\n```\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-26T09:07:53Z",
    "diffHunk": "@@ -0,0 +1,400 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction, RDDFunction2\n+from pyspark.rdd import portable_hash\n+from pyspark.streaming.duration import Seconds\n+\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def print_(self, label=None):\n+        \"\"\"\n+        Since print is reserved name for python, we cannot define a \"print\" method function.\n+        This function prints serialized data in RDD in DStream because Scala and Java cannot\n+        deserialized pickled python object. Please use DStream.pyprint() to print results.\n+\n+        Call DStream.print() and this function will print byte array in the DStream\n+        \"\"\"\n+        # a hack to call print function in DStream\n+        getattr(self._jdstream, \"print\")(label)"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "giwa"
    },
    "body": "c should be capital\n'C'onvert\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-28T20:10:35Z",
    "diffHunk": "@@ -0,0 +1,632 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda rdd, _: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, lambda a, _, t: func(a, t), self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(rdd, time):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(time / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self.take(1)[0]\n+\n+    def take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        rdds = []\n+\n+        def take(rdd, _):\n+            if rdd:\n+                rdds.append(rdd)\n+                if len(rdds) == n:\n+                    # FIXME: NPE in JVM\n+                    self._ssc.stop(False)\n+        self.foreachRDD(take)\n+        self._ssc.start()\n+        self._ssc.awaitTermination()\n+        return rdds\n+\n+    def collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(rdd, time):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(rdd, time):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a SequenceFile of serialized objects. The serializer\n+        used is L{pyspark.serializers.PickleSerializer}, default batch size\n+        is 10.\n+        \"\"\"\n+\n+        def saveAsPickleFile(rdd, time):\n+            \"\"\"\n+            Closure to save element in RDD in the DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsPickleFile(path)\n+\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, lambda a, t: func(a), True)\n+\n+    def transformWithTime(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, func, False)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, lambda a, b, t: func(a, b), self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartitions(self, numPartitions):\n+        \"\"\"\n+        Return a new DStream with an increased or decreased level of parallelism. Each RDD in the\n+        returned DStream has exactly numPartitions partitions.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.repartition(numPartitions))\n+\n+    @property\n+    def _slideDuration(self):\n+        \"\"\"\n+        Return the slideDuration in seconds of this DStream\n+        \"\"\"\n+        return self._jdstream.dstream().slideDuration().milliseconds() / 1000.0\n+\n+    def union(self, other):\n+        \"\"\"\n+        Return a new DStream by unifying data of another DStream with this DStream.\n+        @param other Another DStream having the same interval (i.e., slideDuration) as this DStream.\n+        \"\"\"\n+        if self._slideDuration != other._slideDuration:\n+            raise ValueError(\"the two DStream should have same slide duration\")\n+        return self.transformWith(lambda a, b: a.union(b), other, True)\n+\n+    def cogroup(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'cogroup' between RDDs of `this`\n+        DStream and `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions` partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.cogroup(b, numPartitions), other)\n+\n+    def join(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.join(b, numPartitions), other)\n+\n+    def leftOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'left outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.leftOuterJion(b, numPartitions), other)\n+\n+    def rightOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'right outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.rightOuterJoin(b, numPartitions), other)\n+\n+    def fullOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'full outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.fullOuterJoin(b, numPartitions), other)\n+\n+    def _jtime(self, timestamp):\n+        \"\"\" convert datetime or unix_timestamp into Time"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Shouldnt there be a doc string for the DStream class? Please copy the Scala DStream doc string.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:35:06Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):",
    "line": 34
  }, {
    "author": {
      "login": "davies"
    },
    "body": "done\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T07:44:50Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):",
    "line": 34
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This doc string is very misleading. This sounds as if it returns the total running count of all elements received in a stream. Please copy the Scala class doc string.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:37:00Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream."
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "`sum` doesnt exist in the Scala/Java API, lets not add this to the Python API as of now. \n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:37:59Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Can you copy the Scala/ Java docstrings for all these functions? Some of them seem to be copied from the rdd docs and are inconsistent with the streaming doc strings.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:39:09Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "There is a slight inconsistency with this approach of the setting the default of number of partitions. The Scala/Java DStream API uses an older way of determining the number of partitions, which uses the default parallelism configuration (see code in PairDStreamFunctions). But this uses the smarter default partitions based on the number of partitions of the pre-shuffle RDD. There maybe significant performance difference. It maybe a good idea to keep things consistent, and consider improving this in a different JIRA+PR. \n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:44:05Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Unless absolutely necessary, lets not add such private, test-only methods to the dstream.py\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:45:06Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "It is clearer to say \"Persist the RDDs of this DStream...\" similar to the Scala doc.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:46:13Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER})."
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Wrong doc string, copy scala doc string.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:46:45Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This method does not exist for scala / java dstream API. do you think this is super important? If not, lets have this as a private method, so that we can expose it if we want later. \n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:48:52Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Should be `repartition`, not `repartitions`\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:49:16Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a SequenceFile of serialized objects. The serializer\n+        used is L{pyspark.serializers.PickleSerializer}, default batch size\n+        is 10.\n+        \"\"\"\n+\n+        def saveAsPickleFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in the DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsPickleFile(path)\n+\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, lambda t, a: func(a), True)\n+\n+    def transformWithTime(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, func, False)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, lambda t, a, b: func(a, b), self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartitions(self, numPartitions):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This does not exist in Scala/Java API. Lets not add this. Instead can `transform` be an operation which can take an rdd and an optional parameter for time? \n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:50:24Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a SequenceFile of serialized objects. The serializer\n+        used is L{pyspark.serializers.PickleSerializer}, default batch size\n+        is 10.\n+        \"\"\"\n+\n+        def saveAsPickleFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in the DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsPickleFile(path)\n+\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, lambda t, a: func(a), True)\n+\n+    def transformWithTime(self, func):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Please add comments on what this method checks. Or just call it `_validate_window_params`\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:54:31Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a SequenceFile of serialized objects. The serializer\n+        used is L{pyspark.serializers.PickleSerializer}, default batch size\n+        is 10.\n+        \"\"\"\n+\n+        def saveAsPickleFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in the DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsPickleFile(path)\n+\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, lambda t, a: func(a), True)\n+\n+    def transformWithTime(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, func, False)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, lambda t, a, b: func(a, b), self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartitions(self, numPartitions):\n+        \"\"\"\n+        Return a new DStream with an increased or decreased level of parallelism. Each RDD in the\n+        returned DStream has exactly numPartitions partitions.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.repartition(numPartitions))\n+\n+    @property\n+    def _slideDuration(self):\n+        \"\"\"\n+        Return the slideDuration in seconds of this DStream\n+        \"\"\"\n+        return self._jdstream.dstream().slideDuration().milliseconds() / 1000.0\n+\n+    def union(self, other):\n+        \"\"\"\n+        Return a new DStream by unifying data of another DStream with this DStream.\n+        @param other Another DStream having the same interval (i.e., slideDuration) as this DStream.\n+        \"\"\"\n+        if self._slideDuration != other._slideDuration:\n+            raise ValueError(\"the two DStream should have same slide duration\")\n+        return self.transformWith(lambda a, b: a.union(b), other, True)\n+\n+    def cogroup(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'cogroup' between RDDs of `this`\n+        DStream and `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions` partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.cogroup(b, numPartitions), other)\n+\n+    def join(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.join(b, numPartitions), other)\n+\n+    def leftOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'left outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.leftOuterJoin(b, numPartitions), other)\n+\n+    def rightOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'right outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.rightOuterJoin(b, numPartitions), other)\n+\n+    def fullOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'full outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.fullOuterJoin(b, numPartitions), other)\n+\n+    def _jtime(self, timestamp):\n+        \"\"\" Convert datetime or unix_timestamp into Time\n+        \"\"\"\n+        if isinstance(timestamp, datetime):\n+            timestamp = time.mktime(timestamp.timetuple())\n+        return self.ctx._jvm.Time(long(timestamp * 1000))\n+\n+    def slice(self, begin, end):\n+        \"\"\"\n+        Return all the RDDs between 'begin' to 'end' (both included)\n+\n+        `begin`, `end` could be datetime.datetime() or unix_timestamp\n+        \"\"\"\n+        jrdds = self._jdstream.slice(self._jtime(begin), self._jtime(end))\n+        return [RDD(jrdd, self.ctx, self._jrdd_deserializer) for jrdd in jrdds]\n+\n+    def _check_window(self, window, slide):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Please add a few lines about the design of this TransformedDStream, especially about the pipelining of transformed dstreams by squashing of transform functions.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T00:57:24Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a SequenceFile of serialized objects. The serializer\n+        used is L{pyspark.serializers.PickleSerializer}, default batch size\n+        is 10.\n+        \"\"\"\n+\n+        def saveAsPickleFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in the DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsPickleFile(path)\n+\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, lambda t, a: func(a), True)\n+\n+    def transformWithTime(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, func, False)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, lambda t, a, b: func(a, b), self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartitions(self, numPartitions):\n+        \"\"\"\n+        Return a new DStream with an increased or decreased level of parallelism. Each RDD in the\n+        returned DStream has exactly numPartitions partitions.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.repartition(numPartitions))\n+\n+    @property\n+    def _slideDuration(self):\n+        \"\"\"\n+        Return the slideDuration in seconds of this DStream\n+        \"\"\"\n+        return self._jdstream.dstream().slideDuration().milliseconds() / 1000.0\n+\n+    def union(self, other):\n+        \"\"\"\n+        Return a new DStream by unifying data of another DStream with this DStream.\n+        @param other Another DStream having the same interval (i.e., slideDuration) as this DStream.\n+        \"\"\"\n+        if self._slideDuration != other._slideDuration:\n+            raise ValueError(\"the two DStream should have same slide duration\")\n+        return self.transformWith(lambda a, b: a.union(b), other, True)\n+\n+    def cogroup(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'cogroup' between RDDs of `this`\n+        DStream and `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions` partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.cogroup(b, numPartitions), other)\n+\n+    def join(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.join(b, numPartitions), other)\n+\n+    def leftOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'left outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.leftOuterJoin(b, numPartitions), other)\n+\n+    def rightOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'right outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.rightOuterJoin(b, numPartitions), other)\n+\n+    def fullOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'full outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.fullOuterJoin(b, numPartitions), other)\n+\n+    def _jtime(self, timestamp):\n+        \"\"\" Convert datetime or unix_timestamp into Time\n+        \"\"\"\n+        if isinstance(timestamp, datetime):\n+            timestamp = time.mktime(timestamp.timetuple())\n+        return self.ctx._jvm.Time(long(timestamp * 1000))\n+\n+    def slice(self, begin, end):\n+        \"\"\"\n+        Return all the RDDs between 'begin' to 'end' (both included)\n+\n+        `begin`, `end` could be datetime.datetime() or unix_timestamp\n+        \"\"\"\n+        jrdds = self._jdstream.slice(self._jtime(begin), self._jtime(end))\n+        return [RDD(jrdd, self.ctx, self._jrdd_deserializer) for jrdd in jrdds]\n+\n+    def _check_window(self, window, slide):\n+        duration = self._jdstream.dstream().slideDuration().milliseconds()\n+        if int(window * 1000) % duration != 0:\n+            raise ValueError(\"windowDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+        if slide and int(slide * 1000) % duration != 0:\n+            raise ValueError(\"slideDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+\n+    def window(self, windowDuration, slideDuration=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains all the elements in seen in a\n+        sliding window of time over this DStream.\n+\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        \"\"\"\n+        self._check_window(windowDuration, slideDuration)\n+        d = self._ssc._jduration(windowDuration)\n+        if slideDuration is None:\n+            return DStream(self._jdstream.window(d), self._ssc, self._jrdd_deserializer)\n+        s = self._ssc._jduration(slideDuration)\n+        return DStream(self._jdstream.window(d, s), self._ssc, self._jrdd_deserializer)\n+\n+    def reduceByWindow(self, reduceFunc, invReduceFunc, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated by reducing all\n+        elements in a sliding window over this DStream.\n+\n+        if `invReduceFunc` is not None, the reduction is done incrementally\n+        using the old window's reduced value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+         This is more efficient than `invReduceFunc` is None.\n+\n+        @param reduceFunc associative reduce function\n+        @param invReduceFunc inverse reduce function of `reduceFunc`\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        \"\"\"\n+        keyed = self.map(lambda x: (1, x))\n+        reduced = keyed.reduceByKeyAndWindow(reduceFunc, invReduceFunc,\n+                                             windowDuration, slideDuration, 1)\n+        return reduced.map(lambda (k, v): v)\n+\n+    def countByWindow(self, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated\n+        by counting the number of elements in a window over this DStream.\n+        windowDuration and slideDuration are as defined in the window() operation.\n+\n+        This is equivalent to window(windowDuration, slideDuration).count(),\n+        but will be more efficient if window is large.\n+        \"\"\"\n+        return self.map(lambda x: 1).reduceByWindow(operator.add, operator.sub,\n+                                                    windowDuration, slideDuration)\n+\n+    def countByValueAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the count of distinct elements in\n+        RDDs in a sliding window over this DStream.\n+\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions  number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        keyed = self.map(lambda x: (x, 1))\n+        counted = keyed.reduceByKeyAndWindow(operator.add, operator.sub,\n+                                             windowDuration, slideDuration, numPartitions)\n+        return counted.filter(lambda (k, v): v > 0).count()\n+\n+    def groupByKeyAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying `groupByKey` over a sliding window.\n+        Similar to `DStream.groupByKey()`, but applies it over a sliding window.\n+\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions  Number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        ls = self.mapValues(lambda x: [x])\n+        grouped = ls.reduceByKeyAndWindow(lambda a, b: a.extend(b) or a, lambda a, b: a[len(b):],\n+                                          windowDuration, slideDuration, numPartitions)\n+        return grouped.mapValues(ResultIterable)\n+\n+    def reduceByKeyAndWindow(self, func, invFunc, windowDuration, slideDuration=None,\n+                             numPartitions=None, filterFunc=None):\n+        \"\"\"\n+        Return a new DStream by applying incremental `reduceByKey` over a sliding window.\n+\n+        The reduced value of over a new window is calculated using the old window's reduce value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+\n+        `invFunc` can be None, then it will reduce all the RDDs in window, could be slower\n+        than having `invFunc`.\n+\n+        @param reduceFunc     associative reduce function\n+        @param invReduceFunc  inverse function of `reduceFunc`\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions  number of partitions of each RDD in the new DStream.\n+        @param filterFunc     function to filter expired key-value pairs;\n+                              only pairs that satisfy the function are retained\n+                              set this to null if you do not want to filter\n+        \"\"\"\n+        self._check_window(windowDuration, slideDuration)\n+        reduced = self.reduceByKey(func)\n+\n+        def reduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            r = a.union(b).reduceByKey(func, numPartitions) if a else b\n+            if filterFunc:\n+                r = r.filter(filterFunc)\n+            return r\n+\n+        def invReduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            joined = a.leftOuterJoin(b, numPartitions)\n+            return joined.mapValues(lambda (v1, v2): invFunc(v1, v2) if v2 is not None else v1)\n+\n+        jreduceFunc = RDDFunction(self.ctx, reduceFunc, reduced._jrdd_deserializer)\n+        if invReduceFunc:\n+            jinvReduceFunc = RDDFunction(self.ctx, invReduceFunc, reduced._jrdd_deserializer)\n+        else:\n+            jinvReduceFunc = None\n+        if slideDuration is None:\n+            slideDuration = self._slideDuration\n+        dstream = self.ctx._jvm.PythonReducedWindowedDStream(reduced._jdstream.dstream(),\n+                                                             jreduceFunc, jinvReduceFunc,\n+                                                             self._ssc._jduration(windowDuration),\n+                                                             self._ssc._jduration(slideDuration))\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+    def updateStateByKey(self, updateFunc, numPartitions=None):\n+        \"\"\"\n+        Return a new \"state\" DStream where the state for each key is updated by applying\n+        the given function on the previous state of the key and the new values of the key.\n+\n+        @param updateFunc State update function ([(k, vs, s)] -> [(k, s)]).\n+                          If `s` is None, then `k` will be eliminated.\n+        \"\"\"\n+        def reduceFunc(t, a, b):\n+            if a is None:\n+                g = b.groupByKey(numPartitions).map(lambda (k, vs): (k, list(vs), None))\n+            else:\n+                g = a.cogroup(b, numPartitions)\n+                g = g.map(lambda (k, (va, vb)): (k, list(vb), list(va)[0] if len(va) else None))\n+            state = g.mapPartitions(lambda x: updateFunc(x))\n+            return state.filter(lambda (k, v): v is not None)\n+\n+        jreduceFunc = RDDFunction(self.ctx, reduceFunc,\n+                                  self.ctx.serializer, self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonStateDStream(self._jdstream.dstream(), jreduceFunc)\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+\n+class TransformedDStream(DStream):"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "done\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T07:45:15Z",
    "diffHunk": "@@ -0,0 +1,633 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream which contains the number of elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)]).sum()\n+\n+    def sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Pass each value in the key-value pair DStream through flatMap function\n+        without changing the keys: this also retains the original RDD's partition.\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each partition of this DStream,\n+        while tracking the index of the original partition.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream by reduceing the elements of this RDD using the specified\n+        commutative and associative binary operator.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Merge the value for each key using an associative reduce function.\n+\n+        This will also perform the merging locally on each mapper before\n+        sending results to reducer, similarly to a \"combiner\" in MapReduce.\n+\n+        Output will be hash-partitioned with C{numPartitions} partitions, or\n+        the default parallelism level if C{numPartitions} is not specified.\n+        \"\"\"\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Count the number of elements for each key, and return the result to the\n+        master as a dictionary\n+        \"\"\"\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream partitioned using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreach(self, func):\n+        return self.foreachRDD(lambda _, rdd: rdd.foreach(func))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply userdefined function to all RDD in a DStream.\n+        This python implementation could be expensive because it uses callback server\n+        in order to apply function to RDD in DStream.\n+        This is an output operator, so this DStream will be registered as an output\n+        stream and there materialized.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream. This is an output\n+        operator, so this DStream will be registered as an output stream and there materialized.\n+        \"\"\"\n+        def takeAndPrint(timestamp, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % datetime.fromtimestamp(timestamp / 1000.0)\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def _first(self):\n+        \"\"\"\n+        Return the first RDD in the stream.\n+        \"\"\"\n+        return self._take(1)[0]\n+\n+    def _take(self, n):\n+        \"\"\"\n+        Return the first `n` RDDs in the stream (will start and stop).\n+        \"\"\"\n+        results = []\n+\n+        def take(_, rdd):\n+            if rdd and len(results) < n:\n+                results.extend(rdd.take(n - len(results)))\n+\n+        self.foreachRDD(take)\n+\n+        self._ssc.start()\n+        while len(results) < n:\n+            time.sleep(0.01)\n+        self._ssc.stop(False, True)\n+        return results\n+\n+    def _collect(self):\n+        \"\"\"\n+        Collect each RDDs into the returned list.\n+\n+        :return: list, which will have the collected items.\n+        \"\"\"\n+        result = []\n+\n+        def get_output(_, rdd):\n+            r = rdd.collect()\n+            result.append(r)\n+        self.foreachRDD(get_output)\n+        return result\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a map function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Pass each value in the key-value pair RDD through a flatMap function\n+        without changing the keys; this also retains the original RDD's\n+        partitioning.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream. Applying glom() to an RDD coalesces all\n+        elements within each partition into an list.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist this DStream with the default storage level (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Set this DStream's storage level to persist its values across operations\n+        after the first time it is computed. This can only be used to assign\n+        a new storage level if the DStream does not have a storage level set yet.\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Mark this DStream for checkpointing. It will be saved to a file inside the\n+        checkpoint directory set with L{SparkContext.setCheckpointDir()}\n+\n+        @param interval: time in seconds, after which generated RDD will\n+                         be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream which contains group the values for each key in the\n+        DStream into a single sequence.\n+        Hash-partitions the resulting RDD with into numPartitions partitions in\n+        the DStream.\n+\n+        Note: If you are grouping in order to perform an aggregation (such as a\n+        sum or average) over each key, using reduceByKey will provide much\n+        better performance.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return new DStream which contains the count of each unique value in this\n+        DStreeam as a (value, count) pairs.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a text file, using string representations of elements.\n+        \"\"\"\n+\n+        def saveAsTextFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsTextFile(path)\n+\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save this DStream as a SequenceFile of serialized objects. The serializer\n+        used is L{pyspark.serializers.PickleSerializer}, default batch size\n+        is 10.\n+        \"\"\"\n+\n+        def saveAsPickleFile(time, rdd):\n+            \"\"\"\n+            Closure to save element in RDD in the DStream as Pickled data in file.\n+            This closure is called by py4j callback server.\n+            \"\"\"\n+            path = rddToFileName(prefix, suffix, time)\n+            rdd.saveAsPickleFile(path)\n+\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, lambda t, a: func(a), True)\n+\n+    def transformWithTime(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+        \"\"\"\n+        return TransformedDStream(self, func, False)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+        \"\"\"\n+        jfunc = RDDFunction(self.ctx, lambda t, a, b: func(a, b), self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartitions(self, numPartitions):\n+        \"\"\"\n+        Return a new DStream with an increased or decreased level of parallelism. Each RDD in the\n+        returned DStream has exactly numPartitions partitions.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.repartition(numPartitions))\n+\n+    @property\n+    def _slideDuration(self):\n+        \"\"\"\n+        Return the slideDuration in seconds of this DStream\n+        \"\"\"\n+        return self._jdstream.dstream().slideDuration().milliseconds() / 1000.0\n+\n+    def union(self, other):\n+        \"\"\"\n+        Return a new DStream by unifying data of another DStream with this DStream.\n+        @param other Another DStream having the same interval (i.e., slideDuration) as this DStream.\n+        \"\"\"\n+        if self._slideDuration != other._slideDuration:\n+            raise ValueError(\"the two DStream should have same slide duration\")\n+        return self.transformWith(lambda a, b: a.union(b), other, True)\n+\n+    def cogroup(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'cogroup' between RDDs of `this`\n+        DStream and `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions` partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.cogroup(b, numPartitions), other)\n+\n+    def join(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.join(b, numPartitions), other)\n+\n+    def leftOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'left outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.leftOuterJoin(b, numPartitions), other)\n+\n+    def rightOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'right outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.rightOuterJoin(b, numPartitions), other)\n+\n+    def fullOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+         Return a new DStream by applying 'full outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+         partitions.\n+        \"\"\"\n+        return self.transformWith(lambda a, b: a.fullOuterJoin(b, numPartitions), other)\n+\n+    def _jtime(self, timestamp):\n+        \"\"\" Convert datetime or unix_timestamp into Time\n+        \"\"\"\n+        if isinstance(timestamp, datetime):\n+            timestamp = time.mktime(timestamp.timetuple())\n+        return self.ctx._jvm.Time(long(timestamp * 1000))\n+\n+    def slice(self, begin, end):\n+        \"\"\"\n+        Return all the RDDs between 'begin' to 'end' (both included)\n+\n+        `begin`, `end` could be datetime.datetime() or unix_timestamp\n+        \"\"\"\n+        jrdds = self._jdstream.slice(self._jtime(begin), self._jtime(end))\n+        return [RDD(jrdd, self.ctx, self._jrdd_deserializer) for jrdd in jrdds]\n+\n+    def _check_window(self, window, slide):\n+        duration = self._jdstream.dstream().slideDuration().milliseconds()\n+        if int(window * 1000) % duration != 0:\n+            raise ValueError(\"windowDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+        if slide and int(slide * 1000) % duration != 0:\n+            raise ValueError(\"slideDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+\n+    def window(self, windowDuration, slideDuration=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains all the elements in seen in a\n+        sliding window of time over this DStream.\n+\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        \"\"\"\n+        self._check_window(windowDuration, slideDuration)\n+        d = self._ssc._jduration(windowDuration)\n+        if slideDuration is None:\n+            return DStream(self._jdstream.window(d), self._ssc, self._jrdd_deserializer)\n+        s = self._ssc._jduration(slideDuration)\n+        return DStream(self._jdstream.window(d, s), self._ssc, self._jrdd_deserializer)\n+\n+    def reduceByWindow(self, reduceFunc, invReduceFunc, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated by reducing all\n+        elements in a sliding window over this DStream.\n+\n+        if `invReduceFunc` is not None, the reduction is done incrementally\n+        using the old window's reduced value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+         This is more efficient than `invReduceFunc` is None.\n+\n+        @param reduceFunc associative reduce function\n+        @param invReduceFunc inverse reduce function of `reduceFunc`\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        \"\"\"\n+        keyed = self.map(lambda x: (1, x))\n+        reduced = keyed.reduceByKeyAndWindow(reduceFunc, invReduceFunc,\n+                                             windowDuration, slideDuration, 1)\n+        return reduced.map(lambda (k, v): v)\n+\n+    def countByWindow(self, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated\n+        by counting the number of elements in a window over this DStream.\n+        windowDuration and slideDuration are as defined in the window() operation.\n+\n+        This is equivalent to window(windowDuration, slideDuration).count(),\n+        but will be more efficient if window is large.\n+        \"\"\"\n+        return self.map(lambda x: 1).reduceByWindow(operator.add, operator.sub,\n+                                                    windowDuration, slideDuration)\n+\n+    def countByValueAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the count of distinct elements in\n+        RDDs in a sliding window over this DStream.\n+\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions  number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        keyed = self.map(lambda x: (x, 1))\n+        counted = keyed.reduceByKeyAndWindow(operator.add, operator.sub,\n+                                             windowDuration, slideDuration, numPartitions)\n+        return counted.filter(lambda (k, v): v > 0).count()\n+\n+    def groupByKeyAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying `groupByKey` over a sliding window.\n+        Similar to `DStream.groupByKey()`, but applies it over a sliding window.\n+\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions  Number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        ls = self.mapValues(lambda x: [x])\n+        grouped = ls.reduceByKeyAndWindow(lambda a, b: a.extend(b) or a, lambda a, b: a[len(b):],\n+                                          windowDuration, slideDuration, numPartitions)\n+        return grouped.mapValues(ResultIterable)\n+\n+    def reduceByKeyAndWindow(self, func, invFunc, windowDuration, slideDuration=None,\n+                             numPartitions=None, filterFunc=None):\n+        \"\"\"\n+        Return a new DStream by applying incremental `reduceByKey` over a sliding window.\n+\n+        The reduced value of over a new window is calculated using the old window's reduce value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+\n+        `invFunc` can be None, then it will reduce all the RDDs in window, could be slower\n+        than having `invFunc`.\n+\n+        @param reduceFunc     associative reduce function\n+        @param invReduceFunc  inverse function of `reduceFunc`\n+        @param windowDuration width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions  number of partitions of each RDD in the new DStream.\n+        @param filterFunc     function to filter expired key-value pairs;\n+                              only pairs that satisfy the function are retained\n+                              set this to null if you do not want to filter\n+        \"\"\"\n+        self._check_window(windowDuration, slideDuration)\n+        reduced = self.reduceByKey(func)\n+\n+        def reduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            r = a.union(b).reduceByKey(func, numPartitions) if a else b\n+            if filterFunc:\n+                r = r.filter(filterFunc)\n+            return r\n+\n+        def invReduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            joined = a.leftOuterJoin(b, numPartitions)\n+            return joined.mapValues(lambda (v1, v2): invFunc(v1, v2) if v2 is not None else v1)\n+\n+        jreduceFunc = RDDFunction(self.ctx, reduceFunc, reduced._jrdd_deserializer)\n+        if invReduceFunc:\n+            jinvReduceFunc = RDDFunction(self.ctx, invReduceFunc, reduced._jrdd_deserializer)\n+        else:\n+            jinvReduceFunc = None\n+        if slideDuration is None:\n+            slideDuration = self._slideDuration\n+        dstream = self.ctx._jvm.PythonReducedWindowedDStream(reduced._jdstream.dstream(),\n+                                                             jreduceFunc, jinvReduceFunc,\n+                                                             self._ssc._jduration(windowDuration),\n+                                                             self._ssc._jduration(slideDuration))\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+    def updateStateByKey(self, updateFunc, numPartitions=None):\n+        \"\"\"\n+        Return a new \"state\" DStream where the state for each key is updated by applying\n+        the given function on the previous state of the key and the new values of the key.\n+\n+        @param updateFunc State update function ([(k, vs, s)] -> [(k, s)]).\n+                          If `s` is None, then `k` will be eliminated.\n+        \"\"\"\n+        def reduceFunc(t, a, b):\n+            if a is None:\n+                g = b.groupByKey(numPartitions).map(lambda (k, vs): (k, list(vs), None))\n+            else:\n+                g = a.cogroup(b, numPartitions)\n+                g = g.map(lambda (k, (va, vb)): (k, list(vb), list(va)[0] if len(va) else None))\n+            state = g.mapPartitions(lambda x: updateFunc(x))\n+            return state.filter(lambda (k, v): v is not None)\n+\n+        jreduceFunc = RDDFunction(self.ctx, reduceFunc,\n+                                  self.ctx.serializer, self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonStateDStream(self._jdstream.dstream(), jreduceFunc)\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+\n+class TransformedDStream(DStream):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "please remove this. this is anyways deprecated in scala / java.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-09-30T17:55:10Z",
    "diffHunk": "@@ -0,0 +1,619 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, RDDFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    # def foreach(self, func):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "We have a `context` method that returns the StreamingContext and this public `ctx` field that returns the underlying SparkContext.  This seems like it could be confusing, so maybe we should make the `ctx` field private.  On the other hand, RDD has a `ctx` field that returns the SparkContext, so this is consistent with that.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-02T23:07:54Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Do we need this method?  Can we just move the `reduce(operator.add)` to `count` and remove `_sum`?\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-02T23:10:33Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Why the quotes around 'this'?  It looks like this is a carryover from the Scala docs, but it seems odd to me.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-02T23:13:36Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply a function to each RDD in this DStream.\n+        \"\"\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream.\n+        \"\"\"\n+        def takeAndPrint(time, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % time\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a map function to the value of\n+        each key-value pairs in 'this' DStream without changing the key."
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "It looks like this isn't called from anywhere.  Can we remove it?\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-02T23:14:42Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply a function to each RDD in this DStream.\n+        \"\"\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream.\n+        \"\"\"\n+        def takeAndPrint(time, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % time\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a map function to the value of\n+        each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a flatmap function to the value\n+        of each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the default storage level\n+        (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the given storage level\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Enable periodic checkpointing of RDDs of this DStream\n+\n+        @param interval: time in seconds, after each period of that, generated\n+                         RDD will be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying groupByKey on each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the counts of each\n+        distinct value in each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at text file, using string\n+        representation of elements.\n+        \"\"\"\n+        def saveAsTextFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsTextFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def _saveAsPickleFiles(self, prefix, suffix=None):"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "This is mirror the RDD api of saveAsPickFile. I am not entirely sure whether to expose this, but not point removing the implementation, so just having it as private should be fine for now.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-03T01:39:17Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply a function to each RDD in this DStream.\n+        \"\"\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream.\n+        \"\"\"\n+        def takeAndPrint(time, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % time\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a map function to the value of\n+        each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a flatmap function to the value\n+        of each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the default storage level\n+        (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the given storage level\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Enable periodic checkpointing of RDDs of this DStream\n+\n+        @param interval: time in seconds, after each period of that, generated\n+                         RDD will be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying groupByKey on each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the counts of each\n+        distinct value in each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at text file, using string\n+        representation of elements.\n+        \"\"\"\n+        def saveAsTextFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsTextFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def _saveAsPickleFiles(self, prefix, suffix=None):"
  }, {
    "author": {
      "login": "giwa"
    },
    "body": "I added this function as public method at first. That's why davices left this function in DStream, I think. As far as my understanding, saveAsPickleFile is equivalent to saveAsObjectFile in Scala/Java. If so, it would be good to be a public method.\n\nPython saveAsPickleFile doc string\n\n```\ndef saveAsPickleFile(self, path, batchSize=10): \n         \"\"\" \n          Save this RDD as a SequenceFile of serialized objects. The serializer \n          used is L{pyspark.serializers.PickleSerializer}, default batch size \n          is 10. \n         \"\"\"\n```\n\nScala\n\n```\ndef saveAsObjectFile(path: String): Unit\nSave this RDD as a SequenceFile of serialized objects.\n```\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-03T02:54:52Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply a function to each RDD in this DStream.\n+        \"\"\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream.\n+        \"\"\"\n+        def takeAndPrint(time, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % time\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a map function to the value of\n+        each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a flatmap function to the value\n+        of each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the default storage level\n+        (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the given storage level\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Enable periodic checkpointing of RDDs of this DStream\n+\n+        @param interval: time in seconds, after each period of that, generated\n+                         RDD will be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying groupByKey on each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the counts of each\n+        distinct value in each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at text file, using string\n+        representation of elements.\n+        \"\"\"\n+        def saveAsTextFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsTextFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def _saveAsPickleFiles(self, prefix, suffix=None):"
  }],
  "prId": 2538
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "I don't think we need this local variable; you can just change the next line to\n\n```\nself._ssc = prev._ssc\n```\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-02T23:21:36Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply a function to each RDD in this DStream.\n+        \"\"\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream.\n+        \"\"\"\n+        def takeAndPrint(time, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % time\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a map function to the value of\n+        each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a flatmap function to the value\n+        of each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the default storage level\n+        (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the given storage level\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Enable periodic checkpointing of RDDs of this DStream\n+\n+        @param interval: time in seconds, after each period of that, generated\n+                         RDD will be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying groupByKey on each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the counts of each\n+        distinct value in each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at text file, using string\n+        representation of elements.\n+        \"\"\"\n+        def saveAsTextFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsTextFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def _saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at binary file, the elements are\n+        serialized by pickle.\n+        \"\"\"\n+        def saveAsPickleFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsPickleFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+\n+        `func` can have one argument of `rdd`, or have two arguments of\n+        (`time`, `rdd`)\n+        \"\"\"\n+        if func.func_code.co_argcount == 1:\n+            oldfunc = func\n+            func = lambda t, rdd: oldfunc(rdd)\n+        assert func.func_code.co_argcount == 2, \"func should take one or two arguments\"\n+        return TransformedDStream(self, func)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+\n+        `func` can have two arguments of (`rdd_a`, `rdd_b`) or have three\n+        arguments of (`time`, `rdd_a`, `rdd_b`)\n+        \"\"\"\n+        if func.func_code.co_argcount == 2:\n+            oldfunc = func\n+            func = lambda t, a, b: oldfunc(a, b)\n+        assert func.func_code.co_argcount == 3, \"func should take two or three arguments\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer, other._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartition(self, numPartitions):\n+        \"\"\"\n+        Return a new DStream with an increased or decreased level of parallelism.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.repartition(numPartitions))\n+\n+    @property\n+    def _slideDuration(self):\n+        \"\"\"\n+        Return the slideDuration in seconds of this DStream\n+        \"\"\"\n+        return self._jdstream.dstream().slideDuration().milliseconds() / 1000.0\n+\n+    def union(self, other):\n+        \"\"\"\n+        Return a new DStream by unifying data of another DStream with this DStream.\n+\n+        @param other: Another DStream having the same interval (i.e., slideDuration)\n+                     as this DStream.\n+        \"\"\"\n+        if self._slideDuration != other._slideDuration:\n+            raise ValueError(\"the two DStream should have same slide duration\")\n+        return self.transformWith(lambda a, b: a.union(b), other, True)\n+\n+    def cogroup(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'cogroup' between RDDs of `this`\n+        DStream and `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions` partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.cogroup(b, numPartitions), other)\n+\n+    def join(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.join(b, numPartitions), other)\n+\n+    def leftOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'left outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.leftOuterJoin(b, numPartitions), other)\n+\n+    def rightOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'right outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.rightOuterJoin(b, numPartitions), other)\n+\n+    def fullOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'full outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.fullOuterJoin(b, numPartitions), other)\n+\n+    def _jtime(self, timestamp):\n+        \"\"\" Convert datetime or unix_timestamp into Time\n+        \"\"\"\n+        if isinstance(timestamp, datetime):\n+            timestamp = time.mktime(timestamp.timetuple())\n+        return self.ctx._jvm.Time(long(timestamp * 1000))\n+\n+    def slice(self, begin, end):\n+        \"\"\"\n+        Return all the RDDs between 'begin' to 'end' (both included)\n+\n+        `begin`, `end` could be datetime.datetime() or unix_timestamp\n+        \"\"\"\n+        jrdds = self._jdstream.slice(self._jtime(begin), self._jtime(end))\n+        return [RDD(jrdd, self.ctx, self._jrdd_deserializer) for jrdd in jrdds]\n+\n+    def _validate_window_param(self, window, slide):\n+        duration = self._jdstream.dstream().slideDuration().milliseconds()\n+        if int(window * 1000) % duration != 0:\n+            raise ValueError(\"windowDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+        if slide and int(slide * 1000) % duration != 0:\n+            raise ValueError(\"slideDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+\n+    def window(self, windowDuration, slideDuration=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains all the elements in seen in a\n+        sliding window of time over this DStream.\n+\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        \"\"\"\n+        self._validate_window_param(windowDuration, slideDuration)\n+        d = self._ssc._jduration(windowDuration)\n+        if slideDuration is None:\n+            return DStream(self._jdstream.window(d), self._ssc, self._jrdd_deserializer)\n+        s = self._ssc._jduration(slideDuration)\n+        return DStream(self._jdstream.window(d, s), self._ssc, self._jrdd_deserializer)\n+\n+    def reduceByWindow(self, reduceFunc, invReduceFunc, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated by reducing all\n+        elements in a sliding window over this DStream.\n+\n+        if `invReduceFunc` is not None, the reduction is done incrementally\n+        using the old window's reduced value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+         This is more efficient than `invReduceFunc` is None.\n+\n+        @param reduceFunc:     associative reduce function\n+        @param invReduceFunc:  inverse reduce function of `reduceFunc`\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                               batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                               the new DStream will generate RDDs); must be a multiple of this\n+                               DStream's batching interval\n+        \"\"\"\n+        keyed = self.map(lambda x: (1, x))\n+        reduced = keyed.reduceByKeyAndWindow(reduceFunc, invReduceFunc,\n+                                             windowDuration, slideDuration, 1)\n+        return reduced.map(lambda (k, v): v)\n+\n+    def countByWindow(self, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated\n+        by counting the number of elements in a window over this DStream.\n+        windowDuration and slideDuration are as defined in the window() operation.\n+\n+        This is equivalent to window(windowDuration, slideDuration).count(),\n+        but will be more efficient if window is large.\n+        \"\"\"\n+        return self.map(lambda x: 1).reduceByWindow(operator.add, operator.sub,\n+                                                    windowDuration, slideDuration)\n+\n+    def countByValueAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the count of distinct elements in\n+        RDDs in a sliding window over this DStream.\n+\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions:  number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        keyed = self.map(lambda x: (x, 1))\n+        counted = keyed.reduceByKeyAndWindow(operator.add, operator.sub,\n+                                             windowDuration, slideDuration, numPartitions)\n+        return counted.filter(lambda (k, v): v > 0).count()\n+\n+    def groupByKeyAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying `groupByKey` over a sliding window.\n+        Similar to `DStream.groupByKey()`, but applies it over a sliding window.\n+\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions:  Number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        ls = self.mapValues(lambda x: [x])\n+        grouped = ls.reduceByKeyAndWindow(lambda a, b: a.extend(b) or a, lambda a, b: a[len(b):],\n+                                          windowDuration, slideDuration, numPartitions)\n+        return grouped.mapValues(ResultIterable)\n+\n+    def reduceByKeyAndWindow(self, func, invFunc, windowDuration, slideDuration=None,\n+                             numPartitions=None, filterFunc=None):\n+        \"\"\"\n+        Return a new DStream by applying incremental `reduceByKey` over a sliding window.\n+\n+        The reduced value of over a new window is calculated using the old window's reduce value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+\n+        `invFunc` can be None, then it will reduce all the RDDs in window, could be slower\n+        than having `invFunc`.\n+\n+        @param reduceFunc:     associative reduce function\n+        @param invReduceFunc:  inverse function of `reduceFunc`\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions:  number of partitions of each RDD in the new DStream.\n+        @param filterFunc:     function to filter expired key-value pairs;\n+                              only pairs that satisfy the function are retained\n+                              set this to null if you do not want to filter\n+        \"\"\"\n+        self._validate_window_param(windowDuration, slideDuration)\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        reduced = self.reduceByKey(func, numPartitions)\n+\n+        def reduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            r = a.union(b).reduceByKey(func, numPartitions) if a else b\n+            if filterFunc:\n+                r = r.filter(filterFunc)\n+            return r\n+\n+        def invReduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            joined = a.leftOuterJoin(b, numPartitions)\n+            return joined.mapValues(lambda (v1, v2): invFunc(v1, v2) if v2 is not None else v1)\n+\n+        jreduceFunc = TransformFunction(self.ctx, reduceFunc, reduced._jrdd_deserializer)\n+        if invReduceFunc:\n+            jinvReduceFunc = TransformFunction(self.ctx, invReduceFunc, reduced._jrdd_deserializer)\n+        else:\n+            jinvReduceFunc = None\n+        if slideDuration is None:\n+            slideDuration = self._slideDuration\n+        dstream = self.ctx._jvm.PythonReducedWindowedDStream(reduced._jdstream.dstream(),\n+                                                             jreduceFunc, jinvReduceFunc,\n+                                                             self._ssc._jduration(windowDuration),\n+                                                             self._ssc._jduration(slideDuration))\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+    def updateStateByKey(self, updateFunc, numPartitions=None):\n+        \"\"\"\n+        Return a new \"state\" DStream where the state for each key is updated by applying\n+        the given function on the previous state of the key and the new values of the key.\n+\n+        @param updateFunc: State update function ([(k, vs, s)] -> [(k, s)]).\n+                          If `s` is None, then `k` will be eliminated.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def reduceFunc(t, a, b):\n+            if a is None:\n+                g = b.groupByKey(numPartitions).map(lambda (k, vs): (k, list(vs), None))\n+            else:\n+                g = a.cogroup(b, numPartitions)\n+                g = g.map(lambda (k, (va, vb)): (k, list(vb), list(va)[0] if len(va) else None))\n+            state = g.mapPartitions(lambda x: updateFunc(x))\n+            return state.filter(lambda (k, v): v is not None)\n+\n+        jreduceFunc = TransformFunction(self.ctx, reduceFunc,\n+                                        self.ctx.serializer, self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonStateDStream(self._jdstream.dstream(), jreduceFunc)\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+\n+class TransformedDStream(DStream):\n+    \"\"\"\n+    TransformedDStream is an DStream generated by an Python function\n+    transforming each RDD of an DStream to another RDDs.\n+\n+    Multiple continuous transformations of DStream can be combined into\n+    one transformation.\n+    \"\"\"\n+    def __init__(self, prev, func):\n+        ssc = prev._ssc"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Well, and the ctx line, too.  Just a minor nit / non-issue.\n",
    "commit": "64561e4e503eafb958f6769383ba3b37edbe5fa2",
    "createdAt": "2014-10-02T23:22:07Z",
    "diffHunk": "@@ -0,0 +1,624 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from itertools import chain, ifilter, imap\n+import operator\n+import time\n+from datetime import datetime\n+\n+from py4j.protocol import Py4JJavaError\n+\n+from pyspark import RDD\n+from pyspark.storagelevel import StorageLevel\n+from pyspark.streaming.util import rddToFileName, TransformFunction\n+from pyspark.rdd import portable_hash\n+from pyspark.resultiterable import ResultIterable\n+\n+__all__ = [\"DStream\"]\n+\n+\n+class DStream(object):\n+    \"\"\"\n+    A Discretized Stream (DStream), the basic abstraction in Spark Streaming,\n+    is a continuous sequence of RDDs (of the same type) representing a\n+    continuous stream of data (see L{RDD} in the Spark core documentation\n+    for more details on RDDs).\n+\n+    DStreams can either be created from live data (such as, data from TCP\n+    sockets, Kafka, Flume, etc.) using a L{StreamingContext} or it can be\n+    generated by transforming existing DStreams using operations such as\n+    `map`, `window` and `reduceByKeyAndWindow`. While a Spark Streaming\n+    program is running, each DStream periodically generates a RDD, either\n+    from live data or by transforming the RDD generated by a parent DStream.\n+\n+    DStreams internally is characterized by a few basic properties:\n+     - A list of other DStreams that the DStream depends on\n+     - A time interval at which the DStream generates an RDD\n+     - A function that is used to generate an RDD after each time interval\n+    \"\"\"\n+    def __init__(self, jdstream, ssc, jrdd_deserializer):\n+        self._jdstream = jdstream\n+        self._ssc = ssc\n+        self.ctx = ssc._sc\n+        self._jrdd_deserializer = jrdd_deserializer\n+        self.is_cached = False\n+        self.is_checkpointed = False\n+\n+    def context(self):\n+        \"\"\"\n+        Return the StreamingContext associated with this DStream\n+        \"\"\"\n+        return self._ssc\n+\n+    def count(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by counting each RDD of this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda i: [sum(1 for _ in i)])._sum()\n+\n+    def _sum(self):\n+        \"\"\"\n+        Add up the elements in this DStream.\n+        \"\"\"\n+        return self.mapPartitions(lambda x: [sum(x)]).reduce(operator.add)\n+\n+    def filter(self, f):\n+        \"\"\"\n+        Return a new DStream containing only the elements that satisfy predicate.\n+        \"\"\"\n+        def func(iterator):\n+            return ifilter(f, iterator)\n+        return self.mapPartitions(func, True)\n+\n+    def flatMap(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to all elements of\n+        this DStream, and then flattening the results\n+        \"\"\"\n+        def func(s, iterator):\n+            return chain.from_iterable(imap(f, iterator))\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def map(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream by applying a function to each element of DStream.\n+        \"\"\"\n+        def func(iterator):\n+            return imap(f, iterator)\n+        return self.mapPartitions(func, preservesPartitioning)\n+\n+    def mapPartitions(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitions() to each RDDs of this DStream.\n+        \"\"\"\n+        def func(s, iterator):\n+            return f(iterator)\n+        return self.mapPartitionsWithIndex(func, preservesPartitioning)\n+\n+    def mapPartitionsWithIndex(self, f, preservesPartitioning=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying\n+        mapPartitionsWithIndex() to each RDDs of this DStream.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.mapPartitionsWithIndex(f, preservesPartitioning))\n+\n+    def reduce(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element\n+        generated by reducing each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (None, x)).reduceByKey(func, 1).map(lambda x: x[1])\n+\n+    def reduceByKey(self, func, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying reduceByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.combineByKey(lambda x: x, func, func, numPartitions)\n+\n+    def combineByKey(self, createCombiner, mergeValue, mergeCombiners,\n+                     numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying combineByKey to each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def func(rdd):\n+            return rdd.combineByKey(createCombiner, mergeValue, mergeCombiners, numPartitions)\n+        return self.transform(func)\n+\n+    def partitionBy(self, numPartitions, partitionFunc=portable_hash):\n+        \"\"\"\n+        Return a copy of the DStream in which each RDD are partitioned\n+        using the specified partitioner.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.partitionBy(numPartitions, partitionFunc))\n+\n+    def foreachRDD(self, func):\n+        \"\"\"\n+        Apply a function to each RDD in this DStream.\n+        \"\"\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer)\n+        api = self._ssc._jvm.PythonDStream\n+        api.callForeachRDD(self._jdstream, jfunc)\n+\n+    def pprint(self):\n+        \"\"\"\n+        Print the first ten elements of each RDD generated in this DStream.\n+        \"\"\"\n+        def takeAndPrint(time, rdd):\n+            taken = rdd.take(11)\n+            print \"-------------------------------------------\"\n+            print \"Time: %s\" % time\n+            print \"-------------------------------------------\"\n+            for record in taken[:10]:\n+                print record\n+            if len(taken) > 10:\n+                print \"...\"\n+            print\n+\n+        self.foreachRDD(takeAndPrint)\n+\n+    def mapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a map function to the value of\n+        each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        map_values_fn = lambda (k, v): (k, f(v))\n+        return self.map(map_values_fn, preservesPartitioning=True)\n+\n+    def flatMapValues(self, f):\n+        \"\"\"\n+        Return a new DStream by applying a flatmap function to the value\n+        of each key-value pairs in 'this' DStream without changing the key.\n+        \"\"\"\n+        flat_map_fn = lambda (k, v): ((k, x) for x in f(v))\n+        return self.flatMap(flat_map_fn, preservesPartitioning=True)\n+\n+    def glom(self):\n+        \"\"\"\n+        Return a new DStream in which RDD is generated by applying glom()\n+        to RDD of this DStream.\n+        \"\"\"\n+        def func(iterator):\n+            yield list(iterator)\n+        return self.mapPartitions(func)\n+\n+    def cache(self):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the default storage level\n+        (C{MEMORY_ONLY_SER}).\n+        \"\"\"\n+        self.is_cached = True\n+        self.persist(StorageLevel.MEMORY_ONLY_SER)\n+        return self\n+\n+    def persist(self, storageLevel):\n+        \"\"\"\n+        Persist the RDDs of this DStream with the given storage level\n+        \"\"\"\n+        self.is_cached = True\n+        javaStorageLevel = self.ctx._getJavaStorageLevel(storageLevel)\n+        self._jdstream.persist(javaStorageLevel)\n+        return self\n+\n+    def checkpoint(self, interval):\n+        \"\"\"\n+        Enable periodic checkpointing of RDDs of this DStream\n+\n+        @param interval: time in seconds, after each period of that, generated\n+                         RDD will be checkpointed\n+        \"\"\"\n+        self.is_checkpointed = True\n+        self._jdstream.checkpoint(self._ssc._jduration(interval))\n+        return self\n+\n+    def groupByKey(self, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying groupByKey on each RDD.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))\n+\n+    def countByValue(self):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the counts of each\n+        distinct value in each RDD of this DStream.\n+        \"\"\"\n+        return self.map(lambda x: (x, None)).reduceByKey(lambda x, y: None).count()\n+\n+    def saveAsTextFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at text file, using string\n+        representation of elements.\n+        \"\"\"\n+        def saveAsTextFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsTextFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsTextFile)\n+\n+    def _saveAsPickleFiles(self, prefix, suffix=None):\n+        \"\"\"\n+        Save each RDD in this DStream as at binary file, the elements are\n+        serialized by pickle.\n+        \"\"\"\n+        def saveAsPickleFile(t, rdd):\n+            path = rddToFileName(prefix, suffix, t)\n+            try:\n+                rdd.saveAsPickleFile(path)\n+            except Py4JJavaError as e:\n+                # after recovered from checkpointing, the foreachRDD may\n+                # be called twice\n+                if 'FileAlreadyExistsException' not in str(e):\n+                    raise\n+        return self.foreachRDD(saveAsPickleFile)\n+\n+    def transform(self, func):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream.\n+\n+        `func` can have one argument of `rdd`, or have two arguments of\n+        (`time`, `rdd`)\n+        \"\"\"\n+        if func.func_code.co_argcount == 1:\n+            oldfunc = func\n+            func = lambda t, rdd: oldfunc(rdd)\n+        assert func.func_code.co_argcount == 2, \"func should take one or two arguments\"\n+        return TransformedDStream(self, func)\n+\n+    def transformWith(self, func, other, keepSerializer=False):\n+        \"\"\"\n+        Return a new DStream in which each RDD is generated by applying a function\n+        on each RDD of 'this' DStream and 'other' DStream.\n+\n+        `func` can have two arguments of (`rdd_a`, `rdd_b`) or have three\n+        arguments of (`time`, `rdd_a`, `rdd_b`)\n+        \"\"\"\n+        if func.func_code.co_argcount == 2:\n+            oldfunc = func\n+            func = lambda t, a, b: oldfunc(a, b)\n+        assert func.func_code.co_argcount == 3, \"func should take two or three arguments\"\n+        jfunc = TransformFunction(self.ctx, func, self._jrdd_deserializer, other._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonTransformed2DStream(self._jdstream.dstream(),\n+                                                          other._jdstream.dstream(), jfunc)\n+        jrdd_serializer = self._jrdd_deserializer if keepSerializer else self.ctx.serializer\n+        return DStream(dstream.asJavaDStream(), self._ssc, jrdd_serializer)\n+\n+    def repartition(self, numPartitions):\n+        \"\"\"\n+        Return a new DStream with an increased or decreased level of parallelism.\n+        \"\"\"\n+        return self.transform(lambda rdd: rdd.repartition(numPartitions))\n+\n+    @property\n+    def _slideDuration(self):\n+        \"\"\"\n+        Return the slideDuration in seconds of this DStream\n+        \"\"\"\n+        return self._jdstream.dstream().slideDuration().milliseconds() / 1000.0\n+\n+    def union(self, other):\n+        \"\"\"\n+        Return a new DStream by unifying data of another DStream with this DStream.\n+\n+        @param other: Another DStream having the same interval (i.e., slideDuration)\n+                     as this DStream.\n+        \"\"\"\n+        if self._slideDuration != other._slideDuration:\n+            raise ValueError(\"the two DStream should have same slide duration\")\n+        return self.transformWith(lambda a, b: a.union(b), other, True)\n+\n+    def cogroup(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'cogroup' between RDDs of `this`\n+        DStream and `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions` partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.cogroup(b, numPartitions), other)\n+\n+    def join(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.join(b, numPartitions), other)\n+\n+    def leftOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'left outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.leftOuterJoin(b, numPartitions), other)\n+\n+    def rightOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'right outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.rightOuterJoin(b, numPartitions), other)\n+\n+    def fullOuterJoin(self, other, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying 'full outer join' between RDDs of `this` DStream and\n+        `other` DStream.\n+\n+        Hash partitioning is used to generate the RDDs with `numPartitions`\n+        partitions.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+        return self.transformWith(lambda a, b: a.fullOuterJoin(b, numPartitions), other)\n+\n+    def _jtime(self, timestamp):\n+        \"\"\" Convert datetime or unix_timestamp into Time\n+        \"\"\"\n+        if isinstance(timestamp, datetime):\n+            timestamp = time.mktime(timestamp.timetuple())\n+        return self.ctx._jvm.Time(long(timestamp * 1000))\n+\n+    def slice(self, begin, end):\n+        \"\"\"\n+        Return all the RDDs between 'begin' to 'end' (both included)\n+\n+        `begin`, `end` could be datetime.datetime() or unix_timestamp\n+        \"\"\"\n+        jrdds = self._jdstream.slice(self._jtime(begin), self._jtime(end))\n+        return [RDD(jrdd, self.ctx, self._jrdd_deserializer) for jrdd in jrdds]\n+\n+    def _validate_window_param(self, window, slide):\n+        duration = self._jdstream.dstream().slideDuration().milliseconds()\n+        if int(window * 1000) % duration != 0:\n+            raise ValueError(\"windowDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+        if slide and int(slide * 1000) % duration != 0:\n+            raise ValueError(\"slideDuration must be multiple of the slide duration (%d ms)\"\n+                             % duration)\n+\n+    def window(self, windowDuration, slideDuration=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains all the elements in seen in a\n+        sliding window of time over this DStream.\n+\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        \"\"\"\n+        self._validate_window_param(windowDuration, slideDuration)\n+        d = self._ssc._jduration(windowDuration)\n+        if slideDuration is None:\n+            return DStream(self._jdstream.window(d), self._ssc, self._jrdd_deserializer)\n+        s = self._ssc._jduration(slideDuration)\n+        return DStream(self._jdstream.window(d, s), self._ssc, self._jrdd_deserializer)\n+\n+    def reduceByWindow(self, reduceFunc, invReduceFunc, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated by reducing all\n+        elements in a sliding window over this DStream.\n+\n+        if `invReduceFunc` is not None, the reduction is done incrementally\n+        using the old window's reduced value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+         This is more efficient than `invReduceFunc` is None.\n+\n+        @param reduceFunc:     associative reduce function\n+        @param invReduceFunc:  inverse reduce function of `reduceFunc`\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                               batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                               the new DStream will generate RDDs); must be a multiple of this\n+                               DStream's batching interval\n+        \"\"\"\n+        keyed = self.map(lambda x: (1, x))\n+        reduced = keyed.reduceByKeyAndWindow(reduceFunc, invReduceFunc,\n+                                             windowDuration, slideDuration, 1)\n+        return reduced.map(lambda (k, v): v)\n+\n+    def countByWindow(self, windowDuration, slideDuration):\n+        \"\"\"\n+        Return a new DStream in which each RDD has a single element generated\n+        by counting the number of elements in a window over this DStream.\n+        windowDuration and slideDuration are as defined in the window() operation.\n+\n+        This is equivalent to window(windowDuration, slideDuration).count(),\n+        but will be more efficient if window is large.\n+        \"\"\"\n+        return self.map(lambda x: 1).reduceByWindow(operator.add, operator.sub,\n+                                                    windowDuration, slideDuration)\n+\n+    def countByValueAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream in which each RDD contains the count of distinct elements in\n+        RDDs in a sliding window over this DStream.\n+\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions:  number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        keyed = self.map(lambda x: (x, 1))\n+        counted = keyed.reduceByKeyAndWindow(operator.add, operator.sub,\n+                                             windowDuration, slideDuration, numPartitions)\n+        return counted.filter(lambda (k, v): v > 0).count()\n+\n+    def groupByKeyAndWindow(self, windowDuration, slideDuration, numPartitions=None):\n+        \"\"\"\n+        Return a new DStream by applying `groupByKey` over a sliding window.\n+        Similar to `DStream.groupByKey()`, but applies it over a sliding window.\n+\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions:  Number of partitions of each RDD in the new DStream.\n+        \"\"\"\n+        ls = self.mapValues(lambda x: [x])\n+        grouped = ls.reduceByKeyAndWindow(lambda a, b: a.extend(b) or a, lambda a, b: a[len(b):],\n+                                          windowDuration, slideDuration, numPartitions)\n+        return grouped.mapValues(ResultIterable)\n+\n+    def reduceByKeyAndWindow(self, func, invFunc, windowDuration, slideDuration=None,\n+                             numPartitions=None, filterFunc=None):\n+        \"\"\"\n+        Return a new DStream by applying incremental `reduceByKey` over a sliding window.\n+\n+        The reduced value of over a new window is calculated using the old window's reduce value :\n+         1. reduce the new values that entered the window (e.g., adding new counts)\n+         2. \"inverse reduce\" the old values that left the window (e.g., subtracting old counts)\n+\n+        `invFunc` can be None, then it will reduce all the RDDs in window, could be slower\n+        than having `invFunc`.\n+\n+        @param reduceFunc:     associative reduce function\n+        @param invReduceFunc:  inverse function of `reduceFunc`\n+        @param windowDuration: width of the window; must be a multiple of this DStream's\n+                              batching interval\n+        @param slideDuration:  sliding interval of the window (i.e., the interval after which\n+                              the new DStream will generate RDDs); must be a multiple of this\n+                              DStream's batching interval\n+        @param numPartitions:  number of partitions of each RDD in the new DStream.\n+        @param filterFunc:     function to filter expired key-value pairs;\n+                              only pairs that satisfy the function are retained\n+                              set this to null if you do not want to filter\n+        \"\"\"\n+        self._validate_window_param(windowDuration, slideDuration)\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        reduced = self.reduceByKey(func, numPartitions)\n+\n+        def reduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            r = a.union(b).reduceByKey(func, numPartitions) if a else b\n+            if filterFunc:\n+                r = r.filter(filterFunc)\n+            return r\n+\n+        def invReduceFunc(t, a, b):\n+            b = b.reduceByKey(func, numPartitions)\n+            joined = a.leftOuterJoin(b, numPartitions)\n+            return joined.mapValues(lambda (v1, v2): invFunc(v1, v2) if v2 is not None else v1)\n+\n+        jreduceFunc = TransformFunction(self.ctx, reduceFunc, reduced._jrdd_deserializer)\n+        if invReduceFunc:\n+            jinvReduceFunc = TransformFunction(self.ctx, invReduceFunc, reduced._jrdd_deserializer)\n+        else:\n+            jinvReduceFunc = None\n+        if slideDuration is None:\n+            slideDuration = self._slideDuration\n+        dstream = self.ctx._jvm.PythonReducedWindowedDStream(reduced._jdstream.dstream(),\n+                                                             jreduceFunc, jinvReduceFunc,\n+                                                             self._ssc._jduration(windowDuration),\n+                                                             self._ssc._jduration(slideDuration))\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+    def updateStateByKey(self, updateFunc, numPartitions=None):\n+        \"\"\"\n+        Return a new \"state\" DStream where the state for each key is updated by applying\n+        the given function on the previous state of the key and the new values of the key.\n+\n+        @param updateFunc: State update function ([(k, vs, s)] -> [(k, s)]).\n+                          If `s` is None, then `k` will be eliminated.\n+        \"\"\"\n+        if numPartitions is None:\n+            numPartitions = self.ctx.defaultParallelism\n+\n+        def reduceFunc(t, a, b):\n+            if a is None:\n+                g = b.groupByKey(numPartitions).map(lambda (k, vs): (k, list(vs), None))\n+            else:\n+                g = a.cogroup(b, numPartitions)\n+                g = g.map(lambda (k, (va, vb)): (k, list(vb), list(va)[0] if len(va) else None))\n+            state = g.mapPartitions(lambda x: updateFunc(x))\n+            return state.filter(lambda (k, v): v is not None)\n+\n+        jreduceFunc = TransformFunction(self.ctx, reduceFunc,\n+                                        self.ctx.serializer, self._jrdd_deserializer)\n+        dstream = self.ctx._jvm.PythonStateDStream(self._jdstream.dstream(), jreduceFunc)\n+        return DStream(dstream.asJavaDStream(), self._ssc, self.ctx.serializer)\n+\n+\n+class TransformedDStream(DStream):\n+    \"\"\"\n+    TransformedDStream is an DStream generated by an Python function\n+    transforming each RDD of an DStream to another RDDs.\n+\n+    Multiple continuous transformations of DStream can be combined into\n+    one transformation.\n+    \"\"\"\n+    def __init__(self, prev, func):\n+        ssc = prev._ssc"
  }],
  "prId": 2538
}]