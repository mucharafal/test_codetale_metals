[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "So it also \"supports\" `corr(x, y=\"spearman\")`. This adds some convenience together with some confusion. If `X` is a matrix, user should use `corr(X, method=\"spearman\")`. Example: http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html\n",
    "commit": "5f1e60cfaf84050936bc6005138fe5f1281d2142",
    "createdAt": "2014-08-01T07:19:51Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Python package for statistical functions in MLlib.\n+\"\"\"\n+\n+from pyspark.mllib._common import \\\n+    _get_unmangled_double_vector_rdd, _get_unmangled_rdd, \\\n+    _serialize_double, _serialize_double_vector, \\\n+    _deserialize_double, _deserialize_double_matrix\n+\n+class Statistics(object):\n+\n+    @staticmethod\n+    def corr(x, y=None, method=None):\n+        \"\"\"\n+        Compute the correlation (matrix) for the input RDD(s) using the\n+        specified method.\n+        Methods currently supported: I{pearson (default), spearman}.\n+\n+        If a single RDD of Vectors is passed in, a correlation matrix\n+        comparing the columns in the input RDD is returned. Note that the\n+        method name can be passed in as the second argument without C{method=}."
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Doc was not updated. Please remove `Note that .... without C{methods=}.`\n",
    "commit": "5f1e60cfaf84050936bc6005138fe5f1281d2142",
    "createdAt": "2014-08-01T20:38:35Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Python package for statistical functions in MLlib.\n+\"\"\"\n+\n+from pyspark.mllib._common import \\\n+    _get_unmangled_double_vector_rdd, _get_unmangled_rdd, \\\n+    _serialize_double, _serialize_double_vector, \\\n+    _deserialize_double, _deserialize_double_matrix\n+\n+class Statistics(object):\n+\n+    @staticmethod\n+    def corr(x, y=None, method=None):\n+        \"\"\"\n+        Compute the correlation (matrix) for the input RDD(s) using the\n+        specified method.\n+        Methods currently supported: I{pearson (default), spearman}.\n+\n+        If a single RDD of Vectors is passed in, a correlation matrix\n+        comparing the columns in the input RDD is returned. Note that the\n+        method name can be passed in as the second argument without C{method=}."
  }],
  "prId": 1713
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "new line at the end\n",
    "commit": "5f1e60cfaf84050936bc6005138fe5f1281d2142",
    "createdAt": "2014-08-01T07:20:55Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Python package for statistical functions in MLlib.\n+\"\"\"\n+\n+from pyspark.mllib._common import \\\n+    _get_unmangled_double_vector_rdd, _get_unmangled_rdd, \\\n+    _serialize_double, _serialize_double_vector, \\\n+    _deserialize_double, _deserialize_double_matrix\n+\n+class Statistics(object):\n+\n+    @staticmethod\n+    def corr(x, y=None, method=None):\n+        \"\"\"\n+        Compute the correlation (matrix) for the input RDD(s) using the\n+        specified method.\n+        Methods currently supported: I{pearson (default), spearman}.\n+\n+        If a single RDD of Vectors is passed in, a correlation matrix\n+        comparing the columns in the input RDD is returned. Note that the\n+        method name can be passed in as the second argument without C{method=}.\n+        If two RDDs of floats are passed in, a single float is returned.\n+\n+        >>> x = sc.parallelize([1.0, 0.0, -2.0], 2)\n+        >>> y = sc.parallelize([4.0, 5.0, 3.0], 2)\n+        >>> zeros = sc.parallelize([0.0, 0.0, 0.0], 2)\n+        >>> abs(Statistics.corr(x, y) - 0.6546537) < 1e-7\n+        True\n+        >>> Statistics.corr(x, y) == Statistics.corr(x, y, \"pearson\")\n+        True\n+        >>> Statistics.corr(x, y, \"spearman\")\n+        0.5\n+        >>> from math import isnan\n+        >>> isnan(Statistics.corr(x, zeros))\n+        True\n+        >>> from linalg import Vectors\n+        >>> rdd = sc.parallelize([Vectors.dense([1, 0, 0, -2]), Vectors.dense([4, 5, 0, 3]),\n+        ...                       Vectors.dense([6, 7, 0,  8]), Vectors.dense([9, 0, 0, 1])])\n+        >>> Statistics.corr(rdd)\n+        array([[ 1.        ,  0.05564149,         nan,  0.40047142],\n+               [ 0.05564149,  1.        ,         nan,  0.91359586],\n+               [        nan,         nan,  1.        ,         nan],\n+               [ 0.40047142,  0.91359586,         nan,  1.        ]])\n+        >>> Statistics.corr(rdd, \"spearman\")\n+        array([[ 1.        ,  0.10540926,         nan,  0.4       ],\n+               [ 0.10540926,  1.        ,         nan,  0.9486833 ],\n+               [        nan,         nan,  1.        ,         nan],\n+               [ 0.4       ,  0.9486833 ,         nan,  1.        ]])\n+        \"\"\"\n+        sc = x.ctx\n+        # Check inputs to determine whether a single value or a matrix is needed for output.\n+        # Since it's legal for users to use the method name as the second argument, we need to\n+        # check if y is used to specify the method name instead.\n+        if type(y) == str:\n+            if not method:\n+                method = y\n+            else:\n+                raise TypeError(\"Multiple string arguments detected when only at most one \" \\\n+                                + \"allowed for Statistics.corr\")\n+        if not y or type(y) == str:\n+            try:\n+                Xser = _get_unmangled_double_vector_rdd(x)\n+            except TypeError:\n+                raise TypeError(\"corr called on a single RDD not consisted of Vectors.\")\n+            resultMat = sc._jvm.PythonMLLibAPI().corr(Xser._jrdd, method)\n+            return _deserialize_double_matrix(resultMat)\n+        else:\n+            xSer = _get_unmangled_rdd(x, _serialize_double)\n+            ySer = _get_unmangled_rdd(y, _serialize_double)\n+            result = sc._jvm.PythonMLLibAPI().corr(xSer._jrdd, ySer._jrdd, method)\n+            return result\n+\n+\n+def _test():\n+    import doctest\n+    from pyspark import SparkContext\n+    globs = globals().copy()\n+    globs['sc'] = SparkContext('local[4]', 'PythonTest', batchSize=2)\n+    (failure_count, test_count) = doctest.testmod(globs=globs, optionflags=doctest.ELLIPSIS)\n+    globs['sc'].stop()\n+    if failure_count:\n+        exit(-1)\n+\n+\n+if __name__ == \"__main__\":\n+    _test()",
    "line": 104
  }],
  "prId": 1713
}]