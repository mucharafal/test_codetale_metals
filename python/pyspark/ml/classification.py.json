[{
  "comments": [{
    "author": {
      "login": "huaxingao"
    },
    "body": "it's a little strange to have ```setThreshold/Thresholds``` in the XXXParams class, but scala ```LogisticRegressionParams``` does this way, so I just do the same to be consistent with scala side. ",
    "commit": "cdf87c78731747c183d71e5d5fa7c044d1269231",
    "createdAt": "2019-10-16T16:52:09Z",
    "diffHunk": "@@ -271,10 +282,167 @@ def intercept(self):\n         return self._call_java(\"intercept\")\n \n \n+class _LogisticRegressionParams(_JavaProbabilisticClassifierParams, HasRegParam,\n+                                HasElasticNetParam, HasMaxIter, HasFitIntercept, HasTol,\n+                                HasStandardization, HasWeightCol, HasAggregationDepth,\n+                                HasThreshold):\n+    \"\"\"\n+    Params for :py:class:`LogisticRegression` and :py:class:`LogisticRegressionModel`.\n+\n+    .. versionadded:: 3.0.0\n+    \"\"\"\n+\n+    threshold = Param(Params._dummy(), \"threshold\",\n+                      \"Threshold in binary classification prediction, in range [0, 1].\" +\n+                      \" If threshold and thresholds are both set, they must match.\" +\n+                      \"e.g. if threshold is p, then thresholds must be equal to [1-p, p].\",\n+                      typeConverter=TypeConverters.toFloat)\n+\n+    family = Param(Params._dummy(), \"family\",\n+                   \"The name of family which is a description of the label distribution to \" +\n+                   \"be used in the model. Supported options: auto, binomial, multinomial\",\n+                   typeConverter=TypeConverters.toString)\n+\n+    lowerBoundsOnCoefficients = Param(Params._dummy(), \"lowerBoundsOnCoefficients\",\n+                                      \"The lower bounds on coefficients if fitting under bound \"\n+                                      \"constrained optimization. The bound matrix must be \"\n+                                      \"compatible with the shape \"\n+                                      \"(1, number of features) for binomial regression, or \"\n+                                      \"(number of classes, number of features) \"\n+                                      \"for multinomial regression.\",\n+                                      typeConverter=TypeConverters.toMatrix)\n+\n+    upperBoundsOnCoefficients = Param(Params._dummy(), \"upperBoundsOnCoefficients\",\n+                                      \"The upper bounds on coefficients if fitting under bound \"\n+                                      \"constrained optimization. The bound matrix must be \"\n+                                      \"compatible with the shape \"\n+                                      \"(1, number of features) for binomial regression, or \"\n+                                      \"(number of classes, number of features) \"\n+                                      \"for multinomial regression.\",\n+                                      typeConverter=TypeConverters.toMatrix)\n+\n+    lowerBoundsOnIntercepts = Param(Params._dummy(), \"lowerBoundsOnIntercepts\",\n+                                    \"The lower bounds on intercepts if fitting under bound \"\n+                                    \"constrained optimization. The bounds vector size must be\"\n+                                    \"equal with 1 for binomial regression, or the number of\"\n+                                    \"lasses for multinomial regression.\",\n+                                    typeConverter=TypeConverters.toVector)\n+\n+    upperBoundsOnIntercepts = Param(Params._dummy(), \"upperBoundsOnIntercepts\",\n+                                    \"The upper bounds on intercepts if fitting under bound \"\n+                                    \"constrained optimization. The bound vector size must be \"\n+                                    \"equal with 1 for binomial regression, or the number of \"\n+                                    \"classes for multinomial regression.\",\n+                                    typeConverter=TypeConverters.toVector)\n+\n+    @since(\"1.4.0\")\n+    def setThreshold(self, value):\n+        \"\"\"\n+        Sets the value of :py:attr:`threshold`.\n+        Clears value of :py:attr:`thresholds` if it has been set.\n+        \"\"\"\n+        self._set(threshold=value)\n+        self._clear(self.thresholds)\n+        return self\n+\n+    @since(\"1.4.0\")\n+    def getThreshold(self):\n+        \"\"\"\n+        Get threshold for binary classification.\n+\n+        If :py:attr:`thresholds` is set with length 2 (i.e., binary classification),\n+        this returns the equivalent threshold:\n+        :math:`\\\\frac{1}{1 + \\\\frac{thresholds(0)}{thresholds(1)}}`.\n+        Otherwise, returns :py:attr:`threshold` if set or its default value if unset.\n+        \"\"\"\n+        self._checkThresholdConsistency()\n+        if self.isSet(self.thresholds):\n+            ts = self.getOrDefault(self.thresholds)\n+            if len(ts) != 2:\n+                raise ValueError(\"Logistic Regression getThreshold only applies to\" +\n+                                 \" binary classification, but thresholds has length != 2.\" +\n+                                 \"  thresholds: \" + \",\".join(ts))\n+            return 1.0/(1.0 + ts[0]/ts[1])\n+        else:\n+            return self.getOrDefault(self.threshold)\n+\n+    @since(\"1.5.0\")\n+    def setThresholds(self, value):\n+        \"\"\"\n+        Sets the value of :py:attr:`thresholds`.\n+        Clears value of :py:attr:`threshold` if it has been set.\n+        \"\"\"\n+        self._set(thresholds=value)\n+        self._clear(self.threshold)\n+        return self",
    "line": 156
  }],
  "prId": 26142
}]