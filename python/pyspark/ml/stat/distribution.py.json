[{
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "This import should be moved above.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T00:51:27Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "You can use the `numRows`, `numCols`\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T00:54:47Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\""
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "This method is redundant right?\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T00:59:38Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse\n+            s_pinv = self.__pinv_1d(s, eps)\n+\n+            # prec_U ndarray\n+            # A decomposition such that np.dot(prec_U, prec_U.T)\n+            # is the precision matrix, i.e. inverse of the covariance matrix.\n+            self.prec_U = np.multiply(u, np.sqrt(s_pinv))\n+\n+            #log_det_cov : float\n+            #Logarithm of the determinant of the covariance matrix\n+            self.log_det_cov = np.sum(np.log(s[s > eps]))\n+\n+        except ValueError :\n+            raise ValueError(\"Covariance matrix has no non-zero singular values\")\n+\n+    def __pdf(self,x):\n+        \"\"\"\n+        Calculates density at point x using precomputed Constants\n+        \"\"\"\n+        return np.exp(self.__logpdf(x))\n+\n+    def __logpdf(self,x) :\n+        \"\"\"\n+        Calculates log-density at point x using precomputed Constants\n+\n+        x  Points at which to evaluate the log of the probability\n+            density function\n+        log_det_cov : float\n+            Logarithm of the determinant of the covariance matrix\n+\n+        prec_U ndarray\n+            A decomposition such that np.dot(prec_U, prec_U.T)\n+            is the precision matrix, i.e. inverse of the covariance matrix.\n+\n+        \"\"\"\n+        x = self.__process_quantiles(x, self.dim)\n+        dim = x.shape[-1]\n+        delta = x - self.mu\n+        maha = np.sum(np.square(np.dot(delta, self.prec_U)), axis=-1)\n+        return -0.5 * (dim * np.log(2 * np.pi) + self.log_det_cov + maha)\n+\n+\n+     \n+\n+    def __process_parameters(self, dim, mean, cov):"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "Should we fall back to SciPy's multivariate normal if that is present?\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:04:02Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "`# compute the pseudoinverse of s`\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:11:27Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse"
  }, {
    "author": {
      "login": "MechCoder"
    },
    "body": "Also not sure if a one-liner deserves its own helper method with documentation.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:12:41Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "This can be easily vectorized. You are creating a copy anyway.\n\n```\nv_c = np.zeros_like(v)\nmask = v_c <= eps\nv_c[~mask] = 1. / v_c[~mask]\n```\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:15:56Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse\n+            s_pinv = self.__pinv_1d(s, eps)\n+\n+            # prec_U ndarray\n+            # A decomposition such that np.dot(prec_U, prec_U.T)\n+            # is the precision matrix, i.e. inverse of the covariance matrix.\n+            self.prec_U = np.multiply(u, np.sqrt(s_pinv))\n+\n+            #log_det_cov : float\n+            #Logarithm of the determinant of the covariance matrix\n+            self.log_det_cov = np.sum(np.log(s[s > eps]))\n+\n+        except ValueError :\n+            raise ValueError(\"Covariance matrix has no non-zero singular values\")\n+\n+    def __pdf(self,x):\n+        \"\"\"\n+        Calculates density at point x using precomputed Constants\n+        \"\"\"\n+        return np.exp(self.__logpdf(x))\n+\n+    def __logpdf(self,x) :\n+        \"\"\"\n+        Calculates log-density at point x using precomputed Constants\n+\n+        x  Points at which to evaluate the log of the probability\n+            density function\n+        log_det_cov : float\n+            Logarithm of the determinant of the covariance matrix\n+\n+        prec_U ndarray\n+            A decomposition such that np.dot(prec_U, prec_U.T)\n+            is the precision matrix, i.e. inverse of the covariance matrix.\n+\n+        \"\"\"\n+        x = self.__process_quantiles(x, self.dim)\n+        dim = x.shape[-1]\n+        delta = x - self.mu\n+        maha = np.sum(np.square(np.dot(delta, self.prec_U)), axis=-1)\n+        return -0.5 * (dim * np.log(2 * np.pi) + self.log_det_cov + maha)\n+\n+\n+     \n+\n+    def __process_parameters(self, dim, mean, cov):\n+        \"\"\"\n+        Helper funtion to process input values, based on scipy multivariate\n+\n+        Infer dimensionality from mean or covariance matrix, ensure that\n+        mean and covariance are full vector resp. matrix.\n+\n+        \"\"\"\n+\n+        # Try to infer dimensionality\n+        if dim is None:\n+            if mean is None:\n+                if cov is None:\n+                    dim = 1\n+                else:\n+                    cov = np.asarray(cov, dtype=float)\n+                    if cov.ndim < 2:\n+                        dim = 1\n+                    else:\n+                        dim = cov.shape[0]\n+            else:\n+                mean = np.asarray(mean, dtype=float)\n+                dim = mean.size\n+        else:\n+            if not np.isscalar(dim):\n+                raise ValueError(\"Dimension of random variable must be a scalar.\")\n+\n+        # Check input sizes and return full arrays for mean and cov if necessary\n+        if mean is None:\n+            mean = np.zeros(dim)\n+        mean = np.asarray(mean, dtype=float)\n+\n+        if cov is None:\n+            cov = 1.0\n+        cov = np.asarray(cov, dtype=float)\n+\n+        if dim == 1:\n+            mean.shape = (1,)\n+            cov.shape = (1, 1)\n+\n+        if mean.ndim != 1 or mean.shape[0] != dim:\n+            raise ValueError(\"Array 'mean' must be vector of length %d.\" % dim)\n+        if cov.ndim == 0:\n+            cov = cov * np.eye(dim)\n+        elif cov.ndim == 1:\n+            cov = np.diag(cov)\n+        else:\n+            if cov.shape != (dim, dim):\n+                raise ValueError(\"Array 'cov' must be at most two-dimensional,\"\n+                                     \" but cov.ndim = %d\" % cov.ndim)\n+\n+        return dim, mean, cov\n+\n+    def __process_quantiles(self, x, dim):\n+        \"\"\"\n+        Helper funtion to process quantiles, based on scipy multivariate\n+\n+        Adjust quantiles array so that last axis labels the components of\n+        each data point.\n+        \n+        \"\"\"\n+        x = np.asarray(x, dtype=float)\n+\n+        if x.ndim == 0:\n+            x = x[np.newaxis]\n+        elif x.ndim == 1:\n+            if dim == 1:\n+                x = x[:, np.newaxis]\n+            else:\n+                x = x[np.newaxis, :]\n+\n+        return x\n+\n+\n+    def __pinv_1d(self, v, eps=1e-5):\n+        \"\"\"\n+        A helper function for computing the pseudoinverse, based on scipy multivariate \n+\n+        v : iterable of numbers\n+            This may be thought of as a vector of eigenvalues or singular values.\n+        eps : float\n+            Elements of v smaller than eps are considered negligible.\n+        returns  1d float ndarray\n+            A vector of pseudo-inverted numbers. \n+        \"\"\"\n+        return np.array([0 if abs(x) < eps else 1/x for x in v], dtype=float)"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "`u * np.sqrt(s_pinv)` should be a shorthand to do the same thing.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:31:21Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse\n+            s_pinv = self.__pinv_1d(s, eps)\n+\n+            # prec_U ndarray\n+            # A decomposition such that np.dot(prec_U, prec_U.T)\n+            # is the precision matrix, i.e. inverse of the covariance matrix.\n+            self.prec_U = np.multiply(u, np.sqrt(s_pinv))"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "It is safe to assume x is 1-D. You have just asserted that it is a Vector above. (i.e do away with this)\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:33:35Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse\n+            s_pinv = self.__pinv_1d(s, eps)\n+\n+            # prec_U ndarray\n+            # A decomposition such that np.dot(prec_U, prec_U.T)\n+            # is the precision matrix, i.e. inverse of the covariance matrix.\n+            self.prec_U = np.multiply(u, np.sqrt(s_pinv))\n+\n+            #log_det_cov : float\n+            #Logarithm of the determinant of the covariance matrix\n+            self.log_det_cov = np.sum(np.log(s[s > eps]))\n+\n+        except ValueError :\n+            raise ValueError(\"Covariance matrix has no non-zero singular values\")\n+\n+    def __pdf(self,x):\n+        \"\"\"\n+        Calculates density at point x using precomputed Constants\n+        \"\"\"\n+        return np.exp(self.__logpdf(x))\n+\n+    def __logpdf(self,x) :\n+        \"\"\"\n+        Calculates log-density at point x using precomputed Constants\n+\n+        x  Points at which to evaluate the log of the probability\n+            density function\n+        log_det_cov : float\n+            Logarithm of the determinant of the covariance matrix\n+\n+        prec_U ndarray\n+            A decomposition such that np.dot(prec_U, prec_U.T)\n+            is the precision matrix, i.e. inverse of the covariance matrix.\n+\n+        \"\"\"\n+        x = self.__process_quantiles(x, self.dim)"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "MechCoder"
    },
    "body": "you should replace `np.sum(np.square(` with `np.dot` operations.\n\n```\ndelta_U = np.dot(delta, self.prec_U)\nmaha = np.dot(delta_U, delta_U)\n```\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T01:36:58Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse\n+            s_pinv = self.__pinv_1d(s, eps)\n+\n+            # prec_U ndarray\n+            # A decomposition such that np.dot(prec_U, prec_U.T)\n+            # is the precision matrix, i.e. inverse of the covariance matrix.\n+            self.prec_U = np.multiply(u, np.sqrt(s_pinv))\n+\n+            #log_det_cov : float\n+            #Logarithm of the determinant of the covariance matrix\n+            self.log_det_cov = np.sum(np.log(s[s > eps]))\n+\n+        except ValueError :\n+            raise ValueError(\"Covariance matrix has no non-zero singular values\")\n+\n+    def __pdf(self,x):\n+        \"\"\"\n+        Calculates density at point x using precomputed Constants\n+        \"\"\"\n+        return np.exp(self.__logpdf(x))\n+\n+    def __logpdf(self,x) :\n+        \"\"\"\n+        Calculates log-density at point x using precomputed Constants\n+\n+        x  Points at which to evaluate the log of the probability\n+            density function\n+        log_det_cov : float\n+            Logarithm of the determinant of the covariance matrix\n+\n+        prec_U ndarray\n+            A decomposition such that np.dot(prec_U, prec_U.T)\n+            is the precision matrix, i.e. inverse of the covariance matrix.\n+\n+        \"\"\"\n+        x = self.__process_quantiles(x, self.dim)\n+        dim = x.shape[-1]\n+        delta = x - self.mu\n+        maha = np.sum(np.square(np.dot(delta, self.prec_U)), axis=-1)"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "vectorijk"
    },
    "body": "you could use\n\n```\n`<http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case>`_\n```\n\nto make sure link displayed correctly in documentation.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T07:28:18Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "vectorijk"
    },
    "body": "same here.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-06-04T07:28:32Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "lins05"
    },
    "body": "To run the doctest, I think we need to call the `doctest.testmod()` explicitly like other modules do. Check [mllib/util.py](https://github.com/apache/spark/blob/v2.0.0-rc2/python/pyspark/mllib/util.py#L509-L528).\n\nAlso need to add this module to the `python_test_goals` to pyspark_ml module object of [dev/sparktestsupport/modules.py](https://github.com/apache/spark/blob/v2.0.0-rc2/dev/sparktestsupport/modules.py#L401-L411)\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-10T14:43:31Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "lins05"
    },
    "body": "`Vectors` is not imported in this module.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-10T14:44:15Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])"
  }, {
    "author": {
      "login": "praveendareddy21"
    },
    "body": "Vectors is used for creating Vector Object. But this class takes already created object as input.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-11T00:52:48Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])"
  }, {
    "author": {
      "login": "lins05"
    },
    "body": "I see, but the missing import of `Vectors` would fail the doctest.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-11T03:31:00Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "lins05"
    },
    "body": "Two many blank lines above.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-10T14:45:15Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\""
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "lins05"
    },
    "body": "Insert one space before and after the `=`.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-10T14:45:41Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu"
  }],
  "prId": 13248
}, {
  "comments": [{
    "author": {
      "login": "lins05"
    },
    "body": "The docstring is inconsistent with the method signature.\n",
    "commit": "901d2b0d6b23dd6126ed2f15c36a49451fa85cce",
    "createdAt": "2016-07-10T14:46:21Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from pyspark.ml.linalg import DenseVector, DenseMatrix, Vector\n+import numpy as np\n+\n+__all__ = ['MultivariateGaussian']\n+\n+\n+\n+class MultivariateGaussian():\n+    \"\"\"\n+    This class provides basic functionality for a Multivariate Gaussian (Normal) Distribution. In\n+     the event that the covariance matrix is singular, the density will be computed in a\n+    reduced dimensional subspace under which the distribution is supported.\n+    (see [[http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Degenerate_case]])\n+\n+    mu The mean vector of the distribution\n+    sigma The covariance matrix of the distribution\n+\n+\n+    >>> mu = Vectors.dense([0.0, 0.0])\n+    >>> sigma= DenseMatrix(2, 2, [1.0, 1.0, 1.0, 1.0])\n+    >>> x = Vectors.dense([1.0, 1.0])\n+    >>> m = MultivariateGaussian(mu, sigma)\n+    >>> m.pdf(x)\n+    0.0682586811486\n+\n+    \"\"\"\n+\n+    def __init__(self, mu, sigma):\n+        \"\"\"\n+        __init__(self, mu, sigma)\n+\n+        mu The mean vector of the distribution\n+        sigma The covariance matrix of the distribution\n+\n+        mu and sigma must be instances of DenseVector and DenseMatrix respectively.\n+\n+        \"\"\"\n+\n+\n+        assert (isinstance(mu, DenseVector)), \"mu must be a DenseVector Object\"\n+        assert (isinstance(sigma, DenseMatrix)), \"sigma must be a DenseMatrix Object\"\n+\n+        sigma_shape=sigma.toArray().shape\n+        assert (sigma_shape[0]==sigma_shape[1]) , \"Covariance matrix must be square\"\n+        assert (sigma_shape[0]==mu.size) , \"Mean vector length must match covariance matrix size\"\n+\n+        # initialize eagerly precomputed attributes\n+        \n+        self.mu=mu\n+\n+        # storing sigma as numpy.ndarray\n+        # furthur calculations are done ndarray only\n+        self.sigma=sigma.toArray()\n+        \n+\n+        # initialize attributes to be computed later\n+\n+        self.prec_U = None\n+        self.log_det_cov = None\n+\n+        # compute distribution dependent constants\n+        self.__calculateCovarianceConstants()\n+\n+\n+    def pdf(self,x):\n+        \"\"\"\n+        Returns density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__pdf(x))\n+\n+    def logpdf(self,x):\n+        \"\"\"\n+        Returns the log-density of this multivariate Gaussian at a point given by Vector x\n+        \"\"\"\n+        assert (isinstance(x, Vector)), \"x must be of Vector Type\"\n+        return float(self.__logpdf(x))\n+\n+    def __calculateCovarianceConstants(self):\n+        \"\"\"\n+        Calculates distribution dependent components used for the density function\n+        based on scipy multivariate library\n+        refer https://github.com/scipy/scipy/blob/master/scipy/stats/_multivariate.py\n+        tested with precision of 9 significant digits(refer testcase)\n+        \n+\n+        \"\"\"\n+\n+        try :\n+            # pre-processing input parameters\n+            # throws ValueError with invalid inputs\n+            self.dim, self.mu, self.sigma = self.__process_parameters(None, self.mu, self.sigma)\n+\n+            # return the eigenvalues and eigenvectors \n+            # of a Hermitian or symmetric matrix.\n+            # s =  eigen values\n+            # u = eigen vectors\n+            s, u = np.linalg.eigh(self.sigma)\n+\n+            #Singular values are considered to be non-zero only if \n+            #they exceed a tolerance based on machine precision, matrix size, and\n+            #relation to the maximum singular value (same tolerance used by, e.g., Octave).\n+\n+            # calculation for machine precision\n+            t = u.dtype.char.lower()\n+            factor = {'f': 1E3, 'd': 1E6}\n+            cond = factor[t] * np.finfo(t).eps\n+\n+            eps = cond * np.max(abs(s))\n+\n+            # checkng whether covariance matrix has any non-zero singular values\n+            if np.min(s) < -eps:\n+                raise ValueError\n+\n+            #computing the pseudoinverse\n+            s_pinv = self.__pinv_1d(s, eps)\n+\n+            # prec_U ndarray\n+            # A decomposition such that np.dot(prec_U, prec_U.T)\n+            # is the precision matrix, i.e. inverse of the covariance matrix.\n+            self.prec_U = np.multiply(u, np.sqrt(s_pinv))\n+\n+            #log_det_cov : float\n+            #Logarithm of the determinant of the covariance matrix\n+            self.log_det_cov = np.sum(np.log(s[s > eps]))\n+\n+        except ValueError :\n+            raise ValueError(\"Covariance matrix has no non-zero singular values\")\n+\n+    def __pdf(self,x):\n+        \"\"\"\n+        Calculates density at point x using precomputed Constants\n+        \"\"\"\n+        return np.exp(self.__logpdf(x))\n+\n+    def __logpdf(self,x) :\n+        \"\"\"\n+        Calculates log-density at point x using precomputed Constants\n+\n+        x  Points at which to evaluate the log of the probability\n+            density function\n+        log_det_cov : float\n+            Logarithm of the determinant of the covariance matrix\n+\n+        prec_U ndarray\n+            A decomposition such that np.dot(prec_U, prec_U.T)\n+            is the precision matrix, i.e. inverse of the covariance matrix.\n+"
  }],
  "prId": 13248
}]