[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Also add a test case for this?",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-01-31T22:16:02Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.",
    "line": 12
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "ok, done, please review",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-02T13:26:00Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.",
    "line": 12
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "It sounds like we missing the case when `numPartitions ` is not provided. Please check the above implementation of `repartition`?",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-01-31T22:18:50Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> data = df.union(df).repartition(1, \"age\")\n+        >>> data.rdd.getNumPartitions()\n+        1\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data = data.repartitionByRange(3, \"age\")\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        \"\"\"\n+        if isinstance(numPartitions, int):\n+            if len(cols) == 0:\n+                return ValueError(\"At least one partition-by expression must be specified.\")\n+            else:\n+                return DataFrame(\n+                    self._jdf.repartitionByRange(numPartitions, self._jcols(*cols)), self.sql_ctx)\n+        else:"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "ok,done, please review",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-02T13:25:49Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> data = df.union(df).repartition(1, \"age\")\n+        >>> data.rdd.getNumPartitions()\n+        1\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data = data.repartitionByRange(3, \"age\")\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        \"\"\"\n+        if isinstance(numPartitions, int):\n+            if len(cols) == 0:\n+                return ValueError(\"At least one partition-by expression must be specified.\")\n+            else:\n+                return DataFrame(\n+                    self._jdf.repartitionByRange(numPartitions, self._jcols(*cols)), self.sql_ctx)\n+        else:"
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Mind if I ask why we added `**kwargs`?",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-01T03:31:35Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "sorryï¼Œ unused,  remove it",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-02T12:00:25Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):"
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think we don't have to test `repartition` within `repartitionByRange`'s doctest but leave\r\n\r\n``  .. seealso:: :meth:`repartition` ``",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-01T03:50:16Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> data = df.union(df).repartition(1, \"age\")"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "ok, change it to repartitionByRange",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-02T12:04:12Z",
    "diffHunk": "@@ -667,6 +667,55 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols, **kwargs):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> data = df.union(df).repartition(1, \"age\")"
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think we don't need `union` too.",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-02T13:59:56Z",
    "diffHunk": "@@ -667,6 +667,92 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.union(df)\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data = data.repartitionByRange(3, \"age\")\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data = data.repartitionByRange(\"age\")\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data2 = df.union(df).union(df)"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "How to test data after repartitionByRange(\"age\")",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-03T13:09:24Z",
    "diffHunk": "@@ -667,6 +667,92 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.union(df)\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data = data.repartitionByRange(3, \"age\")\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data = data.repartitionByRange(\"age\")\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data2 = df.union(df).union(df)"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "If it's a test purpose only, let's put this in `pyspark/sql/tests.py`.",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-03T16:33:48Z",
    "diffHunk": "@@ -667,6 +667,92 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.union(df)\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data = data.repartitionByRange(3, \"age\")\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data = data.repartitionByRange(\"age\")\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data2 = df.union(df).union(df)"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "ok, remove union",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-04T08:08:04Z",
    "diffHunk": "@@ -667,6 +667,92 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.union(df)\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data = data.repartitionByRange(3, \"age\")\n+        >>> data.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  2|Alice|\n+        |  5|  Bob|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data = data.repartitionByRange(\"age\")\n+        >>> data.rdd.getNumPartitions()\n+        3\n+        >>> data2 = df.union(df).union(df)"
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "ditto - I think `repartitionByRange` doctest should focus on `repartitionByRange`.",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-02T14:01:55Z",
    "diffHunk": "@@ -667,6 +667,92 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.union(df)"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "How to test data after repartitionByRange(\"age\")?",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-03T13:09:31Z",
    "diffHunk": "@@ -667,6 +667,92 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.union(df)"
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "`an int or Column` -> `an int, string or Column`",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-04T09:16:00Z",
    "diffHunk": "@@ -667,6 +667,51 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.repartitionByRange(\"age\")\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        \"\"\"\n+        if isinstance(numPartitions, int):\n+            if len(cols) == 0:\n+                return ValueError(\"At least one partition-by expression must be specified.\")\n+            else:\n+                return DataFrame(\n+                    self._jdf.repartitionByRange(numPartitions, self._jcols(*cols)), self.sql_ctx)\n+        elif isinstance(numPartitions, (basestring, Column)):\n+            cols = (numPartitions,) + cols\n+            return DataFrame(self._jdf.repartitionByRange(self._jcols(*cols)), self.sql_ctx)\n+        else:\n+            raise TypeError(\"numPartitions should be an int or Column\")"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "ok, done",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-04T09:44:48Z",
    "diffHunk": "@@ -667,6 +667,51 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")\n+    def repartitionByRange(self, numPartitions, *cols):\n+        \"\"\"\n+        Returns a new :class:`DataFrame` partitioned by the given partitioning expressions. The\n+        resulting DataFrame is range partitioned.\n+\n+        ``numPartitions`` can be an int to specify the target number of partitions or a Column.\n+        If it is a Column, it will be used as the first partitioning column. If not specified,\n+        the default number of partitions is used.\n+\n+        At least one partition-by expression must be specified.\n+        When no explicit sort order is specified, \"ascending nulls first\" is assumed.\n+\n+        >>> df.repartitionByRange(2, \"age\").rdd.getNumPartitions()\n+        2\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        >>> df.repartitionByRange(1, \"age\").rdd.getNumPartitions()\n+        1\n+        >>> data = df.repartitionByRange(\"age\")\n+        >>> df.show()\n+        +---+-----+\n+        |age| name|\n+        +---+-----+\n+        |  2|Alice|\n+        |  5|  Bob|\n+        +---+-----+\n+        \"\"\"\n+        if isinstance(numPartitions, int):\n+            if len(cols) == 0:\n+                return ValueError(\"At least one partition-by expression must be specified.\")\n+            else:\n+                return DataFrame(\n+                    self._jdf.repartitionByRange(numPartitions, self._jcols(*cols)), self.sql_ctx)\n+        elif isinstance(numPartitions, (basestring, Column)):\n+            cols = (numPartitions,) + cols\n+            return DataFrame(self._jdf.repartitionByRange(self._jcols(*cols)), self.sql_ctx)\n+        else:\n+            raise TypeError(\"numPartitions should be an int or Column\")"
  }],
  "prId": 20456
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Hm, I prefer 2.4.0 but am okay with 2.3.0.",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-04T09:21:10Z",
    "diffHunk": "@@ -667,6 +667,51 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Sorry, shall we just target 2.4.0?",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-06T00:28:00Z",
    "diffHunk": "@@ -667,6 +667,51 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")"
  }, {
    "author": {
      "login": "xubo245"
    },
    "body": "ok, rename to 2.4.0, done",
    "commit": "67feea1c3b8ddc5d8292565e4aacd25bf853e310",
    "createdAt": "2018-02-06T01:09:20Z",
    "diffHunk": "@@ -667,6 +667,51 @@ def repartition(self, numPartitions, *cols):\n         else:\n             raise TypeError(\"numPartitions should be an int or Column\")\n \n+    @since(\"2.3.0\")"
  }],
  "prId": 20456
}]