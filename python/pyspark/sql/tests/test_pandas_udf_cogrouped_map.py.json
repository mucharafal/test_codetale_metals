[{
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "I don't think you need a newline here?",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-07-10T22:02:02Z",
    "diffHunk": "@@ -0,0 +1,257 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+",
    "line": 20
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "could you combine this with `_test_with_key_left` and just add a param to choose which udf to apply?",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-07-10T22:11:14Z",
    "diffHunk": "@@ -0,0 +1,257 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, output_schema='id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_df = self.spark\\\n+            .createDataFrame(left)\\\n+            .groupby(col('id') % 2 == 0)\n+\n+        right_df = self.spark \\\n+            .createDataFrame(right) \\\n+            .groupby(col('id') % 2 == 0)\n+\n+        @pandas_udf('k long, v long, v2 long', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l[['k', 'v']], r[['k', 'v2']], on=['k'])\n+\n+        result = left_df \\\n+            .cogroup(right_df) \\\n+            .apply(merge_pandas) \\\n+            .sort(['k']) \\\n+            .toPandas()\n+\n+        expected = pd.DataFrame.from_dict({\n+            'k': [5, 6, 7],\n+            'v': [9, 10, 11],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_with_key_left(self):\n+        self._test_with_key_left(self.data1, self.data2)\n+\n+    def test_with_key_right(self):\n+        self._test_with_key_right(self.data1, self.data2)\n+\n+    def test_with_key_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_with_key_right(left, self.data2)\n+\n+    def test_with_key_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_with_key_left(self.data1, right)\n+\n+    def test_with_key_complex(self):\n+\n+        @pandas_udf('id long, k int, v int, key boolean', PandasUDFType.COGROUPED_MAP)\n+        def left_assign_key(key, l, _):\n+            return l.assign(key=key[0])\n+\n+        result = self.data1 \\\n+            .groupby(col('id') % 2 == 0)\\\n+            .cogroup(self.data2.groupby(col('id') % 2 == 0)) \\\n+            .apply(left_assign_key) \\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        expected = self.data1.toPandas()\n+        expected = expected.assign(key=expected.id % 2 == 0)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_wrong_return_type(self):\n+        with QuietTest(self.sc):\n+            with self.assertRaisesRegexp(\n+                    NotImplementedError,\n+                    'Invalid returnType.*cogrouped map Pandas UDF.*MapType'):\n+                pandas_udf(\n+                    lambda l, r: l,\n+                    'id long, v map<int, int>',\n+                    PandasUDFType.COGROUPED_MAP)\n+\n+    def test_wrong_args(self):\n+        left = self.data1\n+        right = self.data2\n+\n+        with QuietTest(self.sc):\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(lambda l, r: l)\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(udf(lambda l, r: l, DoubleType()))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(sum(left.v))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(left.v + 1)\n+            with self.assertRaisesRegexp(ValueError, 'Invalid function'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(\n+                    pandas_udf(lambda: 1, StructType([StructField(\"d\", DoubleType())])))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(pandas_udf(lambda x, y: x, DoubleType()))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf.*COGROUPED_MAP'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(\n+                    pandas_udf(lambda x, y: x, DoubleType(), PandasUDFType.SCALAR))\n+\n+    @staticmethod\n+    def _test_with_key_left(left, right):\n+\n+        @pandas_udf('id long, k int, v int, key long', PandasUDFType.COGROUPED_MAP)\n+        def left_assign_key(key, l, _):\n+            return l.assign(key=key[0])\n+\n+        result = left \\\n+            .groupby('id') \\\n+            .cogroup(right.groupby('id')) \\\n+            .apply(left_assign_key) \\\n+            .toPandas()\n+\n+        expected = left.toPandas()\n+        expected = expected.assign(key=expected.id)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    @staticmethod\n+    def _test_with_key_right(left, right):"
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "The above block is a little hard to sift through. Maybe add a comment above each case to describe what case it is?",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-07-10T22:14:02Z",
    "diffHunk": "@@ -0,0 +1,257 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, output_schema='id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_df = self.spark\\\n+            .createDataFrame(left)\\\n+            .groupby(col('id') % 2 == 0)\n+\n+        right_df = self.spark \\\n+            .createDataFrame(right) \\\n+            .groupby(col('id') % 2 == 0)\n+\n+        @pandas_udf('k long, v long, v2 long', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l[['k', 'v']], r[['k', 'v2']], on=['k'])\n+\n+        result = left_df \\\n+            .cogroup(right_df) \\\n+            .apply(merge_pandas) \\\n+            .sort(['k']) \\\n+            .toPandas()\n+\n+        expected = pd.DataFrame.from_dict({\n+            'k': [5, 6, 7],\n+            'v': [9, 10, 11],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_with_key_left(self):\n+        self._test_with_key_left(self.data1, self.data2)\n+\n+    def test_with_key_right(self):\n+        self._test_with_key_right(self.data1, self.data2)\n+\n+    def test_with_key_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_with_key_right(left, self.data2)\n+\n+    def test_with_key_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_with_key_left(self.data1, right)\n+\n+    def test_with_key_complex(self):\n+\n+        @pandas_udf('id long, k int, v int, key boolean', PandasUDFType.COGROUPED_MAP)\n+        def left_assign_key(key, l, _):\n+            return l.assign(key=key[0])\n+\n+        result = self.data1 \\\n+            .groupby(col('id') % 2 == 0)\\\n+            .cogroup(self.data2.groupby(col('id') % 2 == 0)) \\\n+            .apply(left_assign_key) \\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        expected = self.data1.toPandas()\n+        expected = expected.assign(key=expected.id % 2 == 0)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_wrong_return_type(self):\n+        with QuietTest(self.sc):\n+            with self.assertRaisesRegexp(\n+                    NotImplementedError,\n+                    'Invalid returnType.*cogrouped map Pandas UDF.*MapType'):\n+                pandas_udf(\n+                    lambda l, r: l,\n+                    'id long, v map<int, int>',\n+                    PandasUDFType.COGROUPED_MAP)\n+\n+    def test_wrong_args(self):\n+        left = self.data1\n+        right = self.data2\n+\n+        with QuietTest(self.sc):\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(lambda l, r: l)\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(udf(lambda l, r: l, DoubleType()))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(sum(left.v))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(left.v + 1)\n+            with self.assertRaisesRegexp(ValueError, 'Invalid function'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(\n+                    pandas_udf(lambda: 1, StructType([StructField(\"d\", DoubleType())])))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(pandas_udf(lambda x, y: x, DoubleType()))\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf.*COGROUPED_MAP'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(\n+                    pandas_udf(lambda x, y: x, DoubleType(), PandasUDFType.SCALAR))"
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "So is this filtering out half of the groups in the left?",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-07-10T22:16:00Z",
    "diffHunk": "@@ -0,0 +1,257 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, output_schema='id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_df = self.spark\\\n+            .createDataFrame(left)\\\n+            .groupby(col('id') % 2 == 0)\n+\n+        right_df = self.spark \\\n+            .createDataFrame(right) \\\n+            .groupby(col('id') % 2 == 0)\n+\n+        @pandas_udf('k long, v long, v2 long', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l[['k', 'v']], r[['k', 'v2']], on=['k'])\n+\n+        result = left_df \\\n+            .cogroup(right_df) \\\n+            .apply(merge_pandas) \\\n+            .sort(['k']) \\\n+            .toPandas()\n+\n+        expected = pd.DataFrame.from_dict({\n+            'k': [5, 6, 7],\n+            'v': [9, 10, 11],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_with_key_left(self):\n+        self._test_with_key_left(self.data1, self.data2)\n+\n+    def test_with_key_right(self):\n+        self._test_with_key_right(self.data1, self.data2)\n+\n+    def test_with_key_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)",
    "line": 162
  }, {
    "author": {
      "login": "d80tb7"
    },
    "body": "yes, by default `self.data1` and `self.data2` are set up so that all cogroups will have data present on both the left and right sides.  Some of these tests filter out half the data on one side so we can test that everything works correctly if we have data on one side of the cogroup but not the other.",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-07-11T20:54:00Z",
    "diffHunk": "@@ -0,0 +1,257 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, output_schema='id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_df = self.spark\\\n+            .createDataFrame(left)\\\n+            .groupby(col('id') % 2 == 0)\n+\n+        right_df = self.spark \\\n+            .createDataFrame(right) \\\n+            .groupby(col('id') % 2 == 0)\n+\n+        @pandas_udf('k long, v long, v2 long', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l[['k', 'v']], r[['k', 'v2']], on=['k'])\n+\n+        result = left_df \\\n+            .cogroup(right_df) \\\n+            .apply(merge_pandas) \\\n+            .sort(['k']) \\\n+            .toPandas()\n+\n+        expected = pd.DataFrame.from_dict({\n+            'k': [5, 6, 7],\n+            'v': [9, 10, 11],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_with_key_left(self):\n+        self._test_with_key_left(self.data1, self.data2)\n+\n+    def test_with_key_right(self):\n+        self._test_with_key_right(self.data1, self.data2)\n+\n+    def test_with_key_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)",
    "line": 162
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "icexelloss"
    },
    "body": "Maybe rename to `left_gdf` (left grouped dataframe)?",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-08-06T22:28:22Z",
    "diffHunk": "@@ -0,0 +1,285 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, 'id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_df = self.spark\\"
  }, {
    "author": {
      "login": "d80tb7"
    },
    "body": "yes- that's better- done.",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-08-20T15:25:02Z",
    "diffHunk": "@@ -0,0 +1,285 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, 'id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_df = self.spark\\"
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "Could you reorganize imports? Seems like there are unused imports.",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-08-27T20:11:14Z",
    "diffHunk": "@@ -0,0 +1,285 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import datetime\n+import unittest\n+import sys\n+\n+from collections import OrderedDict\n+from decimal import Decimal\n+\n+from pyspark.sql import Row\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import *\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa",
    "line": 32
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think we should leave this as a comment, not a string. Since it's not the top of the module currently, it's not docstring either.",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-09-22T08:51:13Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import unittest\n+import sys\n+\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import DoubleType, StructType, StructField\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check",
    "line": 37
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit\r\n\r\n```python\r\n_check_column_type = sys.version >= '3'\r\n```",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-09-22T08:51:51Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import unittest\n+import sys\n+\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import DoubleType, StructType, StructField\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False",
    "line": 40
  }],
  "prId": 24981
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "This file should be added into `dev/sparktestsupport/modules.py`; otherwise, we don't actually run the tests ...",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-09-22T08:53:50Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import unittest\n+import sys\n+\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import DoubleType, StructType, StructField\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, 'id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_gdf = self.spark\\\n+            .createDataFrame(left)\\\n+            .groupby(col('id') % 2 == 0)\n+\n+        right_gdf = self.spark \\\n+            .createDataFrame(right) \\\n+            .groupby(col('id') % 2 == 0)\n+\n+        @pandas_udf('k long, v long, v2 long', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l[['k', 'v']], r[['k', 'v2']], on=['k'])\n+\n+        result = left_gdf \\\n+            .cogroup(right_gdf) \\\n+            .apply(merge_pandas) \\\n+            .sort(['k']) \\\n+            .toPandas()\n+\n+        expected = pd.DataFrame.from_dict({\n+            'k': [5, 6, 7],\n+            'v': [9, 10, 11],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_empty_group_by(self):\n+        left = self.data1\n+        right = self.data2\n+\n+        @pandas_udf('id long, k int, v int, v2 int', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l, r, on=['id', 'k'])\n+\n+        result = left.groupby().cogroup(right.groupby())\\\n+            .apply(merge_pandas) \\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        left = left.toPandas()\n+        right = right.toPandas()\n+\n+        expected = pd \\\n+            .merge(left, right, on=['id', 'k']) \\\n+            .sort_values(by=['id', 'k'])\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_mixed_scalar_udfs_followed_by_cogrouby_apply(self):\n+        df = self.spark.range(0, 10).toDF('v1')\n+        df = df.withColumn('v2', udf(lambda x: x + 1, 'int')(df['v1'])) \\\n+            .withColumn('v3', pandas_udf(lambda x: x + 2, 'int')(df['v1']))\n+\n+        result = df.groupby().cogroup(df.groupby())\\\n+            .apply(pandas_udf(lambda x, y: pd.DataFrame([(x.sum().sum(), y.sum().sum())]),\n+                              'sum1 int, sum2 int',\n+                              PandasUDFType.COGROUPED_MAP)).collect()\n+\n+        self.assertEquals(result[0]['sum1'], 165)\n+        self.assertEquals(result[0]['sum2'], 165)\n+\n+    def test_with_key_left(self):\n+        self._test_with_key(self.data1, self.data1, isLeft=True)\n+\n+    def test_with_key_right(self):\n+        self._test_with_key(self.data1, self.data1, isLeft=False)\n+\n+    def test_with_key_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_with_key(left, self.data1, isLeft=True)\n+\n+    def test_with_key_right_group_empty(self):\n+        right = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_with_key(self.data1, right, isLeft=False)\n+\n+    def test_with_key_complex(self):\n+\n+        @pandas_udf('id long, k int, v int, key boolean', PandasUDFType.COGROUPED_MAP)\n+        def left_assign_key(key, l, _):\n+            return l.assign(key=key[0])\n+\n+        result = self.data1 \\\n+            .groupby(col('id') % 2 == 0)\\\n+            .cogroup(self.data2.groupby(col('id') % 2 == 0)) \\\n+            .apply(left_assign_key) \\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        expected = self.data1.toPandas()\n+        expected = expected.assign(key=expected.id % 2 == 0)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_wrong_return_type(self):\n+        with QuietTest(self.sc):\n+            with self.assertRaisesRegexp(\n+                    NotImplementedError,\n+                    'Invalid returnType.*cogrouped map Pandas UDF.*MapType'):\n+                pandas_udf(\n+                    lambda l, r: l,\n+                    'id long, v map<int, int>',\n+                    PandasUDFType.COGROUPED_MAP)\n+\n+    def test_wrong_args(self):\n+        # Test that we get a sensible exception invalid values passed to apply\n+        left = self.data1\n+        right = self.data2\n+        with QuietTest(self.sc):\n+            # Function rather than a udf\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(lambda l, r: l)\n+\n+            # Udf missing return type\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(udf(lambda l, r: l, DoubleType()))\n+\n+            # Pass in expression rather than udf\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(left.v + 1)\n+\n+            # Zero arg function\n+            with self.assertRaisesRegexp(ValueError, 'Invalid function'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(pandas_udf(lambda: 1, StructType([StructField(\"d\", DoubleType())])))\n+\n+            # Udf without PandasUDFType\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(pandas_udf(lambda x, y: x, DoubleType()))\n+\n+            # Udf with incorrect PandasUDFType\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf.*COGROUPED_MAP'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(pandas_udf(lambda x, y: x, DoubleType(), PandasUDFType.SCALAR))\n+\n+    @staticmethod\n+    def _test_with_key(left, right, isLeft):\n+\n+        @pandas_udf('id long, k int, v int, key long', PandasUDFType.COGROUPED_MAP)\n+        def right_assign_key(key, l, r):\n+            return l.assign(key=key[0]) if isLeft else r.assign(key=key[0])\n+\n+        result = left \\\n+            .groupby('id') \\\n+            .cogroup(right.groupby('id')) \\\n+            .apply(right_assign_key) \\\n+            .toPandas()\n+\n+        expected = left.toPandas() if isLeft else right.toPandas()\n+        expected = expected.assign(key=expected.id)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    @staticmethod\n+    def _test_merge(left, right, output_schema='id long, k int, v int, v2 int'):\n+\n+        @pandas_udf(output_schema, PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l, r, on=['id', 'k'])\n+\n+        result = left \\\n+            .groupby('id') \\\n+            .cogroup(right.groupby('id')) \\\n+            .apply(merge_pandas)\\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        left = left.toPandas()\n+        right = right.toPandas()\n+\n+        expected = pd \\\n+            .merge(left, right, on=['id', 'k']) \\\n+            .sort_values(by=['id', 'k'])\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+\n+if __name__ == \"__main__\":",
    "line": 272
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "addressed at https://github.com/apache/spark/pull/25890",
    "commit": "1b966fda46c5334cf7963bae0bece159c9568622",
    "createdAt": "2019-09-22T12:44:16Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+import unittest\n+import sys\n+\n+from pyspark.sql.functions import array, explode, col, lit, udf, sum, pandas_udf, PandasUDFType\n+from pyspark.sql.types import DoubleType, StructType, StructField\n+from pyspark.testing.sqlutils import ReusedSQLTestCase, have_pandas, have_pyarrow, \\\n+    pandas_requirement_message, pyarrow_requirement_message\n+from pyspark.testing.utils import QuietTest\n+\n+if have_pandas:\n+    import pandas as pd\n+    from pandas.util.testing import assert_frame_equal, assert_series_equal\n+\n+if have_pyarrow:\n+    import pyarrow as pa\n+\n+\n+\"\"\"\n+Tests below use pd.DataFrame.assign that will infer mixed types (unicode/str) for column names\n+from kwargs w/ Python 2, so need to set check_column_type=False and avoid this check\n+\"\"\"\n+if sys.version < '3':\n+    _check_column_type = False\n+else:\n+    _check_column_type = True\n+\n+\n+@unittest.skipIf(\n+    not have_pandas or not have_pyarrow,\n+    pandas_requirement_message or pyarrow_requirement_message)\n+class CoGroupedMapPandasUDFTests(ReusedSQLTestCase):\n+\n+    @property\n+    def data1(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks')))\\\n+            .withColumn(\"v\", col('k') * 10)\\\n+            .drop('ks')\n+\n+    @property\n+    def data2(self):\n+        return self.spark.range(10).toDF('id') \\\n+            .withColumn(\"ks\", array([lit(i) for i in range(20, 30)])) \\\n+            .withColumn(\"k\", explode(col('ks'))) \\\n+            .withColumn(\"v2\", col('k') * 100) \\\n+            .drop('ks')\n+\n+    def test_simple(self):\n+        self._test_merge(self.data1, self.data2)\n+\n+    def test_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_merge(left, self.data2)\n+\n+    def test_right_group_empty(self):\n+        right = self.data2.where(col(\"id\") % 2 == 0)\n+        self._test_merge(self.data1, right)\n+\n+    def test_different_schemas(self):\n+        right = self.data2.withColumn('v3', lit('a'))\n+        self._test_merge(self.data1, right, 'id long, k int, v int, v2 int, v3 string')\n+\n+    def test_complex_group_by(self):\n+        left = pd.DataFrame.from_dict({\n+            'id': [1, 2, 3],\n+            'k':  [5, 6, 7],\n+            'v': [9, 10, 11]\n+        })\n+\n+        right = pd.DataFrame.from_dict({\n+            'id': [11, 12, 13],\n+            'k': [5, 6, 7],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        left_gdf = self.spark\\\n+            .createDataFrame(left)\\\n+            .groupby(col('id') % 2 == 0)\n+\n+        right_gdf = self.spark \\\n+            .createDataFrame(right) \\\n+            .groupby(col('id') % 2 == 0)\n+\n+        @pandas_udf('k long, v long, v2 long', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l[['k', 'v']], r[['k', 'v2']], on=['k'])\n+\n+        result = left_gdf \\\n+            .cogroup(right_gdf) \\\n+            .apply(merge_pandas) \\\n+            .sort(['k']) \\\n+            .toPandas()\n+\n+        expected = pd.DataFrame.from_dict({\n+            'k': [5, 6, 7],\n+            'v': [9, 10, 11],\n+            'v2': [90, 100, 110]\n+        })\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_empty_group_by(self):\n+        left = self.data1\n+        right = self.data2\n+\n+        @pandas_udf('id long, k int, v int, v2 int', PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l, r, on=['id', 'k'])\n+\n+        result = left.groupby().cogroup(right.groupby())\\\n+            .apply(merge_pandas) \\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        left = left.toPandas()\n+        right = right.toPandas()\n+\n+        expected = pd \\\n+            .merge(left, right, on=['id', 'k']) \\\n+            .sort_values(by=['id', 'k'])\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_mixed_scalar_udfs_followed_by_cogrouby_apply(self):\n+        df = self.spark.range(0, 10).toDF('v1')\n+        df = df.withColumn('v2', udf(lambda x: x + 1, 'int')(df['v1'])) \\\n+            .withColumn('v3', pandas_udf(lambda x: x + 2, 'int')(df['v1']))\n+\n+        result = df.groupby().cogroup(df.groupby())\\\n+            .apply(pandas_udf(lambda x, y: pd.DataFrame([(x.sum().sum(), y.sum().sum())]),\n+                              'sum1 int, sum2 int',\n+                              PandasUDFType.COGROUPED_MAP)).collect()\n+\n+        self.assertEquals(result[0]['sum1'], 165)\n+        self.assertEquals(result[0]['sum2'], 165)\n+\n+    def test_with_key_left(self):\n+        self._test_with_key(self.data1, self.data1, isLeft=True)\n+\n+    def test_with_key_right(self):\n+        self._test_with_key(self.data1, self.data1, isLeft=False)\n+\n+    def test_with_key_left_group_empty(self):\n+        left = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_with_key(left, self.data1, isLeft=True)\n+\n+    def test_with_key_right_group_empty(self):\n+        right = self.data1.where(col(\"id\") % 2 == 0)\n+        self._test_with_key(self.data1, right, isLeft=False)\n+\n+    def test_with_key_complex(self):\n+\n+        @pandas_udf('id long, k int, v int, key boolean', PandasUDFType.COGROUPED_MAP)\n+        def left_assign_key(key, l, _):\n+            return l.assign(key=key[0])\n+\n+        result = self.data1 \\\n+            .groupby(col('id') % 2 == 0)\\\n+            .cogroup(self.data2.groupby(col('id') % 2 == 0)) \\\n+            .apply(left_assign_key) \\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        expected = self.data1.toPandas()\n+        expected = expected.assign(key=expected.id % 2 == 0)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    def test_wrong_return_type(self):\n+        with QuietTest(self.sc):\n+            with self.assertRaisesRegexp(\n+                    NotImplementedError,\n+                    'Invalid returnType.*cogrouped map Pandas UDF.*MapType'):\n+                pandas_udf(\n+                    lambda l, r: l,\n+                    'id long, v map<int, int>',\n+                    PandasUDFType.COGROUPED_MAP)\n+\n+    def test_wrong_args(self):\n+        # Test that we get a sensible exception invalid values passed to apply\n+        left = self.data1\n+        right = self.data2\n+        with QuietTest(self.sc):\n+            # Function rather than a udf\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(lambda l, r: l)\n+\n+            # Udf missing return type\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(udf(lambda l, r: l, DoubleType()))\n+\n+            # Pass in expression rather than udf\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id')).apply(left.v + 1)\n+\n+            # Zero arg function\n+            with self.assertRaisesRegexp(ValueError, 'Invalid function'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(pandas_udf(lambda: 1, StructType([StructField(\"d\", DoubleType())])))\n+\n+            # Udf without PandasUDFType\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(pandas_udf(lambda x, y: x, DoubleType()))\n+\n+            # Udf with incorrect PandasUDFType\n+            with self.assertRaisesRegexp(ValueError, 'Invalid udf.*COGROUPED_MAP'):\n+                left.groupby('id').cogroup(right.groupby('id'))\\\n+                    .apply(pandas_udf(lambda x, y: x, DoubleType(), PandasUDFType.SCALAR))\n+\n+    @staticmethod\n+    def _test_with_key(left, right, isLeft):\n+\n+        @pandas_udf('id long, k int, v int, key long', PandasUDFType.COGROUPED_MAP)\n+        def right_assign_key(key, l, r):\n+            return l.assign(key=key[0]) if isLeft else r.assign(key=key[0])\n+\n+        result = left \\\n+            .groupby('id') \\\n+            .cogroup(right.groupby('id')) \\\n+            .apply(right_assign_key) \\\n+            .toPandas()\n+\n+        expected = left.toPandas() if isLeft else right.toPandas()\n+        expected = expected.assign(key=expected.id)\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+    @staticmethod\n+    def _test_merge(left, right, output_schema='id long, k int, v int, v2 int'):\n+\n+        @pandas_udf(output_schema, PandasUDFType.COGROUPED_MAP)\n+        def merge_pandas(l, r):\n+            return pd.merge(l, r, on=['id', 'k'])\n+\n+        result = left \\\n+            .groupby('id') \\\n+            .cogroup(right.groupby('id')) \\\n+            .apply(merge_pandas)\\\n+            .sort(['id', 'k']) \\\n+            .toPandas()\n+\n+        left = left.toPandas()\n+        right = right.toPandas()\n+\n+        expected = pd \\\n+            .merge(left, right, on=['id', 'k']) \\\n+            .sort_values(by=['id', 'k'])\n+\n+        assert_frame_equal(expected, result, check_column_type=_check_column_type)\n+\n+\n+if __name__ == \"__main__\":",
    "line": 272
  }],
  "prId": 24981
}]