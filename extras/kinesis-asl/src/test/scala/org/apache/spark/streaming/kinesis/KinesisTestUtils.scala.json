[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "extra line\n",
    "commit": "932485aee0955ee1e4c38f48a50338233aa35c16",
    "createdAt": "2015-11-04T07:51:45Z",
    "diffHunk": "@@ -90,24 +102,44 @@ private[kinesis] class KinesisTestUtils extends Logging {\n    * Push data to Kinesis stream and return a map of\n    * shardId -> seq of (data, seq number) pushed to corresponding shard\n    */\n-  def pushData(testData: Seq[Int]): Map[String, Seq[(Int, String)]] = {\n+  def pushData(testData: Seq[Int], aggregate: Boolean): Map[String, Seq[(Int, String)]] = {\n     require(streamCreated, \"Stream not yet created, call createStream() to create one\")\n     val shardIdToSeqNumbers = new mutable.HashMap[String, ArrayBuffer[(Int, String)]]()\n \n     testData.foreach { num =>\n       val str = num.toString\n-      val putRecordRequest = new PutRecordRequest().withStreamName(streamName)\n-        .withData(ByteBuffer.wrap(str.getBytes()))\n-        .withPartitionKey(str)\n-\n-      val putRecordResult = kinesisClient.putRecord(putRecordRequest)\n-      val shardId = putRecordResult.getShardId\n-      val seqNumber = putRecordResult.getSequenceNumber()\n-      val sentSeqNumbers = shardIdToSeqNumbers.getOrElseUpdate(shardId,\n-        new ArrayBuffer[(Int, String)]())\n-      sentSeqNumbers += ((num, seqNumber))\n+      val data = ByteBuffer.wrap(str.getBytes())\n+      if (aggregate) {\n+        val future = kinesisProducer.addUserRecord(streamName, str, data)\n+        val kinesisCallBack = new FutureCallback[UserRecordResult]() {\n+          override def onFailure(t: Throwable): Unit = {} // do nothing\n+\n+          override def onSuccess(result: UserRecordResult): Unit = {\n+            val shardId = result.getShardId\n+            val seqNumber = result.getSequenceNumber()\n+            val sentSeqNumbers = shardIdToSeqNumbers.getOrElseUpdate(shardId,\n+              new ArrayBuffer[(Int, String)]())\n+            sentSeqNumbers += ((num, seqNumber))\n+          }\n+        }\n+\n+        Futures.addCallback(future, kinesisCallBack)\n+        kinesisProducer.flushSync() // make sure we send all data before returning the map\n+      } else {\n+        val putRecordRequest = new PutRecordRequest().withStreamName(streamName)\n+          .withData(data)\n+          .withPartitionKey(str)\n+\n+        val putRecordResult = kinesisClient.putRecord(putRecordRequest)\n+        val shardId = putRecordResult.getShardId\n+        val seqNumber = putRecordResult.getSequenceNumber()\n+        val sentSeqNumbers = shardIdToSeqNumbers.getOrElseUpdate(shardId,\n+          new ArrayBuffer[(Int, String)]())\n+        sentSeqNumbers += ((num, seqNumber))\n+      }\n     }\n \n+"
  }],
  "prId": 9403
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Cant this code be deduped with lines 134 to 138\n",
    "commit": "932485aee0955ee1e4c38f48a50338233aa35c16",
    "createdAt": "2015-11-04T08:12:54Z",
    "diffHunk": "@@ -90,24 +102,44 @@ private[kinesis] class KinesisTestUtils extends Logging {\n    * Push data to Kinesis stream and return a map of\n    * shardId -> seq of (data, seq number) pushed to corresponding shard\n    */\n-  def pushData(testData: Seq[Int]): Map[String, Seq[(Int, String)]] = {\n+  def pushData(testData: Seq[Int], aggregate: Boolean): Map[String, Seq[(Int, String)]] = {\n     require(streamCreated, \"Stream not yet created, call createStream() to create one\")\n     val shardIdToSeqNumbers = new mutable.HashMap[String, ArrayBuffer[(Int, String)]]()\n \n     testData.foreach { num =>\n       val str = num.toString\n-      val putRecordRequest = new PutRecordRequest().withStreamName(streamName)\n-        .withData(ByteBuffer.wrap(str.getBytes()))\n-        .withPartitionKey(str)\n-\n-      val putRecordResult = kinesisClient.putRecord(putRecordRequest)\n-      val shardId = putRecordResult.getShardId\n-      val seqNumber = putRecordResult.getSequenceNumber()\n-      val sentSeqNumbers = shardIdToSeqNumbers.getOrElseUpdate(shardId,\n-        new ArrayBuffer[(Int, String)]())\n-      sentSeqNumbers += ((num, seqNumber))\n+      val data = ByteBuffer.wrap(str.getBytes())\n+      if (aggregate) {\n+        val future = kinesisProducer.addUserRecord(streamName, str, data)\n+        val kinesisCallBack = new FutureCallback[UserRecordResult]() {\n+          override def onFailure(t: Throwable): Unit = {} // do nothing\n+\n+          override def onSuccess(result: UserRecordResult): Unit = {\n+            val shardId = result.getShardId",
    "line": 54
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "Even though they have the same methods, they are of different types. UserRecordResult is not a subclass of PutRecordResult\n",
    "commit": "932485aee0955ee1e4c38f48a50338233aa35c16",
    "createdAt": "2015-11-04T19:45:43Z",
    "diffHunk": "@@ -90,24 +102,44 @@ private[kinesis] class KinesisTestUtils extends Logging {\n    * Push data to Kinesis stream and return a map of\n    * shardId -> seq of (data, seq number) pushed to corresponding shard\n    */\n-  def pushData(testData: Seq[Int]): Map[String, Seq[(Int, String)]] = {\n+  def pushData(testData: Seq[Int], aggregate: Boolean): Map[String, Seq[(Int, String)]] = {\n     require(streamCreated, \"Stream not yet created, call createStream() to create one\")\n     val shardIdToSeqNumbers = new mutable.HashMap[String, ArrayBuffer[(Int, String)]]()\n \n     testData.foreach { num =>\n       val str = num.toString\n-      val putRecordRequest = new PutRecordRequest().withStreamName(streamName)\n-        .withData(ByteBuffer.wrap(str.getBytes()))\n-        .withPartitionKey(str)\n-\n-      val putRecordResult = kinesisClient.putRecord(putRecordRequest)\n-      val shardId = putRecordResult.getShardId\n-      val seqNumber = putRecordResult.getSequenceNumber()\n-      val sentSeqNumbers = shardIdToSeqNumbers.getOrElseUpdate(shardId,\n-        new ArrayBuffer[(Int, String)]())\n-      sentSeqNumbers += ((num, seqNumber))\n+      val data = ByteBuffer.wrap(str.getBytes())\n+      if (aggregate) {\n+        val future = kinesisProducer.addUserRecord(streamName, str, data)\n+        val kinesisCallBack = new FutureCallback[UserRecordResult]() {\n+          override def onFailure(t: Throwable): Unit = {} // do nothing\n+\n+          override def onSuccess(result: UserRecordResult): Unit = {\n+            val shardId = result.getShardId",
    "line": 54
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "aah, nvm then.\n",
    "commit": "932485aee0955ee1e4c38f48a50338233aa35c16",
    "createdAt": "2015-11-04T22:36:35Z",
    "diffHunk": "@@ -90,24 +102,44 @@ private[kinesis] class KinesisTestUtils extends Logging {\n    * Push data to Kinesis stream and return a map of\n    * shardId -> seq of (data, seq number) pushed to corresponding shard\n    */\n-  def pushData(testData: Seq[Int]): Map[String, Seq[(Int, String)]] = {\n+  def pushData(testData: Seq[Int], aggregate: Boolean): Map[String, Seq[(Int, String)]] = {\n     require(streamCreated, \"Stream not yet created, call createStream() to create one\")\n     val shardIdToSeqNumbers = new mutable.HashMap[String, ArrayBuffer[(Int, String)]]()\n \n     testData.foreach { num =>\n       val str = num.toString\n-      val putRecordRequest = new PutRecordRequest().withStreamName(streamName)\n-        .withData(ByteBuffer.wrap(str.getBytes()))\n-        .withPartitionKey(str)\n-\n-      val putRecordResult = kinesisClient.putRecord(putRecordRequest)\n-      val shardId = putRecordResult.getShardId\n-      val seqNumber = putRecordResult.getSequenceNumber()\n-      val sentSeqNumbers = shardIdToSeqNumbers.getOrElseUpdate(shardId,\n-        new ArrayBuffer[(Int, String)]())\n-      sentSeqNumbers += ((num, seqNumber))\n+      val data = ByteBuffer.wrap(str.getBytes())\n+      if (aggregate) {\n+        val future = kinesisProducer.addUserRecord(streamName, str, data)\n+        val kinesisCallBack = new FutureCallback[UserRecordResult]() {\n+          override def onFailure(t: Throwable): Unit = {} // do nothing\n+\n+          override def onSuccess(result: UserRecordResult): Unit = {\n+            val shardId = result.getShardId",
    "line": 54
  }],
  "prId": 9403
}]