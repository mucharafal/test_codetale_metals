[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Can you make all of them private? \n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-05T20:35:17Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  val app = \"TestKinesisReceiver\""
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Please rename variables correctly, its not checkpointState any more.\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:07:56Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  val app = \"TestKinesisReceiver\"\n+  val stream = \"mySparkStream\"\n+  val endpoint = \"endpoint-url\"\n+  val workerId = \"dummyWorkerId\"\n+  val shardId = \"dummyShardId\"\n+  val seqNum = \"123\"\n+  val otherSeqNum = \"245\"\n+  val checkpointInterval = Duration(10)\n+  val someSeqNum = Some(seqNum)\n+  val someOtherSeqNum = Some(otherSeqNum)\n+\n+  var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+  }\n+\n+  test(\"checkpoint is not called for None's and nulls\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState ="
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Why even have options in the signature such that you have to test for it???\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:10:33Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  val app = \"TestKinesisReceiver\"\n+  val stream = \"mySparkStream\"\n+  val endpoint = \"endpoint-url\"\n+  val workerId = \"dummyWorkerId\"\n+  val shardId = \"dummyShardId\"\n+  val seqNum = \"123\"\n+  val otherSeqNum = \"245\"\n+  val checkpointInterval = Duration(10)\n+  val someSeqNum = Some(seqNum)\n+  val someOtherSeqNum = Some(otherSeqNum)\n+\n+  var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+  }\n+\n+  test(\"checkpoint is not called for None's and nulls\") {"
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Do not use thread.sleep. causes a lot of flakiness, and we have been actively removing sleep from everywhere. \n\nRather I think instead its best to use `streaming.util.RecurringTime` and `util.clock` instead of `scheduledExecutionContext` for implementing the `KinesisCheckpointer`. Then you can test using `util.ManualClock`.\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:19:03Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  val app = \"TestKinesisReceiver\"\n+  val stream = \"mySparkStream\"\n+  val endpoint = \"endpoint-url\"\n+  val workerId = \"dummyWorkerId\"\n+  val shardId = \"dummyShardId\"\n+  val seqNum = \"123\"\n+  val otherSeqNum = \"245\"\n+  val checkpointInterval = Duration(10)\n+  val someSeqNum = Some(seqNum)\n+  val someOtherSeqNum = Some(otherSeqNum)\n+\n+  var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+  }\n+\n+  test(\"checkpoint is not called for None's and nulls\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+    checkpointState.checkpoint(shardId, None)\n+    checkpointState.checkpoint(shardId, Option(null))\n+    // the above two calls should be No-Ops\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is called after sequence number increases\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+  }\n+\n+  test(\"should checkpoint if we have exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.setCheckpointer(shardId, checkpointerMock)\n+    Thread.sleep(checkpointInterval.milliseconds * 5)"
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "remove sleep\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:22:42Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  val app = \"TestKinesisReceiver\"\n+  val stream = \"mySparkStream\"\n+  val endpoint = \"endpoint-url\"\n+  val workerId = \"dummyWorkerId\"\n+  val shardId = \"dummyShardId\"\n+  val seqNum = \"123\"\n+  val otherSeqNum = \"245\"\n+  val checkpointInterval = Duration(10)\n+  val someSeqNum = Some(seqNum)\n+  val someOtherSeqNum = Some(otherSeqNum)\n+\n+  var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+  }\n+\n+  test(\"checkpoint is not called for None's and nulls\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+    checkpointState.checkpoint(shardId, None)\n+    checkpointState.checkpoint(shardId, Option(null))\n+    // the above two calls should be No-Ops\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is called after sequence number increases\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+  }\n+\n+  test(\"should checkpoint if we have exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.setCheckpointer(shardId, checkpointerMock)\n+    Thread.sleep(checkpointInterval.milliseconds * 5)\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+    checkpointState.shutdown()\n+  }\n+\n+  test(\"shouldn't checkpoint if we have not exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, Milliseconds(Long.MaxValue), workerId)\n+    checkpointState.setCheckpointer(shardId, checkpointerMock)\n+    Thread.sleep(checkpointInterval.milliseconds)"
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "remove sleep\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:22:49Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  val app = \"TestKinesisReceiver\"\n+  val stream = \"mySparkStream\"\n+  val endpoint = \"endpoint-url\"\n+  val workerId = \"dummyWorkerId\"\n+  val shardId = \"dummyShardId\"\n+  val seqNum = \"123\"\n+  val otherSeqNum = \"245\"\n+  val checkpointInterval = Duration(10)\n+  val someSeqNum = Some(seqNum)\n+  val someOtherSeqNum = Some(otherSeqNum)\n+\n+  var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+  }\n+\n+  test(\"checkpoint is not called for None's and nulls\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+    checkpointState.checkpoint(shardId, None)\n+    checkpointState.checkpoint(shardId, Option(null))\n+    // the above two calls should be No-Ops\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is called after sequence number increases\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+  }\n+\n+  test(\"should checkpoint if we have exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.setCheckpointer(shardId, checkpointerMock)\n+    Thread.sleep(checkpointInterval.milliseconds * 5)\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+    checkpointState.shutdown()\n+  }\n+\n+  test(\"shouldn't checkpoint if we have not exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, Milliseconds(Long.MaxValue), workerId)\n+    checkpointState.setCheckpointer(shardId, checkpointerMock)\n+    Thread.sleep(checkpointInterval.milliseconds)\n+    verify(checkpointerMock, never()).checkpoint(anyString())\n+    checkpointState.shutdown()\n+  }\n+\n+  test(\"should not checkpoint for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.setCheckpointer(shardId, checkpointerMock)\n+    Thread.sleep(checkpointInterval.milliseconds * 5)"
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Cant some of this duplicate code move into the before?\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:31:30Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  private val app = \"TestKinesisReceiver\"\n+  private val stream = \"mySparkStream\"\n+  private val endpoint = \"endpoint-url\"\n+  private val workerId = \"dummyWorkerId\"\n+  private val shardId = \"dummyShardId\"\n+  private val seqNum = \"123\"\n+  private val otherSeqNum = \"245\"\n+  private val checkpointInterval = Duration(10)\n+  private val someSeqNum = Some(seqNum)\n+  private val someOtherSeqNum = Some(otherSeqNum)\n+\n+  private var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  private var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+  }\n+\n+  test(\"checkpoint is not called for None's and nulls\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState =\n+      new KinesisCheckpointer(receiverMock, checkpointInterval, workerId)\n+    checkpointState.checkpoint(shardId, Option(checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+    checkpointState.checkpoint(shardId, None)\n+    checkpointState.checkpoint(shardId, Option(null))\n+    // the above two calls should be No-Ops\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    val checkpointState ="
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Nit: dont we generally use `before { .... }` \n\n```\n[tdas @ Zion spark2] git grep \"beforeFunction\" | wc -l\n       5\n[tdas @ Zion spark2] git grep \"before {\" | wc -l\n      44\n```\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-06T00:32:29Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase, Milliseconds}\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase with MockitoSugar with BeforeAndAfter {\n+\n+  private val app = \"TestKinesisReceiver\"\n+  private val stream = \"mySparkStream\"\n+  private val endpoint = \"endpoint-url\"\n+  private val workerId = \"dummyWorkerId\"\n+  private val shardId = \"dummyShardId\"\n+  private val seqNum = \"123\"\n+  private val otherSeqNum = \"245\"\n+  private val checkpointInterval = Duration(10)\n+  private val someSeqNum = Some(seqNum)\n+  private val someOtherSeqNum = Some(otherSeqNum)\n+\n+  private var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  private var checkpointerMock: IRecordProcessorCheckpointer = _\n+\n+  override def beforeFunction(): Unit = {"
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "~~`checkpointInterval` is only `10ms` in this test. It will be flaky in a slow Jenkins. Could you use a longer `checkpointInterval` (e.g., 10 seconds) for this test?~~\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-09T20:09:25Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import java.util.concurrent.{TimeoutException, ExecutorService}\n+\n+import scala.concurrent.{Await, ExecutionContext, Future}\n+import scala.concurrent.duration._\n+import scala.language.postfixOps\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.{PrivateMethodTester, BeforeAndAfterEach}\n+import org.scalatest.concurrent.Eventually\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase}\n+import org.apache.spark.util.ManualClock\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase\n+  with MockitoSugar\n+  with BeforeAndAfterEach\n+  with PrivateMethodTester\n+  with Eventually {\n+\n+  private val workerId = \"dummyWorkerId\"\n+  private val shardId = \"dummyShardId\"\n+  private val seqNum = \"123\"\n+  private val otherSeqNum = \"245\"\n+  private val checkpointInterval = Duration(10)\n+  private val someSeqNum = Some(seqNum)\n+  private val someOtherSeqNum = Some(otherSeqNum)\n+\n+  private var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  private var checkpointerMock: IRecordProcessorCheckpointer = _\n+  private var kinesisCheckpointer: KinesisCheckpointer = _\n+  private var clock: ManualClock = _\n+\n+  private val checkpoint = PrivateMethod[Unit]('checkpoint)\n+\n+  override def beforeEach(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+    clock = new ManualClock()\n+    kinesisCheckpointer = new KinesisCheckpointer(receiverMock, checkpointInterval, workerId, clock)\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is called after sequence number increases\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+  }\n+\n+  test(\"should checkpoint if we have exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(5 * checkpointInterval.milliseconds)\n+\n+    eventually(timeout(1 second)) {\n+      verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+      verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+    }\n+  }\n+\n+  test(\"shouldn't checkpoint if we have not exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(checkpointInterval.milliseconds / 2)",
    "line": 102
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Sorry, never mind. This is a manually clock. It should be safe.\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-09T20:12:07Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import java.util.concurrent.{TimeoutException, ExecutorService}\n+\n+import scala.concurrent.{Await, ExecutionContext, Future}\n+import scala.concurrent.duration._\n+import scala.language.postfixOps\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.{PrivateMethodTester, BeforeAndAfterEach}\n+import org.scalatest.concurrent.Eventually\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase}\n+import org.apache.spark.util.ManualClock\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase\n+  with MockitoSugar\n+  with BeforeAndAfterEach\n+  with PrivateMethodTester\n+  with Eventually {\n+\n+  private val workerId = \"dummyWorkerId\"\n+  private val shardId = \"dummyShardId\"\n+  private val seqNum = \"123\"\n+  private val otherSeqNum = \"245\"\n+  private val checkpointInterval = Duration(10)\n+  private val someSeqNum = Some(seqNum)\n+  private val someOtherSeqNum = Some(otherSeqNum)\n+\n+  private var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  private var checkpointerMock: IRecordProcessorCheckpointer = _\n+  private var kinesisCheckpointer: KinesisCheckpointer = _\n+  private var clock: ManualClock = _\n+\n+  private val checkpoint = PrivateMethod[Unit]('checkpoint)\n+\n+  override def beforeEach(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+    clock = new ManualClock()\n+    kinesisCheckpointer = new KinesisCheckpointer(receiverMock, checkpointInterval, workerId, clock)\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is called after sequence number increases\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+  }\n+\n+  test(\"should checkpoint if we have exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(5 * checkpointInterval.milliseconds)\n+\n+    eventually(timeout(1 second)) {\n+      verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+      verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+    }\n+  }\n+\n+  test(\"shouldn't checkpoint if we have not exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(checkpointInterval.milliseconds / 2)",
    "line": 102
  }],
  "prId": 9421
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "The checkpoint timer may call checkpoint before this line checks it. Note: if `checkpoint` is called but not yet returns, the times counter will be 1 as well. I suggest the following minor changes to this test:\n\n```\n  test(\"if checkpointing is going on, wait until finished before removing and checkpointing\") {\n    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n    when(checkpointerMock.checkpoint(anyString)).thenAnswer(new Answer[Unit] {\n      override def answer(invocations: InvocationOnMock): Unit = {\n        clock.waitTillTime(clock.getTimeMillis() + checkpointInterval.milliseconds / 2)\n      }\n    })\n\n    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n    clock.advance(checkpointInterval.milliseconds)\n    eventually(timeout(1 second)) {\n      verify(checkpointerMock, times(1)).checkpoint(anyString())\n    }\n    // don't block test thread\n    val f = Future(kinesisCheckpointer.removeCheckpointer(shardId, checkpointerMock))(\n      ExecutionContext.global)\n\n    intercept[TimeoutException] {\n      Await.ready(f, 50 millis)\n    }\n\n    clock.advance(checkpointInterval.milliseconds / 2)\n    eventually(timeout(1 second)) {\n      verify(checkpointerMock, times(2)).checkpoint(anyString())\n    }\n```\n\nUse `checkpointInterval.milliseconds / 2` so that the background checkpointer timer won't run twice.\n",
    "commit": "63d2e5284034c899b5ae0ccdb6e3e1ac5c022f1c",
    "createdAt": "2015-11-09T20:59:00Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kinesis\n+\n+import java.util.concurrent.{TimeoutException, ExecutorService}\n+\n+import scala.concurrent.{Await, ExecutionContext, Future}\n+import scala.concurrent.duration._\n+import scala.language.postfixOps\n+\n+import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer\n+import org.mockito.Matchers._\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.{PrivateMethodTester, BeforeAndAfterEach}\n+import org.scalatest.concurrent.Eventually\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.mock.MockitoSugar\n+\n+import org.apache.spark.streaming.{Duration, TestSuiteBase}\n+import org.apache.spark.util.ManualClock\n+\n+class KinesisCheckpointerSuite extends TestSuiteBase\n+  with MockitoSugar\n+  with BeforeAndAfterEach\n+  with PrivateMethodTester\n+  with Eventually {\n+\n+  private val workerId = \"dummyWorkerId\"\n+  private val shardId = \"dummyShardId\"\n+  private val seqNum = \"123\"\n+  private val otherSeqNum = \"245\"\n+  private val checkpointInterval = Duration(10)\n+  private val someSeqNum = Some(seqNum)\n+  private val someOtherSeqNum = Some(otherSeqNum)\n+\n+  private var receiverMock: KinesisReceiver[Array[Byte]] = _\n+  private var checkpointerMock: IRecordProcessorCheckpointer = _\n+  private var kinesisCheckpointer: KinesisCheckpointer = _\n+  private var clock: ManualClock = _\n+\n+  private val checkpoint = PrivateMethod[Unit]('checkpoint)\n+\n+  override def beforeEach(): Unit = {\n+    receiverMock = mock[KinesisReceiver[Array[Byte]]]\n+    checkpointerMock = mock[IRecordProcessorCheckpointer]\n+    clock = new ManualClock()\n+    kinesisCheckpointer = new KinesisCheckpointer(receiverMock, checkpointInterval, workerId, clock)\n+  }\n+\n+  test(\"checkpoint is not called twice for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"checkpoint is called after sequence number increases\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+    kinesisCheckpointer.invokePrivate(checkpoint(shardId, checkpointerMock))\n+\n+    verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+    verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+  }\n+\n+  test(\"should checkpoint if we have exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(5 * checkpointInterval.milliseconds)\n+\n+    eventually(timeout(1 second)) {\n+      verify(checkpointerMock, times(1)).checkpoint(seqNum)\n+      verify(checkpointerMock, times(1)).checkpoint(otherSeqNum)\n+    }\n+  }\n+\n+  test(\"shouldn't checkpoint if we have not exceeded the checkpoint interval\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(checkpointInterval.milliseconds / 2)\n+\n+    verify(checkpointerMock, never()).checkpoint(anyString())\n+  }\n+\n+  test(\"should not checkpoint for the same sequence number\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+\n+    clock.advance(checkpointInterval.milliseconds * 5)\n+    eventually(timeout(1 second)) {\n+      verify(checkpointerMock, atMost(1)).checkpoint(anyString())\n+    }\n+  }\n+\n+  test(\"removing checkpointer checkpoints one last time\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId)).thenReturn(someSeqNum)\n+\n+    kinesisCheckpointer.removeCheckpointer(shardId, checkpointerMock)\n+    verify(checkpointerMock, times(1)).checkpoint(anyString())\n+  }\n+\n+  test(\"if checkpointing is going on, wait until finished before removing and checkpointing\") {\n+    when(receiverMock.getLatestSeqNumToCheckpoint(shardId))\n+      .thenReturn(someSeqNum).thenReturn(someOtherSeqNum)\n+    when(checkpointerMock.checkpoint(anyString)).thenAnswer(new Answer[Unit] {\n+      override def answer(invocations: InvocationOnMock): Unit = {\n+        clock.waitTillTime(clock.getTimeMillis() + 100)\n+      }\n+    })\n+\n+    kinesisCheckpointer.setCheckpointer(shardId, checkpointerMock)\n+    clock.advance(checkpointInterval.milliseconds)\n+    verify(checkpointerMock, times(0)).checkpoint(anyString())"
  }],
  "prId": 9421
}]