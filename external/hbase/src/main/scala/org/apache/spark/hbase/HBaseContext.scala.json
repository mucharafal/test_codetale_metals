[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I'd sort and separate these imports like you can see in other source files.\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-27T09:54:35Z",
    "diffHunk": "@@ -0,0 +1,544 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration",
    "line": 20
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "And also group them together like \n`import java.io.{ByteArrayOutputStream, ByteArrayOutputStream, DataOutputStream}`\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-29T21:57:32Z",
    "diffHunk": "@@ -0,0 +1,544 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration",
    "line": 20
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "The param name is `rdd` rather than `RDD[t]`. I don't think scaladoc / javadoc will parse that.\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-27T09:55:33Z",
    "diffHunk": "@@ -0,0 +1,544 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.protobuf.ProtobufUtil\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.hadoop.hbase.mapreduce.MutationSerialization\n+import org.apache.hadoop.hbase.mapreduce.ResultSerialization\n+import org.apache.hadoop.hbase.mapreduce.KeyValueSerialization\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import org.apache.hadoop.hbase.protobuf.generated.MasterProtos\n+import org.apache.hadoop.hbase.protobuf.generated.MasterProtos\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc - active SparkContext\n+ *  @param broadcastedConf - This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over"
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This has to be `@param tableName` right? or else I sure wasn't aware scaladoc supported that syntax\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-27T09:57:31Z",
    "diffHunk": "@@ -0,0 +1,544 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.protobuf.ProtobufUtil\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.hadoop.hbase.mapreduce.MutationSerialization\n+import org.apache.hadoop.hbase.mapreduce.ResultSerialization\n+import org.apache.hadoop.hbase.mapreduce.KeyValueSerialization\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import org.apache.hadoop.hbase.protobuf.generated.MasterProtos\n+import org.apache.hadoop.hbase.protobuf.generated.MasterProtos\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc - active SparkContext\n+ *  @param broadcastedConf - This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @param f       function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream[t]  Original DStream with data to iterate over\n+   * @param f           function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    dstream.foreach((rdd, time) => {\n+      foreachPartition(rdd, f)\n+    })\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD mapPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @param mp      function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase\n+   * @return        Returns a new RDD generated by the user definition\n+   *                function just like normal mapPartition\n+   */\n+  def mapPartition[T, U: ClassTag](rdd: RDD[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): RDD[U] = {\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming DStream\n+   * mapPartition.\n+   * \n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param DStream[t] Original DStream with data to iterate over\n+   * @param mp         function to be given a iterator to iterate through\n+   *                   the DStream values and a HConnection object to \n+   *                   interact with HBase\n+   * @return           Returns a new DStream generated by the user \n+   *                   definition function just like normal mapPartition\n+   */\n+  def streamMap[T, U: ClassTag](dstream: DStream[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): DStream[U] = {\n+\n+    dstream.mapPartitions(it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take RDD \n+   * and generate puts and send them to HBase.  \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @tableName     The name of the table to put into "
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "batchSize is declared as a `java.lang.Integer` instead of a `scala.Int`. I bet it all kind of works but would `Int` not be more standard?\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-27T09:58:32Z",
    "diffHunk": "@@ -0,0 +1,544 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.protobuf.ProtobufUtil\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.hadoop.hbase.mapreduce.MutationSerialization\n+import org.apache.hadoop.hbase.mapreduce.ResultSerialization\n+import org.apache.hadoop.hbase.mapreduce.KeyValueSerialization\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import org.apache.hadoop.hbase.protobuf.generated.MasterProtos\n+import org.apache.hadoop.hbase.protobuf.generated.MasterProtos\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc - active SparkContext\n+ *  @param broadcastedConf - This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @param f       function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream[t]  Original DStream with data to iterate over\n+   * @param f           function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    dstream.foreach((rdd, time) => {\n+      foreachPartition(rdd, f)\n+    })\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD mapPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @param mp      function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase\n+   * @return        Returns a new RDD generated by the user definition\n+   *                function just like normal mapPartition\n+   */\n+  def mapPartition[T, U: ClassTag](rdd: RDD[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): RDD[U] = {\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming DStream\n+   * mapPartition.\n+   * \n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param DStream[t] Original DStream with data to iterate over\n+   * @param mp         function to be given a iterator to iterate through\n+   *                   the DStream values and a HConnection object to \n+   *                   interact with HBase\n+   * @return           Returns a new DStream generated by the user \n+   *                   definition function just like normal mapPartition\n+   */\n+  def streamMap[T, U: ClassTag](dstream: DStream[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): DStream[U] = {\n+\n+    dstream.mapPartitions(it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take RDD \n+   * and generate puts and send them to HBase.  \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @tableName     The name of the table to put into \n+   * @param f       function to convert a value in the RDD to a HBase Put\n+   * @autoFlush     if autoFlush should be turned on\n+   */\n+  def bulkPut[T](rdd: RDD[T], tableName: String, f: (T) => Put, autoFlush: Boolean) {\n+\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableName)\n+          htable.setAutoFlush(autoFlush, true)\n+          iterator.foreach(T => htable.put(f(T)))\n+          htable.flushCommits()\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamMapPartition method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate puts and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream[t] Original DStream with data to iterate over\n+   * @tableName        The name of the table to put into \n+   * @param f          function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        if autoFlush should be turned on\n+   */\n+  def streamBulkPut[T](dstream: DStream[T],\n+    tableName: String,\n+    f: (T) => Put,\n+    autoFlush: Boolean) = {\n+    dstream.foreach((rdd, time) => {\n+      bulkPut(rdd, tableName, f, autoFlush)\n+    })\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and \n+   * generate increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD[t]  Original RDD with data to iterate over\n+   * @tableName     The name of the table to increment to \n+   * @param f       function to convert a value in the RDD to a \n+   *                HBase Increments\n+   * @batchSize     The number of increments to batch before sending to HBase\n+   */\n+  def bulkIncrement[T](rdd: RDD[T], tableName:String, f:(T) => Increment, batchSize: Integer) {"
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Is there a need for this constructor? Better to do the following.\n\n```\nclass HBaseContext(@transient sc: Sparkcontext, @transient config: Configuration) extends Serializable {\n    val broadcastConf = sc.broadcast(new SerializableWritable(config))\n}\n```\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-29T22:47:38Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+",
    "line": 78
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Please take a look at other the scala docs of RDD transformation to understand the style. For example, a better way to explain this method would be to do the following. \n`Applies a function on each partition of the given RDD using a HBase connection`.\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-30T01:30:40Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     Active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.",
    "line": 89
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This should be foreachRDD(). DStream.foreach() is deprecated in favor of DStream.foreachRDD().\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-07-30T01:47:26Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     Active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD  Original RDD with data to iterate over\n+   * @param f    Function to be given a iterator to iterate through\n+   *             the RDD values and a HConnection object to interact \n+   *             with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream     Original DStream with data to iterate over\n+   * @param f           Function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],",
    "line": 120
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "saintstack"
    },
    "body": "This paragraph needs an edit\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-08-22T16:21:36Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.",
    "line": 68
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "saintstack"
    },
    "body": "I wonder if users will care about auto flush enough that it should show up in the api?  Rather, for those who care, could then not set it in the passed in configuration rather than on a per method basis?  Just a thought if you are looking to simplify.\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-08-22T16:25:32Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     Active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD  Original RDD with data to iterate over\n+   * @param f    Function to be given a iterator to iterate through\n+   *             the RDD values and a HConnection object to interact \n+   *             with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream     Original DStream with data to iterate over\n+   * @param f           Function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    dstream.foreach((rdd, time) => {\n+      foreachPartition(rdd, f)\n+    })\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD mapPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param mp      Function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase\n+   * @return        Returns a new RDD generated by the user definition\n+   *                function just like normal mapPartition\n+   */\n+  def mapPartition[T, U: ClassTag](rdd: RDD[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): RDD[U] = {\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming DStream\n+   * mapPartition.\n+   * \n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param mp         Function to be given a iterator to iterate through\n+   *                   the DStream values and a HConnection object to \n+   *                   interact with HBase\n+   * @return           Returns a new DStream generated by the user \n+   *                   definition function just like normal mapPartition\n+   */\n+  def streamMap[T, U: ClassTag](dstream: DStream[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): DStream[U] = {\n+\n+    dstream.mapPartitions(it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take RDD \n+   * and generate puts and send them to HBase.  \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def bulkPut[T](rdd: RDD[T], tableNm: String, f: (T) => Put, autoFlush: Boolean) {\n+\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          htable.setAutoFlush(autoFlush, true)\n+          iterator.foreach(T => htable.put(f(T)))\n+          htable.flushCommits()\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamMapPartition method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate puts and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on",
    "line": 221
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "saintstack"
    },
    "body": "'additional' (this issue happens in a few places below...)\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-08-22T16:28:10Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     Active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD  Original RDD with data to iterate over\n+   * @param f    Function to be given a iterator to iterate through\n+   *             the RDD values and a HConnection object to interact \n+   *             with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream     Original DStream with data to iterate over\n+   * @param f           Function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    dstream.foreach((rdd, time) => {\n+      foreachPartition(rdd, f)\n+    })\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD mapPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param mp      Function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase\n+   * @return        Returns a new RDD generated by the user definition\n+   *                function just like normal mapPartition\n+   */\n+  def mapPartition[T, U: ClassTag](rdd: RDD[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): RDD[U] = {\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming DStream\n+   * mapPartition.\n+   * \n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param mp         Function to be given a iterator to iterate through\n+   *                   the DStream values and a HConnection object to \n+   *                   interact with HBase\n+   * @return           Returns a new DStream generated by the user \n+   *                   definition function just like normal mapPartition\n+   */\n+  def streamMap[T, U: ClassTag](dstream: DStream[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): DStream[U] = {\n+\n+    dstream.mapPartitions(it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take RDD \n+   * and generate puts and send them to HBase.  \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def bulkPut[T](rdd: RDD[T], tableNm: String, f: (T) => Put, autoFlush: Boolean) {\n+\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          htable.setAutoFlush(autoFlush, true)\n+          iterator.foreach(T => htable.put(f(T)))\n+          htable.flushCommits()\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamMapPartition method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate puts and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def streamBulkPut[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Put,\n+    autoFlush: Boolean) = {\n+    dstream.foreach((rdd, time) => {\n+      bulkPut(rdd, tableNm, f, autoFlush)\n+    })\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and \n+   * generate increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to increment to \n+   * @param f          Function to convert a value in the RDD to a \n+   *                   HBase Increments\n+   * @batchSize        The number of increments to batch before sending to HBase\n+   */\n+  def bulkIncrement[T](rdd: RDD[T], tableNm:String, f:(T) => Increment, batchSize: Int) {\n+    bulkMutation(rdd, tableNm, f, batchSize)\n+  }\n+  \n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and generate delete\n+   * and send them to HBase.  The complexity of even the HConnection is \n+   * removed from the developer\n+   *  \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param tableNm     The name of the table to delete from \n+   * @param f       function to convert a value in the RDD to a \n+   *                HBase Deletes\n+   * @batchSize     The number of delete to batch before sending to HBase\n+   */\n+  def bulkDelete[T](rdd: RDD[T], tableNm:String, f:(T) => Delete, batchSize: Int) {\n+    bulkMutation(rdd, tableNm, f, batchSize)\n+  }\n+  \n+  /** \n+   *  Under lining function to support all bulk mutations\n+   *  \n+   *  May be opened up if requested\n+   */\n+  private def bulkMutation[T](rdd: RDD[T], tableNm: String, f: (T) => Mutation, batchSize: Int) {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          val mutationList = new ArrayList[Mutation]\n+          iterator.foreach(T => {\n+            mutationList.add(f(T))\n+            if (mutationList.size >= batchSize) {\n+              htable.batch(mutationList)\n+              mutationList.clear()\n+            }\n+          })\n+          if (mutationList.size() > 0) {\n+            htable.batch(mutationList)\n+            mutationList.clear()\n+          }\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamForeach method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate Increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to increments into \n+   * @param f          function to convert a value in the RDD to a \n+   *                   HBase Increments\n+   * @batchSize        The number of increments to batch before sending to HBase\n+   */\n+  def streamBulkIncrement[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Increment,\n+    batchSize: Int) = {\n+    streamBulkMutation(dstream, tableNm, f, batchSize)\n+  }\n+  \n+  /**\n+   * A simple abstraction over the HBaseContext.streamForeach method.\n+   * \n+   * It allow addition support for a user to take a DStream and ",
    "line": 321
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "saintstack"
    },
    "body": "I know what this about having read your nice design doc.  Should there be a few more notes in here on why this is needed?\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-08-22T16:31:43Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     Active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD  Original RDD with data to iterate over\n+   * @param f    Function to be given a iterator to iterate through\n+   *             the RDD values and a HConnection object to interact \n+   *             with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream     Original DStream with data to iterate over\n+   * @param f           Function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    dstream.foreach((rdd, time) => {\n+      foreachPartition(rdd, f)\n+    })\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD mapPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param mp      Function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase\n+   * @return        Returns a new RDD generated by the user definition\n+   *                function just like normal mapPartition\n+   */\n+  def mapPartition[T, U: ClassTag](rdd: RDD[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): RDD[U] = {\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming DStream\n+   * mapPartition.\n+   * \n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param mp         Function to be given a iterator to iterate through\n+   *                   the DStream values and a HConnection object to \n+   *                   interact with HBase\n+   * @return           Returns a new DStream generated by the user \n+   *                   definition function just like normal mapPartition\n+   */\n+  def streamMap[T, U: ClassTag](dstream: DStream[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): DStream[U] = {\n+\n+    dstream.mapPartitions(it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take RDD \n+   * and generate puts and send them to HBase.  \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def bulkPut[T](rdd: RDD[T], tableNm: String, f: (T) => Put, autoFlush: Boolean) {\n+\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          htable.setAutoFlush(autoFlush, true)\n+          iterator.foreach(T => htable.put(f(T)))\n+          htable.flushCommits()\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamMapPartition method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate puts and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def streamBulkPut[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Put,\n+    autoFlush: Boolean) = {\n+    dstream.foreach((rdd, time) => {\n+      bulkPut(rdd, tableNm, f, autoFlush)\n+    })\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and \n+   * generate increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to increment to \n+   * @param f          Function to convert a value in the RDD to a \n+   *                   HBase Increments\n+   * @batchSize        The number of increments to batch before sending to HBase\n+   */\n+  def bulkIncrement[T](rdd: RDD[T], tableNm:String, f:(T) => Increment, batchSize: Int) {\n+    bulkMutation(rdd, tableNm, f, batchSize)\n+  }\n+  \n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and generate delete\n+   * and send them to HBase.  The complexity of even the HConnection is \n+   * removed from the developer\n+   *  \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param tableNm     The name of the table to delete from \n+   * @param f       function to convert a value in the RDD to a \n+   *                HBase Deletes\n+   * @batchSize     The number of delete to batch before sending to HBase\n+   */\n+  def bulkDelete[T](rdd: RDD[T], tableNm:String, f:(T) => Delete, batchSize: Int) {\n+    bulkMutation(rdd, tableNm, f, batchSize)\n+  }\n+  \n+  /** \n+   *  Under lining function to support all bulk mutations\n+   *  \n+   *  May be opened up if requested\n+   */\n+  private def bulkMutation[T](rdd: RDD[T], tableNm: String, f: (T) => Mutation, batchSize: Int) {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          val mutationList = new ArrayList[Mutation]\n+          iterator.foreach(T => {\n+            mutationList.add(f(T))\n+            if (mutationList.size >= batchSize) {\n+              htable.batch(mutationList)\n+              mutationList.clear()\n+            }\n+          })\n+          if (mutationList.size() > 0) {\n+            htable.batch(mutationList)\n+            mutationList.clear()\n+          }\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamForeach method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate Increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to increments into \n+   * @param f          function to convert a value in the RDD to a \n+   *                   HBase Increments\n+   * @batchSize        The number of increments to batch before sending to HBase\n+   */\n+  def streamBulkIncrement[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Increment,\n+    batchSize: Int) = {\n+    streamBulkMutation(dstream, tableNm, f, batchSize)\n+  }\n+  \n+  /**\n+   * A simple abstraction over the HBaseContext.streamForeach method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate Delete and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream   Original DStream with data to iterate over\n+   * @param tableNm The name of the table to delete from \n+   * @param f         function to convert a value in the RDD to a \n+   *                  HBase Delete\n+   * @batchSize       The number of deletes to batch before sending to HBase\n+   */\n+  def streamBulkDelete[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Delete,\n+    batchSize: Int) = {\n+    streamBulkMutation(dstream, tableNm, f, batchSize)\n+  }\n+  \n+  /** \n+   *  Under lining function to support all bulk streaming mutations\n+   *  \n+   *  May be opened up if requested\n+   */\n+  private def streamBulkMutation[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Mutation,\n+    batchSize: Int) = {\n+    dstream.foreach((rdd, time) => {\n+      bulkMutation(rdd, tableNm, f, batchSize)\n+    })\n+  }\n+\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.mapPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and generates a\n+   * new RDD based on Gets and the results they bring back from HBase",
    "line": 359
  }],
  "prId": 1608
}, {
  "comments": [{
    "author": {
      "login": "saintstack"
    },
    "body": "Again, pardon my ignorance, but out of interest, how is this @serializable implemented in scala-land?\n",
    "commit": "c36fff554e199b4ae6fb086a1dc3af9b919f5bce",
    "createdAt": "2014-08-22T16:38:31Z",
    "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.hbase\n+\n+import org.apache.hadoop.hbase.HBaseConfiguration\n+import org.apache.spark.rdd.RDD\n+import java.io.ByteArrayOutputStream\n+import java.io.DataOutputStream\n+import java.io.ByteArrayInputStream\n+import java.io.DataInputStream\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.hbase.client.HConnectionManager\n+import org.apache.spark.api.java.JavaPairRDD\n+import java.io.OutputStream\n+import org.apache.hadoop.hbase.client.HTable\n+import org.apache.hadoop.hbase.client.Scan\n+import org.apache.hadoop.hbase.client.Get\n+import java.util.ArrayList\n+import org.apache.hadoop.hbase.client.Result\n+import scala.reflect.ClassTag\n+import org.apache.hadoop.hbase.client.HConnection\n+import org.apache.hadoop.hbase.client.Put\n+import org.apache.hadoop.hbase.client.Increment\n+import org.apache.hadoop.hbase.client.Delete\n+import org.apache.spark.SparkContext\n+import org.apache.hadoop.hbase.mapreduce.TableInputFormat\n+import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable\n+import org.apache.hadoop.hbase.util.Bytes\n+import org.apache.hadoop.mapreduce.Job\n+import org.apache.hadoop.hbase.mapreduce.TableMapper\n+import org.apache.hadoop.hbase.mapreduce.IdentityTableMapper\n+import org.apache.hadoop.hbase.util.Base64\n+import org.apache.spark.rdd.HadoopRDD\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.SerializableWritable\n+import java.util.HashMap\n+import java.util.concurrent.atomic.AtomicInteger\n+import org.apache.hadoop.hbase.HConstants\n+import java.util.concurrent.atomic.AtomicLong\n+import java.util.Timer\n+import java.util.TimerTask\n+import org.apache.hadoop.hbase.client.Mutation\n+import scala.collection.mutable.MutableList\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * HBaseContext is a façade of simple and complex HBase operations\n+ * like bulk put, get, increment, delete, and scan\n+ *\n+ * HBase Context will take the responsibilities to happen to\n+ * complexity of disseminating the configuration information\n+ * to the working and managing the life cycle of HConnections.\n+ *\n+ * First constructor:\n+ *  @param sc              Active SparkContext\n+ *  @param broadcastedConf This is a Broadcast object that holds a\n+ * serializable Configuration object\n+ *\n+ */\n+@serializable class HBaseContext(@transient sc: SparkContext,\n+  broadcastedConf: Broadcast[SerializableWritable[Configuration]]) {\n+\n+  /**\n+   * Second constructor option:\n+   *  @param sc     Active SparkContext\n+   *  @param config Configuration object to make connection to HBase\n+   */\n+  def this(@transient sc: SparkContext, @transient config: Configuration) {\n+    this(sc, sc.broadcast(new SerializableWritable(config)))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD foreachPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param RDD  Original RDD with data to iterate over\n+   * @param f    Function to be given a iterator to iterate through\n+   *             the RDD values and a HConnection object to interact \n+   *             with HBase \n+   */\n+  def foreachPartition[T](rdd: RDD[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition(broadcastedConf, it, f))\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming dStream foreach\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * @param DStream     Original DStream with data to iterate over\n+   * @param f           Function to be given a iterator to iterate through\n+   *                    the DStream values and a HConnection object to \n+   *                    interact with HBase \n+   */\n+  def streamForeach[T](dstream: DStream[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+    dstream.foreach((rdd, time) => {\n+      foreachPartition(rdd, f)\n+    })\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark RDD mapPartition.\n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param mp      Function to be given a iterator to iterate through\n+   *                the RDD values and a HConnection object to interact \n+   *                with HBase\n+   * @return        Returns a new RDD generated by the user definition\n+   *                function just like normal mapPartition\n+   */\n+  def mapPartition[T, U: ClassTag](rdd: RDD[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): RDD[U] = {\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple enrichment of the traditional Spark Streaming DStream\n+   * mapPartition.\n+   * \n+   * This function differs from the original in that it offers the \n+   * developer access to a already connected HConnection object\n+   * \n+   * Note: Do not close the HConnection object.  All HConnection\n+   * management is handled outside this method\n+   * \n+   * Note: Make sure to partition correctly to avoid memory issue when\n+   *       getting data from HBase\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param mp         Function to be given a iterator to iterate through\n+   *                   the DStream values and a HConnection object to \n+   *                   interact with HBase\n+   * @return           Returns a new DStream generated by the user \n+   *                   definition function just like normal mapPartition\n+   */\n+  def streamMap[T, U: ClassTag](dstream: DStream[T],\n+    mp: (Iterator[T], HConnection) => Iterator[U]): DStream[U] = {\n+\n+    dstream.mapPartitions(it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      mp), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take RDD \n+   * and generate puts and send them to HBase.  \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def bulkPut[T](rdd: RDD[T], tableNm: String, f: (T) => Put, autoFlush: Boolean) {\n+\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          htable.setAutoFlush(autoFlush, true)\n+          iterator.foreach(T => htable.put(f(T)))\n+          htable.flushCommits()\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamMapPartition method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate puts and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to put into \n+   * @param f          Function to convert a value in the RDD to a HBase Put\n+   * @autoFlush        If autoFlush should be turned on\n+   */\n+  def streamBulkPut[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Put,\n+    autoFlush: Boolean) = {\n+    dstream.foreach((rdd, time) => {\n+      bulkPut(rdd, tableNm, f, autoFlush)\n+    })\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and \n+   * generate increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to increment to \n+   * @param f          Function to convert a value in the RDD to a \n+   *                   HBase Increments\n+   * @batchSize        The number of increments to batch before sending to HBase\n+   */\n+  def bulkIncrement[T](rdd: RDD[T], tableNm:String, f:(T) => Increment, batchSize: Int) {\n+    bulkMutation(rdd, tableNm, f, batchSize)\n+  }\n+  \n+  /**\n+   * A simple abstraction over the HBaseContext.foreachPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and generate delete\n+   * and send them to HBase.  The complexity of even the HConnection is \n+   * removed from the developer\n+   *  \n+   * @param RDD     Original RDD with data to iterate over\n+   * @param tableNm     The name of the table to delete from \n+   * @param f       function to convert a value in the RDD to a \n+   *                HBase Deletes\n+   * @batchSize     The number of delete to batch before sending to HBase\n+   */\n+  def bulkDelete[T](rdd: RDD[T], tableNm:String, f:(T) => Delete, batchSize: Int) {\n+    bulkMutation(rdd, tableNm, f, batchSize)\n+  }\n+  \n+  /** \n+   *  Under lining function to support all bulk mutations\n+   *  \n+   *  May be opened up if requested\n+   */\n+  private def bulkMutation[T](rdd: RDD[T], tableNm: String, f: (T) => Mutation, batchSize: Int) {\n+    rdd.foreachPartition(\n+      it => hbaseForeachPartition[T](\n+        broadcastedConf,\n+        it,\n+        (iterator, hConnection) => {\n+          val htable = hConnection.getTable(tableNm)\n+          val mutationList = new ArrayList[Mutation]\n+          iterator.foreach(T => {\n+            mutationList.add(f(T))\n+            if (mutationList.size >= batchSize) {\n+              htable.batch(mutationList)\n+              mutationList.clear()\n+            }\n+          })\n+          if (mutationList.size() > 0) {\n+            htable.batch(mutationList)\n+            mutationList.clear()\n+          }\n+          htable.close()\n+        }))\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamForeach method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate Increments and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to increments into \n+   * @param f          function to convert a value in the RDD to a \n+   *                   HBase Increments\n+   * @batchSize        The number of increments to batch before sending to HBase\n+   */\n+  def streamBulkIncrement[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Increment,\n+    batchSize: Int) = {\n+    streamBulkMutation(dstream, tableNm, f, batchSize)\n+  }\n+  \n+  /**\n+   * A simple abstraction over the HBaseContext.streamForeach method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generate Delete and send them to HBase.  \n+   * \n+   * The complexity of even the HConnection is \n+   * removed from the developer\n+   * \n+   * @param DStream   Original DStream with data to iterate over\n+   * @param tableNm The name of the table to delete from \n+   * @param f         function to convert a value in the RDD to a \n+   *                  HBase Delete\n+   * @batchSize       The number of deletes to batch before sending to HBase\n+   */\n+  def streamBulkDelete[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Delete,\n+    batchSize: Int) = {\n+    streamBulkMutation(dstream, tableNm, f, batchSize)\n+  }\n+  \n+  /** \n+   *  Under lining function to support all bulk streaming mutations\n+   *  \n+   *  May be opened up if requested\n+   */\n+  private def streamBulkMutation[T](dstream: DStream[T],\n+    tableNm: String,\n+    f: (T) => Mutation,\n+    batchSize: Int) = {\n+    dstream.foreach((rdd, time) => {\n+      bulkMutation(rdd, tableNm, f, batchSize)\n+    })\n+  }\n+\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.mapPartition method.\n+   * \n+   * It allow addition support for a user to take a RDD and generates a\n+   * new RDD based on Gets and the results they bring back from HBase\n+   * \n+   * @param RDD        Original RDD with data to iterate over\n+   * @param tableNm  The name of the table to get from \n+   * @param makeGet    Function to convert a value in the RDD to a \n+   *                   HBase Get\n+   * @param convertResult This will convert the HBase Result object to \n+   *                   what ever the user wants to put in the resulting \n+   *                   RDD\n+   * return            New RDD that is created by the Get to HBase\n+   */\n+  def bulkGet[T, U: ClassTag](tableNm: String,\n+    batchSize: Int,\n+    rdd: RDD[T],\n+    makeGet: (T) => Get,\n+    convertResult: (Result) => U): RDD[U] = {\n+\n+    val getMapPartition = new GetMapPartition(tableNm,\n+      batchSize,\n+      makeGet,\n+      convertResult)\n+\n+    rdd.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      getMapPartition.run), true)\n+  }\n+\n+  /**\n+   * A simple abstraction over the HBaseContext.streamMap method.\n+   * \n+   * It allow addition support for a user to take a DStream and \n+   * generates a new DStream based on Gets and the results \n+   * they bring back from HBase\n+   * \n+   * @param DStream    Original DStream with data to iterate over\n+   * @param tableNm  The name of the table to get from \n+   * @param makeGet    Function to convert a value in the DStream to a \n+   *                   HBase Get\n+   * @param convertResult This will convert the HBase Result object to \n+   *                   what ever the user wants to put in the resulting \n+   *                   DStream\n+   * return            new DStream that is created by the Get to HBase    \n+   */\n+  def streamBulkGet[T, U: ClassTag](tableNm: String,\n+      batchSize:Int,\n+      dstream: DStream[T],\n+      makeGet: (T) => Get, \n+      convertResult: (Result) => U): DStream[U] = {\n+\n+    val getMapPartition = new GetMapPartition(tableNm,\n+      batchSize,\n+      makeGet,\n+      convertResult)\n+\n+    dstream.mapPartitions[U](it => hbaseMapPartition[T, U](broadcastedConf,\n+      it,\n+      getMapPartition.run), true)\n+  }\n+\n+  /**\n+   * This function will use the native HBase TableInputFormat with the \n+   * given scan object to generate a new RDD\n+   * \n+   *  @param tableNm The name of the table to scan\n+   *  @param scan      The HBase scan object to use to read data from HBase\n+   *  @param f         Function to convert a Result object from HBase into \n+   *                   what the user wants in the final generated RDD\n+   *  @return          New RDD with results from scan \n+   */\n+  def hbaseRDD[U: ClassTag](tableNm: String, scan: Scan, f: ((ImmutableBytesWritable, Result)) => U): RDD[U] = {\n+\n+    var job: Job = new Job(broadcastedConf.value.value)\n+\n+    TableMapReduceUtil.initTableMapperJob(tableNm, scan, classOf[IdentityTableMapper], null, null, job)\n+\n+    sc.newAPIHadoopRDD(job.getConfiguration(),\n+      classOf[TableInputFormat],\n+      classOf[ImmutableBytesWritable],\n+      classOf[Result]).map(f)\n+  }\n+\n+  /**\n+   * A overloaded version of HBaseContext hbaseRDD that predefines the \n+   * type of the outputing RDD\n+   * \n+   *  @param tableNm The name of the table to scan\n+   *  @param scan      The HBase scan object to use to read data from HBase\n+   *  @return          New RDD with results from scan \n+   * \n+   */\n+  def hbaseRDD(tableNm: String, scans: Scan): RDD[(Array[Byte], java.util.List[(Array[Byte], Array[Byte], Array[Byte])])] = {\n+    hbaseRDD[(Array[Byte], java.util.List[(Array[Byte], Array[Byte], Array[Byte])])](\n+      tableNm,\n+      scans,\n+      (r: (ImmutableBytesWritable, Result)) => {\n+        val it = r._2.list().iterator()\n+        val list = new ArrayList[(Array[Byte], Array[Byte], Array[Byte])]()\n+\n+        while (it.hasNext()) {\n+          val kv = it.next()\n+          list.add((kv.getFamily(), kv.getQualifier(), kv.getValue()))\n+        }\n+\n+        (r._1.copyBytes(), list)\n+      })\n+  }\n+  \n+  /** \n+   *  Under lining wrapper all foreach functions in HBaseContext\n+   *  \n+   */\n+  private def hbaseForeachPartition[T](configBroadcast: Broadcast[SerializableWritable[Configuration]],\n+    it: Iterator[T],\n+    f: (Iterator[T], HConnection) => Unit) = {\n+\n+    val config = configBroadcast.value.value\n+\n+    val hConnection = HConnectionStaticCache.getHConnection(config)\n+    try {\n+      f(it, hConnection)\n+    } finally {\n+      HConnectionStaticCache.finishWithHConnection(config, hConnection)\n+    }\n+  }\n+\n+  /** \n+   *  Under lining wrapper all mapPartition functions in HBaseContext\n+   *  \n+   */\n+  private def hbaseMapPartition[K, U](configBroadcast: Broadcast[SerializableWritable[Configuration]],\n+    it: Iterator[K],\n+    mp: (Iterator[K], HConnection) => Iterator[U]): Iterator[U] = {\n+\n+    val config = configBroadcast.value.value\n+\n+    val hConnection = HConnectionStaticCache.getHConnection(config)\n+\n+    try {\n+      val res = mp(it, hConnection)\n+      res\n+    } finally {\n+      HConnectionStaticCache.finishWithHConnection(config, hConnection)\n+    }\n+  }\n+  \n+  /** \n+   *  Under lining wrapper all get mapPartition functions in HBaseContext\n+   *  \n+   */\n+  @serializable private  class GetMapPartition[T, U: ClassTag](tableNm: String, ",
    "line": 508
  }],
  "prId": 1608
}]