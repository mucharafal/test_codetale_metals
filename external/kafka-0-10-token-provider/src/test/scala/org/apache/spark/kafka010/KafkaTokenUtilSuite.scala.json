[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.contains(blah)`",
    "commit": "e5bcc181d5b748490efdbf83625a47fb36892b82",
    "createdAt": "2019-04-26T20:33:40Z",
    "diffHunk": "@@ -202,24 +177,74 @@ class KafkaTokenUtilSuite extends SparkFunSuite with KafkaDelegationTokenTest {\n     assert(KafkaTokenUtil.isGlobalJaasConfigurationProvided)\n   }\n \n-  test(\"isTokenAvailable without token should return false\") {\n-    assert(!KafkaTokenUtil.isTokenAvailable())\n+  test(\"findMatchingToken without token should return None\") {\n+    assert(KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers) === None)\n+  }\n+\n+  test(\"findMatchingToken with non-matching tokens should return None\") {\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.target.bootstrap.servers.regex\",\n+      nonMatchingTargetServersRegex)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    addTokenToUGI(identifier1)\n+    addTokenToUGI(identifier2, Some(\"intentionally_garbage\"))\n+\n+    assert(KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers) === None)\n   }\n \n-  test(\"isTokenAvailable with token should return true\") {\n-    addTokenToUGI()\n+  test(\"findMatchingToken with one matching token should return cluster configuration\") {\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    addTokenToUGI(identifier1)\n \n-    assert(KafkaTokenUtil.isTokenAvailable())\n+    assert(KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers) ===\n+      Some(KafkaTokenSparkConf.getClusterConfig(sparkConf, identifier1)))\n+  }\n+\n+  test(\"findMatchingToken with multiple matching tokens should throw exception\") {\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    addTokenToUGI(identifier1)\n+    addTokenToUGI(identifier2)\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers)\n+    }\n+    assert(thrown.getMessage contains"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "e5bcc181d5b748490efdbf83625a47fb36892b82",
    "createdAt": "2019-04-29T10:56:53Z",
    "diffHunk": "@@ -202,24 +177,74 @@ class KafkaTokenUtilSuite extends SparkFunSuite with KafkaDelegationTokenTest {\n     assert(KafkaTokenUtil.isGlobalJaasConfigurationProvided)\n   }\n \n-  test(\"isTokenAvailable without token should return false\") {\n-    assert(!KafkaTokenUtil.isTokenAvailable())\n+  test(\"findMatchingToken without token should return None\") {\n+    assert(KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers) === None)\n+  }\n+\n+  test(\"findMatchingToken with non-matching tokens should return None\") {\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.target.bootstrap.servers.regex\",\n+      nonMatchingTargetServersRegex)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    addTokenToUGI(identifier1)\n+    addTokenToUGI(identifier2, Some(\"intentionally_garbage\"))\n+\n+    assert(KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers) === None)\n   }\n \n-  test(\"isTokenAvailable with token should return true\") {\n-    addTokenToUGI()\n+  test(\"findMatchingToken with one matching token should return cluster configuration\") {\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    addTokenToUGI(identifier1)\n \n-    assert(KafkaTokenUtil.isTokenAvailable())\n+    assert(KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers) ===\n+      Some(KafkaTokenSparkConf.getClusterConfig(sparkConf, identifier1)))\n+  }\n+\n+  test(\"findMatchingToken with multiple matching tokens should throw exception\") {\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier1.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.bootstrap.servers\", bootStrapServers)\n+    sparkConf.set(s\"spark.kafka.clusters.$identifier2.target.bootstrap.servers.regex\",\n+      matchingTargetServersRegex)\n+    addTokenToUGI(identifier1)\n+    addTokenToUGI(identifier2)\n+\n+    val thrown = intercept[IllegalArgumentException] {\n+      KafkaTokenUtil.findMatchingToken(sparkConf, bootStrapServers)\n+    }\n+    assert(thrown.getMessage contains"
  }],
  "prId": 24305
}]