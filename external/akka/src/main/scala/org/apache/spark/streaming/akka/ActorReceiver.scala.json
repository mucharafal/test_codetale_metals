[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "JavaActorReceiver provides Java APIs. Don't use Scala `implicit` and `Timeout` here.\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T00:42:56Z",
    "diffHunk": "@@ -162,6 +177,18 @@ abstract class JavaActorReceiver extends UntypedActor {\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def storeSync[T](item: T)(implicit timeout: Timeout) {"
  }, {
    "author": {
      "login": "lin-zhao"
    },
    "body": "I assume you are talking about line 190. Removed `implicit`. akka `Timeout` should work with java. See http://doc.akka.io/docs/akka/2.4.2/java/untyped-actors.html#Ask__Send-And-Receive-Future\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T01:20:43Z",
    "diffHunk": "@@ -162,6 +177,18 @@ abstract class JavaActorReceiver extends UntypedActor {\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def storeSync[T](item: T)(implicit timeout: Timeout) {"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Yeah. `Timeout` is fine.\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T01:29:14Z",
    "diffHunk": "@@ -162,6 +177,18 @@ abstract class JavaActorReceiver extends UntypedActor {\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def storeSync[T](item: T)(implicit timeout: Timeout) {"
  }],
  "prId": 11176
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Blocking an Actor may have some potential issue.\n\nInstead of calling `Await.ready`, why not create a similar method like `ask` and return `Future`? E.g.,\n\n```\n  def store[T](item: T, timeout: Timeout): Future[Unit] = {\n    context.parent.ask(AskStoreSingleItemData(item))(timeout).map(_ => {})\n  }\n```\n\nThen the user can call `Await.ready` if they feel it's safe, or use another `ExecutionContext` to avoid blocking the Actor\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T01:24:04Z",
    "diffHunk": "@@ -162,6 +177,18 @@ abstract class JavaActorReceiver extends UntypedActor {\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def storeSync[T](item: T)(timeout: Timeout) {\n+    Await.ready(context.parent.ask(SingleItemDataSync(item))(timeout), timeout.duration)"
  }, {
    "author": {
      "login": "lin-zhao"
    },
    "body": "Addressed.\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T07:32:58Z",
    "diffHunk": "@@ -162,6 +177,18 @@ abstract class JavaActorReceiver extends UntypedActor {\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def storeSync[T](item: T)(timeout: Timeout) {\n+    Await.ready(context.parent.ask(SingleItemDataSync(item))(timeout), timeout.duration)"
  }],
  "prId": 11176
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Don't return `Future[Any]`. Return `Future[Unit]` instead. Otherwise, we need to make `Ack` public.\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:09:42Z",
    "diffHunk": "@@ -105,13 +108,25 @@ abstract class ActorReceiver extends Actor {\n   }\n \n   /**\n-   * Store a single item of received data to Spark's memory.\n+   * Store a single item of received data to Spark's memory asynchronously.\n    * These single items will be aggregated together into data blocks before\n    * being pushed into Spark's memory.\n    */\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def store[T](item: T, timeout: Timeout): Future[Any] = {"
  }, {
    "author": {
      "login": "lin-zhao"
    },
    "body": "That's true. But `Future.map` creates an additional thread that listens to the `ack` future. This is frequently executed code and may have performance implication. \n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:25:32Z",
    "diffHunk": "@@ -105,13 +108,25 @@ abstract class ActorReceiver extends Actor {\n   }\n \n   /**\n-   * Store a single item of received data to Spark's memory.\n+   * Store a single item of received data to Spark's memory asynchronously.\n    * These single items will be aggregated together into data blocks before\n    * being pushed into Spark's memory.\n    */\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def store[T](item: T, timeout: Timeout): Future[Any] = {"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Just use `f.map(_ => {})(context.dispatcher)`? Comparing what we did in `store(msg.asInstanceOf[T])`, I think the `map` cost doesn't matter.\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:39:19Z",
    "diffHunk": "@@ -105,13 +108,25 @@ abstract class ActorReceiver extends Actor {\n   }\n \n   /**\n-   * Store a single item of received data to Spark's memory.\n+   * Store a single item of received data to Spark's memory asynchronously.\n    * These single items will be aggregated together into data blocks before\n    * being pushed into Spark's memory.\n    */\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input.\n+   */\n+  def store[T](item: T, timeout: Timeout): Future[Any] = {"
  }],
  "prId": 11176
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Rename this one to `AskStoreSingleItemData`. `Sync` is not correct now\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:10:59Z",
    "diffHunk": "@@ -179,8 +206,10 @@ case class Statistics(numberOfMsgs: Int,\n /** Case class to receive data sent by child actors */\n private[akka] sealed trait ActorReceiverData\n private[akka] case class SingleItemData[T](item: T) extends ActorReceiverData\n+private[akka] case class SingleItemDataSync[T](item: T) extends ActorReceiverData"
  }],
  "prId": 11176
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "`Store a single item of received data to Spark's memory synchronously.` -> \n\n```\nStore a single item of received data to Spark's memory and return a `Future`. The `Future` will be completed when the operator finishes, or with an `akka.pattern.AskTimeoutException` after the given timeout has expired.\n```\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:17:30Z",
    "diffHunk": "@@ -105,13 +108,25 @@ abstract class ActorReceiver extends Actor {\n   }\n \n   /**\n-   * Store a single item of received data to Spark's memory.\n+   * Store a single item of received data to Spark's memory asynchronously.\n    * These single items will be aggregated together into data blocks before\n    * being pushed into Spark's memory.\n    */\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously."
  }],
  "prId": 11176
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "not need to block actually. E.g., the user can write the following non blocking codes to control the speed as well.\n\n``` Scala\nclass UserActor extends ActorReceiver {\n\n  override def preStart(): Unit = {\n    self ! Emit\n  }\n\n  override def receive: Receive = {\n    case Emit =>\n      val item = getNextItem()\n      store(item, 10.seconds).onSuccess {\n        case _ =>\n          self ! Emit\n      }\n  }\n}\n```\n\nSo please change it to `this method allows the user to control the flow speed using`Future`.`\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:26:03Z",
    "diffHunk": "@@ -105,13 +108,25 @@ abstract class ActorReceiver extends Actor {\n   }\n \n   /**\n-   * Store a single item of received data to Spark's memory.\n+   * Store a single item of received data to Spark's memory asynchronously.\n    * These single items will be aggregated together into data blocks before\n    * being pushed into Spark's memory.\n    */\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously.\n+   * These single items will be aggregated together into data blocks before\n+   * being pushed into Spark's memory.\n+   *\n+   * As opposed to [[ActorReceiver.store[T]: Unit]], this method allows flow control\n+   * (maxRate, backpressure) to block the input."
  }],
  "prId": 11176
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Please update the comments as well\n",
    "commit": "58f7aa0c33fcb4cc6711ec441b997a6494058668",
    "createdAt": "2016-02-25T18:28:05Z",
    "diffHunk": "@@ -162,6 +177,18 @@ abstract class JavaActorReceiver extends UntypedActor {\n   def store[T](item: T) {\n     context.parent ! SingleItemData(item)\n   }\n+\n+  /**\n+   * Store a single item of received data to Spark's memory synchronously."
  }],
  "prId": 11176
}]