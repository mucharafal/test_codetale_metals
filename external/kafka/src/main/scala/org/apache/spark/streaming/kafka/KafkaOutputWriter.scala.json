[{
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Hi Hari, a simple question, will `Producer` be shared between each partition? IIUC your code seems to reuse Producer when it is already created, is there any specific purpose to do so?\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-10-29T07:51:42Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver. So the\n+        // ProducerCache from the driver is likely to get serialized and\n+        // sent, which is fine - because at that point the Producer itself is\n+        // not initialized, so a None is sent over the wire.\n+        // Get the producer from that local executor and write!\n+        val producer: Producer[K, V] = {\n+          if (ProducerCache.isCached) {"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "Besides from my understanding I think this `if (...) else (...)` code may has concurrency issue, it would be better to change `ProducerCache` into a singleton factory.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-10-29T08:04:29Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver. So the\n+        // ProducerCache from the driver is likely to get serialized and\n+        // sent, which is fine - because at that point the Producer itself is\n+        // not initialized, so a None is sent over the wire.\n+        // Get the producer from that local executor and write!\n+        val producer: Producer[K, V] = {\n+          if (ProducerCache.isCached) {"
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "The idea is to not create a new Producer instance for each partition. Instead, use the instance of a producer already available on that executor. The drawback is this slightly complex caching mechanism - while the advantage is to reduce the overhead of creating a new producer instance and connecting to Kafka etc. \n\nI am not too familiar with the internals of Kafka - so erring on the side of caution.\n\nYou are right in the fact that there is a concurrency issue here - I will fix that in an update later today.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-10-29T16:56:01Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver. So the\n+        // ProducerCache from the driver is likely to get serialized and\n+        // sent, which is fine - because at that point the Producer itself is\n+        // not initialized, so a None is sent over the wire.\n+        // Get the producer from that local executor and write!\n+        val producer: Producer[K, V] = {\n+          if (ProducerCache.isCached) {"
  }],
  "prId": 2994
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "A empty line after Apache header :).\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-10-29T08:05:37Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */",
    "line": 16
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "Will fix.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-10-29T16:56:16Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */",
    "line": 16
  }],
  "prId": 2994
}, {
  "comments": [{
    "author": {
      "login": "helena"
    },
    "body": "Why create a new producer each write?\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-09T14:59:05Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "@helena - Please see discussion earlier on this thread. For now, we can do this for simplicity, but an earlier commit does cache the Producer. If we see this as too inefficient once we run it and test it out on real use-cases, we can bring back the cached Producer code.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-10T19:37:36Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "helena"
    },
    "body": "Note taken but it seems quite inefficient to both broadcast and create a new Producer for each.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-10T19:47:41Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "The broadcast is only for the configuration -- to avoid shipping that with each task in the closure (since that is reused). Do you see an alternate way of doing it?\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-10T19:57:19Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "helena"
    },
    "body": "I do, but it is a completely different design of doing this. I'm working on something that allows writing to kafka from DStream and RDD but i'm headed to talk at a conference and won't be able to get back to this code until next week. Getting this functionality in asap is important :) so I'm glad you are doing this.\nI might suggest 'writeToKafka' be changed to 'saveToKafka' for api naming convention reasons.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-11T16:22:44Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "If there is a way to keep the Producer around, that is not terribly complex, it would be awesome. As far as I could see, the ProducerCache thing in an earlier version was what I could think of. \n\nI think we could extend this patch to also write an RDD to Kafka (it can use the same semantics). Do you have a repo which I can peek at?\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-11T19:37:16Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "Also, this is likely going in after 1.2 -- so we can wait for you to get back and discuss this further.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2014-11-13T21:28:42Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }, {
    "author": {
      "login": "mkuthan"
    },
    "body": "You could consider share kafkaproducer per JVM/executor as long as producer is thread safe. I'm affraid that new producer for every partition will be main bottleneck in real-word scenarios.\nPlease refer to this blog post: http://allegro.tech/2015/08/spark-kafka-integration.html\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2015-11-04T12:50:23Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =",
    "line": 109
  }],
  "prId": 2994
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Hi @harishreedharan , the Kafka producer API is changed after 0.8.2, you may also need to update the code accordingly.\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2015-07-09T01:17:06Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =\n+          new Producer[K, V](new ProducerConfig(broadcastedConfig.value))\n+        try {\n+          producer.send(events.map(serializerFunc).toArray: _*)",
    "line": 112
  }, {
    "author": {
      "login": "harishreedharan"
    },
    "body": "I am not really updating this branch anymore. I am maintaining it here: https://github.com/cloudera/spark-kafka-writer\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2015-07-09T02:09:16Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =\n+          new Producer[K, V](new ProducerConfig(broadcastedConfig.value))\n+        try {\n+          producer.send(events.map(serializerFunc).toArray: _*)",
    "line": 112
  }, {
    "author": {
      "login": "mkuthan"
    },
    "body": "Please remember that kafka producer is asynchronous. The processing should wait until the results are really published to the kafka cluster.  Please check how it is implemented in Samza:\nhttps://github.com/apache/samza/blob/master/samza-kafka/src/main/scala/org/apache/samza/system/kafka/KafkaSystemProducer.scala\n\nI'm not sure that we need retry policy, but at least we should check the result of the producer.send.\n\nMy $.02 cents :-)\n",
    "commit": "0a45f1ab5ba5f9440a78e47e48b48f0321d440c1",
    "createdAt": "2015-11-04T12:53:23Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.util.Properties\n+\n+import scala.reflect.ClassTag\n+\n+import kafka.producer.{ProducerConfig, KeyedMessage, Producer}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.streaming.dstream.DStream\n+\n+/**\n+ * Import this object in this form:\n+ * {{{\n+ *   import org.apache.spark.streaming.kafka.KafkaWriter._\n+ * }}}\n+ *\n+ * Once imported, the `writeToKafka` can be called on any [[DStream]] object in this form:\n+ * {{{\n+ *   dstream.writeToKafka(producerConfig, f)\n+ * }}}\n+ */\n+object KafkaWriter {\n+  import scala.language.implicitConversions\n+  /**\n+   * This implicit method allows the user to call dstream.writeToKafka(..)\n+   * @param dstream - DStream to write to Kafka\n+   * @tparam T - The type of the DStream\n+   * @tparam K - The type of the key to serialize to\n+   * @tparam V - The type of the value to serialize to\n+   * @return\n+   */\n+  implicit def createKafkaOutputWriter[T: ClassTag, K, V](dstream: DStream[T]): KafkaWriter[T] = {\n+    new KafkaWriter[T](dstream)\n+  }\n+}\n+\n+/**\n+ *\n+ * This class can be used to write data to Kafka from Spark Streaming. To write data to Kafka\n+ * simply `import org.apache.spark.streaming.kafka.KafkaWriter._` in your application and call\n+ * `dstream.writeToKafka(producerConf, func)`\n+ *\n+ * Here is an example:\n+ * {{{\n+ * // Adding this line allows the user to call dstream.writeDStreamToKafka(..)\n+ * import org.apache.spark.streaming.kafka.KafkaWriter._\n+ *\n+ * class ExampleWriter {\n+ *   val instream = ssc.queueStream(toBe)\n+ *   val producerConf = new Properties()\n+ *   producerConf.put(\"serializer.class\", \"kafka.serializer.DefaultEncoder\")\n+ *   producerConf.put(\"key.serializer.class\", \"kafka.serializer.StringEncoder\")\n+ *   producerConf.put(\"metadata.broker.list\", \"kafka.example.com:5545\")\n+ *   producerConf.put(\"request.required.acks\", \"1\")\n+ *   instream.writeToKafka(producerConf,\n+ *    (x: String) => new KeyedMessage[String, String](\"default\", null, x))\n+ *   ssc.start()\n+ * }\n+ *\n+ * }}}\n+ * @param dstream - The [[DStream]] to be written to Kafka\n+ *\n+ */\n+class KafkaWriter[T: ClassTag](@transient dstream: DStream[T]) extends Serializable with Logging {\n+\n+  /**\n+   * To write data from a DStream to Kafka, call this function after creating the DStream. Once\n+   * the DStream is passed into this function, all data coming from the DStream is written out to\n+   * Kafka. The properties instance takes the configuration required to connect to the Kafka\n+   * brokers in the standard Kafka format. The serializerFunc is a function that converts each\n+   * element of the RDD to a Kafka [[KeyedMessage]]. This closure should be serializable - so it\n+   * should use only instances of Serializables.\n+   * @param producerConfig The configuration that can be used to connect to Kafka\n+   * @param serializerFunc The function to convert the data from the stream into Kafka\n+   *                       [[KeyedMessage]]s.\n+   * @tparam K The type of the key\n+   * @tparam V The type of the value\n+   *\n+   */\n+  def writeToKafka[K, V](producerConfig: Properties,\n+    serializerFunc: T => KeyedMessage[K, V]): Unit = {\n+\n+    // Broadcast the producer to avoid sending it every time.\n+    val broadcastedConfig = dstream.ssc.sc.broadcast(producerConfig)\n+\n+    def func = (rdd: RDD[T]) => {\n+      rdd.foreachPartition(events => {\n+        // The ForEachDStream runs the function locally on the driver.\n+        // This code can alternatively use sc.runJob, but this approach seemed cleaner.\n+        val producer: Producer[K, V] =\n+          new Producer[K, V](new ProducerConfig(broadcastedConfig.value))\n+        try {\n+          producer.send(events.map(serializerFunc).toArray: _*)",
    "line": 112
  }],
  "prId": 2994
}]