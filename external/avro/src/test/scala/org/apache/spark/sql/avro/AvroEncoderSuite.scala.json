[{
  "comments": [{
    "author": {
      "login": "gengliangwang"
    },
    "body": "nit: use the api using `jsonFormatSchema`",
    "commit": "dfae1b08209c3c60beeaeb4dacacf1571047b460",
    "createdAt": "2018-12-13T05:09:58Z",
    "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.avro\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.avro.{Schema, SchemaBuilder}\n+import org.apache.avro.generic.{GenericData, GenericRecordBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkContext}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.apache.spark.sql.types.{FloatType, IntegerType, StringType}\n+\n+class AvroEncoderSuite extends SharedSQLContext {\n+  import testImplicits._\n+\n+  test(\"encoder from json schema\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"simple_record\",\n+        |  \"fields\" :\n+        |   [\n+        |    { \"name\" : \"myUInt\", \"type\" : [ \"int\", \"null\" ], \"default\" : 1 },\n+        |    { \"name\" : \"myULong\", \"type\" : [ \"long\", \"null\" ], \"default\" : 2 },\n+        |    { \"name\" : \"myUBool\", \"type\" : [ \"boolean\", \"null\" ], \"default\" : true },\n+        |    { \"name\" : \"myUDouble\", \"type\" : [ \"double\", \"null\" ], \"default\" : 3 },\n+        |    { \"name\" : \"myUFloat\", \"type\" : [ \"float\", \"null\" ], \"default\" : 4.5 },\n+        |    { \"name\" : \"myUString\", \"type\" : [ \"string\", \"null\" ], \"default\" : \"foo\" },\n+        |\n+        |    { \"name\" : \"myInt\", \"type\" : \"int\", \"default\" : 10 },\n+        |    { \"name\" : \"myLong\", \"type\" : \"long\", \"default\" : 11 },\n+        |    { \"name\" : \"myBool\", \"type\" : \"boolean\", \"default\" : false },\n+        |    { \"name\" : \"myDouble\", \"type\" : \"double\", \"default\" : 12 },\n+        |    { \"name\" : \"myFloat\", \"type\" : \"float\", \"default\" : 13.14 },\n+        |    { \"name\" : \"myString\", \"type\" : \"string\", \"default\" : \"bar\" },\n+        |\n+        |    { \"name\" : \"myArray\", \"type\" :\n+        |     { \"type\" : \"array\", \"items\" : \"bytes\" }, \"default\" : [ \"a12b\", \"cc50\" ] },\n+        |    { \"name\" : \"myMap\", \"type\" : { \"type\" : \"map\", \"values\" : \"string\" },\n+        |     \"default\" : {\"a\":\"A\", \"b\":\"B\"} }\n+        |   ]\n+        |}\n+      \"\"\".stripMargin\n+    val encoder = AvroEncoder.of(avroSchema)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"generic record converts to row and back\") {\n+    // complex schema including type of basic type, array with int/string/record/enum,\n+    // nested record and map.\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"boolean\",\n+        |    \"type\" : \"boolean\",\n+        |    \"default\" : false\n+        |  }, {\n+        |    \"name\" : \"int\",\n+        |    \"type\" : \"int\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"long\",\n+        |    \"type\" : \"long\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float\",\n+        |    \"type\" : \"float\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"double\",\n+        |    \"type\" : \"double\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"string\",\n+        |    \"type\" : \"string\",\n+        |    \"default\" : \"string\"\n+        |  }, {\n+        |    \"name\" : \"bytes\",\n+        |    \"type\" : \"bytes\",\n+        |    \"default\" : \"bytes\"\n+        |  }, {\n+        |    \"name\" : \"nested\",\n+        |    \"type\" : {\n+        |      \"type\" : \"record\",\n+        |      \"name\" : \"simple_record\",\n+        |      \"fields\" : [ {\n+        |        \"name\" : \"nested1\",\n+        |        \"type\" : \"int\",\n+        |        \"default\" : 0\n+        |      }, {\n+        |        \"name\" : \"nested2\",\n+        |        \"type\" : \"string\",\n+        |        \"default\" : \"string\"\n+        |      } ]\n+        |    },\n+        |    \"default\" : {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }\n+        |  }, {\n+        |    \"name\" : \"enum\",\n+        |    \"type\" : {\n+        |      \"type\" : \"enum\",\n+        |      \"name\" : \"simple_enums\",\n+        |      \"symbols\" : [ \"SPADES\", \"HEARTS\", \"CLUBS\", \"DIAMONDS\" ]\n+        |    },\n+        |    \"default\" : \"SPADES\"\n+        |  }, {\n+        |    \"name\" : \"int_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"int\"\n+        |    },\n+        |    \"default\" : [ 1, 2, 3 ]\n+        |  }, {\n+        |    \"name\" : \"string_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"string\"\n+        |    },\n+        |    \"default\" : [ \"a\", \"b\", \"c\" ]\n+        |  }, {\n+        |    \"name\" : \"record_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_record\"\n+        |    },\n+        |    \"default\" : [ {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }, {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    } ]\n+        |  }, {\n+        |    \"name\" : \"enum_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_enums\"\n+        |    },\n+        |    \"default\" : [ \"SPADES\", \"HEARTS\", \"SPADES\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : {\n+        |        \"type\" : \"fixed\",\n+        |        \"name\" : \"simple_fixed\",\n+        |        \"size\" : 3\n+        |      }\n+        |    },\n+        |    \"default\" : [ \"foo\", \"bar\", \"baz\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed\",\n+        |    \"type\" : {\n+        |      \"type\" : \"fixed\",\n+        |      \"name\" : \"simple_fixed_item\",\n+        |      \"size\" : 16\n+        |    },\n+        |    \"default\" : \"string_length_16\"\n+        |  }, {\n+        |    \"name\" : \"map\",\n+        |    \"type\" : {\n+        |      \"type\" : \"map\",\n+        |      \"values\" : \"string\"\n+        |    },\n+        |    \"default\" : {\n+        |      \"a\" : \"A\"\n+        |    }\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val encoder = AvroEncoder.of[GenericData.Record](schema)\n+    logInfo(schema.toString)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"encoder resolves union types to rows\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"int_null_union\",\n+        |    \"type\" : [ \"null\", \"int\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"string_null_union\",\n+        |    \"type\" : [ \"null\", \"string\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"int_long_union\",\n+        |    \"type\" : [ \"int\", \"long\" ],\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float_double_union\",\n+        |    \"type\" : [ \"float\", \"double\" ],\n+        |    \"default\" : 0.0\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)"
  }, {
    "author": {
      "login": "xuanyuanking"
    },
    "body": "Thanks, done in 00cb983.",
    "commit": "dfae1b08209c3c60beeaeb4dacacf1571047b460",
    "createdAt": "2018-12-13T14:14:29Z",
    "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.avro\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.avro.{Schema, SchemaBuilder}\n+import org.apache.avro.generic.{GenericData, GenericRecordBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkContext}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.apache.spark.sql.types.{FloatType, IntegerType, StringType}\n+\n+class AvroEncoderSuite extends SharedSQLContext {\n+  import testImplicits._\n+\n+  test(\"encoder from json schema\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"simple_record\",\n+        |  \"fields\" :\n+        |   [\n+        |    { \"name\" : \"myUInt\", \"type\" : [ \"int\", \"null\" ], \"default\" : 1 },\n+        |    { \"name\" : \"myULong\", \"type\" : [ \"long\", \"null\" ], \"default\" : 2 },\n+        |    { \"name\" : \"myUBool\", \"type\" : [ \"boolean\", \"null\" ], \"default\" : true },\n+        |    { \"name\" : \"myUDouble\", \"type\" : [ \"double\", \"null\" ], \"default\" : 3 },\n+        |    { \"name\" : \"myUFloat\", \"type\" : [ \"float\", \"null\" ], \"default\" : 4.5 },\n+        |    { \"name\" : \"myUString\", \"type\" : [ \"string\", \"null\" ], \"default\" : \"foo\" },\n+        |\n+        |    { \"name\" : \"myInt\", \"type\" : \"int\", \"default\" : 10 },\n+        |    { \"name\" : \"myLong\", \"type\" : \"long\", \"default\" : 11 },\n+        |    { \"name\" : \"myBool\", \"type\" : \"boolean\", \"default\" : false },\n+        |    { \"name\" : \"myDouble\", \"type\" : \"double\", \"default\" : 12 },\n+        |    { \"name\" : \"myFloat\", \"type\" : \"float\", \"default\" : 13.14 },\n+        |    { \"name\" : \"myString\", \"type\" : \"string\", \"default\" : \"bar\" },\n+        |\n+        |    { \"name\" : \"myArray\", \"type\" :\n+        |     { \"type\" : \"array\", \"items\" : \"bytes\" }, \"default\" : [ \"a12b\", \"cc50\" ] },\n+        |    { \"name\" : \"myMap\", \"type\" : { \"type\" : \"map\", \"values\" : \"string\" },\n+        |     \"default\" : {\"a\":\"A\", \"b\":\"B\"} }\n+        |   ]\n+        |}\n+      \"\"\".stripMargin\n+    val encoder = AvroEncoder.of(avroSchema)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"generic record converts to row and back\") {\n+    // complex schema including type of basic type, array with int/string/record/enum,\n+    // nested record and map.\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"boolean\",\n+        |    \"type\" : \"boolean\",\n+        |    \"default\" : false\n+        |  }, {\n+        |    \"name\" : \"int\",\n+        |    \"type\" : \"int\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"long\",\n+        |    \"type\" : \"long\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float\",\n+        |    \"type\" : \"float\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"double\",\n+        |    \"type\" : \"double\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"string\",\n+        |    \"type\" : \"string\",\n+        |    \"default\" : \"string\"\n+        |  }, {\n+        |    \"name\" : \"bytes\",\n+        |    \"type\" : \"bytes\",\n+        |    \"default\" : \"bytes\"\n+        |  }, {\n+        |    \"name\" : \"nested\",\n+        |    \"type\" : {\n+        |      \"type\" : \"record\",\n+        |      \"name\" : \"simple_record\",\n+        |      \"fields\" : [ {\n+        |        \"name\" : \"nested1\",\n+        |        \"type\" : \"int\",\n+        |        \"default\" : 0\n+        |      }, {\n+        |        \"name\" : \"nested2\",\n+        |        \"type\" : \"string\",\n+        |        \"default\" : \"string\"\n+        |      } ]\n+        |    },\n+        |    \"default\" : {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }\n+        |  }, {\n+        |    \"name\" : \"enum\",\n+        |    \"type\" : {\n+        |      \"type\" : \"enum\",\n+        |      \"name\" : \"simple_enums\",\n+        |      \"symbols\" : [ \"SPADES\", \"HEARTS\", \"CLUBS\", \"DIAMONDS\" ]\n+        |    },\n+        |    \"default\" : \"SPADES\"\n+        |  }, {\n+        |    \"name\" : \"int_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"int\"\n+        |    },\n+        |    \"default\" : [ 1, 2, 3 ]\n+        |  }, {\n+        |    \"name\" : \"string_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"string\"\n+        |    },\n+        |    \"default\" : [ \"a\", \"b\", \"c\" ]\n+        |  }, {\n+        |    \"name\" : \"record_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_record\"\n+        |    },\n+        |    \"default\" : [ {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }, {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    } ]\n+        |  }, {\n+        |    \"name\" : \"enum_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_enums\"\n+        |    },\n+        |    \"default\" : [ \"SPADES\", \"HEARTS\", \"SPADES\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : {\n+        |        \"type\" : \"fixed\",\n+        |        \"name\" : \"simple_fixed\",\n+        |        \"size\" : 3\n+        |      }\n+        |    },\n+        |    \"default\" : [ \"foo\", \"bar\", \"baz\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed\",\n+        |    \"type\" : {\n+        |      \"type\" : \"fixed\",\n+        |      \"name\" : \"simple_fixed_item\",\n+        |      \"size\" : 16\n+        |    },\n+        |    \"default\" : \"string_length_16\"\n+        |  }, {\n+        |    \"name\" : \"map\",\n+        |    \"type\" : {\n+        |      \"type\" : \"map\",\n+        |      \"values\" : \"string\"\n+        |    },\n+        |    \"default\" : {\n+        |      \"a\" : \"A\"\n+        |    }\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val encoder = AvroEncoder.of[GenericData.Record](schema)\n+    logInfo(schema.toString)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"encoder resolves union types to rows\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"int_null_union\",\n+        |    \"type\" : [ \"null\", \"int\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"string_null_union\",\n+        |    \"type\" : [ \"null\", \"string\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"int_long_union\",\n+        |    \"type\" : [ \"int\", \"long\" ],\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float_double_union\",\n+        |    \"type\" : [ \"float\", \"double\" ],\n+        |    \"default\" : 0.0\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)"
  }],
  "prId": 22878
}, {
  "comments": [{
    "author": {
      "login": "gengliangwang"
    },
    "body": "nit: remove logInfo, or improve the output",
    "commit": "dfae1b08209c3c60beeaeb4dacacf1571047b460",
    "createdAt": "2018-12-13T05:10:18Z",
    "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.avro\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.avro.{Schema, SchemaBuilder}\n+import org.apache.avro.generic.{GenericData, GenericRecordBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkContext}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.apache.spark.sql.types.{FloatType, IntegerType, StringType}\n+\n+class AvroEncoderSuite extends SharedSQLContext {\n+  import testImplicits._\n+\n+  test(\"encoder from json schema\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"simple_record\",\n+        |  \"fields\" :\n+        |   [\n+        |    { \"name\" : \"myUInt\", \"type\" : [ \"int\", \"null\" ], \"default\" : 1 },\n+        |    { \"name\" : \"myULong\", \"type\" : [ \"long\", \"null\" ], \"default\" : 2 },\n+        |    { \"name\" : \"myUBool\", \"type\" : [ \"boolean\", \"null\" ], \"default\" : true },\n+        |    { \"name\" : \"myUDouble\", \"type\" : [ \"double\", \"null\" ], \"default\" : 3 },\n+        |    { \"name\" : \"myUFloat\", \"type\" : [ \"float\", \"null\" ], \"default\" : 4.5 },\n+        |    { \"name\" : \"myUString\", \"type\" : [ \"string\", \"null\" ], \"default\" : \"foo\" },\n+        |\n+        |    { \"name\" : \"myInt\", \"type\" : \"int\", \"default\" : 10 },\n+        |    { \"name\" : \"myLong\", \"type\" : \"long\", \"default\" : 11 },\n+        |    { \"name\" : \"myBool\", \"type\" : \"boolean\", \"default\" : false },\n+        |    { \"name\" : \"myDouble\", \"type\" : \"double\", \"default\" : 12 },\n+        |    { \"name\" : \"myFloat\", \"type\" : \"float\", \"default\" : 13.14 },\n+        |    { \"name\" : \"myString\", \"type\" : \"string\", \"default\" : \"bar\" },\n+        |\n+        |    { \"name\" : \"myArray\", \"type\" :\n+        |     { \"type\" : \"array\", \"items\" : \"bytes\" }, \"default\" : [ \"a12b\", \"cc50\" ] },\n+        |    { \"name\" : \"myMap\", \"type\" : { \"type\" : \"map\", \"values\" : \"string\" },\n+        |     \"default\" : {\"a\":\"A\", \"b\":\"B\"} }\n+        |   ]\n+        |}\n+      \"\"\".stripMargin\n+    val encoder = AvroEncoder.of(avroSchema)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"generic record converts to row and back\") {\n+    // complex schema including type of basic type, array with int/string/record/enum,\n+    // nested record and map.\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"boolean\",\n+        |    \"type\" : \"boolean\",\n+        |    \"default\" : false\n+        |  }, {\n+        |    \"name\" : \"int\",\n+        |    \"type\" : \"int\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"long\",\n+        |    \"type\" : \"long\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float\",\n+        |    \"type\" : \"float\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"double\",\n+        |    \"type\" : \"double\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"string\",\n+        |    \"type\" : \"string\",\n+        |    \"default\" : \"string\"\n+        |  }, {\n+        |    \"name\" : \"bytes\",\n+        |    \"type\" : \"bytes\",\n+        |    \"default\" : \"bytes\"\n+        |  }, {\n+        |    \"name\" : \"nested\",\n+        |    \"type\" : {\n+        |      \"type\" : \"record\",\n+        |      \"name\" : \"simple_record\",\n+        |      \"fields\" : [ {\n+        |        \"name\" : \"nested1\",\n+        |        \"type\" : \"int\",\n+        |        \"default\" : 0\n+        |      }, {\n+        |        \"name\" : \"nested2\",\n+        |        \"type\" : \"string\",\n+        |        \"default\" : \"string\"\n+        |      } ]\n+        |    },\n+        |    \"default\" : {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }\n+        |  }, {\n+        |    \"name\" : \"enum\",\n+        |    \"type\" : {\n+        |      \"type\" : \"enum\",\n+        |      \"name\" : \"simple_enums\",\n+        |      \"symbols\" : [ \"SPADES\", \"HEARTS\", \"CLUBS\", \"DIAMONDS\" ]\n+        |    },\n+        |    \"default\" : \"SPADES\"\n+        |  }, {\n+        |    \"name\" : \"int_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"int\"\n+        |    },\n+        |    \"default\" : [ 1, 2, 3 ]\n+        |  }, {\n+        |    \"name\" : \"string_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"string\"\n+        |    },\n+        |    \"default\" : [ \"a\", \"b\", \"c\" ]\n+        |  }, {\n+        |    \"name\" : \"record_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_record\"\n+        |    },\n+        |    \"default\" : [ {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }, {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    } ]\n+        |  }, {\n+        |    \"name\" : \"enum_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_enums\"\n+        |    },\n+        |    \"default\" : [ \"SPADES\", \"HEARTS\", \"SPADES\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : {\n+        |        \"type\" : \"fixed\",\n+        |        \"name\" : \"simple_fixed\",\n+        |        \"size\" : 3\n+        |      }\n+        |    },\n+        |    \"default\" : [ \"foo\", \"bar\", \"baz\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed\",\n+        |    \"type\" : {\n+        |      \"type\" : \"fixed\",\n+        |      \"name\" : \"simple_fixed_item\",\n+        |      \"size\" : 16\n+        |    },\n+        |    \"default\" : \"string_length_16\"\n+        |  }, {\n+        |    \"name\" : \"map\",\n+        |    \"type\" : {\n+        |      \"type\" : \"map\",\n+        |      \"values\" : \"string\"\n+        |    },\n+        |    \"default\" : {\n+        |      \"a\" : \"A\"\n+        |    }\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val encoder = AvroEncoder.of[GenericData.Record](schema)\n+    logInfo(schema.toString)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"encoder resolves union types to rows\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"int_null_union\",\n+        |    \"type\" : [ \"null\", \"int\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"string_null_union\",\n+        |    \"type\" : [ \"null\", \"string\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"int_long_union\",\n+        |    \"type\" : [ \"int\", \"long\" ],\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float_double_union\",\n+        |    \"type\" : [ \"float\", \"double\" ],\n+        |    \"default\" : 0.0\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val encoder = AvroEncoder.of[GenericData.Record](schema)\n+    logInfo(schema.toString(true))"
  }, {
    "author": {
      "login": "xuanyuanking"
    },
    "body": "Thanks, remove done in 00cb983.",
    "commit": "dfae1b08209c3c60beeaeb4dacacf1571047b460",
    "createdAt": "2018-12-13T14:14:43Z",
    "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.avro\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.avro.{Schema, SchemaBuilder}\n+import org.apache.avro.generic.{GenericData, GenericRecordBuilder}\n+\n+import org.apache.spark.{SparkConf, SparkContext}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.apache.spark.sql.types.{FloatType, IntegerType, StringType}\n+\n+class AvroEncoderSuite extends SharedSQLContext {\n+  import testImplicits._\n+\n+  test(\"encoder from json schema\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"simple_record\",\n+        |  \"fields\" :\n+        |   [\n+        |    { \"name\" : \"myUInt\", \"type\" : [ \"int\", \"null\" ], \"default\" : 1 },\n+        |    { \"name\" : \"myULong\", \"type\" : [ \"long\", \"null\" ], \"default\" : 2 },\n+        |    { \"name\" : \"myUBool\", \"type\" : [ \"boolean\", \"null\" ], \"default\" : true },\n+        |    { \"name\" : \"myUDouble\", \"type\" : [ \"double\", \"null\" ], \"default\" : 3 },\n+        |    { \"name\" : \"myUFloat\", \"type\" : [ \"float\", \"null\" ], \"default\" : 4.5 },\n+        |    { \"name\" : \"myUString\", \"type\" : [ \"string\", \"null\" ], \"default\" : \"foo\" },\n+        |\n+        |    { \"name\" : \"myInt\", \"type\" : \"int\", \"default\" : 10 },\n+        |    { \"name\" : \"myLong\", \"type\" : \"long\", \"default\" : 11 },\n+        |    { \"name\" : \"myBool\", \"type\" : \"boolean\", \"default\" : false },\n+        |    { \"name\" : \"myDouble\", \"type\" : \"double\", \"default\" : 12 },\n+        |    { \"name\" : \"myFloat\", \"type\" : \"float\", \"default\" : 13.14 },\n+        |    { \"name\" : \"myString\", \"type\" : \"string\", \"default\" : \"bar\" },\n+        |\n+        |    { \"name\" : \"myArray\", \"type\" :\n+        |     { \"type\" : \"array\", \"items\" : \"bytes\" }, \"default\" : [ \"a12b\", \"cc50\" ] },\n+        |    { \"name\" : \"myMap\", \"type\" : { \"type\" : \"map\", \"values\" : \"string\" },\n+        |     \"default\" : {\"a\":\"A\", \"b\":\"B\"} }\n+        |   ]\n+        |}\n+      \"\"\".stripMargin\n+    val encoder = AvroEncoder.of(avroSchema)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"generic record converts to row and back\") {\n+    // complex schema including type of basic type, array with int/string/record/enum,\n+    // nested record and map.\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"boolean\",\n+        |    \"type\" : \"boolean\",\n+        |    \"default\" : false\n+        |  }, {\n+        |    \"name\" : \"int\",\n+        |    \"type\" : \"int\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"long\",\n+        |    \"type\" : \"long\",\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float\",\n+        |    \"type\" : \"float\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"double\",\n+        |    \"type\" : \"double\",\n+        |    \"default\" : 0.0\n+        |  }, {\n+        |    \"name\" : \"string\",\n+        |    \"type\" : \"string\",\n+        |    \"default\" : \"string\"\n+        |  }, {\n+        |    \"name\" : \"bytes\",\n+        |    \"type\" : \"bytes\",\n+        |    \"default\" : \"bytes\"\n+        |  }, {\n+        |    \"name\" : \"nested\",\n+        |    \"type\" : {\n+        |      \"type\" : \"record\",\n+        |      \"name\" : \"simple_record\",\n+        |      \"fields\" : [ {\n+        |        \"name\" : \"nested1\",\n+        |        \"type\" : \"int\",\n+        |        \"default\" : 0\n+        |      }, {\n+        |        \"name\" : \"nested2\",\n+        |        \"type\" : \"string\",\n+        |        \"default\" : \"string\"\n+        |      } ]\n+        |    },\n+        |    \"default\" : {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }\n+        |  }, {\n+        |    \"name\" : \"enum\",\n+        |    \"type\" : {\n+        |      \"type\" : \"enum\",\n+        |      \"name\" : \"simple_enums\",\n+        |      \"symbols\" : [ \"SPADES\", \"HEARTS\", \"CLUBS\", \"DIAMONDS\" ]\n+        |    },\n+        |    \"default\" : \"SPADES\"\n+        |  }, {\n+        |    \"name\" : \"int_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"int\"\n+        |    },\n+        |    \"default\" : [ 1, 2, 3 ]\n+        |  }, {\n+        |    \"name\" : \"string_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"string\"\n+        |    },\n+        |    \"default\" : [ \"a\", \"b\", \"c\" ]\n+        |  }, {\n+        |    \"name\" : \"record_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_record\"\n+        |    },\n+        |    \"default\" : [ {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    }, {\n+        |      \"nested1\" : 0,\n+        |      \"nested2\" : \"string\"\n+        |    } ]\n+        |  }, {\n+        |    \"name\" : \"enum_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : \"simple_enums\"\n+        |    },\n+        |    \"default\" : [ \"SPADES\", \"HEARTS\", \"SPADES\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed_array\",\n+        |    \"type\" : {\n+        |      \"type\" : \"array\",\n+        |      \"items\" : {\n+        |        \"type\" : \"fixed\",\n+        |        \"name\" : \"simple_fixed\",\n+        |        \"size\" : 3\n+        |      }\n+        |    },\n+        |    \"default\" : [ \"foo\", \"bar\", \"baz\" ]\n+        |  }, {\n+        |    \"name\" : \"fixed\",\n+        |    \"type\" : {\n+        |      \"type\" : \"fixed\",\n+        |      \"name\" : \"simple_fixed_item\",\n+        |      \"size\" : 16\n+        |    },\n+        |    \"default\" : \"string_length_16\"\n+        |  }, {\n+        |    \"name\" : \"map\",\n+        |    \"type\" : {\n+        |      \"type\" : \"map\",\n+        |      \"values\" : \"string\"\n+        |    },\n+        |    \"default\" : {\n+        |      \"a\" : \"A\"\n+        |    }\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val encoder = AvroEncoder.of[GenericData.Record](schema)\n+    logInfo(schema.toString)\n+    val expressionEncoder = encoder.asInstanceOf[ExpressionEncoder[GenericData.Record]]\n+    val record = new GenericRecordBuilder(schema).build\n+    val row = expressionEncoder.toRow(record)\n+    val recordFromRow = expressionEncoder.resolveAndBind().fromRow(row)\n+    assert(record.toString == recordFromRow.toString)\n+  }\n+\n+  test(\"encoder resolves union types to rows\") {\n+    val avroSchema =\n+      \"\"\"\n+        |{\n+        |  \"type\" : \"record\",\n+        |  \"name\" : \"record\",\n+        |  \"fields\" : [ {\n+        |    \"name\" : \"int_null_union\",\n+        |    \"type\" : [ \"null\", \"int\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"string_null_union\",\n+        |    \"type\" : [ \"null\", \"string\" ],\n+        |    \"default\" : null\n+        |  }, {\n+        |    \"name\" : \"int_long_union\",\n+        |    \"type\" : [ \"int\", \"long\" ],\n+        |    \"default\" : 0\n+        |  }, {\n+        |    \"name\" : \"float_double_union\",\n+        |    \"type\" : [ \"float\", \"double\" ],\n+        |    \"default\" : 0.0\n+        |  } ]\n+        |}\n+      \"\"\".stripMargin\n+\n+    val schema = new Schema.Parser().parse(avroSchema)\n+    val encoder = AvroEncoder.of[GenericData.Record](schema)\n+    logInfo(schema.toString(true))"
  }],
  "prId": 22878
}]