[{
  "comments": [{
    "author": {
      "login": "markgrover"
    },
    "body": "Nit: All kafka related logging statements outside of this file start with an upper case letter. However, this file often starts log lines with lower cases.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-16T00:08:04Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+\n+import org.apache.kafka.clients.consumer.{ ConsumerConfig, ConsumerRecord, KafkaConsumer }\n+import org.apache.kafka.common.TopicPartition\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Consumer of single topicpartition, intended for cached reuse.\n+ * Underlying consumer is not threadsafe, so neither is this,\n+ * but processing the same topicpartition and group id in multiple threads would be bad anyway.\n+ */\n+private[kafka]\n+class CachedKafkaConsumer[K, V] private(\n+  val groupId: String,\n+  val topic: String,\n+  val partition: Int,\n+  val kafkaParams: ju.Map[String, Object]) extends Logging {\n+\n+  assert(groupId == kafkaParams.get(ConsumerConfig.GROUP_ID_CONFIG),\n+    \"groupId used for cache key must match the groupId in kafkaParams\")\n+\n+  val topicPartition = new TopicPartition(topic, partition)\n+\n+  protected val consumer = {\n+    val c = new KafkaConsumer[K, V](kafkaParams)\n+    val tps = new ju.ArrayList[TopicPartition]()\n+    tps.add(topicPartition)\n+    c.assign(tps)\n+    c\n+  }\n+\n+  // TODO if the buffer was kept around as a random-access structure,\n+  // could possibly optimize re-calculating of an RDD in the same batch\n+  protected var buffer = ju.Collections.emptyList[ConsumerRecord[K, V]]().iterator\n+  protected var nextOffset = -2L\n+\n+  /**\n+   * Get the record for the given offset, waiting up to timeout ms if IO is necessary.\n+   * Sequential forward access will use buffers, but random access will be horribly inefficient.\n+   */\n+  def get(offset: Long, timeout: Long): ConsumerRecord[K, V] = {\n+    log.debug(s\"get $groupId $topic $partition nextOffset $nextOffset requested $offset\")\n+    if (offset != nextOffset) {\n+      log.info(s\"initial fetch for $groupId $topic $partition $offset\")"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "markgrover"
    },
    "body": "Is this needed if poll is going to set the buffer again anyways?\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-16T00:09:50Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+\n+import org.apache.kafka.clients.consumer.{ ConsumerConfig, ConsumerRecord, KafkaConsumer }\n+import org.apache.kafka.common.TopicPartition\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Consumer of single topicpartition, intended for cached reuse.\n+ * Underlying consumer is not threadsafe, so neither is this,\n+ * but processing the same topicpartition and group id in multiple threads would be bad anyway.\n+ */\n+private[kafka]\n+class CachedKafkaConsumer[K, V] private(\n+  val groupId: String,\n+  val topic: String,\n+  val partition: Int,\n+  val kafkaParams: ju.Map[String, Object]) extends Logging {\n+\n+  assert(groupId == kafkaParams.get(ConsumerConfig.GROUP_ID_CONFIG),\n+    \"groupId used for cache key must match the groupId in kafkaParams\")\n+\n+  val topicPartition = new TopicPartition(topic, partition)\n+\n+  protected val consumer = {\n+    val c = new KafkaConsumer[K, V](kafkaParams)\n+    val tps = new ju.ArrayList[TopicPartition]()\n+    tps.add(topicPartition)\n+    c.assign(tps)\n+    c\n+  }\n+\n+  // TODO if the buffer was kept around as a random-access structure,\n+  // could possibly optimize re-calculating of an RDD in the same batch\n+  protected var buffer = ju.Collections.emptyList[ConsumerRecord[K, V]]().iterator\n+  protected var nextOffset = -2L\n+\n+  /**\n+   * Get the record for the given offset, waiting up to timeout ms if IO is necessary.\n+   * Sequential forward access will use buffers, but random access will be horribly inefficient.\n+   */\n+  def get(offset: Long, timeout: Long): ConsumerRecord[K, V] = {\n+    log.debug(s\"get $groupId $topic $partition nextOffset $nextOffset requested $offset\")\n+    if (offset != nextOffset) {\n+      log.info(s\"initial fetch for $groupId $topic $partition $offset\")\n+      buffer = ju.Collections.emptyList[ConsumerRecord[K, V]]().iterator"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "markgrover"
    },
    "body": "May be I am over engineering here and if so please feel free to tell me so and reject.\nIf the record offset is lower than offset, should we check if the buffer already has the record, before trying to read it from kafka?\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-16T00:11:26Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+\n+import org.apache.kafka.clients.consumer.{ ConsumerConfig, ConsumerRecord, KafkaConsumer }\n+import org.apache.kafka.common.TopicPartition\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Consumer of single topicpartition, intended for cached reuse.\n+ * Underlying consumer is not threadsafe, so neither is this,\n+ * but processing the same topicpartition and group id in multiple threads would be bad anyway.\n+ */\n+private[kafka]\n+class CachedKafkaConsumer[K, V] private(\n+  val groupId: String,\n+  val topic: String,\n+  val partition: Int,\n+  val kafkaParams: ju.Map[String, Object]) extends Logging {\n+\n+  assert(groupId == kafkaParams.get(ConsumerConfig.GROUP_ID_CONFIG),\n+    \"groupId used for cache key must match the groupId in kafkaParams\")\n+\n+  val topicPartition = new TopicPartition(topic, partition)\n+\n+  protected val consumer = {\n+    val c = new KafkaConsumer[K, V](kafkaParams)\n+    val tps = new ju.ArrayList[TopicPartition]()\n+    tps.add(topicPartition)\n+    c.assign(tps)\n+    c\n+  }\n+\n+  // TODO if the buffer was kept around as a random-access structure,\n+  // could possibly optimize re-calculating of an RDD in the same batch\n+  protected var buffer = ju.Collections.emptyList[ConsumerRecord[K, V]]().iterator\n+  protected var nextOffset = -2L\n+\n+  /**\n+   * Get the record for the given offset, waiting up to timeout ms if IO is necessary.\n+   * Sequential forward access will use buffers, but random access will be horribly inefficient.\n+   */\n+  def get(offset: Long, timeout: Long): ConsumerRecord[K, V] = {\n+    log.debug(s\"get $groupId $topic $partition nextOffset $nextOffset requested $offset\")\n+    if (offset != nextOffset) {\n+      log.info(s\"initial fetch for $groupId $topic $partition $offset\")\n+      buffer = ju.Collections.emptyList[ConsumerRecord[K, V]]().iterator\n+      seek(offset)\n+      poll(timeout)\n+    }\n+\n+    if (!buffer.hasNext()) { poll(timeout) }\n+    assert(buffer.hasNext(),\n+      s\"failed to get records for $groupId $topic $partition $offset after polling for $timeout\")\n+    var record = buffer.next()\n+\n+    if (record.offset != offset) {"
  }],
  "prId": 11863
}]