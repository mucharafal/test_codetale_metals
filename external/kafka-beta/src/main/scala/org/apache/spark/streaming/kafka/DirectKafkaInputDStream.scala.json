[{
  "comments": [{
    "author": {
      "login": "markgrover"
    },
    "body": "Again unrelated, but pretty out of date scaladoc.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-15T23:49:41Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>."
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "markgrover"
    },
    "body": "I think this means that DirectKafkaInputDStream::checkpoint() also isn't supported.\n\nJust by a quick look at the code, I haven't figured out just yet the relationship between ssc.checkpoint() and dstream.checkpoint(). But, does that mean that users can't call ssc.checkpoint() when using the new consumer based DirectKafkaInputDStream?\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-15T23:59:10Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "The point here is that calling checkpoint directly on a stream or rdd of records that arent serializable doesn't make sense.\n\nMy kafka-exactly-once repo of examples has a job that uses ssc.checkpoint, and so do the unit tests.  They still seem to work.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-18T16:24:13Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {"
  }, {
    "author": {
      "login": "markgrover"
    },
    "body": "That sounds good then.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-19T23:10:10Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "markgrover"
    },
    "body": "We should make this distinct from the older implementation.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-16T00:17:05Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka direct stream [$id]\""
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "eallain-poctu"
    },
    "body": "commitAll call is located in KafkaRDD creation and perform async commit as described.\nDoes it mean that offsets commited at this point concern the previous Kafka RDD ?\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-20T12:47:55Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "commitAll is defined lower in this same file, and simply drains the queue of whatever offsets have been provided by the user via commitAsync.\n\nAs the name implies, commitAsync doesn't give you any particular timing guarantees, but you can't really get transactional commits into Kafka in any case.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-20T14:27:46Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()"
  }, {
    "author": {
      "login": "eallain-poctu"
    },
    "body": "I see. If it's asynchrone, does it mean that checkpointed offset and committed offset in kafka are desynchonized ?\nIt would mean that we can restart the stream whether from the checkpoint or from the commited kafka offset  as long as we are idempotent ?\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-04-20T15:21:30Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "I personally wouldn't want to use both checkpoints and kafka committed offsets, but I suppose you could do that.  Yes, in any case, you need idempotence.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T02:52:25Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Hi @koeninger , why we are changing to use `ju.Map[String, Object]` instead of `Map[String, String]` like previous code? From my understanding it still doesn't simplify the code. Also type `Object`may be hard for Python code to communicate through py4j.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T01:16:06Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "The underlying consumer uses java maps.  Given that you need to set up the driver-side consumer using that map, it's a lot easier for the configuration of the executor-side consumer to use the same kind of map.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T02:46:16Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "Yes, I understaood Kafka `Consumer` requires such parameter, but it is not quite api friendly if want to support python through py4j. Maybe we can have a wrapper of python API.\n\nAlso using `Object` in Scala API requires type conversion, may not be so convenient for user.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T02:57:17Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "Any python api would almost certainly need to be a wrapper anyway.  I think it's a little premature to get hung up on ju.Map without seeing how it actually plays out in a python wrapper.  If you want to work on one, go for it.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T03:11:06Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Will this code take care of partition rebalance? From my understanding it will. \n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T01:42:37Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "If by partition rebalance you mean adding partitions, only if the driver side consumer was set up with a dynamic partition assignment.  If it's fixed assignment, then it's fixed assignment.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T02:47:12Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "@koeninger , so from user side, how to use this `commitAsync`? Also from my understanding,  since here use asynchronous committing, so we still cannot guarantee anything?\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T02:22:22Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()\n+    Some(rdd)\n+  }\n+\n+  override def start(): Unit = {\n+    val c = consumer\n+    c.poll(0)\n+    if (currentOffsets.isEmpty) {\n+      currentOffsets = c.assignment().asScala.map { tp =>\n+        tp -> c.position(tp)\n+      }.toMap\n+    }\n+\n+    // don't actually want to consume any messages, so pause all partitions\n+    currentOffsets.keySet.foreach(tp => c.pause(tp))\n+  }\n+\n+  override def stop(): Unit = this.synchronized {\n+    if (kc != null) {\n+      kc.close()\n+    }\n+  }\n+\n+  protected val commitQueue = new ConcurrentLinkedQueue[OffsetRange]\n+  protected val commitCallback = new AtomicReference[OffsetCommitCallback]\n+\n+  /**\n+   * Queue up offset ranges for commit to Kafka at a future time.  Threadsafe.\n+   * @param offsetRanges The maximum untilOffset for a given partition will be used at commit.\n+   */\n+  def commitAsync(offsetRanges: Array[OffsetRange]): Unit = {"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "There's an example of using commitAsync in the tests.  As far as guarantees, the thing is, using kafka to store offset commits isn't transactional anyways.  You'd still need to be able to handle reprocessing messages even if it was a blocking commit.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T02:51:06Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()\n+    Some(rdd)\n+  }\n+\n+  override def start(): Unit = {\n+    val c = consumer\n+    c.poll(0)\n+    if (currentOffsets.isEmpty) {\n+      currentOffsets = c.assignment().asScala.map { tp =>\n+        tp -> c.position(tp)\n+      }.toMap\n+    }\n+\n+    // don't actually want to consume any messages, so pause all partitions\n+    currentOffsets.keySet.foreach(tp => c.pause(tp))\n+  }\n+\n+  override def stop(): Unit = this.synchronized {\n+    if (kc != null) {\n+      kc.close()\n+    }\n+  }\n+\n+  protected val commitQueue = new ConcurrentLinkedQueue[OffsetRange]\n+  protected val commitCallback = new AtomicReference[OffsetCommitCallback]\n+\n+  /**\n+   * Queue up offset ranges for commit to Kafka at a future time.  Threadsafe.\n+   * @param offsetRanges The maximum untilOffset for a given partition will be used at commit.\n+   */\n+  def commitAsync(offsetRanges: Array[OffsetRange]): Unit = {"
  }],
  "prId": 11863
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Here will throw NPE if `preferredHosts` is null, this will be happened when we choose `preferBrokers` for this parameter.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T06:20:43Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()\n+    Some(rdd)\n+  }\n+\n+  override def start(): Unit = {\n+    val c = consumer\n+    c.poll(0)\n+    if (currentOffsets.isEmpty) {\n+      currentOffsets = c.assignment().asScala.map { tp =>\n+        tp -> c.position(tp)\n+      }.toMap\n+    }\n+\n+    // don't actually want to consume any messages, so pause all partitions\n+    currentOffsets.keySet.foreach(tp => c.pause(tp))\n+  }\n+\n+  override def stop(): Unit = this.synchronized {\n+    if (kc != null) {\n+      kc.close()\n+    }\n+  }\n+\n+  protected val commitQueue = new ConcurrentLinkedQueue[OffsetRange]\n+  protected val commitCallback = new AtomicReference[OffsetCommitCallback]\n+\n+  /**\n+   * Queue up offset ranges for commit to Kafka at a future time.  Threadsafe.\n+   * @param offsetRanges The maximum untilOffset for a given partition will be used at commit.\n+   */\n+  def commitAsync(offsetRanges: Array[OffsetRange]): Unit = {\n+    commitAsync(offsetRanges, null)\n+  }\n+\n+  /**\n+   * Queue up offset ranges for commit to Kafka at a future time.  Threadsafe.\n+   * @param offsetRanges The maximum untilOffset for a given partition will be used at commit.\n+   * @param callback Only the most recently provided callback will be used at commit.\n+   */\n+  def commitAsync(offsetRanges: Array[OffsetRange], callback: OffsetCommitCallback): Unit = {\n+    commitCallback.set(callback)\n+    commitQueue.addAll(ju.Arrays.asList(offsetRanges: _*))\n+  }\n+\n+  protected def commitAll(): Unit = {\n+    val m = new ju.HashMap[TopicPartition, OffsetAndMetadata]()\n+    val it = commitQueue.iterator()\n+    while (it.hasNext) {\n+      val osr = it.next\n+      val tp = osr.topicPartition\n+      val x = m.get(tp)\n+      val offset = if (null == x) { osr.untilOffset } else { Math.max(x.offset, osr.untilOffset) }\n+      m.put(tp, new OffsetAndMetadata(offset))\n+    }\n+    if (!m.isEmpty) {\n+      consumer.commitAsync(m, commitCallback.get)\n+    }\n+  }\n+\n+  private[streaming]\n+  class DirectKafkaInputDStreamCheckpointData extends DStreamCheckpointData(this) {\n+    def batchForTime: mutable.HashMap[Time, Array[(String, Int, Long, Long)]] = {\n+      data.asInstanceOf[mutable.HashMap[Time, Array[OffsetRange.OffsetRangeTuple]]]\n+    }\n+\n+    override def update(time: Time) {\n+      batchForTime.clear()\n+      generatedRDDs.foreach { kv =>\n+        val a = kv._2.asInstanceOf[KafkaRDD[K, V]].offsetRanges.map(_.toTuple).toArray\n+        batchForTime += kv._1 -> a\n+      }\n+    }\n+\n+    override def cleanup(time: Time) { }\n+\n+    override def restore() {\n+      batchForTime.toSeq.sortBy(_._1)(Time.ordering).foreach { case (t, b) =>\n+         logInfo(s\"Restoring KafkaRDD for time $t ${b.mkString(\"[\", \", \", \"]\")}\")\n+         generatedRDDs += t -> new KafkaRDD[K, V](\n+           context.sparkContext, executorKafkaParams, b.map(OffsetRange(_)), getPreferredHosts)\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A RateController to retrieve the rate from RateEstimator.\n+   */\n+  private[streaming] class DirectKafkaRateController(id: Int, estimator: RateEstimator)\n+    extends RateController(id, estimator) {\n+    override def publish(rate: Long): Unit = ()\n+  }\n+}\n+\n+object DirectKafkaInputDStream extends Logging {\n+  import org.apache.spark.streaming.api.java.{ JavaInputDStream, JavaStreamingContext }\n+  import org.apache.spark.api.java.function.{ Function0 => JFunction0 }\n+\n+  /** Prefer to run on kafka brokers, if they are on same hosts as executors */\n+  val preferBrokers: ju.Map[TopicPartition, String] = null\n+  /** Prefer a consistent executor per TopicPartition, evenly from all executors */\n+  val preferConsistent: ju.Map[TopicPartition, String] = ju.Collections.emptyMap()\n+\n+  /** Scala constructor */\n+  def apply[K: ClassTag, V: ClassTag](\n+      ssc: StreamingContext,\n+      preferredHosts: ju.Map[TopicPartition, String],\n+      executorKafkaParams: ju.Map[String, Object],\n+      driverConsumer: () => Consumer[K, V]\n+    ): DirectKafkaInputDStream[K, V] = {\n+    val ph = new ju.HashMap[TopicPartition, String](preferredHosts)"
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "Good catch, will fix this shortly.\n",
    "commit": "cffb0e0fb89808732c3ab3c1c7d83049549e2e2d",
    "createdAt": "2016-05-06T14:24:39Z",
    "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka\n+\n+import java.{ util => ju }\n+import java.util.concurrent.ConcurrentLinkedQueue\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+import scala.reflect.ClassTag\n+\n+import org.apache.kafka.clients.consumer._\n+import org.apache.kafka.common.{ PartitionInfo, TopicPartition }\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.StorageLevel\n+import org.apache.spark.streaming.{StreamingContext, Time}\n+import org.apache.spark.streaming.dstream._\n+import org.apache.spark.streaming.scheduler.{RateController, StreamInputInfo}\n+import org.apache.spark.streaming.scheduler.rate.RateEstimator\n+\n+/**\n+ *  A stream of {@link org.apache.spark.streaming.kafka.KafkaRDD} where\n+ * each given Kafka topic/partition corresponds to an RDD partition.\n+ * The spark configuration spark.streaming.kafka.maxRatePerPartition gives the maximum number\n+ *  of messages\n+ * per second that each '''partition''' will accept.\n+ * Starting offsets are specified in advance,\n+ * and this DStream is not responsible for committing offsets,\n+ * so that you can control exactly-once semantics.\n+ * @param kafkaParams Kafka <a href=\"http://kafka.apache.org/documentation.html#newconsumerconfigs\">\n+ * configuration parameters</a>.\n+ *   Requires  \"bootstrap.servers\" to be set with Kafka broker(s),\n+ *   NOT zookeeper servers, specified in host1:port1,host2:port2 form.\n+ */\n+\n+class DirectKafkaInputDStream[K: ClassTag, V: ClassTag] private[spark] (\n+    _ssc: StreamingContext,\n+    preferredHosts: ju.Map[TopicPartition, String],\n+    executorKafkaParams: ju.Map[String, Object],\n+    driverConsumer: () => Consumer[K, V]\n+  ) extends InputDStream[ConsumerRecord[K, V]](_ssc) with Logging {\n+\n+  @transient private var kc: Consumer[K, V] = null\n+  def consumer(): Consumer[K, V] = this.synchronized {\n+    if (null == kc) {\n+      kc = driverConsumer()\n+    }\n+    kc\n+  }\n+  consumer()\n+\n+  override def persist(newLevel: StorageLevel): DStream[ConsumerRecord[K, V]] = {\n+    log.error(\"Kafka ConsumerRecord is not serializable. \" +\n+      \"Use .map to extract fields before calling .persist or .window\")\n+    super.persist(newLevel)\n+  }\n+\n+  protected def getBrokers = {\n+    val c = consumer\n+    val result = new ju.HashMap[TopicPartition, String]()\n+    val hosts = new ju.HashMap[TopicPartition, String]()\n+    val assignments = c.assignment().iterator()\n+    while (assignments.hasNext()) {\n+      val tp: TopicPartition = assignments.next()\n+      if (null == hosts.get(tp)) {\n+        val infos = c.partitionsFor(tp.topic).iterator()\n+        while (infos.hasNext()) {\n+          val i = infos.next()\n+          hosts.put(new TopicPartition(i.topic(), i.partition()), i.leader.host())\n+        }\n+      }\n+      result.put(tp, hosts.get(tp))\n+    }\n+    result\n+  }\n+\n+  protected def getPreferredHosts: ju.Map[TopicPartition, String] = {\n+    if (preferredHosts == DirectKafkaInputDStream.preferBrokers) {\n+      getBrokers\n+    } else {\n+      preferredHosts\n+    }\n+  }\n+\n+  // Keep this consistent with how other streams are named (e.g. \"Flume polling stream [2]\")\n+  private[streaming] override def name: String = s\"Kafka beta direct stream [$id]\"\n+\n+  protected[streaming] override val checkpointData =\n+    new DirectKafkaInputDStreamCheckpointData\n+\n+\n+  /**\n+   * Asynchronously maintains & sends new rate limits to the receiver through the receiver tracker.\n+   */\n+  override protected[streaming] val rateController: Option[RateController] = {\n+    if (RateController.isBackPressureEnabled(ssc.conf)) {\n+      Some(new DirectKafkaRateController(id,\n+        RateEstimator.create(ssc.conf, context.graph.batchDuration)))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private val maxRateLimitPerPartition: Int = context.sparkContext.getConf.getInt(\n+    \"spark.streaming.kafka.maxRatePerPartition\", 0)\n+\n+  protected[streaming] def maxMessagesPerPartition(\n+    offsets: Map[TopicPartition, Long]): Option[Map[TopicPartition, Long]] = {\n+    val estimatedRateLimit = rateController.map(_.getLatestRate().toInt)\n+\n+    // calculate a per-partition rate limit based on current lag\n+    val effectiveRateLimitPerPartition = estimatedRateLimit.filter(_ > 0) match {\n+      case Some(rate) =>\n+        val lagPerPartition = offsets.map { case (tp, offset) =>\n+          tp -> Math.max(offset - currentOffsets(tp), 0)\n+        }\n+        val totalLag = lagPerPartition.values.sum\n+\n+        lagPerPartition.map { case (tp, lag) =>\n+          val backpressureRate = Math.round(lag / totalLag.toFloat * rate)\n+          tp -> (if (maxRateLimitPerPartition > 0) {\n+            Math.min(backpressureRate, maxRateLimitPerPartition)} else backpressureRate)\n+        }\n+      case None => offsets.map { case (tp, offset) => tp -> maxRateLimitPerPartition }\n+    }\n+\n+    if (effectiveRateLimitPerPartition.values.sum > 0) {\n+      val secsPerBatch = context.graph.batchDuration.milliseconds.toDouble / 1000\n+      Some(effectiveRateLimitPerPartition.map {\n+        case (tp, limit) => tp -> (secsPerBatch * limit).toLong\n+      })\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected var currentOffsets = Map[TopicPartition, Long]()\n+\n+  protected def latestOffsets(): Map[TopicPartition, Long] = {\n+    val c = consumer\n+    c.poll(0)\n+    val parts = c.assignment().asScala\n+\n+    // make sure new partitions are reflected in currentOffsets\n+    val newPartitions = parts.diff(currentOffsets.keySet)\n+    currentOffsets = currentOffsets ++ newPartitions.map(tp => tp -> c.position(tp)).toMap\n+    newPartitions.foreach(tp => c.pause(tp))\n+\n+    c.seekToEnd()\n+    parts.map(tp => tp -> c.position(tp)).toMap\n+  }\n+\n+  // limits the maximum number of messages per partition\n+  protected def clamp(\n+    offsets: Map[TopicPartition, Long]): Map[TopicPartition, Long] = {\n+\n+    maxMessagesPerPartition(offsets).map { mmp =>\n+      mmp.map { case (tp, messages) =>\n+          val uo = offsets(tp)\n+          tp -> Math.min(currentOffsets(tp) + messages, uo)\n+      }\n+    }.getOrElse(offsets)\n+  }\n+\n+  override def compute(validTime: Time): Option[KafkaRDD[K, V]] = {\n+    val untilOffsets = clamp(latestOffsets())\n+    val offsetRanges = untilOffsets.map { case (tp, uo) =>\n+      val fo = currentOffsets(tp)\n+      OffsetRange(tp.topic, tp.partition, fo, uo)\n+    }\n+    val rdd = new KafkaRDD[K, V](\n+      context.sparkContext, executorKafkaParams, offsetRanges.toArray, getPreferredHosts)\n+\n+    // Report the record number and metadata of this batch interval to InputInfoTracker.\n+    val description = offsetRanges.filter { offsetRange =>\n+      // Don't display empty ranges.\n+      offsetRange.fromOffset != offsetRange.untilOffset\n+    }.map { offsetRange =>\n+      s\"topic: ${offsetRange.topic}\\tpartition: ${offsetRange.partition}\\t\" +\n+        s\"offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}\"\n+    }.mkString(\"\\n\")\n+    // Copy offsetRanges to immutable.List to prevent from being modified by the user\n+    val metadata = Map(\n+      \"offsets\" -> offsetRanges.toList,\n+      StreamInputInfo.METADATA_KEY_DESCRIPTION -> description)\n+    val inputInfo = StreamInputInfo(id, rdd.count, metadata)\n+    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)\n+\n+    currentOffsets = untilOffsets\n+    commitAll()\n+    Some(rdd)\n+  }\n+\n+  override def start(): Unit = {\n+    val c = consumer\n+    c.poll(0)\n+    if (currentOffsets.isEmpty) {\n+      currentOffsets = c.assignment().asScala.map { tp =>\n+        tp -> c.position(tp)\n+      }.toMap\n+    }\n+\n+    // don't actually want to consume any messages, so pause all partitions\n+    currentOffsets.keySet.foreach(tp => c.pause(tp))\n+  }\n+\n+  override def stop(): Unit = this.synchronized {\n+    if (kc != null) {\n+      kc.close()\n+    }\n+  }\n+\n+  protected val commitQueue = new ConcurrentLinkedQueue[OffsetRange]\n+  protected val commitCallback = new AtomicReference[OffsetCommitCallback]\n+\n+  /**\n+   * Queue up offset ranges for commit to Kafka at a future time.  Threadsafe.\n+   * @param offsetRanges The maximum untilOffset for a given partition will be used at commit.\n+   */\n+  def commitAsync(offsetRanges: Array[OffsetRange]): Unit = {\n+    commitAsync(offsetRanges, null)\n+  }\n+\n+  /**\n+   * Queue up offset ranges for commit to Kafka at a future time.  Threadsafe.\n+   * @param offsetRanges The maximum untilOffset for a given partition will be used at commit.\n+   * @param callback Only the most recently provided callback will be used at commit.\n+   */\n+  def commitAsync(offsetRanges: Array[OffsetRange], callback: OffsetCommitCallback): Unit = {\n+    commitCallback.set(callback)\n+    commitQueue.addAll(ju.Arrays.asList(offsetRanges: _*))\n+  }\n+\n+  protected def commitAll(): Unit = {\n+    val m = new ju.HashMap[TopicPartition, OffsetAndMetadata]()\n+    val it = commitQueue.iterator()\n+    while (it.hasNext) {\n+      val osr = it.next\n+      val tp = osr.topicPartition\n+      val x = m.get(tp)\n+      val offset = if (null == x) { osr.untilOffset } else { Math.max(x.offset, osr.untilOffset) }\n+      m.put(tp, new OffsetAndMetadata(offset))\n+    }\n+    if (!m.isEmpty) {\n+      consumer.commitAsync(m, commitCallback.get)\n+    }\n+  }\n+\n+  private[streaming]\n+  class DirectKafkaInputDStreamCheckpointData extends DStreamCheckpointData(this) {\n+    def batchForTime: mutable.HashMap[Time, Array[(String, Int, Long, Long)]] = {\n+      data.asInstanceOf[mutable.HashMap[Time, Array[OffsetRange.OffsetRangeTuple]]]\n+    }\n+\n+    override def update(time: Time) {\n+      batchForTime.clear()\n+      generatedRDDs.foreach { kv =>\n+        val a = kv._2.asInstanceOf[KafkaRDD[K, V]].offsetRanges.map(_.toTuple).toArray\n+        batchForTime += kv._1 -> a\n+      }\n+    }\n+\n+    override def cleanup(time: Time) { }\n+\n+    override def restore() {\n+      batchForTime.toSeq.sortBy(_._1)(Time.ordering).foreach { case (t, b) =>\n+         logInfo(s\"Restoring KafkaRDD for time $t ${b.mkString(\"[\", \", \", \"]\")}\")\n+         generatedRDDs += t -> new KafkaRDD[K, V](\n+           context.sparkContext, executorKafkaParams, b.map(OffsetRange(_)), getPreferredHosts)\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A RateController to retrieve the rate from RateEstimator.\n+   */\n+  private[streaming] class DirectKafkaRateController(id: Int, estimator: RateEstimator)\n+    extends RateController(id, estimator) {\n+    override def publish(rate: Long): Unit = ()\n+  }\n+}\n+\n+object DirectKafkaInputDStream extends Logging {\n+  import org.apache.spark.streaming.api.java.{ JavaInputDStream, JavaStreamingContext }\n+  import org.apache.spark.api.java.function.{ Function0 => JFunction0 }\n+\n+  /** Prefer to run on kafka brokers, if they are on same hosts as executors */\n+  val preferBrokers: ju.Map[TopicPartition, String] = null\n+  /** Prefer a consistent executor per TopicPartition, evenly from all executors */\n+  val preferConsistent: ju.Map[TopicPartition, String] = ju.Collections.emptyMap()\n+\n+  /** Scala constructor */\n+  def apply[K: ClassTag, V: ClassTag](\n+      ssc: StreamingContext,\n+      preferredHosts: ju.Map[TopicPartition, String],\n+      executorKafkaParams: ju.Map[String, Object],\n+      driverConsumer: () => Consumer[K, V]\n+    ): DirectKafkaInputDStream[K, V] = {\n+    val ph = new ju.HashMap[TopicPartition, String](preferredHosts)"
  }],
  "prId": 11863
}]