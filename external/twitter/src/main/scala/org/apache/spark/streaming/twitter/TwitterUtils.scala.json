[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This looks like a big hack. Just use different method names if you are trying to avoid type conflict after erasure.\n",
    "commit": "eecd364fc816a783cf26a99d47308a3792474176",
    "createdAt": "2014-12-30T09:58:53Z",
    "diffHunk": "@@ -25,6 +25,91 @@ import org.apache.spark.streaming.api.java.{JavaReceiverInputDStream, JavaDStrea\n import org.apache.spark.streaming.dstream.{ReceiverInputDStream, DStream}\n \n object TwitterUtils {\n+\n+  // For implicit parameter used to avoid to have same type after erasure\n+  case class Ignore(value: String ) {"
  }],
  "prId": 3246
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "There are _12_ new overloads of `createStream` on top of the existing 4. This seems like big overkill. There should be one version in Java/Scala that takes all arguments, one each that takes minimal arguments, and any others needed to retain binary compatibility. The rest seem superfluous.\n",
    "commit": "eecd364fc816a783cf26a99d47308a3792474176",
    "createdAt": "2014-12-30T10:03:17Z",
    "diffHunk": "@@ -112,20 +269,91 @@ object TwitterUtils {\n     ): JavaReceiverInputDStream[Status] = {\n     createStream(jssc.ssc, Some(twitterAuth), filters)\n   }\n-\n+ \n+  /**\n+   * Create a input stream that returns tweets received from Twitter.\n+   * Storage level of the data will be the default StorageLevel.MEMORY_AND_DISK_SER_2.\n+   * @param jssc        JavaStreamingContext object\n+   * @param twitterAuth Twitter4J Authorization\n+   * @param filters     Set of filter strings to get only those tweets that match them\n+   * @param locations Set of longitude, latitude pairs to get only those tweets\n+   *        that falling within the requested bounding boxes\n+   */\n+  def createStream(\n+      jssc: JavaStreamingContext,\n+      twitterAuth: Authorization,\n+      filters: Array[String],\n+      locations: Array[Array[Double]]\n+    ): JavaReceiverInputDStream[Status] = {\n+    createStream(jssc.ssc, Some(twitterAuth), filters, locations.map(_.toSeq).toSeq)\n+  }\n+ \n+  /**\n+   * Create a input stream that returns tweets received from Twitter.\n+   * Storage level of the data will be the default StorageLevel.MEMORY_AND_DISK_SER_2.\n+   * @param jssc        JavaStreamingContext object\n+   * @param twitterAuth Twitter4J Authorization\n+   * @param locations Set of longitude, latitude pairs to get only those tweets\n+   *        that falling within the requested bounding boxes\n+   */\n+  def createStream(\n+      jssc: JavaStreamingContext,\n+      twitterAuth: Authorization,\n+      locations: Array[Array[Double]]\n+    ): JavaReceiverInputDStream[Status] = {\n+    createStream(jssc.ssc, Some(twitterAuth), Nil, locations.map(_.toSeq).toSeq)\n+  }\n+ \n+  /**\n+   * Create a input stream that returns tweets received from Twitter.\n+   * @param jssc         JavaStreamingContext object\n+   * @param twitterAuth  Twitter4J Authorization object\n+   * @param filters      Set of filter strings to get only those tweets that match them\n+   * @param storageLevel Storage level to use for storing the received objects\n+   */\n+  def createStream(\n+      jssc: JavaStreamingContext,\n+      twitterAuth: Authorization,\n+      filters: Array[String],\n+      storageLevel: StorageLevel\n+    ): JavaReceiverInputDStream[Status] = {\n+    createStream(jssc.ssc, Some(twitterAuth), filters, Nil, storageLevel)\n+  }\n+ \n   /**\n    * Create a input stream that returns tweets received from Twitter.\n    * @param jssc         JavaStreamingContext object\n    * @param twitterAuth  Twitter4J Authorization object\n    * @param filters      Set of filter strings to get only those tweets that match them\n+   * @param locations Set of longitude, latitude pairs to get only those tweets\n+   *        that falling within the requested bounding boxes\n    * @param storageLevel Storage level to use for storing the received objects\n    */\n   def createStream(\n       jssc: JavaStreamingContext,\n       twitterAuth: Authorization,\n       filters: Array[String],\n+      locations: Array[Array[Double]],\n+      storageLevel: StorageLevel\n+    ): JavaReceiverInputDStream[Status] = {\n+    createStream(jssc.ssc, Some(twitterAuth), filters, locations.map(_.toSeq).toSeq, storageLevel)\n+  }\n+ \n+  /**\n+   * Create a input stream that returns tweets received from Twitter.\n+   * @param jssc         JavaStreamingContext object\n+   * @param twitterAuth  Twitter4J Authorization object\n+   * @param locations Set of longitude, latitude pairs to get only those tweets\n+   *        that falling within the requested bounding boxes\n+   * @param storageLevel Storage level to use for storing the received objects\n+   */\n+  def createStream("
  }],
  "prId": 3246
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "There's a couple spurious changes adding whitespace at the ends of lines. Not really worth fixing for its own sake but check the diff to see if you can fix it if you make another commit.\n",
    "commit": "eecd364fc816a783cf26a99d47308a3792474176",
    "createdAt": "2015-01-22T16:35:12Z",
    "diffHunk": "@@ -53,7 +67,7 @@ object TwitterUtils {\n    * @param jssc   JavaStreamingContext object\n    */\n   def createStream(jssc: JavaStreamingContext): JavaReceiverInputDStream[Status] = {\n-    createStream(jssc.ssc, None)\n+    createStream(jssc.ssc, None) "
  }],
  "prId": 3246
}]