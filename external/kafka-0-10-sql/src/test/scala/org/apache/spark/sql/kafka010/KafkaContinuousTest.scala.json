[{
  "comments": [{
    "author": {
      "login": "jose-torres"
    },
    "body": "I think this logic is subtly incorrect (and what's causing the flakiness in the continuous test). It needs to get the actual scan config being used from DataSourceV2ScanExec in the physical plan; r.scanConfigBuilder.build() will always produce the most up-to-date `knownPartitions` value, where what we want is the value that `lastExecution` was run with. In the prior iteration of the API this wasn't an issue because `KafkaContinuousReader` would precompute knownPartitions.",
    "commit": "51cda76897353344427aaa666e29be408263eeb1",
    "createdAt": "2018-08-21T19:58:58Z",
    "diffHunk": "@@ -47,7 +47,9 @@ trait KafkaContinuousTest extends KafkaSourceTest {\n     eventually(timeout(streamingTimeout)) {\n       assert(\n         query.lastExecution.logical.collectFirst {\n-          case StreamingDataSourceV2Relation(_, _, _, r: KafkaContinuousReader) => r\n+          case r: StreamingDataSourceV2Relation\n+              if r.readSupport.isInstanceOf[KafkaContinuousReadSupport] =>\n+            r.scanConfigBuilder.build().asInstanceOf[KafkaContinuousScanConfig]"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "good catch!",
    "commit": "51cda76897353344427aaa666e29be408263eeb1",
    "createdAt": "2018-08-22T01:45:48Z",
    "diffHunk": "@@ -47,7 +47,9 @@ trait KafkaContinuousTest extends KafkaSourceTest {\n     eventually(timeout(streamingTimeout)) {\n       assert(\n         query.lastExecution.logical.collectFirst {\n-          case StreamingDataSourceV2Relation(_, _, _, r: KafkaContinuousReader) => r\n+          case r: StreamingDataSourceV2Relation\n+              if r.readSupport.isInstanceOf[KafkaContinuousReadSupport] =>\n+            r.scanConfigBuilder.build().asInstanceOf[KafkaContinuousScanConfig]"
  }],
  "prId": 22009
}]