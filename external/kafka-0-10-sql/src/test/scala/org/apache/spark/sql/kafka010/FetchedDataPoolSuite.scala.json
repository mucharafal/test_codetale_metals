[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I think you need to release some item at a different time so that the timer only evicts certain idle items, but not all. That would trigger the bug that I mentioned before in your code.\r\n\r\nBut that's probably a little complicated since your test is relying on the actual eviction thread running, instead of using a manual clock and manually running the eviction process...",
    "commit": "68af3d56710e21b4b8a9a1640ededb3eb7d3117b",
    "createdAt": "2019-08-26T18:53:48Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord\n+import org.apache.kafka.common.TopicPartition\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.sql.kafka010.KafkaDataConsumer.CacheKey\n+import org.apache.spark.sql.test.SharedSparkSession\n+\n+class FetchedDataPoolSuite extends SharedSparkSession with PrivateMethodTester {\n+  import FetchedDataPool._\n+  type Record = ConsumerRecord[Array[Byte], Array[Byte]]\n+\n+  private val dummyBytes = \"dummy\".getBytes\n+\n+  // Helper private method accessors for FetchedDataPool\n+  private type PoolCacheType = mutable.Map[CacheKey, CachedFetchedDataList]\n+  private val _cache = PrivateMethod[PoolCacheType]('cache)\n+\n+  def getCache(pool: FetchedDataPool): PoolCacheType = {\n+    pool.invokePrivate(_cache())\n+  }\n+\n+  test(\"acquire fresh one\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    dataPool.release(cacheKey, data)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"acquire fetched data from multiple keys\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKeys = (0 until 10).map { partId =>\n+      CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+    }\n+\n+    assert(getCache(dataPool).size === 0)\n+    cacheKeys.foreach { key => assert(getCache(dataPool).get(key).isEmpty) }\n+\n+    val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+    dataList.map { case (_, data) =>\n+      data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+    }\n+\n+    dataList.foreach { case (key, data) =>\n+      dataPool.release(key, data)\n+    }\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(!getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"continuous use of fetched data from single key\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => data.next() }\n+\n+    dataPool.release(cacheKey, data)\n+\n+    // suppose next batch\n+\n+    val data2 = dataPool.acquire(cacheKey, data.nextOffsetInFetchedData)\n+\n+    assert(data.eq(data2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.release(cacheKey, data2)\n+\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"multiple tasks referring same key continuously using fetched data\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val dataFromTask1 = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    val dataFromTask2 = dataPool.acquire(cacheKey, 0)\n+\n+    // it shouldn't give same object as dataFromTask1 though it asks same offset\n+    // it definitely works when offsets are not overlapped: skip adding test for that\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).size === 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // reading from task 1\n+    dataFromTask1.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => dataFromTask1.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask1)\n+\n+    // reading from task 2\n+    dataFromTask2.withNewPoll(testRecords(0, 30).listIterator, 30)\n+\n+    (0 to 5).foreach { _ => dataFromTask2.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask2)\n+\n+    // suppose next batch for task 1\n+    val data2FromTask1 = dataPool.acquire(cacheKey, dataFromTask1.nextOffsetInFetchedData)\n+    assert(data2FromTask1.eq(dataFromTask1))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    // suppose next batch for task 2\n+    val data2FromTask2 = dataPool.acquire(cacheKey, dataFromTask2.nextOffsetInFetchedData)\n+    assert(data2FromTask2.eq(dataFromTask2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 2\n+    dataPool.release(cacheKey, data2FromTask2)\n+    assert(!getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 1\n+    dataPool.release(cacheKey, data2FromTask1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"evict idle fetched data\") {\n+    import FetchedDataPool._\n+    import org.scalatest.time.SpanSugar._\n+\n+    val minEvictableIdleTimeMillis = 1000\n+    val evictorThreadRunIntervalMillis = 500\n+\n+    val newConf = Seq(\n+      CONFIG_NAME_MIN_EVICTABLE_IDLE_TIME_MILLIS -> minEvictableIdleTimeMillis.toString,\n+      CONFIG_NAME_EVICTOR_THREAD_RUN_INTERVAL_MILLIS -> evictorThreadRunIntervalMillis.toString)\n+\n+    withSparkConf(newConf: _*) {\n+      val dataPool = FetchedDataPool.build\n+\n+      val cacheKeys = (0 until 10).map { partId =>\n+        CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+      }\n+\n+      val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+      assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+      dataList.map { case (_, data) =>\n+        data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+      }\n+\n+      val dataToEvict = dataList.take(3)\n+      dataToEvict.foreach { case (key, data) =>"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Yeah I see the point. Maybe I considered similar one but given commons pool just relies on ScheduledThreadPoolExecutor for evictor thread which doesn't seem to deal with manual clock, I might gave up at that time.\r\n\r\nGiven pool allows calling evict directly, I'll try to add the test which doesn't rely on eviction thread (though it still relies on wall-time as we've got time from System).",
    "commit": "68af3d56710e21b4b8a9a1640ededb3eb7d3117b",
    "createdAt": "2019-08-26T20:22:25Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord\n+import org.apache.kafka.common.TopicPartition\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.sql.kafka010.KafkaDataConsumer.CacheKey\n+import org.apache.spark.sql.test.SharedSparkSession\n+\n+class FetchedDataPoolSuite extends SharedSparkSession with PrivateMethodTester {\n+  import FetchedDataPool._\n+  type Record = ConsumerRecord[Array[Byte], Array[Byte]]\n+\n+  private val dummyBytes = \"dummy\".getBytes\n+\n+  // Helper private method accessors for FetchedDataPool\n+  private type PoolCacheType = mutable.Map[CacheKey, CachedFetchedDataList]\n+  private val _cache = PrivateMethod[PoolCacheType]('cache)\n+\n+  def getCache(pool: FetchedDataPool): PoolCacheType = {\n+    pool.invokePrivate(_cache())\n+  }\n+\n+  test(\"acquire fresh one\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    dataPool.release(cacheKey, data)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"acquire fetched data from multiple keys\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKeys = (0 until 10).map { partId =>\n+      CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+    }\n+\n+    assert(getCache(dataPool).size === 0)\n+    cacheKeys.foreach { key => assert(getCache(dataPool).get(key).isEmpty) }\n+\n+    val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+    dataList.map { case (_, data) =>\n+      data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+    }\n+\n+    dataList.foreach { case (key, data) =>\n+      dataPool.release(key, data)\n+    }\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(!getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"continuous use of fetched data from single key\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => data.next() }\n+\n+    dataPool.release(cacheKey, data)\n+\n+    // suppose next batch\n+\n+    val data2 = dataPool.acquire(cacheKey, data.nextOffsetInFetchedData)\n+\n+    assert(data.eq(data2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.release(cacheKey, data2)\n+\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"multiple tasks referring same key continuously using fetched data\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val dataFromTask1 = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    val dataFromTask2 = dataPool.acquire(cacheKey, 0)\n+\n+    // it shouldn't give same object as dataFromTask1 though it asks same offset\n+    // it definitely works when offsets are not overlapped: skip adding test for that\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).size === 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // reading from task 1\n+    dataFromTask1.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => dataFromTask1.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask1)\n+\n+    // reading from task 2\n+    dataFromTask2.withNewPoll(testRecords(0, 30).listIterator, 30)\n+\n+    (0 to 5).foreach { _ => dataFromTask2.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask2)\n+\n+    // suppose next batch for task 1\n+    val data2FromTask1 = dataPool.acquire(cacheKey, dataFromTask1.nextOffsetInFetchedData)\n+    assert(data2FromTask1.eq(dataFromTask1))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    // suppose next batch for task 2\n+    val data2FromTask2 = dataPool.acquire(cacheKey, dataFromTask2.nextOffsetInFetchedData)\n+    assert(data2FromTask2.eq(dataFromTask2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 2\n+    dataPool.release(cacheKey, data2FromTask2)\n+    assert(!getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 1\n+    dataPool.release(cacheKey, data2FromTask1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"evict idle fetched data\") {\n+    import FetchedDataPool._\n+    import org.scalatest.time.SpanSugar._\n+\n+    val minEvictableIdleTimeMillis = 1000\n+    val evictorThreadRunIntervalMillis = 500\n+\n+    val newConf = Seq(\n+      CONFIG_NAME_MIN_EVICTABLE_IDLE_TIME_MILLIS -> minEvictableIdleTimeMillis.toString,\n+      CONFIG_NAME_EVICTOR_THREAD_RUN_INTERVAL_MILLIS -> evictorThreadRunIntervalMillis.toString)\n+\n+    withSparkConf(newConf: _*) {\n+      val dataPool = FetchedDataPool.build\n+\n+      val cacheKeys = (0 until 10).map { partId =>\n+        CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+      }\n+\n+      val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+      assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+      dataList.map { case (_, data) =>\n+        data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+      }\n+\n+      val dataToEvict = dataList.take(3)\n+      dataToEvict.foreach { case (key, data) =>"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Ah I realized I confused this with InternalKafkaConsumer. My bad. I'll try to see whether we can let FetchDataPool play with manual clock.",
    "commit": "68af3d56710e21b4b8a9a1640ededb3eb7d3117b",
    "createdAt": "2019-08-26T23:02:16Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord\n+import org.apache.kafka.common.TopicPartition\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.sql.kafka010.KafkaDataConsumer.CacheKey\n+import org.apache.spark.sql.test.SharedSparkSession\n+\n+class FetchedDataPoolSuite extends SharedSparkSession with PrivateMethodTester {\n+  import FetchedDataPool._\n+  type Record = ConsumerRecord[Array[Byte], Array[Byte]]\n+\n+  private val dummyBytes = \"dummy\".getBytes\n+\n+  // Helper private method accessors for FetchedDataPool\n+  private type PoolCacheType = mutable.Map[CacheKey, CachedFetchedDataList]\n+  private val _cache = PrivateMethod[PoolCacheType]('cache)\n+\n+  def getCache(pool: FetchedDataPool): PoolCacheType = {\n+    pool.invokePrivate(_cache())\n+  }\n+\n+  test(\"acquire fresh one\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    dataPool.release(cacheKey, data)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"acquire fetched data from multiple keys\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKeys = (0 until 10).map { partId =>\n+      CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+    }\n+\n+    assert(getCache(dataPool).size === 0)\n+    cacheKeys.foreach { key => assert(getCache(dataPool).get(key).isEmpty) }\n+\n+    val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+    dataList.map { case (_, data) =>\n+      data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+    }\n+\n+    dataList.foreach { case (key, data) =>\n+      dataPool.release(key, data)\n+    }\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(!getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"continuous use of fetched data from single key\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => data.next() }\n+\n+    dataPool.release(cacheKey, data)\n+\n+    // suppose next batch\n+\n+    val data2 = dataPool.acquire(cacheKey, data.nextOffsetInFetchedData)\n+\n+    assert(data.eq(data2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.release(cacheKey, data2)\n+\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"multiple tasks referring same key continuously using fetched data\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val dataFromTask1 = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    val dataFromTask2 = dataPool.acquire(cacheKey, 0)\n+\n+    // it shouldn't give same object as dataFromTask1 though it asks same offset\n+    // it definitely works when offsets are not overlapped: skip adding test for that\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).size === 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // reading from task 1\n+    dataFromTask1.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => dataFromTask1.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask1)\n+\n+    // reading from task 2\n+    dataFromTask2.withNewPoll(testRecords(0, 30).listIterator, 30)\n+\n+    (0 to 5).foreach { _ => dataFromTask2.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask2)\n+\n+    // suppose next batch for task 1\n+    val data2FromTask1 = dataPool.acquire(cacheKey, dataFromTask1.nextOffsetInFetchedData)\n+    assert(data2FromTask1.eq(dataFromTask1))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    // suppose next batch for task 2\n+    val data2FromTask2 = dataPool.acquire(cacheKey, dataFromTask2.nextOffsetInFetchedData)\n+    assert(data2FromTask2.eq(dataFromTask2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 2\n+    dataPool.release(cacheKey, data2FromTask2)\n+    assert(!getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 1\n+    dataPool.release(cacheKey, data2FromTask1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"evict idle fetched data\") {\n+    import FetchedDataPool._\n+    import org.scalatest.time.SpanSugar._\n+\n+    val minEvictableIdleTimeMillis = 1000\n+    val evictorThreadRunIntervalMillis = 500\n+\n+    val newConf = Seq(\n+      CONFIG_NAME_MIN_EVICTABLE_IDLE_TIME_MILLIS -> minEvictableIdleTimeMillis.toString,\n+      CONFIG_NAME_EVICTOR_THREAD_RUN_INTERVAL_MILLIS -> evictorThreadRunIntervalMillis.toString)\n+\n+    withSparkConf(newConf: _*) {\n+      val dataPool = FetchedDataPool.build\n+\n+      val cacheKeys = (0 until 10).map { partId =>\n+        CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+      }\n+\n+      val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+      assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+      dataList.map { case (_, data) =>\n+        data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+      }\n+\n+      val dataToEvict = dataList.take(3)\n+      dataToEvict.foreach { case (key, data) =>"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Addressed.",
    "commit": "68af3d56710e21b4b8a9a1640ededb3eb7d3117b",
    "createdAt": "2019-08-27T05:22:53Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord\n+import org.apache.kafka.common.TopicPartition\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.sql.kafka010.KafkaDataConsumer.CacheKey\n+import org.apache.spark.sql.test.SharedSparkSession\n+\n+class FetchedDataPoolSuite extends SharedSparkSession with PrivateMethodTester {\n+  import FetchedDataPool._\n+  type Record = ConsumerRecord[Array[Byte], Array[Byte]]\n+\n+  private val dummyBytes = \"dummy\".getBytes\n+\n+  // Helper private method accessors for FetchedDataPool\n+  private type PoolCacheType = mutable.Map[CacheKey, CachedFetchedDataList]\n+  private val _cache = PrivateMethod[PoolCacheType]('cache)\n+\n+  def getCache(pool: FetchedDataPool): PoolCacheType = {\n+    pool.invokePrivate(_cache())\n+  }\n+\n+  test(\"acquire fresh one\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    dataPool.release(cacheKey, data)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"acquire fetched data from multiple keys\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKeys = (0 until 10).map { partId =>\n+      CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+    }\n+\n+    assert(getCache(dataPool).size === 0)\n+    cacheKeys.foreach { key => assert(getCache(dataPool).get(key).isEmpty) }\n+\n+    val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+    dataList.map { case (_, data) =>\n+      data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+    }\n+\n+    dataList.foreach { case (key, data) =>\n+      dataPool.release(key, data)\n+    }\n+\n+    assert(getCache(dataPool).size === cacheKeys.size)\n+    cacheKeys.map { key =>\n+      assert(getCache(dataPool)(key).size === 1)\n+      assert(!getCache(dataPool)(key).head.inUse)\n+    }\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"continuous use of fetched data from single key\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val data = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => data.next() }\n+\n+    dataPool.release(cacheKey, data)\n+\n+    // suppose next batch\n+\n+    val data2 = dataPool.acquire(cacheKey, data.nextOffsetInFetchedData)\n+\n+    assert(data.eq(data2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.release(cacheKey, data2)\n+\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"multiple tasks referring same key continuously using fetched data\") {\n+    val dataPool = FetchedDataPool.build\n+\n+    val cacheKey = CacheKey(\"testgroup\", new TopicPartition(\"topic\", 0))\n+\n+    assert(getCache(dataPool).get(cacheKey).isEmpty)\n+\n+    val dataFromTask1 = dataPool.acquire(cacheKey, 0)\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 1, expectedNumTotal = 1)\n+    assert(getCache(dataPool)(cacheKey).size === 1)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    val dataFromTask2 = dataPool.acquire(cacheKey, 0)\n+\n+    // it shouldn't give same object as dataFromTask1 though it asks same offset\n+    // it definitely works when offsets are not overlapped: skip adding test for that\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).size === 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // reading from task 1\n+    dataFromTask1.withNewPoll(testRecords(0, 5).listIterator, 5)\n+\n+    (0 to 3).foreach { _ => dataFromTask1.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask1)\n+\n+    // reading from task 2\n+    dataFromTask2.withNewPoll(testRecords(0, 30).listIterator, 30)\n+\n+    (0 to 5).foreach { _ => dataFromTask2.next() }\n+\n+    dataPool.release(cacheKey, dataFromTask2)\n+\n+    // suppose next batch for task 1\n+    val data2FromTask1 = dataPool.acquire(cacheKey, dataFromTask1.nextOffsetInFetchedData)\n+    assert(data2FromTask1.eq(dataFromTask1))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey).head.inUse)\n+\n+    // suppose next batch for task 2\n+    val data2FromTask2 = dataPool.acquire(cacheKey, dataFromTask2.nextOffsetInFetchedData)\n+    assert(data2FromTask2.eq(dataFromTask2))\n+\n+    assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 2, expectedNumTotal = 2)\n+    assert(getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 2\n+    dataPool.release(cacheKey, data2FromTask2)\n+    assert(!getCache(dataPool)(cacheKey)(1).inUse)\n+\n+    // release from task 1\n+    dataPool.release(cacheKey, data2FromTask1)\n+    assert(!getCache(dataPool)(cacheKey).head.inUse)\n+\n+    dataPool.shutdown()\n+  }\n+\n+  test(\"evict idle fetched data\") {\n+    import FetchedDataPool._\n+    import org.scalatest.time.SpanSugar._\n+\n+    val minEvictableIdleTimeMillis = 1000\n+    val evictorThreadRunIntervalMillis = 500\n+\n+    val newConf = Seq(\n+      CONFIG_NAME_MIN_EVICTABLE_IDLE_TIME_MILLIS -> minEvictableIdleTimeMillis.toString,\n+      CONFIG_NAME_EVICTOR_THREAD_RUN_INTERVAL_MILLIS -> evictorThreadRunIntervalMillis.toString)\n+\n+    withSparkConf(newConf: _*) {\n+      val dataPool = FetchedDataPool.build\n+\n+      val cacheKeys = (0 until 10).map { partId =>\n+        CacheKey(\"testgroup\", new TopicPartition(\"topic\", partId))\n+      }\n+\n+      val dataList = cacheKeys.map(key => (key, dataPool.acquire(key, 0)))\n+\n+      assertFetchedDataPoolStatistic(dataPool, expectedNumCreated = 10, expectedNumTotal = 10)\n+\n+      dataList.map { case (_, data) =>\n+        data.withNewPoll(testRecords(0, 5).listIterator, 5)\n+      }\n+\n+      val dataToEvict = dataList.take(3)\n+      dataToEvict.foreach { case (key, data) =>"
  }],
  "prId": 22138
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Minor, but a lot of these tests look very similar and could probably be calls to a parameterized function. Seems the things that are changing are i. the number of `CacheKey` instances in the pool and ii. the number of times you use the cached entry for each `CacheKey`.\r\n\r\nSo if you have a `testCacheKey(pool, key)` method, you can just call it with the same pool multiple times and with different keys to test the different behaviors you're currently testing.",
    "commit": "68af3d56710e21b4b8a9a1640ededb3eb7d3117b",
    "createdAt": "2019-08-28T19:34:34Z",
    "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.concurrent.TimeUnit\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord\n+import org.apache.kafka.common.TopicPartition\n+import org.jmock.lib.concurrent.DeterministicScheduler\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.kafka010.KafkaDataConsumer.CacheKey\n+import org.apache.spark.sql.test.SharedSparkSession\n+import org.apache.spark.util.ManualClock\n+\n+class FetchedDataPoolSuite extends SharedSparkSession with PrivateMethodTester {\n+  import FetchedDataPool._\n+  type Record = ConsumerRecord[Array[Byte], Array[Byte]]\n+\n+  private val dummyBytes = \"dummy\".getBytes\n+\n+  // Helper private method accessors for FetchedDataPool\n+  private type PoolCacheType = mutable.Map[CacheKey, CachedFetchedDataList]\n+  private val _cache = PrivateMethod[PoolCacheType]('cache)\n+\n+  def getCache(pool: FetchedDataPool): PoolCacheType = {\n+    pool.invokePrivate(_cache())\n+  }\n+\n+  test(\"acquire fresh one\") {"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Given this test and next test are very similar and other tests behave differently, I'd just remove this test and rely on test for multiple keys, as test for multiple keys will pretty much cover the single key as well. In other places most of redundant things are assertions which are already covered by more basic tests. I'll also remove them.",
    "commit": "68af3d56710e21b4b8a9a1640ededb3eb7d3117b",
    "createdAt": "2019-08-28T22:58:59Z",
    "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.concurrent.TimeUnit\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord\n+import org.apache.kafka.common.TopicPartition\n+import org.jmock.lib.concurrent.DeterministicScheduler\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.kafka010.KafkaDataConsumer.CacheKey\n+import org.apache.spark.sql.test.SharedSparkSession\n+import org.apache.spark.util.ManualClock\n+\n+class FetchedDataPoolSuite extends SharedSparkSession with PrivateMethodTester {\n+  import FetchedDataPool._\n+  type Record = ConsumerRecord[Array[Byte], Array[Byte]]\n+\n+  private val dummyBytes = \"dummy\".getBytes\n+\n+  // Helper private method accessors for FetchedDataPool\n+  private type PoolCacheType = mutable.Map[CacheKey, CachedFetchedDataList]\n+  private val _cache = PrivateMethod[PoolCacheType]('cache)\n+\n+  def getCache(pool: FetchedDataPool): PoolCacheType = {\n+    pool.invokePrivate(_cache())\n+  }\n+\n+  test(\"acquire fresh one\") {"
  }],
  "prId": 22138
}]