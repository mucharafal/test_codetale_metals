[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's have `()` since this has a side-effect; `resetGlobalConfig` -> `resetGlobalConfig()`",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:27:31Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig\n+      resetUGI\n+      resetSparkEnv\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig: Unit = {"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:47:04Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig\n+      resetUGI\n+      resetSparkEnv\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig: Unit = {"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`resetUGI` -> `resetUGI()`.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:27:54Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig\n+      resetUGI\n+      resetSparkEnv\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig: Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI: Unit = {"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:46:59Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig\n+      resetUGI\n+      resetSparkEnv\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig: Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI: Unit = {"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`resetSparkEnv` -> `resetSparkEnv()`.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:28:08Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig\n+      resetUGI\n+      resetSparkEnv\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig: Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI: Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv: Unit = {"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:46:56Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig\n+      resetUGI\n+      resetSparkEnv\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig: Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI: Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv: Unit = {"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`\"SCRAM-SHA-512\"` -> `Kafka.TOKEN_SASL_MECHANISM.defaultValueString`?",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T18:59:04Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "+1",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T02:09:28Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T10:09:43Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Just a question. So, `setAuthenticationConfigIfNeeded` is currently no-op in this case intentionally. Is it better to raise an `IllegalArgumentException` with some directional error message about requirements?",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-14T19:06:01Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token and invalid mechanism should throw exception\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map[String, String](Kafka.TOKEN_SASL_MECHANISM.key -> \"INVALID\"))\n+    addTokenToUGI()\n+\n+    val e = intercept[IllegalArgumentException] {\n+      KafkaConfigUpdater(testModule, params)\n+        .setAuthenticationConfigIfNeeded()\n+        .build()\n+    }\n+\n+    assert(e.getMessage.contains(\"Delegation token works only with SCRAM mechanism.\"))\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded without security should not set values\") {",
    "line": 104
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "It seems better to me too to let `setAuthenticationConfigIfNeeded` only works properly with security config. (need to remove `IfNeeded` then) It would fail fast and gives us the chance to provide proper guide, maybe missing configuration for authentication. \r\n\r\nBut no strong opinion since this looks like providing convenience vs being strict to help end users to find possible missing point, and both look reasonable.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T02:20:42Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token and invalid mechanism should throw exception\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map[String, String](Kafka.TOKEN_SASL_MECHANISM.key -> \"INVALID\"))\n+    addTokenToUGI()\n+\n+    val e = intercept[IllegalArgumentException] {\n+      KafkaConfigUpdater(testModule, params)\n+        .setAuthenticationConfigIfNeeded()\n+        .build()\n+    }\n+\n+    assert(e.getMessage.contains(\"Delegation token works only with SCRAM mechanism.\"))\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded without security should not set values\") {",
    "line": 104
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "This was the original implementation which was asked to change like this on other PRs (and I agree with it).\r\nThe reasoning behind was to keep fluent API and not having something like this(which is hardly testable):\r\n```\r\n    val updater = KafkaConfigUpdater(\"executor\", specifiedKafkaParams)\r\n      .set(...)\r\n      .set(...)\r\n\r\n    if (!globalSecurity && tokenAvailable)\r\n      updater.setAuthenticationConfig(...)\r\n    else if (somethingNew)\r\n      updater.set(...)\r\n\r\n    updater.build()\r\n```\r\nThere is no flag like `kafka.securityEnabled` and Kafka can't tell it either.\r\n\r\n> Is it better to raise an IllegalArgumentException with some directional error message about requirements?\r\n\r\nSecurity parameters shouldn't always set, for example:\r\n* If unsecure\r\n* If user provided JVM global JAAS configuration (this provide total freedom to users)\r\n\r\n> It would fail fast and gives us the chance to provide proper guide\r\n\r\n* No security => nothing to check and do\r\n* With global JAAS => it's not possible to parse JAAS config and suggest changes\r\n* With DT => The user warned in advance to provide `SCRAM` related `sasl.mechanism` because the related Kafka error message is cryptic a bit.\r\n\r\nI personally don't see more possibilities to provide convenience for users.\r\n",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T10:09:26Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token and invalid mechanism should throw exception\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map[String, String](Kafka.TOKEN_SASL_MECHANISM.key -> \"INVALID\"))\n+    addTokenToUGI()\n+\n+    val e = intercept[IllegalArgumentException] {\n+      KafkaConfigUpdater(testModule, params)\n+        .setAuthenticationConfigIfNeeded()\n+        .build()\n+    }\n+\n+    assert(e.getMessage.contains(\"Delegation token works only with SCRAM mechanism.\"))\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded without security should not set values\") {",
    "line": 104
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "I meant the case end users intend to set security so call `setAuthenticationConfig*` in KafkaConfigUpdater but they missed setting up security config. I guess error message will be provided in Kafka side but it might be cryptic so seeking the possibility to provide better message. \r\nNo strong opinion and either is fine because end users can be indicated in any way. Just for clarifying my opinion.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-17T01:15:37Z",
    "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {\n+    SparkEnv.set(null)\n+  }\n+\n+  test(\"set should always set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .set(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset without existing key should set value\") {\n+    val params = Map.empty[String, String]\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, testValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setIfUnset with existing key should not set value\") {\n+    val params = Map[String, String](testKey -> testValue)\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setIfUnset(testKey, otherTestValue)\n+      .build()\n+\n+    assert(updatedParams.size() === 1)\n+    assert(updatedParams.get(testKey) === testValue)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with global security should not set values\") {\n+    val params = Map.empty[String, String]\n+    setGlobalKafkaClientConfig()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 0)\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token should set values\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map.empty)\n+    addTokenToUGI()\n+\n+    val updatedParams = KafkaConfigUpdater(testModule, params)\n+      .setAuthenticationConfigIfNeeded()\n+      .build()\n+\n+    assert(updatedParams.size() === 2)\n+    assert(updatedParams.containsKey(SaslConfigs.SASL_JAAS_CONFIG))\n+    assert(updatedParams.get(SaslConfigs.SASL_MECHANISM) === \"SCRAM-SHA-512\")\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded with token and invalid mechanism should throw exception\") {\n+    val params = Map.empty[String, String]\n+    setSparkEnv(Map[String, String](Kafka.TOKEN_SASL_MECHANISM.key -> \"INVALID\"))\n+    addTokenToUGI()\n+\n+    val e = intercept[IllegalArgumentException] {\n+      KafkaConfigUpdater(testModule, params)\n+        .setAuthenticationConfigIfNeeded()\n+        .build()\n+    }\n+\n+    assert(e.getMessage.contains(\"Delegation token works only with SCRAM mechanism.\"))\n+  }\n+\n+  test(\"setAuthenticationConfigIfNeeded without security should not set values\") {",
    "line": 104
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`import org.mockito.Mockito._` -> `import org.mockito.Mockito.{doReturn, mock}`",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T21:15:15Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-17T08:16:26Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's remove this one-liner function and use `SparkEnv.set(null)` in `afterEach` directly. That's shorter and clear enough.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T22:08:30Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-17T08:18:06Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {\n+    UserGroupInformation.setLoginUser(null)\n+  }\n+\n+  private def setSparkEnv(settings: Traversable[(String, String)]): Unit = {\n+    val conf = new SparkConf().setAll(settings)\n+    val env = mock(classOf[SparkEnv])\n+    doReturn(conf).when(env).conf\n+    SparkEnv.set(env)\n+  }\n+\n+  private def resetSparkEnv(): Unit = {"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Also, let's remove this one-liner function, too. We already start to duplicate the same function here and `KafkaSecurityHelperSuite`.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T22:10:39Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Fixed.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-17T08:18:55Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {\n+    val token = new Token[KafkaDelegationTokenIdentifier](\n+      tokenId.getBytes,\n+      tokenPassword.getBytes,\n+      KafkaTokenUtil.TOKEN_KIND,\n+      KafkaTokenUtil.TOKEN_SERVICE\n+    )\n+    val creds = new Credentials()\n+    creds.addToken(KafkaTokenUtil.TOKEN_SERVICE, token)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+  }\n+\n+  private def resetUGI(): Unit = {"
  }],
  "prId": 23321
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "This `addTokenToUGI` function is exactly the same in both `KafkaConfigUpdaterSuite` and `KafkaSecurityHelperSuite`. We had better avoid this kind of `copy&paste` as possible as we can. Could you please rethink about these these suites and suggest a better way to do this, @gaborgsomogyi ?\r\n",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-15T22:17:13Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {"
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Yeah, this can be simplified. Created a trait.",
    "commit": "dcacd7546fd42542da91a3076fea2915065cdff4",
    "createdAt": "2018-12-17T08:49:25Z",
    "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.kafka010\n+\n+import java.{util => ju}\n+import java.util.UUID\n+import javax.security.auth.login.{AppConfigurationEntry, Configuration}\n+\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+import org.apache.hadoop.security.token.Token\n+import org.apache.kafka.common.config.SaslConfigs\n+import org.mockito.Mockito._\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkEnv, SparkFunSuite}\n+import org.apache.spark.deploy.security.KafkaTokenUtil\n+import org.apache.spark.deploy.security.KafkaTokenUtil.KafkaDelegationTokenIdentifier\n+import org.apache.spark.internal.config._\n+\n+class KafkaConfigUpdaterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+  private val testModule = \"testModule\"\n+  private val testKey = \"testKey\"\n+  private val testValue = \"testValue\"\n+  private val otherTestValue = \"otherTestValue\"\n+  private val tokenId = \"tokenId\" + UUID.randomUUID().toString\n+  private val tokenPassword = \"tokenPassword\" + UUID.randomUUID().toString\n+\n+  private class KafkaJaasConfiguration extends Configuration {\n+    val entry =\n+      new AppConfigurationEntry(\n+        \"DummyModule\",\n+        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+        ju.Collections.emptyMap[String, Object]()\n+      )\n+\n+    override def getAppConfigurationEntry(name: String): Array[AppConfigurationEntry] = {\n+      if (name.equals(\"KafkaClient\")) {\n+        Array(entry)\n+      } else {\n+        null\n+      }\n+    }\n+  }\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      resetGlobalConfig()\n+      resetUGI()\n+      resetSparkEnv()\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  private def setGlobalKafkaClientConfig(): Unit = {\n+    Configuration.setConfiguration(new KafkaJaasConfiguration)\n+  }\n+\n+  private def resetGlobalConfig(): Unit = {\n+    Configuration.setConfiguration(null)\n+  }\n+\n+  private def addTokenToUGI(): Unit = {"
  }],
  "prId": 23321
}]