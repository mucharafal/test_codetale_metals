[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Just a style question or nit, but, what about: `def shutdown(): Unit = synchronized { ...`",
    "commit": "e3ae84523621405d2f2b55ec92cb79921aaba961",
    "createdAt": "2018-02-20T23:13:22Z",
    "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka010.mocks\n+\n+import java.util.concurrent.TimeUnit\n+\n+import scala.collection.mutable.PriorityQueue\n+\n+import kafka.utils.{Scheduler, Time}\n+\n+/**\n+ * A mock scheduler that executes tasks synchronously using a mock time instance.\n+ * Tasks are executed synchronously when the time is advanced.\n+ * This class is meant to be used in conjunction with MockTime.\n+ *\n+ * Example usage\n+ * <code>\n+ *   val time = new MockTime\n+ *   time.scheduler.schedule(\"a task\", println(\"hello world: \" + time.milliseconds), delay = 1000)\n+ *   time.sleep(1001) // this should cause our scheduled task to fire\n+ * </code>\n+ *\n+ * Incrementing the time to the exact next execution time of a task will result in that task\n+ * executing (it as if execution itself takes no time).\n+ */\n+private[kafka010] class MockScheduler(val time: Time) extends Scheduler {\n+\n+  /* a priority queue of tasks ordered by next execution time */\n+  var tasks = new PriorityQueue[MockTask]()\n+\n+  def isStarted: Boolean = true\n+\n+  def startup() {}\n+\n+  def shutdown() {"
  }],
  "prId": 20572
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`java.lang.Long.compare(t.nextExecution, nextExecution)` does this too in a line, but whatever",
    "commit": "e3ae84523621405d2f2b55ec92cb79921aaba961",
    "createdAt": "2018-02-20T23:14:40Z",
    "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka010.mocks\n+\n+import java.util.concurrent.TimeUnit\n+\n+import scala.collection.mutable.PriorityQueue\n+\n+import kafka.utils.{Scheduler, Time}\n+\n+/**\n+ * A mock scheduler that executes tasks synchronously using a mock time instance.\n+ * Tasks are executed synchronously when the time is advanced.\n+ * This class is meant to be used in conjunction with MockTime.\n+ *\n+ * Example usage\n+ * <code>\n+ *   val time = new MockTime\n+ *   time.scheduler.schedule(\"a task\", println(\"hello world: \" + time.milliseconds), delay = 1000)\n+ *   time.sleep(1001) // this should cause our scheduled task to fire\n+ * </code>\n+ *\n+ * Incrementing the time to the exact next execution time of a task will result in that task\n+ * executing (it as if execution itself takes no time).\n+ */\n+private[kafka010] class MockScheduler(val time: Time) extends Scheduler {\n+\n+  /* a priority queue of tasks ordered by next execution time */\n+  var tasks = new PriorityQueue[MockTask]()\n+\n+  def isStarted: Boolean = true\n+\n+  def startup() {}\n+\n+  def shutdown() {\n+    this synchronized {\n+      tasks.foreach(_.fun())\n+      tasks.clear()\n+    }\n+  }\n+\n+  /**\n+   * Check for any tasks that need to execute. Since this is a mock scheduler this check only occurs\n+   * when this method is called and the execution happens synchronously in the calling thread.\n+   * If you are using the scheduler associated with a MockTime instance this call\n+   * will be triggered automatically.\n+   */\n+  def tick() {\n+    this synchronized {\n+      val now = time.milliseconds\n+      while(!tasks.isEmpty && tasks.head.nextExecution <= now) {\n+        /* pop and execute the task with the lowest next execution time */\n+        val curr = tasks.dequeue\n+        curr.fun()\n+        /* if the task is periodic, reschedule it and re-enqueue */\n+        if(curr.periodic) {\n+          curr.nextExecution += curr.period\n+          this.tasks += curr\n+        }\n+      }\n+    }\n+  }\n+\n+  def schedule(\n+      name: String,\n+      fun: () => Unit,\n+      delay: Long = 0,\n+      period: Long = -1,\n+      unit: TimeUnit = TimeUnit.MILLISECONDS) {\n+    this synchronized {\n+      tasks += MockTask(name, fun, time.milliseconds + delay, period = period)\n+      tick()\n+    }\n+  }\n+\n+}\n+\n+case class MockTask(\n+    val name: String,\n+    val fun: () => Unit,\n+    var nextExecution: Long,\n+    val period: Long) extends Ordered[MockTask] {\n+  def periodic: Boolean = period >= 0\n+  def compare(t: MockTask): Int = {\n+    if (t.nextExecution == nextExecution) {"
  }],
  "prId": 20572
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think I'd still write such methods as:\r\n\r\n```\r\ndef foo(): T = synchronized {\r\n   ...\r\n}\r\n```\r\n\r\nThis is how the rest of the code base does it (and other Scala code I've seen).",
    "commit": "e3ae84523621405d2f2b55ec92cb79921aaba961",
    "createdAt": "2018-02-23T15:20:56Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.kafka010.mocks\n+\n+import java.util.concurrent.TimeUnit\n+\n+import scala.collection.mutable.PriorityQueue\n+\n+import kafka.utils.{Scheduler, Time}\n+\n+/**\n+ * A mock scheduler that executes tasks synchronously using a mock time instance.\n+ * Tasks are executed synchronously when the time is advanced.\n+ * This class is meant to be used in conjunction with MockTime.\n+ *\n+ * Example usage\n+ * <code>\n+ *   val time = new MockTime\n+ *   time.scheduler.schedule(\"a task\", println(\"hello world: \" + time.milliseconds), delay = 1000)\n+ *   time.sleep(1001) // this should cause our scheduled task to fire\n+ * </code>\n+ *\n+ * Incrementing the time to the exact next execution time of a task will result in that task\n+ * executing (it as if execution itself takes no time).\n+ */\n+private[kafka010] class MockScheduler(val time: Time) extends Scheduler {\n+\n+  /* a priority queue of tasks ordered by next execution time */\n+  var tasks = new PriorityQueue[MockTask]()\n+\n+  def isStarted: Boolean = true\n+\n+  def startup(): Unit = {}\n+\n+  def shutdown(): Unit = synchronized {\n+    tasks.foreach(_.fun())\n+    tasks.clear()\n+  }\n+\n+  /**\n+   * Check for any tasks that need to execute. Since this is a mock scheduler this check only occurs\n+   * when this method is called and the execution happens synchronously in the calling thread.\n+   * If you are using the scheduler associated with a MockTime instance this call\n+   * will be triggered automatically.\n+   */\n+  def tick() {\n+    this synchronized {\n+      val now = time.milliseconds\n+      while(!tasks.isEmpty && tasks.head.nextExecution <= now) {\n+        /* pop and execute the task with the lowest next execution time */\n+        val curr = tasks.dequeue\n+        curr.fun()\n+        /* if the task is periodic, reschedule it and re-enqueue */\n+        if(curr.periodic) {\n+          curr.nextExecution += curr.period\n+          this.tasks += curr\n+        }\n+      }\n+    }\n+  }\n+\n+  def schedule(\n+      name: String,\n+      fun: () => Unit,\n+      delay: Long = 0,\n+      period: Long = -1,\n+      unit: TimeUnit = TimeUnit.MILLISECONDS) {\n+    this synchronized {"
  }],
  "prId": 20572
}]