[{
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "do these need to be thread safe? Is boot up, and cleanup serial?",
    "commit": "63cc11dfa575ac25ee3751a93a2cb5a6b9886218",
    "createdAt": "2018-08-17T20:59:16Z",
    "diffHunk": "@@ -120,61 +120,56 @@ private[kafka010] class KafkaTestUtils extends Logging {\n \n   /** setup the whole embedded servers, including Zookeeper and Kafka brokers */\n   def setup(): Unit = {\n+    // Set up a KafkaTestUtils leak detector so that we can see where the leak KafkaTestUtils is\n+    // created.\n+    val exception = new SparkException(\"It was created at: \")\n+    leakDetector = ShutdownHookManager.addShutdownHook { () =>\n+      logError(\"Found a leak KafkaTestUtils.\", exception)\n+    }\n+\n     setupEmbeddedZookeeper()\n     setupEmbeddedKafkaServer()\n   }\n \n   /** Teardown the whole servers, including Kafka broker and Zookeeper */\n   def teardown(): Unit = {\n-    // There is a race condition that may kill JVM when terminating the Kafka cluster. We set\n-    // a custom Procedure here during the termination in order to keep JVM running and not fail the\n-    // tests.\n-    val logExitEvent = new Exit.Procedure {\n-      override def execute(statusCode: Int, message: String): Unit = {\n-        logError(s\"Prevent Kafka from killing JVM (statusCode: $statusCode message: $message)\")\n-      }\n+    if (leakDetector != null) {\n+      ShutdownHookManager.removeShutdownHook(leakDetector)\n     }\n-    Exit.setExitProcedure(logExitEvent)\n-    Exit.setHaltProcedure(logExitEvent)\n-    try {\n-      brokerReady = false\n-      zkReady = false\n-\n-      if (producer != null) {\n-        producer.close()\n-        producer = null\n-      }\n+    brokerReady = false",
    "line": 70
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "No. We set up in `beforeAll` and clean up in `afterAll`, which will be in the same thread.",
    "commit": "63cc11dfa575ac25ee3751a93a2cb5a6b9886218",
    "createdAt": "2018-08-17T21:20:09Z",
    "diffHunk": "@@ -120,61 +120,56 @@ private[kafka010] class KafkaTestUtils extends Logging {\n \n   /** setup the whole embedded servers, including Zookeeper and Kafka brokers */\n   def setup(): Unit = {\n+    // Set up a KafkaTestUtils leak detector so that we can see where the leak KafkaTestUtils is\n+    // created.\n+    val exception = new SparkException(\"It was created at: \")\n+    leakDetector = ShutdownHookManager.addShutdownHook { () =>\n+      logError(\"Found a leak KafkaTestUtils.\", exception)\n+    }\n+\n     setupEmbeddedZookeeper()\n     setupEmbeddedKafkaServer()\n   }\n \n   /** Teardown the whole servers, including Kafka broker and Zookeeper */\n   def teardown(): Unit = {\n-    // There is a race condition that may kill JVM when terminating the Kafka cluster. We set\n-    // a custom Procedure here during the termination in order to keep JVM running and not fail the\n-    // tests.\n-    val logExitEvent = new Exit.Procedure {\n-      override def execute(statusCode: Int, message: String): Unit = {\n-        logError(s\"Prevent Kafka from killing JVM (statusCode: $statusCode message: $message)\")\n-      }\n+    if (leakDetector != null) {\n+      ShutdownHookManager.removeShutdownHook(leakDetector)\n     }\n-    Exit.setExitProcedure(logExitEvent)\n-    Exit.setHaltProcedure(logExitEvent)\n-    try {\n-      brokerReady = false\n-      zkReady = false\n-\n-      if (producer != null) {\n-        producer.close()\n-        producer = null\n-      }\n+    brokerReady = false",
    "line": 70
  }],
  "prId": 22106
}]