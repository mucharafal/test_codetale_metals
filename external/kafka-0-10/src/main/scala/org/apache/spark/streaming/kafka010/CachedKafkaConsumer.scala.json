[{
  "comments": [{
    "author": {
      "login": "koeninger"
    },
    "body": "Shouldn't this method call be after the cast?",
    "commit": "639f11c9fd856f58d067036f9b9131ea9efdc13d",
    "createdAt": "2017-11-20T17:24:33Z",
    "diffHunk": "@@ -155,11 +178,11 @@ object CachedKafkaConsumer extends Logging {\n         logInfo(s\"Cache miss for $k\")\n         logDebug(cache.keySet.toString)\n         val c = new CachedKafkaConsumer[K, V](groupId, topic, partition, kafkaParams)\n-        cache.put(k, c)\n+        cache.put(k, c.acquireAndGet())\n         c\n       } else {\n         // any given topicpartition should have a consistent key and value type\n-        v.asInstanceOf[CachedKafkaConsumer[K, V]]\n+        v.acquireAndGet().asInstanceOf[CachedKafkaConsumer[K, V]]",
    "line": 81
  }, {
    "author": {
      "login": "daroo"
    },
    "body": "It can be, but actually it doesn't matter as the cache value has CachedKafkaConsumer[_, _] type",
    "commit": "639f11c9fd856f58d067036f9b9131ea9efdc13d",
    "createdAt": "2017-11-20T17:40:06Z",
    "diffHunk": "@@ -155,11 +178,11 @@ object CachedKafkaConsumer extends Logging {\n         logInfo(s\"Cache miss for $k\")\n         logDebug(cache.keySet.toString)\n         val c = new CachedKafkaConsumer[K, V](groupId, topic, partition, kafkaParams)\n-        cache.put(k, c)\n+        cache.put(k, c.acquireAndGet())\n         c\n       } else {\n         // any given topicpartition should have a consistent key and value type\n-        v.asInstanceOf[CachedKafkaConsumer[K, V]]\n+        v.acquireAndGet().asInstanceOf[CachedKafkaConsumer[K, V]]",
    "line": 81
  }],
  "prId": 19789
}]