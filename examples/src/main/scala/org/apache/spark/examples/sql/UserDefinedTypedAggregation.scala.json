[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Same comment here with object reuse.",
    "commit": "0b17e132b24daf0f0eab5cd53e3dc84ffb56c2dd",
    "createdAt": "2016-12-19T21:08:05Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.examples.sql\n+\n+// $example on:typed_custom_aggregation$\n+import org.apache.spark.sql.expressions.Aggregator\n+import org.apache.spark.sql.Encoder\n+import org.apache.spark.sql.Encoders\n+import org.apache.spark.sql.SparkSession\n+// $example off:typed_custom_aggregation$\n+\n+object UserDefinedTypedAggregation {\n+\n+  // $example on:typed_custom_aggregation$\n+  case class Salary(person: String, salary: Long)\n+  case class Average(sum: Long, count: Long)\n+\n+  object MyAverage extends Aggregator[Salary, Average, Double] {\n+    // A zero value for this aggregation. Should satisfy the property that any b + zero = b\n+    def zero: Average = Average(0L, 0L)\n+    // Combine two values to produce a new value. For performance, the function may modify `b` and"
  }],
  "prId": 16329
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Maybe comment what `name` is doing here.  I actually had to look it up.",
    "commit": "0b17e132b24daf0f0eab5cd53e3dc84ffb56c2dd",
    "createdAt": "2016-12-19T21:16:22Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.examples.sql\n+\n+// $example on:typed_custom_aggregation$\n+import org.apache.spark.sql.expressions.Aggregator\n+import org.apache.spark.sql.Encoder\n+import org.apache.spark.sql.Encoders\n+import org.apache.spark.sql.SparkSession\n+// $example off:typed_custom_aggregation$\n+\n+object UserDefinedTypedAggregation {\n+\n+  // $example on:typed_custom_aggregation$\n+  case class Salary(person: String, salary: Long)\n+  case class Average(sum: Long, count: Long)\n+\n+  object MyAverage extends Aggregator[Salary, Average, Double] {\n+    // A zero value for this aggregation. Should satisfy the property that any b + zero = b\n+    def zero: Average = Average(0L, 0L)\n+    // Combine two values to produce a new value. For performance, the function may modify `b` and\n+    // return it instead of constructing a new object for b\n+    def reduce(b: Average, a: Salary): Average = Average(b.sum + a.salary, b.count + 1)\n+    // Merge two intermediate values\n+    def merge(b1: Average, b2: Average): Average = Average(b1.sum + b2.sum, b1.count + b2.count)\n+    // Transform the output of the reduction\n+    def finish(reduction: Average): Double = reduction.sum.toDouble / reduction.count\n+    // Specifies the Encoder for the intermediate value type\n+    def bufferEncoder: Encoder[Average] = Encoders.product\n+    // Specifies the Encoder for the final output value type\n+    def outputEncoder: Encoder[Double] = Encoders.scalaDouble\n+  }\n+  // $example off:typed_custom_aggregation$\n+\n+  def main(args: Array[String]): Unit = {\n+    val spark = SparkSession\n+      .builder()\n+      .appName(\"Spark SQL user-defined Datasets aggregation example\")\n+      .getOrCreate()\n+\n+    import spark.implicits._\n+\n+    // $example on:typed_custom_aggregation$\n+    val ds = spark.read.json(\"examples/src/main/resources/salaries.json\").as[Salary]\n+    ds.show()\n+    // +-------+------+\n+    // | person|salary|\n+    // +-------+------+\n+    // |Michael|  3000|\n+    // |   Andy|  4500|\n+    // | Justin|  3500|\n+    // |  Berta|  4000|\n+    // +-------+------+\n+\n+    val averageSalary = MyAverage.toColumn.name(\"average_salary\")"
  }],
  "prId": 16329
}, {
  "comments": [{
    "author": {
      "login": "michalsenkyr"
    },
    "body": "Why are you constructing a new object instead of modifying the `var`s in one of the parameters? Is it required in the `merge` method and not in the `reduce` method?",
    "commit": "0b17e132b24daf0f0eab5cd53e3dc84ffb56c2dd",
    "createdAt": "2016-12-21T20:17:39Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.examples.sql\n+\n+// $example on:typed_custom_aggregation$\n+import org.apache.spark.sql.expressions.Aggregator\n+import org.apache.spark.sql.Encoder\n+import org.apache.spark.sql.Encoders\n+import org.apache.spark.sql.SparkSession\n+// $example off:typed_custom_aggregation$\n+\n+object UserDefinedTypedAggregation {\n+\n+  // $example on:typed_custom_aggregation$\n+  case class Employee(name: String, salary: Long)\n+  case class Average(var sum: Long, var count: Long)\n+\n+  object MyAverage extends Aggregator[Employee, Average, Double] {\n+    // A zero value for this aggregation. Should satisfy the property that any b + zero = b\n+    def zero: Average = Average(0L, 0L)\n+    // Combine two values to produce a new value. For performance, the function may modify `buffer`\n+    // and return it instead of constructing a new object\n+    def reduce(buffer: Average, employee: Employee): Average = {\n+      buffer.sum += employee.salary\n+      buffer.count += 1\n+      buffer\n+    }\n+    // Merge two intermediate values\n+    def merge(b1: Average, b2: Average): Average = Average(b1.sum + b2.sum, b1.count + b2.count)"
  }, {
    "author": {
      "login": "aokolnychyi"
    },
    "body": "@michalsenkyr It is not required to create a new object in the `merge` method. One can modify the vars and return the existing object just like in the `reduce` method.  However, it is less critical here since this method will be called on pre-aggregated data and not for every element. On the one hand, I can apply here the same approach as in the `reduce` method to make the example consistent. On the other hand, the current code shows that it is not mandatory to modify vars. Probably, a comment might help. I am not sure which approach is better. Therefore, I am open to suggestions.",
    "commit": "0b17e132b24daf0f0eab5cd53e3dc84ffb56c2dd",
    "createdAt": "2016-12-22T11:16:05Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.examples.sql\n+\n+// $example on:typed_custom_aggregation$\n+import org.apache.spark.sql.expressions.Aggregator\n+import org.apache.spark.sql.Encoder\n+import org.apache.spark.sql.Encoders\n+import org.apache.spark.sql.SparkSession\n+// $example off:typed_custom_aggregation$\n+\n+object UserDefinedTypedAggregation {\n+\n+  // $example on:typed_custom_aggregation$\n+  case class Employee(name: String, salary: Long)\n+  case class Average(var sum: Long, var count: Long)\n+\n+  object MyAverage extends Aggregator[Employee, Average, Double] {\n+    // A zero value for this aggregation. Should satisfy the property that any b + zero = b\n+    def zero: Average = Average(0L, 0L)\n+    // Combine two values to produce a new value. For performance, the function may modify `buffer`\n+    // and return it instead of constructing a new object\n+    def reduce(buffer: Average, employee: Employee): Average = {\n+      buffer.sum += employee.salary\n+      buffer.count += 1\n+      buffer\n+    }\n+    // Merge two intermediate values\n+    def merge(b1: Average, b2: Average): Average = Average(b1.sum + b2.sum, b1.count + b2.count)"
  }, {
    "author": {
      "login": "michalsenkyr"
    },
    "body": "Personally, I prefer consistency. When I saw this, I immediately wondered whether there is a specific reason you did it this way.\r\nI'd rather see both methods use the same paradigm. In this case probably the immutable one as the option of mutability is already mentioned in the comment above.\r\nOr you can mention it again in the comment on this method if you want to provide examples of both. This way it just seems a little confusing.",
    "commit": "0b17e132b24daf0f0eab5cd53e3dc84ffb56c2dd",
    "createdAt": "2016-12-22T19:25:20Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.examples.sql\n+\n+// $example on:typed_custom_aggregation$\n+import org.apache.spark.sql.expressions.Aggregator\n+import org.apache.spark.sql.Encoder\n+import org.apache.spark.sql.Encoders\n+import org.apache.spark.sql.SparkSession\n+// $example off:typed_custom_aggregation$\n+\n+object UserDefinedTypedAggregation {\n+\n+  // $example on:typed_custom_aggregation$\n+  case class Employee(name: String, salary: Long)\n+  case class Average(var sum: Long, var count: Long)\n+\n+  object MyAverage extends Aggregator[Employee, Average, Double] {\n+    // A zero value for this aggregation. Should satisfy the property that any b + zero = b\n+    def zero: Average = Average(0L, 0L)\n+    // Combine two values to produce a new value. For performance, the function may modify `buffer`\n+    // and return it instead of constructing a new object\n+    def reduce(buffer: Average, employee: Employee): Average = {\n+      buffer.sum += employee.salary\n+      buffer.count += 1\n+      buffer\n+    }\n+    // Merge two intermediate values\n+    def merge(b1: Average, b2: Average): Average = Average(b1.sum + b2.sum, b1.count + b2.count)"
  }],
  "prId": 16329
}]