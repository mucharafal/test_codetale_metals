[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Please use Python's style for doc.\n\n```\ndef parsePoint(line):\n   \"\"\"\n   doc\n   \"\"\"\n```\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T00:16:03Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import sys, numpy\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+\n+\n+# Parse a line of text into an MLlib LabeledPoint object"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "I got this from logistic_regression.py  I'll update it everywhere I find it.\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T00:43:38Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import sys, numpy\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+\n+\n+# Parse a line of text into an MLlib LabeledPoint object"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "We can do that during QA. Let's focus on DT in this PR :)\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T00:44:33Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import sys, numpy\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+\n+\n+# Parse a line of text into an MLlib LabeledPoint object"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It is really hard to guess what this method does until I read the code in main. So more doc is needed. Another option is to remove it and use it in unit test, because people will use this as a template to build their own applications. Swapping the first feature with the label is not a common operation.\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T00:16:09Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import sys, numpy\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+\n+\n+# Parse a line of text into an MLlib LabeledPoint object\n+def parsePoint(line):\n+    values = [float(s) for s in line.split(',')]\n+    if values[0] == -1:   # Convert -1 labels to 0 for MLlib\n+        values[0] = 0\n+    return LabeledPoint(values[0], values[1:])\n+\n+# Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+def getAccuracy(dtModel, data):\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data)\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+# Return mean squared error (MSE) of DecisionTreeModel on the given RDD[LabeledPoint].\n+def getMSE(dtModel, data):\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data)\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+# Return a new LabeledPoint with the label and feature 0 swapped.\n+def swapLabelAndFeature0(labeledPoint):"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Shall we make this configurable?\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T00:16:31Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import sys, numpy\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+\n+\n+# Parse a line of text into an MLlib LabeledPoint object\n+def parsePoint(line):\n+    values = [float(s) for s in line.split(',')]\n+    if values[0] == -1:   # Convert -1 labels to 0 for MLlib\n+        values[0] = 0\n+    return LabeledPoint(values[0], values[1:])\n+\n+# Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+def getAccuracy(dtModel, data):\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data)\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+# Return mean squared error (MSE) of DecisionTreeModel on the given RDD[LabeledPoint].\n+def getMSE(dtModel, data):\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data)\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+# Return a new LabeledPoint with the label and feature 0 swapped.\n+def swapLabelAndFeature0(labeledPoint):\n+    newLabel = labeledPoint.label\n+    newFeatures = labeledPoint.features\n+    (newLabel, newFeatures[0]) = (newFeatures[0], newLabel)\n+    return LabeledPoint(newLabel, newFeatures)\n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) != 1:\n+        print >> sys.stderr, \"Usage: logistic_regression\"\n+        exit(-1)\n+    sc = SparkContext(appName=\"PythonDT\")\n+\n+    # Load data.\n+    dataPath = 'data/mllib/sample_tree_data.csv'"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: Do we want to check `data.count() == 0`?\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T16:49:57Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The exit code should be in range [0, 255]. So `-1` maps to `255`, which has a special meaning (out of range?). `exit(1)` may be better here.\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T16:50:01Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "space after `,`\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T16:50:04Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)\n+    origToNewLabels = dict([(sortedClasses[i], i) for i in range(0,numClasses)])"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: Is it safe to assume that the input labels are all integers? It may be rare to have `{0, 0.5, 2}` but it may happen.\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T16:50:07Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)\n+    origToNewLabels = dict([(sortedClasses[i], i) for i in range(0,numClasses)])\n+\n+    print \"numClasses = %d\" % numClasses\n+    print \"Per-class example fractions, counts:\"\n+    print \"Class\\tFrac\\tCount\"\n+    for c in sortedClasses:\n+        frac = classCounts[c] / (numExamples + 0.0)\n+        print \"%g\\t%g\\t%d\" % (c, frac, classCounts[c])\n+\n+    if (sortedClasses[0] == 0 and sortedClasses[-1] == numClasses - 1):"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "I don't think I do assume integer values.  This check is to see if we need to relabel for DecisionTree (which requires class labels to be in 0,...,numClasses-1).\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T18:49:25Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)\n+    origToNewLabels = dict([(sortedClasses[i], i) for i in range(0,numClasses)])\n+\n+    print \"numClasses = %d\" % numClasses\n+    print \"Per-class example fractions, counts:\"\n+    print \"Class\\tFrac\\tCount\"\n+    for c in sortedClasses:\n+        frac = classCounts[c] / (numExamples + 0.0)\n+        print \"%g\\t%g\\t%d\" % (c, frac, classCounts[c])\n+\n+    if (sortedClasses[0] == 0 and sortedClasses[-1] == numClasses - 1):"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Only the first and the last were checked. The values in the middle could be something like `0.5`.\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-03T00:07:27Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)\n+    origToNewLabels = dict([(sortedClasses[i], i) for i in range(0,numClasses)])\n+\n+    print \"numClasses = %d\" % numClasses\n+    print \"Per-class example fractions, counts:\"\n+    print \"Class\\tFrac\\tCount\"\n+    for c in sortedClasses:\n+        frac = classCounts[c] / (numExamples + 0.0)\n+        print \"%g\\t%g\\t%d\" % (c, frac, classCounts[c])\n+\n+    if (sortedClasses[0] == 0 and sortedClasses[-1] == numClasses - 1):"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`logistic_regression` -> `tree` (or maybe we should change the name to `decision_tree_runner.py` to match Scala's.\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T16:50:12Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)\n+    origToNewLabels = dict([(sortedClasses[i], i) for i in range(0,numClasses)])\n+\n+    print \"numClasses = %d\" % numClasses\n+    print \"Per-class example fractions, counts:\"\n+    print \"Class\\tFrac\\tCount\"\n+    for c in sortedClasses:\n+        frac = classCounts[c] / (numExamples + 0.0)\n+        print \"%g\\t%g\\t%d\" % (c, frac, classCounts[c])\n+\n+    if (sortedClasses[0] == 0 and sortedClasses[-1] == numClasses - 1):\n+        return (data, origToNewLabels)\n+    else:\n+        reindexedData = \\\n+            data.map(lambda x: LabeledPoint(origToNewLabels[x.label], x.features))\n+        return (reindexedData, origToNewLabels)\n+\n+\n+def usage():\n+    print >> sys.stderr, \\\n+        \"Usage: logistic_regression [libsvm format data filepath]\\n\" + \\"
  }],
  "prId": 1727
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "ditto: `exit(1)`\n",
    "commit": "374448874de7a758658e0ac54cf1d578d09e347d",
    "createdAt": "2014-08-02T16:50:17Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Decision tree classification and regression using MLlib.\n+\"\"\"\n+\n+import numpy, os, sys\n+\n+from operator import add\n+\n+from pyspark import SparkContext\n+from pyspark.mllib.regression import LabeledPoint\n+from pyspark.mllib.tree import DecisionTree\n+from pyspark.mllib.util import MLUtils\n+\n+\n+def getAccuracy(dtModel, data):\n+    \"\"\"\n+    Return accuracy of DecisionTreeModel on the given RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + (x[0] == x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainCorrect = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainCorrect / (0.0 + data.count())\n+\n+\n+def getMSE(dtModel, data):\n+    \"\"\"\n+    Return mean squared error (MSE) of DecisionTreeModel on the given\n+    RDD[LabeledPoint].\n+    \"\"\"\n+    seqOp = (lambda acc, x: acc + numpy.square(x[0] - x[1]))\n+    predictions = dtModel.predict(data.map(lambda x: x.features))\n+    truth = data.map(lambda p: p.label)\n+    trainMSE = predictions.zip(truth).aggregate(0, seqOp, add)\n+    return trainMSE / (0.0 + data.count())\n+\n+\n+def reindexClassLabels(data):\n+    \"\"\"\n+    Re-index class labels in a dataset to the range {0,...,numClasses-1}.\n+    If all labels in that range already appear at least once,\n+     then the returned RDD is the same one (without a mapping).\n+    Note: If a label simply does not appear in the data,\n+          the index will not include it.\n+          Be aware of this when reindexing subsampled data.\n+    :param data: RDD of LabeledPoint where labels are integer values\n+                 denoting labels for a classification problem.\n+    :return: Pair (reindexedData, origToNewLabels) where\n+             reindexedData is an RDD of LabeledPoint with labels in\n+              the range {0,...,numClasses-1}, and\n+             origToNewLabels is a dictionary mapping original labels\n+              to new labels.\n+    \"\"\"\n+    # classCounts: class --> # examples in class\n+    classCounts = data.map(lambda x: x.label).countByValue()\n+    numExamples = sum(classCounts.values())\n+    sortedClasses = sorted(classCounts.keys())\n+    numClasses = len(classCounts)\n+    # origToNewLabels: class --> index in 0,...,numClasses-1\n+    if (numClasses < 2):\n+        print >> sys.stderr, \\\n+            \"Dataset for classification should have at least 2 classes.\" + \\\n+            \" The given dataset had only %d classes.\" % numClasses\n+        exit(-1)\n+    origToNewLabels = dict([(sortedClasses[i], i) for i in range(0,numClasses)])\n+\n+    print \"numClasses = %d\" % numClasses\n+    print \"Per-class example fractions, counts:\"\n+    print \"Class\\tFrac\\tCount\"\n+    for c in sortedClasses:\n+        frac = classCounts[c] / (numExamples + 0.0)\n+        print \"%g\\t%g\\t%d\" % (c, frac, classCounts[c])\n+\n+    if (sortedClasses[0] == 0 and sortedClasses[-1] == numClasses - 1):\n+        return (data, origToNewLabels)\n+    else:\n+        reindexedData = \\\n+            data.map(lambda x: LabeledPoint(origToNewLabels[x.label], x.features))\n+        return (reindexedData, origToNewLabels)\n+\n+\n+def usage():\n+    print >> sys.stderr, \\\n+        \"Usage: logistic_regression [libsvm format data filepath]\\n\" + \\\n+        \" Note: This only supports binary classification.\"\n+    exit(-1)"
  }],
  "prId": 1727
}]