[{
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "no values column anymore",
    "commit": "36fd9bc6366d58541c8306803d8742649be69098",
    "createdAt": "2017-02-09T21:48:03Z",
    "diffHunk": "@@ -0,0 +1,86 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\n+from __future__ import print_function\n+\n+# $example on$\n+from pyspark.ml.feature import BucketedRandomProjectionLSH\n+from pyspark.ml.linalg import Vectors\n+# $example off$\n+from pyspark.sql import SparkSession\n+\n+\"\"\"\n+An example demonstrating BucketedRandomProjectionLSH.\n+Run with:\n+  bin/spark-submit examples/src/main/python/ml/bucketed_random_projection_lsh_example.py\n+\"\"\"\n+\n+if __name__ == \"__main__\":\n+    spark = SparkSession \\\n+        .builder \\\n+        .appName(\"BucketedRandomProjectionLSHExample\") \\\n+        .getOrCreate()\n+\n+    # $example on$\n+    dataA = [(0, Vectors.dense([1.0, 1.0]),),\n+             (1, Vectors.dense([1.0, -1.0]),),\n+             (2, Vectors.dense([-1.0, -1.0]),),\n+             (3, Vectors.dense([-1.0, 1.0]),)]\n+    dfA = spark.createDataFrame(dataA, [\"id\", \"features\"])\n+\n+    dataB = [(4, Vectors.dense([1.0, 0.0]),),\n+             (5, Vectors.dense([-1.0, 0.0]),),\n+             (6, Vectors.dense([0.0, 1.0]),),\n+             (7, Vectors.dense([0.0, -1.0]),)]\n+    dfB = spark.createDataFrame(dataB, [\"id\", \"features\"])\n+\n+    key = Vectors.dense([1.0, 0.0])\n+\n+    brp = BucketedRandomProjectionLSH(inputCol=\"features\", outputCol=\"hashes\", bucketLength=2.0,\n+                                      numHashTables=3)\n+    model = brp.fit(dfA)\n+\n+    # Feature Transformation\n+    print(\"The hashed dataset where hashed values are stored in the column 'values':\")"
  }],
  "prId": 16715
}, {
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "I see what we're going for here, but this is pretty confusing. I think if we could somehow be more clear about the fact that if the datasets that we pass into this function already contain the output column (the \"hashes\" column) then we won't have to recompute it. I spent a bit here just trying to discern the difference between these two lines. ",
    "commit": "36fd9bc6366d58541c8306803d8742649be69098",
    "createdAt": "2017-02-09T21:54:43Z",
    "diffHunk": "@@ -0,0 +1,86 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\n+from __future__ import print_function\n+\n+# $example on$\n+from pyspark.ml.feature import BucketedRandomProjectionLSH\n+from pyspark.ml.linalg import Vectors\n+# $example off$\n+from pyspark.sql import SparkSession\n+\n+\"\"\"\n+An example demonstrating BucketedRandomProjectionLSH.\n+Run with:\n+  bin/spark-submit examples/src/main/python/ml/bucketed_random_projection_lsh_example.py\n+\"\"\"\n+\n+if __name__ == \"__main__\":\n+    spark = SparkSession \\\n+        .builder \\\n+        .appName(\"BucketedRandomProjectionLSHExample\") \\\n+        .getOrCreate()\n+\n+    # $example on$\n+    dataA = [(0, Vectors.dense([1.0, 1.0]),),\n+             (1, Vectors.dense([1.0, -1.0]),),\n+             (2, Vectors.dense([-1.0, -1.0]),),\n+             (3, Vectors.dense([-1.0, 1.0]),)]\n+    dfA = spark.createDataFrame(dataA, [\"id\", \"features\"])\n+\n+    dataB = [(4, Vectors.dense([1.0, 0.0]),),\n+             (5, Vectors.dense([-1.0, 0.0]),),\n+             (6, Vectors.dense([0.0, 1.0]),),\n+             (7, Vectors.dense([0.0, -1.0]),)]\n+    dfB = spark.createDataFrame(dataB, [\"id\", \"features\"])\n+\n+    key = Vectors.dense([1.0, 0.0])\n+\n+    brp = BucketedRandomProjectionLSH(inputCol=\"features\", outputCol=\"hashes\", bucketLength=2.0,\n+                                      numHashTables=3)\n+    model = brp.fit(dfA)\n+\n+    # Feature Transformation\n+    print(\"The hashed dataset where hashed values are stored in the column 'values':\")\n+    model.transform(dfA).show()\n+    # Cache the transformed columns\n+    transformedA = model.transform(dfA).cache()\n+    transformedB = model.transform(dfB).cache()\n+\n+    # Approximate similarity join\n+    print(\"Approximately joining dfA and dfB on distance smaller than 1.5:\")\n+    model.approxSimilarityJoin(dfA, dfB, 1.5)\\\n+        .select(\"datasetA.id\", \"datasetB.id\", \"distCol\").show()\n+    print(\"Joining cached datasets to avoid recomputing the hash values:\")"
  }],
  "prId": 16715
}, {
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "I really do not think this is necessary. If you can do an approx similarity join between two datasets it will hopefully be obvious that you can do a self join. This is also confusing, since the name of the input is `dfA` in both cases, but the filter and select logic reference a `datasetB` and a `datasetA`. At first I thought it was wrong, then I realized that those are the default names, but that's not clear unless you read the API docs.",
    "commit": "36fd9bc6366d58541c8306803d8742649be69098",
    "createdAt": "2017-02-09T21:56:54Z",
    "diffHunk": "@@ -0,0 +1,86 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\n+from __future__ import print_function\n+\n+# $example on$\n+from pyspark.ml.feature import BucketedRandomProjectionLSH\n+from pyspark.ml.linalg import Vectors\n+# $example off$\n+from pyspark.sql import SparkSession\n+\n+\"\"\"\n+An example demonstrating BucketedRandomProjectionLSH.\n+Run with:\n+  bin/spark-submit examples/src/main/python/ml/bucketed_random_projection_lsh_example.py\n+\"\"\"\n+\n+if __name__ == \"__main__\":\n+    spark = SparkSession \\\n+        .builder \\\n+        .appName(\"BucketedRandomProjectionLSHExample\") \\\n+        .getOrCreate()\n+\n+    # $example on$\n+    dataA = [(0, Vectors.dense([1.0, 1.0]),),\n+             (1, Vectors.dense([1.0, -1.0]),),\n+             (2, Vectors.dense([-1.0, -1.0]),),\n+             (3, Vectors.dense([-1.0, 1.0]),)]\n+    dfA = spark.createDataFrame(dataA, [\"id\", \"features\"])\n+\n+    dataB = [(4, Vectors.dense([1.0, 0.0]),),\n+             (5, Vectors.dense([-1.0, 0.0]),),\n+             (6, Vectors.dense([0.0, 1.0]),),\n+             (7, Vectors.dense([0.0, -1.0]),)]\n+    dfB = spark.createDataFrame(dataB, [\"id\", \"features\"])\n+\n+    key = Vectors.dense([1.0, 0.0])\n+\n+    brp = BucketedRandomProjectionLSH(inputCol=\"features\", outputCol=\"hashes\", bucketLength=2.0,\n+                                      numHashTables=3)\n+    model = brp.fit(dfA)\n+\n+    # Feature Transformation\n+    print(\"The hashed dataset where hashed values are stored in the column 'values':\")\n+    model.transform(dfA).show()\n+    # Cache the transformed columns\n+    transformedA = model.transform(dfA).cache()\n+    transformedB = model.transform(dfB).cache()\n+\n+    # Approximate similarity join\n+    print(\"Approximately joining dfA and dfB on distance smaller than 1.5:\")\n+    model.approxSimilarityJoin(dfA, dfB, 1.5)\\\n+        .select(\"datasetA.id\", \"datasetB.id\", \"distCol\").show()\n+    print(\"Joining cached datasets to avoid recomputing the hash values:\")\n+    model.approxSimilarityJoin(transformedA, transformedB, 1.5)\\\n+        .select(\"datasetA.id\", \"datasetB.id\", \"distCol\").show()\n+\n+    # Self Join\n+    print(\"Approximately self join of dfB on distance smaller than 2.5:\")\n+    model.approxSimilarityJoin(dfA, dfA, 2.5).filter(\"datasetA.id < datasetB.id\")\\"
  }],
  "prId": 16715
}, {
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "Still think this is confusing here too. maybe we could leave comments:\r\n\r\n````python\r\n# compute the locality-sensitive hashes for the input rows, then perform approximate nearest neighbor search.\r\n# we could avoid computing hashes by passing in the already-transformed dataframe, e.g. \r\n# `model.approxNearestNeighbors(transformedA, key, 2)`\r\nmodel.approxNearestNeighbors(dfA, key, 2).show()\r\n````\r\n\r\nThis seems better to me because before you'd have to read the code to see the difference between the two cases anyway. Now, those who read the code can _still_ see the difference from the comment, and those who just run the example from the command line will not be confused or waste time trying to understand why we output the exact same table twice with different explanations. \r\n\r\n",
    "commit": "36fd9bc6366d58541c8306803d8742649be69098",
    "createdAt": "2017-02-09T22:05:15Z",
    "diffHunk": "@@ -0,0 +1,86 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\n+from __future__ import print_function\n+\n+# $example on$\n+from pyspark.ml.feature import BucketedRandomProjectionLSH\n+from pyspark.ml.linalg import Vectors\n+# $example off$\n+from pyspark.sql import SparkSession\n+\n+\"\"\"\n+An example demonstrating BucketedRandomProjectionLSH.\n+Run with:\n+  bin/spark-submit examples/src/main/python/ml/bucketed_random_projection_lsh_example.py\n+\"\"\"\n+\n+if __name__ == \"__main__\":\n+    spark = SparkSession \\\n+        .builder \\\n+        .appName(\"BucketedRandomProjectionLSHExample\") \\\n+        .getOrCreate()\n+\n+    # $example on$\n+    dataA = [(0, Vectors.dense([1.0, 1.0]),),\n+             (1, Vectors.dense([1.0, -1.0]),),\n+             (2, Vectors.dense([-1.0, -1.0]),),\n+             (3, Vectors.dense([-1.0, 1.0]),)]\n+    dfA = spark.createDataFrame(dataA, [\"id\", \"features\"])\n+\n+    dataB = [(4, Vectors.dense([1.0, 0.0]),),\n+             (5, Vectors.dense([-1.0, 0.0]),),\n+             (6, Vectors.dense([0.0, 1.0]),),\n+             (7, Vectors.dense([0.0, -1.0]),)]\n+    dfB = spark.createDataFrame(dataB, [\"id\", \"features\"])\n+\n+    key = Vectors.dense([1.0, 0.0])\n+\n+    brp = BucketedRandomProjectionLSH(inputCol=\"features\", outputCol=\"hashes\", bucketLength=2.0,\n+                                      numHashTables=3)\n+    model = brp.fit(dfA)\n+\n+    # Feature Transformation\n+    print(\"The hashed dataset where hashed values are stored in the column 'values':\")\n+    model.transform(dfA).show()\n+    # Cache the transformed columns\n+    transformedA = model.transform(dfA).cache()\n+    transformedB = model.transform(dfB).cache()\n+\n+    # Approximate similarity join\n+    print(\"Approximately joining dfA and dfB on distance smaller than 1.5:\")\n+    model.approxSimilarityJoin(dfA, dfB, 1.5)\\\n+        .select(\"datasetA.id\", \"datasetB.id\", \"distCol\").show()\n+    print(\"Joining cached datasets to avoid recomputing the hash values:\")\n+    model.approxSimilarityJoin(transformedA, transformedB, 1.5)\\\n+        .select(\"datasetA.id\", \"datasetB.id\", \"distCol\").show()\n+\n+    # Self Join\n+    print(\"Approximately self join of dfB on distance smaller than 2.5:\")\n+    model.approxSimilarityJoin(dfA, dfA, 2.5).filter(\"datasetA.id < datasetB.id\")\\\n+        .select(\"datasetA.id\", \"datasetB.id\", \"distCol\").show()\n+\n+    # Approximate nearest neighbor search\n+    print(\"Approximately searching dfA for 2 nearest neighbors of the key:\")\n+    model.approxNearestNeighbors(dfA, key, 2).show()\n+    print(\"Searching cached dataset to avoid recomputing the hash values:\")"
  }],
  "prId": 16715
}, {
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "Can we add the appropriate note for this to the Scala and Java examples as well?",
    "commit": "36fd9bc6366d58541c8306803d8742649be69098",
    "createdAt": "2017-02-13T19:42:51Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\n+from __future__ import print_function\n+\n+# $example on$\n+from pyspark.ml.feature import BucketedRandomProjectionLSH\n+from pyspark.ml.linalg import Vectors\n+from pyspark.sql.functions import col\n+# $example off$\n+from pyspark.sql import SparkSession\n+\n+\"\"\"\n+An example demonstrating BucketedRandomProjectionLSH.\n+Run with:\n+  bin/spark-submit examples/src/main/python/ml/bucketed_random_projection_lsh_example.py",
    "line": 31
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Added in 4 places.",
    "commit": "36fd9bc6366d58541c8306803d8742649be69098",
    "createdAt": "2017-02-14T06:19:47Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\n+from __future__ import print_function\n+\n+# $example on$\n+from pyspark.ml.feature import BucketedRandomProjectionLSH\n+from pyspark.ml.linalg import Vectors\n+from pyspark.sql.functions import col\n+# $example off$\n+from pyspark.sql import SparkSession\n+\n+\"\"\"\n+An example demonstrating BucketedRandomProjectionLSH.\n+Run with:\n+  bin/spark-submit examples/src/main/python/ml/bucketed_random_projection_lsh_example.py",
    "line": 31
  }],
  "prId": 16715
}]