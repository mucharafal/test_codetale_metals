[{
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "nit: extra lines",
    "commit": "c78ebe8b466717f5e31d4ab39e48ad7b358b59a0",
    "createdAt": "2017-04-05T16:11:58Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.examples.sql.streaming;\n+\n+import org.apache.spark.api.java.function.FlatMapFunction;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.MapGroupsWithStateFunction;\n+import org.apache.spark.sql.*;\n+import org.apache.spark.sql.streaming.GroupState;\n+import org.apache.spark.sql.streaming.GroupStateTimeout;\n+import org.apache.spark.sql.streaming.StreamingQuery;\n+\n+import java.io.Serializable;\n+import java.sql.Timestamp;\n+import java.util.*;\n+\n+import scala.Tuple2;\n+\n+/**\n+ * Counts words in UTF8 encoded, '\\n' delimited text received from the network.\n+ * <p>\n+ * Usage: JavaStructuredNetworkWordCount <hostname> <port>\n+ * <hostname> and <port> describe the TCP server that Structured Streaming\n+ * would connect to receive data.\n+ * <p>\n+ * To run this on your local machine, you need to first run a Netcat server\n+ * `$ nc -lk 9999`\n+ * and then run the example\n+ * `$ bin/run-example sql.streaming.JavaStructuredSessionization\n+ * localhost 9999`\n+ */\n+public final class JavaStructuredSessionization {\n+\n+  public static void main(String[] args) throws Exception {\n+    if (args.length < 2) {\n+      System.err.println(\"Usage: JavaStructuredSessionization <hostname> <port>\");\n+      System.exit(1);\n+    }\n+\n+    String host = args[0];\n+    int port = Integer.parseInt(args[1]);\n+\n+    SparkSession spark = SparkSession\n+        .builder()\n+        .appName(\"JavaStructuredSessionization\")\n+        .getOrCreate();\n+\n+    // Create DataFrame representing the stream of input lines from connection to host:port\n+    Dataset<Row> lines = spark\n+        .readStream()\n+        .format(\"socket\")\n+        .option(\"host\", host)\n+        .option(\"port\", port)\n+        .option(\"includeTimestamp\", true)\n+        .load();\n+\n+    FlatMapFunction<LineWithTimestamp, Event> linesToEvents =\n+      new FlatMapFunction<LineWithTimestamp, Event>() {\n+        @Override\n+        public Iterator<Event> call(LineWithTimestamp lineWithTimestamp) throws Exception {\n+          ArrayList<Event> eventList = new ArrayList<Event>();\n+          for (String word : lineWithTimestamp.getLine().split(\" \")) {\n+            eventList.add(new Event(word, lineWithTimestamp.getTimestamp()));\n+          }\n+          System.out.println(\n+              \"Number of events from \" + lineWithTimestamp.getLine() + \" = \" + eventList.size());\n+          return eventList.iterator();\n+        }\n+      };\n+\n+    // Split the lines into words, treat words as sessionId of events\n+    Dataset<Event> events = lines\n+        .withColumnRenamed(\"value\", \"line\")\n+        .as(Encoders.bean(LineWithTimestamp.class))\n+        .flatMap(linesToEvents, Encoders.bean(Event.class));\n+\n+    // Sessionize the events. Track number of events, start and end timestamps of session, and\n+    // and report session updates.\n+    //\n+    // Step 1: Define the state update function\n+    MapGroupsWithStateFunction<String, Event, SessionInfo, SessionUpdate> stateUpdateFunc =\n+      new MapGroupsWithStateFunction<String, Event, SessionInfo, SessionUpdate>() {\n+        @Override public SessionUpdate call(\n+            String sessionId, Iterator<Event> events, GroupState<SessionInfo> state)\n+              throws Exception {\n+          // If timed out, then remove session and send final update\n+          if (state.hasTimedOut()) {\n+            SessionUpdate finalUpdate = new SessionUpdate(\n+                sessionId, state.get().getDurationMs(), state.get().getNumEvents(), true);\n+            state.remove();\n+            return finalUpdate;\n+\n+          } else {\n+            // Find max and min timestamps in events\n+            long maxTimestampMs = Long.MIN_VALUE;\n+            long minTimestampMs = Long.MAX_VALUE;\n+            int numNewEvents = 0;\n+            while (events.hasNext()) {\n+              Event e = events.next();\n+              long timestampMs = e.getTimestamp().getTime();\n+              maxTimestampMs = Math.max(timestampMs, maxTimestampMs);\n+              minTimestampMs = Math.min(timestampMs, minTimestampMs);\n+              numNewEvents += 1;\n+            }\n+            SessionInfo updatedSession = new SessionInfo();\n+\n+            // Update start and end timestamps in session\n+            if (state.exists()) {\n+              SessionInfo oldSession = state.get();\n+              updatedSession.setNumEvents(oldSession.numEvents + numNewEvents);\n+              updatedSession.setStartTimestampMs(oldSession.startTimestampMs);\n+              updatedSession.setEndTimestampMs(Math.max(oldSession.endTimestampMs, maxTimestampMs));\n+            } else {\n+              updatedSession.setNumEvents(numNewEvents);\n+              updatedSession.setStartTimestampMs(minTimestampMs);\n+              updatedSession.setEndTimestampMs(maxTimestampMs);\n+            }\n+            state.update(updatedSession);\n+            // Set timeout such that the session will be expired if no data received for 10 seconds\n+            state.setTimeoutDuration(\"10 seconds\");\n+            return new SessionUpdate(\n+                sessionId, state.get().getDurationMs(), state.get().getNumEvents(), false);\n+          }\n+        }\n+      };\n+\n+    // Step 2: Apply the state update function to the events streaming Dataset grouped by sessionId\n+    Dataset<SessionUpdate> sessionUpdates = events\n+        .groupByKey(\n+            new MapFunction<Event, String>() {\n+              @Override public String call(Event event) throws Exception {\n+                return event.getSessionId();\n+              }\n+            }, Encoders.STRING())\n+        .mapGroupsWithState(\n+            stateUpdateFunc,\n+            Encoders.bean(SessionInfo.class),\n+            Encoders.bean(SessionUpdate.class),\n+            GroupStateTimeout.ProcessingTimeTimeout());\n+\n+    // Start running the query that prints the session updates to the console\n+    StreamingQuery query = sessionUpdates\n+        .writeStream()\n+        .outputMode(\"update\")\n+        .format(\"console\")\n+        .start();\n+\n+    query.awaitTermination();\n+  }\n+\n+  /**\n+   * User-defined data type representing the raw lines with timestamps.\n+   */\n+  public static class LineWithTimestamp implements Serializable {\n+    private String line;\n+    private Timestamp timestamp;\n+\n+    public Timestamp getTimestamp() { return timestamp; }\n+    public void setTimestamp(Timestamp timestamp) { this.timestamp = timestamp; }\n+\n+    public String getLine() { return line; }\n+    public void setLine(String sessionId) { this.line = sessionId; }\n+  }\n+\n+  /**\n+   * User-defined data type representing the input events\n+   */\n+  public static class Event implements Serializable {\n+    private String sessionId;\n+    private Timestamp timestamp;\n+\n+    public Event() { }\n+    public Event(String sessionId, Timestamp timestamp) {\n+      this.sessionId = sessionId;\n+      this.timestamp = timestamp;\n+    }\n+\n+    public Timestamp getTimestamp() { return timestamp; }\n+    public void setTimestamp(Timestamp timestamp) { this.timestamp = timestamp; }\n+\n+    public String getSessionId() { return sessionId; }\n+    public void setSessionId(String sessionId) { this.sessionId = sessionId; }\n+  }\n+\n+  /**\n+   * User-defined data type for storing a session information as state in mapGroupsWithState.\n+   */\n+  public static class SessionInfo implements Serializable {\n+    private int numEvents = 0;\n+    private long startTimestampMs = -1;\n+    private long endTimestampMs = -1;\n+\n+    public int getNumEvents() { return numEvents; }\n+    public void setNumEvents(int numEvents) { this.numEvents = numEvents; }\n+\n+    public long getStartTimestampMs() { return startTimestampMs; }\n+    public void setStartTimestampMs(long startTimestampMs) {\n+      this.startTimestampMs = startTimestampMs;\n+    }\n+\n+    public long getEndTimestampMs() { return endTimestampMs; }\n+    public void setEndTimestampMs(long endTimestampMs) { this.endTimestampMs = endTimestampMs; }\n+\n+    public long getDurationMs() { return endTimestampMs - startTimestampMs; }\n+    @Override public String toString() {\n+      return \"SessionInfo(numEvents = \" + numEvents +\n+          \", timestamps = \" + startTimestampMs + \" to \" + endTimestampMs + \")\";\n+    }\n+  }\n+\n+  /**\n+   * User-defined data type representing the update information returned by mapGroupsWithState.\n+   */\n+  public static class SessionUpdate implements Serializable {\n+    private String id;\n+    private long durationMs;\n+    private int numEvents;\n+    private boolean expired;\n+\n+    public SessionUpdate() { }\n+\n+    public SessionUpdate(String id, long durationMs, int numEvents, boolean expired) {\n+      this.id = id;\n+      this.durationMs = durationMs;\n+      this.numEvents = numEvents;\n+      this.expired = expired;\n+    }\n+\n+    public String getId() { return id; }\n+    public void setId(String id) { this.id = id; }\n+\n+    public long getDurationMs() { return durationMs; }\n+    public void setDurationMs(long durationMs) { this.durationMs = durationMs; }\n+\n+    public int getNumEvents() { return numEvents; }\n+    public void setNumEvents(int numEvents) { this.numEvents = numEvents; }\n+\n+    public boolean isExpired() { return expired; }\n+    public void setExpired(boolean expired) { this.expired = expired; }\n+  }\n+}\n+"
  }],
  "prId": 17539
}]