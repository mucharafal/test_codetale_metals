[{
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "`=` -> `<-`?",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-06-18T06:27:29Z",
    "diffHunk": "@@ -36,188 +36,233 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod('writeObject')\n+writeObject.default = function(object, con, writeType = TRUE) {"
  }],
  "prId": 24888
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "ditto",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-06-18T06:27:55Z",
    "diffHunk": "@@ -36,188 +36,233 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod('writeObject')\n+writeObject.default = function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeType.list = function(object, con) {"
  }, {
    "author": {
      "login": "felixcheung"
    },
    "body": "all other places",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-06-18T06:28:16Z",
    "diffHunk": "@@ -36,188 +36,233 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod('writeObject')\n+writeObject.default = function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeType.list = function(object, con) {"
  }, {
    "author": {
      "login": "MichaelChirico"
    },
    "body": "Yep, have noted the style feedback from Jenkins. Will do when i get a chance.\r\n\r\nAbout the \"Remove comment\" feedbacks, it's just line-final comments that are out-of-style? each comment should get its own line?",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-06-18T06:47:17Z",
    "diffHunk": "@@ -36,188 +36,233 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod('writeObject')\n+writeObject.default = function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeType.list = function(object, con) {"
  }],
  "prId": 24888
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "I see error in the output\r\n```\r\nError: processing vignette 'sparkr-vignettes.Rmd' failed with diagnostics:\r\nargumemt is not a character vector\r\n```",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-06-27T07:28:27Z",
    "diffHunk": "@@ -36,192 +36,246 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod(\"writeObject\")\n+writeObject.default <- function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeObject.struct <-\n+writeObject.list <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    # writeType.list either writes array or list; TRUE is returned for list\n+    if (isTRUE(writeType(object, con))) {\n+      writeObject(length(object), con, writeType = FALSE)\n+      return(writeBin(object, con, endian = \"big\"))\n+    } else {\n+      return(writeArray(object, con))\n+    }\n+  }\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeArray(object, con))\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.jobj <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  if (!isValidJobj(object)) {\n+    stop(\"invalid jobj \", object$id)\n+  }\n+  writeObject(object$id, writeType = FALSE)\n+}\n+# Used to pass in hash maps required on Java side.\n+writeObject.environment <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  len <- length(object)\n+  writeObject(len, con, writeType = FALSE)\n+  if (len > 0L) {\n+    envObj <- ls(object)\n+    writeArray(as.list(envObj), con)\n+    writeObject(mget(envObj, object), writeType = FALSE)\n+  }\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.Date <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.character(object), con, writeType = FALSE)\n+}\n+# covers POSIXct and POSIXt\n+writeObject.POSIXt <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.double(object), con, writeType = FALSE)\n }\n \n-writeRawSerialize <- function(outputCon, batch) {\n+writeRawSerialize <- function(batch, outputCon) {\n   outputSer <- serialize(batch, ascii = FALSE, connection = NULL)\n-  writeRaw(outputCon, outputSer)\n+  writeObject(outputSer, outputCon, writeType = FALSE)\n }\n \n-writeRowSerialize <- function(outputCon, rows) {\n+writeRowSerialize <- function(rows, outputCon) {\n   invisible(lapply(rows, function(r) {\n     bytes <- serializeRow(r)\n-    writeRaw(outputCon, bytes)\n+    writeObject(bytes, outputCon, writeType = FALSE)\n   }))\n }\n \n serializeRow <- function(row) {\n-  rawObj <- rawConnection(raw(0), \"wb\")\n+  rawObj <- rawConnection(raw(0L), \"wb\")\n   on.exit(close(rawObj))\n-  writeList(rawObj, row)\n+  writeObject(as.list(row), rawObj, writeType = FALSE)\n   rawConnectionValue(rawObj)\n }\n \n-writeRaw <- function(con, batch) {\n-  writeInt(con, length(batch))\n-  writeBin(batch, con, endian = \"big\")\n-}\n-\n-writeType <- function(con, class) {\n-  type <- switch(class,\n-                 NULL = \"n\",\n-                 integer = \"i\",\n-                 character = \"c\",\n-                 logical = \"b\",\n-                 double = \"d\",\n-                 numeric = \"d\",\n-                 raw = \"r\",\n-                 array = \"a\",\n-                 list = \"l\",\n-                 struct = \"s\",\n-                 jobj = \"j\",\n-                 environment = \"e\",\n-                 Date = \"D\",\n-                 POSIXlt = \"t\",\n-                 POSIXct = \"t\",\n-                 stop(paste(\"Unsupported type for serialization\", class)))\n-  writeBin(charToRaw(type), con)\n-}\n \n-# Used to pass arrays where all the elements are of the same type\n-writeArray <- function(con, arr) {\n-  # TODO: Empty lists are given type \"character\" right now.\n-  # This may not work if the Java side expects array of any other type.\n-  if (length(arr) == 0) {\n-    elemType <- class(\"somestring\")\n-  } else {\n-    elemType <- getSerdeType(arr[[1]])\n-  }\n+writeType <- function(object, con) UseMethod(\"writeType\")\n+writeType.default <- function(object, con) {\n+  stop(\"Unsupported type for serialization\", class(object))\n+}\n \n-  writeType(con, elemType)\n-  writeInt(con, length(arr))\n+# markers are written into con to signal incoming object\n+#   type according to the following mapping:\n+#        type marker  raw\n+#        Date      D 0x44\n+#       array      a 0x61\n+#     logical      b 0x62\n+#   character      c 0x63\n+#     numeric      d 0x64\n+# environment      e 0x65\n+#     integer      i 0x69\n+#        jobj      j 0x6a\n+#        list      l 0x6c\n+#        null      n 0x6e\n+#         raw      r 0x72\n+#      struct      s 0x73\n+#      POSIXt      t 0x74\n \n-  if (length(arr) > 0) {\n-    for (a in arr) {\n-      writeObject(con, a, FALSE)\n-    }\n-  }\n+# 'is.na' only handles atomic vectors, lists and pairlists;\n+#   all atomic classes except complex are handled; complex will error\n+writeType.integer <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x69), con)\n }\n-\n-# Used to pass arrays where the elements can be of different types\n-writeList <- function(con, list) {\n-  writeInt(con, length(list))\n-  for (elem in list) {\n-    writeObject(con, elem)\n-  }\n+writeType.character <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x63), con)\n }\n-\n-# Used to pass in hash maps required on Java side.\n-writeEnv <- function(con, env) {\n-  len <- length(env)\n-\n-  writeInt(con, len)\n-  if (len > 0) {\n-    writeArray(con, as.list(ls(env)))\n-    vals <- lapply(ls(env), function(x) { env[[x]] })\n-    writeList(con, as.list(vals))\n+writeType.logical <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x62), con)\n+}\n+writeType.numeric <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x64), con)\n+}\n+writeType.raw <- function(object, con) {\n+  writeBin(as.raw(0x72), con)\n+}\n+writeType.list <- function(object, con) {\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeBin(as.raw(0x61), con))\n   }\n+  writeBin(as.raw(0x6c), con)\n+  # emit TRUE to signal that this object is being treated as a list\n+  return(TRUE)\n }\n-\n-writeDate <- function(con, date) {\n-  writeString(con, as.character(date))\n+writeType.struct <- function(object, con) {\n+  writeBin(as.raw(0x73), con)\n+}\n+writeType.jobj <- function(object, con) {\n+  writeBin(as.raw(0x6a), con)\n+}\n+writeType.environment <- function(object, con) {\n+  writeBin(as.raw(0x65), con)\n+}\n+writeType.Date <- function(object, con) {\n+  writeBin(as.raw(0x44), con)\n+}\n+# covers POSIXct and POSIXt\n+writeType.POSIXt <- function(object, con) {\n+  writeBin(as.raw(0x74), con)\n }\n \n-writeTime <- function(con, time) {\n-  writeDouble(con, as.double(time))\n+# Used to pass arrays where all the elements are of the same type\n+writeArray <- function(arr, con) {\n+  # TODO: Empty lists are given type \"character\" right now.\n+  # This may not work if the Java side expects array of any other type.\n+  writeType(if (length(arr) > 0L) arr[[1L]] else \"somestring\", con)\n+  writeObject(length(arr), con, writeType = FALSE)",
    "line": 348
  }, {
    "author": {
      "login": "MichaelChirico"
    },
    "body": "That's funny that there's a typo there. Didn't show up in either the `r-source` or my spark source.... investigating anyway",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-07-04T10:10:45Z",
    "diffHunk": "@@ -36,192 +36,246 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod(\"writeObject\")\n+writeObject.default <- function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeObject.struct <-\n+writeObject.list <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    # writeType.list either writes array or list; TRUE is returned for list\n+    if (isTRUE(writeType(object, con))) {\n+      writeObject(length(object), con, writeType = FALSE)\n+      return(writeBin(object, con, endian = \"big\"))\n+    } else {\n+      return(writeArray(object, con))\n+    }\n+  }\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeArray(object, con))\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.jobj <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  if (!isValidJobj(object)) {\n+    stop(\"invalid jobj \", object$id)\n+  }\n+  writeObject(object$id, writeType = FALSE)\n+}\n+# Used to pass in hash maps required on Java side.\n+writeObject.environment <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  len <- length(object)\n+  writeObject(len, con, writeType = FALSE)\n+  if (len > 0L) {\n+    envObj <- ls(object)\n+    writeArray(as.list(envObj), con)\n+    writeObject(mget(envObj, object), writeType = FALSE)\n+  }\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.Date <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.character(object), con, writeType = FALSE)\n+}\n+# covers POSIXct and POSIXt\n+writeObject.POSIXt <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.double(object), con, writeType = FALSE)\n }\n \n-writeRawSerialize <- function(outputCon, batch) {\n+writeRawSerialize <- function(batch, outputCon) {\n   outputSer <- serialize(batch, ascii = FALSE, connection = NULL)\n-  writeRaw(outputCon, outputSer)\n+  writeObject(outputSer, outputCon, writeType = FALSE)\n }\n \n-writeRowSerialize <- function(outputCon, rows) {\n+writeRowSerialize <- function(rows, outputCon) {\n   invisible(lapply(rows, function(r) {\n     bytes <- serializeRow(r)\n-    writeRaw(outputCon, bytes)\n+    writeObject(bytes, outputCon, writeType = FALSE)\n   }))\n }\n \n serializeRow <- function(row) {\n-  rawObj <- rawConnection(raw(0), \"wb\")\n+  rawObj <- rawConnection(raw(0L), \"wb\")\n   on.exit(close(rawObj))\n-  writeList(rawObj, row)\n+  writeObject(as.list(row), rawObj, writeType = FALSE)\n   rawConnectionValue(rawObj)\n }\n \n-writeRaw <- function(con, batch) {\n-  writeInt(con, length(batch))\n-  writeBin(batch, con, endian = \"big\")\n-}\n-\n-writeType <- function(con, class) {\n-  type <- switch(class,\n-                 NULL = \"n\",\n-                 integer = \"i\",\n-                 character = \"c\",\n-                 logical = \"b\",\n-                 double = \"d\",\n-                 numeric = \"d\",\n-                 raw = \"r\",\n-                 array = \"a\",\n-                 list = \"l\",\n-                 struct = \"s\",\n-                 jobj = \"j\",\n-                 environment = \"e\",\n-                 Date = \"D\",\n-                 POSIXlt = \"t\",\n-                 POSIXct = \"t\",\n-                 stop(paste(\"Unsupported type for serialization\", class)))\n-  writeBin(charToRaw(type), con)\n-}\n \n-# Used to pass arrays where all the elements are of the same type\n-writeArray <- function(con, arr) {\n-  # TODO: Empty lists are given type \"character\" right now.\n-  # This may not work if the Java side expects array of any other type.\n-  if (length(arr) == 0) {\n-    elemType <- class(\"somestring\")\n-  } else {\n-    elemType <- getSerdeType(arr[[1]])\n-  }\n+writeType <- function(object, con) UseMethod(\"writeType\")\n+writeType.default <- function(object, con) {\n+  stop(\"Unsupported type for serialization\", class(object))\n+}\n \n-  writeType(con, elemType)\n-  writeInt(con, length(arr))\n+# markers are written into con to signal incoming object\n+#   type according to the following mapping:\n+#        type marker  raw\n+#        Date      D 0x44\n+#       array      a 0x61\n+#     logical      b 0x62\n+#   character      c 0x63\n+#     numeric      d 0x64\n+# environment      e 0x65\n+#     integer      i 0x69\n+#        jobj      j 0x6a\n+#        list      l 0x6c\n+#        null      n 0x6e\n+#         raw      r 0x72\n+#      struct      s 0x73\n+#      POSIXt      t 0x74\n \n-  if (length(arr) > 0) {\n-    for (a in arr) {\n-      writeObject(con, a, FALSE)\n-    }\n-  }\n+# 'is.na' only handles atomic vectors, lists and pairlists;\n+#   all atomic classes except complex are handled; complex will error\n+writeType.integer <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x69), con)\n }\n-\n-# Used to pass arrays where the elements can be of different types\n-writeList <- function(con, list) {\n-  writeInt(con, length(list))\n-  for (elem in list) {\n-    writeObject(con, elem)\n-  }\n+writeType.character <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x63), con)\n }\n-\n-# Used to pass in hash maps required on Java side.\n-writeEnv <- function(con, env) {\n-  len <- length(env)\n-\n-  writeInt(con, len)\n-  if (len > 0) {\n-    writeArray(con, as.list(ls(env)))\n-    vals <- lapply(ls(env), function(x) { env[[x]] })\n-    writeList(con, as.list(vals))\n+writeType.logical <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x62), con)\n+}\n+writeType.numeric <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x64), con)\n+}\n+writeType.raw <- function(object, con) {\n+  writeBin(as.raw(0x72), con)\n+}\n+writeType.list <- function(object, con) {\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeBin(as.raw(0x61), con))\n   }\n+  writeBin(as.raw(0x6c), con)\n+  # emit TRUE to signal that this object is being treated as a list\n+  return(TRUE)\n }\n-\n-writeDate <- function(con, date) {\n-  writeString(con, as.character(date))\n+writeType.struct <- function(object, con) {\n+  writeBin(as.raw(0x73), con)\n+}\n+writeType.jobj <- function(object, con) {\n+  writeBin(as.raw(0x6a), con)\n+}\n+writeType.environment <- function(object, con) {\n+  writeBin(as.raw(0x65), con)\n+}\n+writeType.Date <- function(object, con) {\n+  writeBin(as.raw(0x44), con)\n+}\n+# covers POSIXct and POSIXt\n+writeType.POSIXt <- function(object, con) {\n+  writeBin(as.raw(0x74), con)\n }\n \n-writeTime <- function(con, time) {\n-  writeDouble(con, as.double(time))\n+# Used to pass arrays where all the elements are of the same type\n+writeArray <- function(arr, con) {\n+  # TODO: Empty lists are given type \"character\" right now.\n+  # This may not work if the Java side expects array of any other type.\n+  writeType(if (length(arr) > 0L) arr[[1L]] else \"somestring\", con)\n+  writeObject(length(arr), con, writeType = FALSE)",
    "line": 348
  }, {
    "author": {
      "login": "MichaelChirico"
    },
    "body": "Will have to try from my home machine. Having trouble reproducing on my mac since I've the wrong Java & I dare not touch it. Could try and do it from Docker but I haven't installed it on the new machine yet... btw do you have a favorite Docker image for debugging Spark?",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-07-04T12:05:17Z",
    "diffHunk": "@@ -36,192 +36,246 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod(\"writeObject\")\n+writeObject.default <- function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeObject.struct <-\n+writeObject.list <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    # writeType.list either writes array or list; TRUE is returned for list\n+    if (isTRUE(writeType(object, con))) {\n+      writeObject(length(object), con, writeType = FALSE)\n+      return(writeBin(object, con, endian = \"big\"))\n+    } else {\n+      return(writeArray(object, con))\n+    }\n+  }\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeArray(object, con))\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.jobj <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  if (!isValidJobj(object)) {\n+    stop(\"invalid jobj \", object$id)\n+  }\n+  writeObject(object$id, writeType = FALSE)\n+}\n+# Used to pass in hash maps required on Java side.\n+writeObject.environment <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  len <- length(object)\n+  writeObject(len, con, writeType = FALSE)\n+  if (len > 0L) {\n+    envObj <- ls(object)\n+    writeArray(as.list(envObj), con)\n+    writeObject(mget(envObj, object), writeType = FALSE)\n+  }\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.Date <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.character(object), con, writeType = FALSE)\n+}\n+# covers POSIXct and POSIXt\n+writeObject.POSIXt <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.double(object), con, writeType = FALSE)\n }\n \n-writeRawSerialize <- function(outputCon, batch) {\n+writeRawSerialize <- function(batch, outputCon) {\n   outputSer <- serialize(batch, ascii = FALSE, connection = NULL)\n-  writeRaw(outputCon, outputSer)\n+  writeObject(outputSer, outputCon, writeType = FALSE)\n }\n \n-writeRowSerialize <- function(outputCon, rows) {\n+writeRowSerialize <- function(rows, outputCon) {\n   invisible(lapply(rows, function(r) {\n     bytes <- serializeRow(r)\n-    writeRaw(outputCon, bytes)\n+    writeObject(bytes, outputCon, writeType = FALSE)\n   }))\n }\n \n serializeRow <- function(row) {\n-  rawObj <- rawConnection(raw(0), \"wb\")\n+  rawObj <- rawConnection(raw(0L), \"wb\")\n   on.exit(close(rawObj))\n-  writeList(rawObj, row)\n+  writeObject(as.list(row), rawObj, writeType = FALSE)\n   rawConnectionValue(rawObj)\n }\n \n-writeRaw <- function(con, batch) {\n-  writeInt(con, length(batch))\n-  writeBin(batch, con, endian = \"big\")\n-}\n-\n-writeType <- function(con, class) {\n-  type <- switch(class,\n-                 NULL = \"n\",\n-                 integer = \"i\",\n-                 character = \"c\",\n-                 logical = \"b\",\n-                 double = \"d\",\n-                 numeric = \"d\",\n-                 raw = \"r\",\n-                 array = \"a\",\n-                 list = \"l\",\n-                 struct = \"s\",\n-                 jobj = \"j\",\n-                 environment = \"e\",\n-                 Date = \"D\",\n-                 POSIXlt = \"t\",\n-                 POSIXct = \"t\",\n-                 stop(paste(\"Unsupported type for serialization\", class)))\n-  writeBin(charToRaw(type), con)\n-}\n \n-# Used to pass arrays where all the elements are of the same type\n-writeArray <- function(con, arr) {\n-  # TODO: Empty lists are given type \"character\" right now.\n-  # This may not work if the Java side expects array of any other type.\n-  if (length(arr) == 0) {\n-    elemType <- class(\"somestring\")\n-  } else {\n-    elemType <- getSerdeType(arr[[1]])\n-  }\n+writeType <- function(object, con) UseMethod(\"writeType\")\n+writeType.default <- function(object, con) {\n+  stop(\"Unsupported type for serialization\", class(object))\n+}\n \n-  writeType(con, elemType)\n-  writeInt(con, length(arr))\n+# markers are written into con to signal incoming object\n+#   type according to the following mapping:\n+#        type marker  raw\n+#        Date      D 0x44\n+#       array      a 0x61\n+#     logical      b 0x62\n+#   character      c 0x63\n+#     numeric      d 0x64\n+# environment      e 0x65\n+#     integer      i 0x69\n+#        jobj      j 0x6a\n+#        list      l 0x6c\n+#        null      n 0x6e\n+#         raw      r 0x72\n+#      struct      s 0x73\n+#      POSIXt      t 0x74\n \n-  if (length(arr) > 0) {\n-    for (a in arr) {\n-      writeObject(con, a, FALSE)\n-    }\n-  }\n+# 'is.na' only handles atomic vectors, lists and pairlists;\n+#   all atomic classes except complex are handled; complex will error\n+writeType.integer <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x69), con)\n }\n-\n-# Used to pass arrays where the elements can be of different types\n-writeList <- function(con, list) {\n-  writeInt(con, length(list))\n-  for (elem in list) {\n-    writeObject(con, elem)\n-  }\n+writeType.character <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x63), con)\n }\n-\n-# Used to pass in hash maps required on Java side.\n-writeEnv <- function(con, env) {\n-  len <- length(env)\n-\n-  writeInt(con, len)\n-  if (len > 0) {\n-    writeArray(con, as.list(ls(env)))\n-    vals <- lapply(ls(env), function(x) { env[[x]] })\n-    writeList(con, as.list(vals))\n+writeType.logical <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x62), con)\n+}\n+writeType.numeric <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x64), con)\n+}\n+writeType.raw <- function(object, con) {\n+  writeBin(as.raw(0x72), con)\n+}\n+writeType.list <- function(object, con) {\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeBin(as.raw(0x61), con))\n   }\n+  writeBin(as.raw(0x6c), con)\n+  # emit TRUE to signal that this object is being treated as a list\n+  return(TRUE)\n }\n-\n-writeDate <- function(con, date) {\n-  writeString(con, as.character(date))\n+writeType.struct <- function(object, con) {\n+  writeBin(as.raw(0x73), con)\n+}\n+writeType.jobj <- function(object, con) {\n+  writeBin(as.raw(0x6a), con)\n+}\n+writeType.environment <- function(object, con) {\n+  writeBin(as.raw(0x65), con)\n+}\n+writeType.Date <- function(object, con) {\n+  writeBin(as.raw(0x44), con)\n+}\n+# covers POSIXct and POSIXt\n+writeType.POSIXt <- function(object, con) {\n+  writeBin(as.raw(0x74), con)\n }\n \n-writeTime <- function(con, time) {\n-  writeDouble(con, as.double(time))\n+# Used to pass arrays where all the elements are of the same type\n+writeArray <- function(arr, con) {\n+  # TODO: Empty lists are given type \"character\" right now.\n+  # This may not work if the Java side expects array of any other type.\n+  writeType(if (length(arr) > 0L) arr[[1L]] else \"somestring\", con)\n+  writeObject(length(arr), con, writeType = FALSE)",
    "line": 348
  }, {
    "author": {
      "login": "MichaelChirico"
    },
    "body": "Hey @felixcheung have finally sort-of got a Docker image able to build Spark from source to help me iterate locally 🎉 \r\n\r\nI'm able to build Spark on master with `./build/mvn -DskipTests clean package -X`, but on the branch here I get:\r\n\r\n```\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Reactor Summary for Spark Project Parent POM 3.0.0-SNAPSHOT:\r\n[INFO] \r\n[INFO] Spark Project Parent POM ........................... SUCCESS [04:47 min]\r\n[INFO] Spark Project Tags ................................. SUCCESS [ 30.888 s]\r\n[INFO] Spark Project Sketch ............................... SUCCESS [  4.329 s]\r\n[INFO] Spark Project Local DB ............................. SUCCESS [ 15.605 s]\r\n[INFO] Spark Project Networking ........................... SUCCESS [ 14.312 s]\r\n[INFO] Spark Project Shuffle Streaming Service ............ SUCCESS [  5.987 s]\r\n[INFO] Spark Project Unsafe ............................... SUCCESS [ 11.286 s]\r\n[INFO] Spark Project Launcher ............................. SUCCESS [ 46.401 s]\r\n[INFO] Spark Project Core ................................. SUCCESS [02:46 min]\r\n[INFO] Spark Project ML Local Library ..................... SUCCESS [ 14.346 s]\r\n[INFO] Spark Project GraphX ............................... SUCCESS [ 12.020 s]\r\n[INFO] Spark Project Streaming ............................ SUCCESS [ 28.049 s]\r\n[INFO] Spark Project Catalyst ............................. SUCCESS [01:52 min]\r\n[INFO] Spark Project SQL .................................. SUCCESS [02:41 min]\r\n[INFO] Spark Project ML Library ........................... FAILURE [01:26 min]\r\n[INFO] Spark Project Tools ................................ SKIPPED\r\n[INFO] Spark Project Hive ................................. SKIPPED\r\n[INFO] Spark Project Graph API ............................ SKIPPED\r\n[INFO] Spark Project Cypher ............................... SKIPPED\r\n[INFO] Spark Project Graph ................................ SKIPPED\r\n[INFO] Spark Project REPL ................................. SKIPPED\r\n[INFO] Spark Project Assembly ............................. SKIPPED\r\n[INFO] Kafka 0.10+ Token Provider for Streaming ........... SKIPPED\r\n[INFO] Spark Integration for Kafka 0.10 ................... SKIPPED\r\n[INFO] Kafka 0.10+ Source for Structured Streaming ........ SKIPPED\r\n[INFO] Spark Project Examples ............................. SKIPPED\r\n[INFO] Spark Integration for Kafka 0.10 Assembly .......... SKIPPED\r\n[INFO] Spark Avro ......................................... SKIPPED\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD FAILURE\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time:  16:41 min\r\n[INFO] Finished at: 2019-09-16T01:47:41Z\r\n[INFO] ------------------------------------------------------------------------\r\n[ERROR] Failed to execute goal net.alchim31.maven:scala-maven-plugin:3.4.4:testCompile (scala-test-compile-first) on project spark-mllib_2.12: Execution scala-test-compile-first of goal net.alchim31.maven:scala-maven-plugin:3.4.4:testCompile failed.: CompileFailed -> [Help 1]\r\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal net.alchim31.maven:scala-maven-plugin:3.4.4:testCompile (scala-test-compile-first) on project spark-mllib_2.12: Execution scala-test-compile-first of goal net.alchim31.maven:scala-maven-plugin:3.4.4:testCompile failed.\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:215)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\nCaused by: org.apache.maven.plugin.PluginExecutionException: Execution scala-test-compile-first of goal net.alchim31.maven:scala-maven-plugin:3.4.4:testCompile failed.\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:148)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\nCaused by: sbt.compiler.CompileFailed\r\n    at sbt_inc.SbtIncrementalCompiler.zincCompile (SbtIncrementalCompiler.java:146)\r\n    at sbt_inc.SbtIncrementalCompiler.compile (SbtIncrementalCompiler.java:88)\r\n    at scala_maven.ScalaCompilerSupport.incrementalCompile (ScalaCompilerSupport.java:320)\r\n    at scala_maven.ScalaCompilerSupport.compile (ScalaCompilerSupport.java:136)\r\n    at scala_maven.ScalaCompilerSupport.doExecute (ScalaCompilerSupport.java:116)\r\n    at scala_maven.ScalaMojoSupport.execute (ScalaMojoSupport.java:574)\r\n    at scala_maven.ScalaTestCompileMojo.execute (ScalaTestCompileMojo.java:50)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\n[ERROR] \r\n[ERROR] \r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/PluginExecutionException\r\n[ERROR] \r\n[ERROR] After correcting the problems, you can resume the build with the command\r\n[ERROR]   mvn <goals> -rf :spark-mllib_2.12\r\n```\r\n\r\nIt doesn't seem like particularly helpful diagnostics to me? Any insight on how to proceed?",
    "commit": "8dafcd2fb72d3cc9a80d82b6c63571bf678820d0",
    "createdAt": "2019-09-16T03:13:23Z",
    "diffHunk": "@@ -36,192 +36,246 @@\n # nolint end\n \n getSerdeType <- function(object) {\n-  type <- class(object)[[1]]\n-  if (is.atomic(object) & !is.raw(object) & length(object) > 1) {\n+  type <- class(object)[[1L]]\n+  if (is.atomic(object) & !is.raw(object) & length(object) > 1L) {\n     \"array\"\n   } else if (type != \"list\") {\n      type\n   } else {\n     # Check if all elements are of same type\n     elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n-    if (length(elemType) <= 1) {\n+    if (length(elemType) <= 1L) {\n       \"array\"\n     } else {\n       \"list\"\n     }\n   }\n }\n \n-writeObject <- function(con, object, writeType = TRUE) {\n-  # NOTE: In R vectors have same type as objects\n-  type <- class(object)[[1]]  # class of POSIXlt is c(\"POSIXlt\", \"POSIXt\")\n-  # Checking types is needed here, since 'is.na' only handles atomic vectors,\n-  # lists and pairlists\n-  if (type %in% c(\"integer\", \"character\", \"logical\", \"double\", \"numeric\")) {\n-    if (is.na(object)) {\n-      object <- NULL\n-      type <- \"NULL\"\n-    }\n-  }\n+# NOTE: In R vectors have same type as objects\n+writeObject <- function(object, con, writeType = TRUE) UseMethod(\"writeObject\")\n+writeObject.default <- function(object, con, writeType = TRUE) {\n+  stop(paste(\"Unsupported type for serialization\", class(object)))\n+}\n \n-  serdeType <- getSerdeType(object)\n+# integer same as logical; will cast TRUE -> 1, FALSE -> 0\n+writeObject.integer <-\n+writeObject.logical <- function(object, con, writeType = TRUE) {\n   if (writeType) {\n-    writeType(con, serdeType)\n+    writeType(object, con)\n   }\n-  switch(serdeType,\n-         NULL = writeVoid(con),\n-         integer = writeInt(con, object),\n-         character = writeString(con, object),\n-         logical = writeBoolean(con, object),\n-         double = writeDouble(con, object),\n-         numeric = writeDouble(con, object),\n-         raw = writeRaw(con, object),\n-         array = writeArray(con, object),\n-         list = writeList(con, object),\n-         struct = writeList(con, object),\n-         jobj = writeJobj(con, object),\n-         environment = writeEnv(con, object),\n-         Date = writeDate(con, object),\n-         POSIXlt = writeTime(con, object),\n-         POSIXct = writeTime(con, object),\n-         stop(paste(\"Unsupported type for serialization\", type)))\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeVoid <- function(con) {\n-  # no value for NULL\n+  writeBin(as.integer(object), con, endian = \"big\")\n }\n-\n-writeJobj <- function(con, value) {\n-  if (!isValidJobj(value)) {\n-    stop(\"invalid jobj \", value$id)\n+writeObject.character <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n   }\n-  writeString(con, value$id)\n-}\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeString <- function(con, value) {\n   utfVal <- enc2utf8(value)\n-  writeInt(con, as.integer(nchar(utfVal, type = \"bytes\") + 1))\n+  writeObject(as.integer(nchar(utfVal, type = \"bytes\") + 1L), writeType = FALSE)\n   writeBin(utfVal, con, endian = \"big\", useBytes = TRUE)\n }\n+writeObject.numeric <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeArray(object, con))\n+  if (is.na(object)) return() # no value for NULL\n \n-writeInt <- function(con, value) {\n-  writeBin(as.integer(value), con, endian = \"big\")\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeDouble <- function(con, value) {\n-  writeBin(value, con, endian = \"big\")\n+writeObject.raw <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n }\n-\n-writeBoolean <- function(con, value) {\n-  # TRUE becomes 1, FALSE becomes 0\n-  writeInt(con, as.integer(value))\n+writeObject.struct <-\n+writeObject.list <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    # writeType.list either writes array or list; TRUE is returned for list\n+    if (isTRUE(writeType(object, con))) {\n+      writeObject(length(object), con, writeType = FALSE)\n+      return(writeBin(object, con, endian = \"big\"))\n+    } else {\n+      return(writeArray(object, con))\n+    }\n+  }\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeArray(object, con))\n+  }\n+  writeObject(length(object), con, writeType = FALSE)\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.jobj <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  if (!isValidJobj(object)) {\n+    stop(\"invalid jobj \", object$id)\n+  }\n+  writeObject(object$id, writeType = FALSE)\n+}\n+# Used to pass in hash maps required on Java side.\n+writeObject.environment <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  len <- length(object)\n+  writeObject(len, con, writeType = FALSE)\n+  if (len > 0L) {\n+    envObj <- ls(object)\n+    writeArray(as.list(envObj), con)\n+    writeObject(mget(envObj, object), writeType = FALSE)\n+  }\n+  writeBin(object, con, endian = \"big\")\n+}\n+writeObject.Date <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.character(object), con, writeType = FALSE)\n+}\n+# covers POSIXct and POSIXt\n+writeObject.POSIXt <- function(object, con, writeType = TRUE) {\n+  if (writeType) {\n+    writeType(object, con)\n+  }\n+  writeObject(as.double(object), con, writeType = FALSE)\n }\n \n-writeRawSerialize <- function(outputCon, batch) {\n+writeRawSerialize <- function(batch, outputCon) {\n   outputSer <- serialize(batch, ascii = FALSE, connection = NULL)\n-  writeRaw(outputCon, outputSer)\n+  writeObject(outputSer, outputCon, writeType = FALSE)\n }\n \n-writeRowSerialize <- function(outputCon, rows) {\n+writeRowSerialize <- function(rows, outputCon) {\n   invisible(lapply(rows, function(r) {\n     bytes <- serializeRow(r)\n-    writeRaw(outputCon, bytes)\n+    writeObject(bytes, outputCon, writeType = FALSE)\n   }))\n }\n \n serializeRow <- function(row) {\n-  rawObj <- rawConnection(raw(0), \"wb\")\n+  rawObj <- rawConnection(raw(0L), \"wb\")\n   on.exit(close(rawObj))\n-  writeList(rawObj, row)\n+  writeObject(as.list(row), rawObj, writeType = FALSE)\n   rawConnectionValue(rawObj)\n }\n \n-writeRaw <- function(con, batch) {\n-  writeInt(con, length(batch))\n-  writeBin(batch, con, endian = \"big\")\n-}\n-\n-writeType <- function(con, class) {\n-  type <- switch(class,\n-                 NULL = \"n\",\n-                 integer = \"i\",\n-                 character = \"c\",\n-                 logical = \"b\",\n-                 double = \"d\",\n-                 numeric = \"d\",\n-                 raw = \"r\",\n-                 array = \"a\",\n-                 list = \"l\",\n-                 struct = \"s\",\n-                 jobj = \"j\",\n-                 environment = \"e\",\n-                 Date = \"D\",\n-                 POSIXlt = \"t\",\n-                 POSIXct = \"t\",\n-                 stop(paste(\"Unsupported type for serialization\", class)))\n-  writeBin(charToRaw(type), con)\n-}\n \n-# Used to pass arrays where all the elements are of the same type\n-writeArray <- function(con, arr) {\n-  # TODO: Empty lists are given type \"character\" right now.\n-  # This may not work if the Java side expects array of any other type.\n-  if (length(arr) == 0) {\n-    elemType <- class(\"somestring\")\n-  } else {\n-    elemType <- getSerdeType(arr[[1]])\n-  }\n+writeType <- function(object, con) UseMethod(\"writeType\")\n+writeType.default <- function(object, con) {\n+  stop(\"Unsupported type for serialization\", class(object))\n+}\n \n-  writeType(con, elemType)\n-  writeInt(con, length(arr))\n+# markers are written into con to signal incoming object\n+#   type according to the following mapping:\n+#        type marker  raw\n+#        Date      D 0x44\n+#       array      a 0x61\n+#     logical      b 0x62\n+#   character      c 0x63\n+#     numeric      d 0x64\n+# environment      e 0x65\n+#     integer      i 0x69\n+#        jobj      j 0x6a\n+#        list      l 0x6c\n+#        null      n 0x6e\n+#         raw      r 0x72\n+#      struct      s 0x73\n+#      POSIXt      t 0x74\n \n-  if (length(arr) > 0) {\n-    for (a in arr) {\n-      writeObject(con, a, FALSE)\n-    }\n-  }\n+# 'is.na' only handles atomic vectors, lists and pairlists;\n+#   all atomic classes except complex are handled; complex will error\n+writeType.integer <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x69), con)\n }\n-\n-# Used to pass arrays where the elements can be of different types\n-writeList <- function(con, list) {\n-  writeInt(con, length(list))\n-  for (elem in list) {\n-    writeObject(con, elem)\n-  }\n+writeType.character <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x63), con)\n }\n-\n-# Used to pass in hash maps required on Java side.\n-writeEnv <- function(con, env) {\n-  len <- length(env)\n-\n-  writeInt(con, len)\n-  if (len > 0) {\n-    writeArray(con, as.list(ls(env)))\n-    vals <- lapply(ls(env), function(x) { env[[x]] })\n-    writeList(con, as.list(vals))\n+writeType.logical <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x62), con)\n+}\n+writeType.numeric <- function(object, con) {\n+  # non-scalar value written as array\n+  if (length(object) > 1L) return(writeBin(as.raw(0x61), con))\n+  if (is.na(object)) return(writeBin(as.raw(0x6e), con))\n+  writeBin(as.raw(0x64), con)\n+}\n+writeType.raw <- function(object, con) {\n+  writeBin(as.raw(0x72), con)\n+}\n+writeType.list <- function(object, con) {\n+  # Check if all elements are of same type\n+  elemType <- unique(sapply(object, function(elem) { getSerdeType(elem) }))\n+  if (length(elemType) <= 1L) {\n+    return(writeBin(as.raw(0x61), con))\n   }\n+  writeBin(as.raw(0x6c), con)\n+  # emit TRUE to signal that this object is being treated as a list\n+  return(TRUE)\n }\n-\n-writeDate <- function(con, date) {\n-  writeString(con, as.character(date))\n+writeType.struct <- function(object, con) {\n+  writeBin(as.raw(0x73), con)\n+}\n+writeType.jobj <- function(object, con) {\n+  writeBin(as.raw(0x6a), con)\n+}\n+writeType.environment <- function(object, con) {\n+  writeBin(as.raw(0x65), con)\n+}\n+writeType.Date <- function(object, con) {\n+  writeBin(as.raw(0x44), con)\n+}\n+# covers POSIXct and POSIXt\n+writeType.POSIXt <- function(object, con) {\n+  writeBin(as.raw(0x74), con)\n }\n \n-writeTime <- function(con, time) {\n-  writeDouble(con, as.double(time))\n+# Used to pass arrays where all the elements are of the same type\n+writeArray <- function(arr, con) {\n+  # TODO: Empty lists are given type \"character\" right now.\n+  # This may not work if the Java side expects array of any other type.\n+  writeType(if (length(arr) > 0L) arr[[1L]] else \"somestring\", con)\n+  writeObject(length(arr), con, writeType = FALSE)",
    "line": 348
  }],
  "prId": 24888
}]