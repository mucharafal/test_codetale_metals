[{
  "comments": [{
    "author": {
      "login": "mtustin-handy"
    },
    "body": "Why \"default\" rather than \"example\"?\n",
    "commit": "83d936870ad0651fc2622593e53d3e31d7eb8d4b",
    "createdAt": "2016-10-07T19:16:26Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.cloud.s3\n+\n+/**\n+ * S3A constants. Different Hadoop versions have an incomplete set of these; keeping them\n+ * in source here ensures that there are no compile/link problems.\n+ */\n+object S3AConstants {\n+  val ACCESS_KEY = \"fs.s3a.access.key\"\n+  val SECRET_KEY = \"fs.s3a.secret.key\"\n+  val AWS_CREDENTIALS_PROVIDER = \"fs.s3a.aws.credentials.provider\"\n+  val ANONYMOUS_CREDENTIALS = \"org.apache.hadoop.fs.s3a.AnonymousAWSCredentialsProvider\"\n+  val SESSION_TOKEN = \"fs.s3a.session.token\"\n+  val MAXIMUM_CONNECTIONS = \"fs.s3a.connection.maximum\"\n+  val SECURE_CONNECTIONS = \"fs.s3a.connection.ssl.enabled\"\n+  val ENDPOINT = \"fs.s3a.endpoint\"\n+  val PATH_STYLE_ACCESS = \"fs.s3a.path.style.access\"\n+  val PROXY_HOST = \"fs.s3a.proxy.host\"\n+  val PROXY_PORT = \"fs.s3a.proxy.port\"\n+  val PROXY_USERNAME = \"fs.s3a.proxy.username\"\n+  val PROXY_PASSWORD = \"fs.s3a.proxy.password\"\n+  val PROXY_DOMAIN = \"fs.s3a.proxy.domain\"\n+  val PROXY_WORKSTATION = \"fs.s3a.proxy.workstation\"\n+  val MAX_ERROR_RETRIES = \"fs.s3a.attempts.maximum\"\n+  val ESTABLISH_TIMEOUT = \"fs.s3a.connection.establish.timeout\"\n+  val SOCKET_TIMEOUT = \"fs.s3a.connection.timeout\"\n+  val MAX_PAGING_KEYS = \"fs.s3a.paging.maximum\"\n+  val MAX_THREADS = \"fs.s3a.threads.max\"\n+  val KEEPALIVE_TIME = \"fs.s3a.threads.keepalivetime\"\n+  val MAX_TOTAL_TASKS = \"fs.s3a.max.total.tasks\"\n+  val MULTIPART_SIZE = \"fs.s3a.multipart.size\"\n+  val MIN_PERMITTED_MULTIPART_SIZE = 5 * (1024 * 1024)\n+  val MIN_MULTIPART_THRESHOLD = \"fs.s3a.multipart.threshold\"\n+  val ENABLE_MULTI_DELETE = \"fs.s3a.multiobjectdelete.enable\"\n+  val BUFFER_DIR = \"fs.s3a.buffer.dir\"\n+  val FAST_UPLOAD = \"fs.s3a.fast.upload\"\n+  val FAST_BUFFER_SIZE = \"fs.s3a.fast.buffer.size\"\n+  val PURGE_EXISTING_MULTIPART = \"fs.s3a.multipart.purge\"\n+  val PURGE_EXISTING_MULTIPART_AGE = \"fs.s3a.multipart.purge.age\"\n+  val SERVER_SIDE_ENCRYPTION_ALGORITHM = \"fs.s3a.server-side-encryption-algorithm\"\n+  val SERVER_SIDE_ENCRYPTION_AES256 = \"AES256\"\n+  val SIGNING_ALGORITHM = \"fs.s3a.signing-algorithm\"\n+  val BLOCK_SIZE = \"fs.s3a.block.size\"\n+  val FS_S3A = \"s3a\"\n+  val USER_AGENT_PREFIX = \"fs.s3a.user.agent.prefix\"\n+  val READAHEAD_RANGE = \"fs.s3a.readahead.range\"\n+  val INPUT_FADVISE = \"fs.s3a.experimental.input.fadvise\";\n+  val SEQUENTIAL_IO = \"sequential\"\n+  val NORMAL_IO = \"normal\"\n+  val RANDOM_IO = \"random\"\n+\n+  /**\n+   * Default source of a public multi-MB CSV file.\n+   */\n+  val S3A_CSV_PATH_DEFAULT = \"s3a://landsat-pds/scene_list.gz\""
  }, {
    "author": {
      "login": "steveloughran"
    },
    "body": "Good q. could be either. I've been using it as a test path for reading a 20MB CSV file which costs $0 to use; the tests are set up so that people testing s3 against their own S3 implementation can switch to a different one. But as you note: it's an example, so the name should be more appropriate. Will fix\n",
    "commit": "83d936870ad0651fc2622593e53d3e31d7eb8d4b",
    "createdAt": "2016-10-08T13:31:05Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.cloud.s3\n+\n+/**\n+ * S3A constants. Different Hadoop versions have an incomplete set of these; keeping them\n+ * in source here ensures that there are no compile/link problems.\n+ */\n+object S3AConstants {\n+  val ACCESS_KEY = \"fs.s3a.access.key\"\n+  val SECRET_KEY = \"fs.s3a.secret.key\"\n+  val AWS_CREDENTIALS_PROVIDER = \"fs.s3a.aws.credentials.provider\"\n+  val ANONYMOUS_CREDENTIALS = \"org.apache.hadoop.fs.s3a.AnonymousAWSCredentialsProvider\"\n+  val SESSION_TOKEN = \"fs.s3a.session.token\"\n+  val MAXIMUM_CONNECTIONS = \"fs.s3a.connection.maximum\"\n+  val SECURE_CONNECTIONS = \"fs.s3a.connection.ssl.enabled\"\n+  val ENDPOINT = \"fs.s3a.endpoint\"\n+  val PATH_STYLE_ACCESS = \"fs.s3a.path.style.access\"\n+  val PROXY_HOST = \"fs.s3a.proxy.host\"\n+  val PROXY_PORT = \"fs.s3a.proxy.port\"\n+  val PROXY_USERNAME = \"fs.s3a.proxy.username\"\n+  val PROXY_PASSWORD = \"fs.s3a.proxy.password\"\n+  val PROXY_DOMAIN = \"fs.s3a.proxy.domain\"\n+  val PROXY_WORKSTATION = \"fs.s3a.proxy.workstation\"\n+  val MAX_ERROR_RETRIES = \"fs.s3a.attempts.maximum\"\n+  val ESTABLISH_TIMEOUT = \"fs.s3a.connection.establish.timeout\"\n+  val SOCKET_TIMEOUT = \"fs.s3a.connection.timeout\"\n+  val MAX_PAGING_KEYS = \"fs.s3a.paging.maximum\"\n+  val MAX_THREADS = \"fs.s3a.threads.max\"\n+  val KEEPALIVE_TIME = \"fs.s3a.threads.keepalivetime\"\n+  val MAX_TOTAL_TASKS = \"fs.s3a.max.total.tasks\"\n+  val MULTIPART_SIZE = \"fs.s3a.multipart.size\"\n+  val MIN_PERMITTED_MULTIPART_SIZE = 5 * (1024 * 1024)\n+  val MIN_MULTIPART_THRESHOLD = \"fs.s3a.multipart.threshold\"\n+  val ENABLE_MULTI_DELETE = \"fs.s3a.multiobjectdelete.enable\"\n+  val BUFFER_DIR = \"fs.s3a.buffer.dir\"\n+  val FAST_UPLOAD = \"fs.s3a.fast.upload\"\n+  val FAST_BUFFER_SIZE = \"fs.s3a.fast.buffer.size\"\n+  val PURGE_EXISTING_MULTIPART = \"fs.s3a.multipart.purge\"\n+  val PURGE_EXISTING_MULTIPART_AGE = \"fs.s3a.multipart.purge.age\"\n+  val SERVER_SIDE_ENCRYPTION_ALGORITHM = \"fs.s3a.server-side-encryption-algorithm\"\n+  val SERVER_SIDE_ENCRYPTION_AES256 = \"AES256\"\n+  val SIGNING_ALGORITHM = \"fs.s3a.signing-algorithm\"\n+  val BLOCK_SIZE = \"fs.s3a.block.size\"\n+  val FS_S3A = \"s3a\"\n+  val USER_AGENT_PREFIX = \"fs.s3a.user.agent.prefix\"\n+  val READAHEAD_RANGE = \"fs.s3a.readahead.range\"\n+  val INPUT_FADVISE = \"fs.s3a.experimental.input.fadvise\";\n+  val SEQUENTIAL_IO = \"sequential\"\n+  val NORMAL_IO = \"normal\"\n+  val RANDOM_IO = \"random\"\n+\n+  /**\n+   * Default source of a public multi-MB CSV file.\n+   */\n+  val S3A_CSV_PATH_DEFAULT = \"s3a://landsat-pds/scene_list.gz\""
  }],
  "prId": 12004
}]