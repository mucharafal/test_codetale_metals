[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I prefer `initMetrics`, and explain that it will be called after `init()`.",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-08-29T21:11:11Z",
    "diffHunk": "@@ -47,6 +48,17 @@\n    */\n   default void init() {}\n \n+  /**\n+   * Initialize the executor plugins used to extend the Spark/Dropwizard metrics system.\n+   *\n+   * <p>Each executor will, during its initialization, invoke this method on each\n+   * plugin provided in the spark.executor.metrics.plugins configuration.</p>\n+   *\n+   * <p>Plugins should register the data sources using the Dropwizard/codahale API</p>\n+   *\n+   */\n+  default void init(MetricRegistry sourceMetricsRegistry) {}"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "Thanks @vanzin for looking at this. I'll be interested to know about your use case for using this (executor plugins for extending the metrics system) . BTW I take the occasion to add that over the summer we have used this code a few times for workload and performance measurements/tests, and found it quite useful, in particular in the context of measuring I/O access time with some custom plugins we worte ( https://github.com/cerndb/SparkExecutorPlugins ) + custom I/O instrumentation for S3, HDFS. I have been thinking also at adding some additional instrumentation for CPU counters or network metrics, but not yet worked on that.\r\nI agree that using one config for \"normal\" plugins and for metrics plugins would reduce complexity and in general be preferrable. I'll appreciate a few more deatils on your proposed changes. I guess what could be a very simple way to merge the two plugin types, is just to pass sourceMetricsregistry to all plugins init code. This would be a breaking change from 2.4, but maybe acceptable for Spark 3.0? I guess there are just a few people using executor plugins in their current form? /cc @squito ",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-08-30T06:49:30Z",
    "diffHunk": "@@ -47,6 +48,17 @@\n    */\n   default void init() {}\n \n+  /**\n+   * Initialize the executor plugins used to extend the Spark/Dropwizard metrics system.\n+   *\n+   * <p>Each executor will, during its initialization, invoke this method on each\n+   * plugin provided in the spark.executor.metrics.plugins configuration.</p>\n+   *\n+   * <p>Plugins should register the data sources using the Dropwizard/codahale API</p>\n+   *\n+   */\n+  default void init(MetricRegistry sourceMetricsRegistry) {}"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I just want to add a new optional metrics source to Spark, and plugging into this functionality seemed nicer than having ad-hoc code. It would also mean this API would be used also inside of Spark.\r\n\r\n>  just to pass sourceMetricsregistry to all plugins init code\r\n\r\nEither is fine, it's a `DeveloperApi` so we can make those changes. But, for future proofing, I'd add a level of indirection - add a `ExecutorPluginContext` class that holds references to things provided to the init method (such as the metrics registry). Then adding things to that class does not break the API.",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-08-30T16:20:01Z",
    "diffHunk": "@@ -47,6 +48,17 @@\n    */\n   default void init() {}\n \n+  /**\n+   * Initialize the executor plugins used to extend the Spark/Dropwizard metrics system.\n+   *\n+   * <p>Each executor will, during its initialization, invoke this method on each\n+   * plugin provided in the spark.executor.metrics.plugins configuration.</p>\n+   *\n+   * <p>Plugins should register the data sources using the Dropwizard/codahale API</p>\n+   *\n+   */\n+  default void init(MetricRegistry sourceMetricsRegistry) {}"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "sorry I forgot to come back to look at this pr.  I agree with marcelo's comment.\r\n\r\nI think its fine to the break the api from 2.4.  If we want, you could even still support old plugins by using reflection.\r\n\r\n(or even version the api, but that seems like overkill at this point)",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-08-30T19:10:40Z",
    "diffHunk": "@@ -47,6 +48,17 @@\n    */\n   default void init() {}\n \n+  /**\n+   * Initialize the executor plugins used to extend the Spark/Dropwizard metrics system.\n+   *\n+   * <p>Each executor will, during its initialization, invoke this method on each\n+   * plugin provided in the spark.executor.metrics.plugins configuration.</p>\n+   *\n+   * <p>Plugins should register the data sources using the Dropwizard/codahale API</p>\n+   *\n+   */\n+  default void init(MetricRegistry sourceMetricsRegistry) {}"
  }],
  "prId": 24901
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I don't like this change. If the plugin needs to complain about something, it can log or throw an exception itself.\r\n\r\nIt's perfectly ok for a plugin to not have an `init` implementation, which is why it's a method with a default implementation.",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-09-04T17:46:35Z",
    "diffHunk": "@@ -44,8 +44,19 @@\n    *\n    * <p>Plugins should create threads in their implementation of this method for\n    * any polling, blocking, or intensive computation.</p>\n+   *\n+   * <p>The user-supplied init method for this class is initialized passing\n+   * executorPluginContext, which contains an handle to the metric registry of the\n+   * executorPlugin. This allows to add custom metrics (gauges, counters, etc).</p>\n+   *\n+   * <p>The Spark executor code will wait on the completion of the execution of the init method."
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "OK.",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-09-04T21:05:32Z",
    "diffHunk": "@@ -44,8 +44,19 @@\n    *\n    * <p>Plugins should create threads in their implementation of this method for\n    * any polling, blocking, or intensive computation.</p>\n+   *\n+   * <p>The user-supplied init method for this class is initialized passing\n+   * executorPluginContext, which contains an handle to the metric registry of the\n+   * executorPlugin. This allows to add custom metrics (gauges, counters, etc).</p>\n+   *\n+   * <p>The Spark executor code will wait on the completion of the execution of the init method."
  }],
  "prId": 24901
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Ah, forgot. This should be replaced with a `@param` describing the parameter.",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-09-04T18:03:18Z",
    "diffHunk": "@@ -44,8 +44,19 @@\n    *\n    * <p>Plugins should create threads in their implementation of this method for\n    * any polling, blocking, or intensive computation.</p>\n+   *\n+   * <p>The user-supplied init method for this class is initialized passing"
  }],
  "prId": 24901
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "The description of the parameter is redundant: we know it's a parameter to the init method; this is *the* documentation for that method. This should instead describe what that parameter is (e.g. \"context information for the executor where the plugin is running\").",
    "commit": "ea7a5df22e66ae618f70bd48965a9c179b64f366",
    "createdAt": "2019-09-06T20:35:39Z",
    "diffHunk": "@@ -40,12 +40,16 @@\n    * Initialize the executor plugin.\n    *\n    * <p>Each executor will, during its initialization, invoke this method on each\n-   * plugin provided in the spark.executor.plugins configuration.</p>\n+   * plugin provided in the spark.executor.plugins configuration. The Spark executor\n+   * will wait on the completion of the execution of the init method.</p>\n    *\n    * <p>Plugins should create threads in their implementation of this method for\n    * any polling, blocking, or intensive computation.</p>\n+   *\n+   * @param pluginContext The user-supplied init method for this class is initialized"
  }],
  "prId": 24901
}]