[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "The re-allocated space might not be used if no further insertion. Shall we do `growAndRehash` at the beginning of `append` when `numKeys == growthThreshold && !isDefined`?",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-08T06:17:06Z",
    "diffHunk": "@@ -742,7 +742,7 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n         longArray.set(pos * 2 + 1, keyHashcode);\n         isDefined = true;\n \n-        if (numKeys > growthThreshold && longArray.size() < MAX_CAPACITY) {\n+        if (numKeys >= growthThreshold && longArray.size() < MAX_CAPACITY) {",
    "line": 14
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Unfortunately, we can't grow in the beginning, otherwise the `pos` will be wrong.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-15T19:23:36Z",
    "diffHunk": "@@ -742,7 +742,7 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n         longArray.set(pos * 2 + 1, keyHashcode);\n         isDefined = true;\n \n-        if (numKeys > growthThreshold && longArray.size() < MAX_CAPACITY) {\n+        if (numKeys >= growthThreshold && longArray.size() < MAX_CAPACITY) {",
    "line": 14
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "OK. LGTM.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-16T02:50:27Z",
    "diffHunk": "@@ -742,7 +742,7 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n         longArray.set(pos * 2 + 1, keyHashcode);\n         isDefined = true;\n \n-        if (numKeys > growthThreshold && longArray.size() < MAX_CAPACITY) {\n+        if (numKeys >= growthThreshold && longArray.size() < MAX_CAPACITY) {",
    "line": 14
  }],
  "prId": 16844
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "Unrelated, but this OutOfMemoryError will not be useful - atleast not in yarn mode.\r\nIt will simply cause the jvm to exit.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-08T21:08:22Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {\n+          // Should not grow beyond the max capacity\n+          return false;\n+        }\n+        try {\n+          growAndRehash();\n+        } catch (OutOfMemoryError oom) {\n+          return false;"
  }],
  "prId": 16844
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "This does not look correct as per documentation of MAX_CAPACITY.\r\nActual number of keys == MAX_CAPACITY (so that total number of entries in longArray is MAX_CAPACITY * 2)",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-08T21:10:26Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "We grow the array when `numKeys >= growthThreshold` and `growthThreshold = capacity * 0.5`.  But we actually allocate `capacity * 2` spaces for the array.\r\n\r\nSo actually `numKeys < growthThreshold = capacity * 0.5 < array length = capacity * 2` should hold true.\r\n\r\nBecause `numKeys < growthThreshold` is always true, if `numKeys == MAX_CAPACITY`, the capacity would be `MAX_CAPACITY * 2` at least and the length of array will be more than `MAX_CAPACITY * 4`.\r\n\r\nBut in `allocate`, there is an assert of `capacity <= MAX_CAPACITY`. Looks like those condition are inconsistent.\r\n",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T14:34:44Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "Also, we need to move the appropriate validation check into growAndRehash() and not here.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T18:40:27Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "There are two reason it will fail to grow: 1) current capacity (longArray.size() / 2) reach MAX_CAPACITY  2) can't allocate a array (OOM).\r\n\r\nSo, I think the checking here is correct.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T18:50:57Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "@davies You are right that the check for `longArray.size() / 2 == MAX_CAPACITY` is the upper bound beyond which we cant grow. It is simply confusing it do it outside growAndRehash - which is what threw me off.\r\nPlease move the check into growAndRehash() and have it return true in case it could successfully grow the map.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T19:07:11Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "@mridulm Do that means we should also rename the `growAndRehash` to `tryGrowAndRehash`? I think those are not necessary.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T19:17:21Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "The invariant in question is for growAndRehash() - not append, and as such should live there.\r\nCode evolution causing grow to be invoked from elsewhere will require duplication of the invariant everywhere.\r\n\r\nBtw, this is in line with all other data structures spark (and other frameworks) have.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T20:29:48Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }],
  "prId": 16844
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This `longArray.size() < MAX_CAPACITY` should be wrong condition.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T14:11:13Z",
    "diffHunk": "@@ -741,14 +741,6 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n         numKeys++;\n         longArray.set(pos * 2 + 1, keyHashcode);\n         isDefined = true;\n-\n-        if (numKeys > growthThreshold && longArray.size() < MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "longArray.size() is the next capacity for current grow strategy, it should be `longArray.size() <= MAX_CAPACITY`",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-09T18:57:29Z",
    "diffHunk": "@@ -741,14 +741,6 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n         numKeys++;\n         longArray.set(pos * 2 + 1, keyHashcode);\n         isDefined = true;\n-\n-        if (numKeys > growthThreshold && longArray.size() < MAX_CAPACITY) {"
  }],
  "prId": 16844
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Is `MAX_CAPACITY` still the maximum number of keys as per documentation of it? If we can have `longArray.size() / 2 == MAX_CAPACITY` at most for the capacity, the actually `numKeys` should be `MAX_CAPACITY / 2`, because we need two long array entries per key, right?",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-10T02:30:53Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "@davies is correct; but it is a slightly unintuitive way to write the condition.\r\n\r\n```\r\nval currentSize = longArray.size()\r\nval newSize = currentSize * 2\r\nval currentKeysLen = currentSize / 2\r\nval newKeysLen = currentKeysLen * 2\r\n\r\nif (newKeysLen > MAX_CAPACITY) then fail.\r\nthat is  if (currentKeysLen == MAX_CAPACITY) then fail // Since we allow only power of 2's for all these values.\r\nthat is  if (longArray.size() / 2 == MAX_CAPACITY)\r\n\r\n```\r\n\r\nParticularly given its location (in append as opposed to grow), it serves to be a bit more confusing that expected.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-10T05:26:01Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "If the `currentKeysLen` above is the number of keys, it never equals to `currentSize / 2`. `currentSize / 2` is actually the `capacity` we want to allocate (but actually we allocate double of it for the array).\r\n\r\nOnce the number of keys reaches `growthThreshold` (i.e., `capacity * 0.5`), we go to grow the array or fail the append. So the number of keys is always less than or equal to `capacity * 0.5` which is `currentSize * 0.5 * 0.5`.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-10T06:33:31Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "To clarify, the length's @davies and I mentioned are not actual number of keys in the map, but maximum number of keys possible in the map.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-10T09:00:44Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ah, I see. It makes sense.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-10T11:38:36Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {\n+        if (longArray.size() / 2 == MAX_CAPACITY) {"
  }],
  "prId": 16844
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I think we need to grow the array only if `isDefined == false`.",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-10T13:23:49Z",
    "diffHunk": "@@ -695,11 +690,16 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       assert (vlen % 8 == 0);\n       assert (longArray != null);\n \n-      if (numKeys == MAX_CAPACITY\n-        // The map could be reused from last spill (because of no enough memory to grow),\n-        // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n-        return false;\n+      if (numKeys >= growthThreshold) {"
  }],
  "prId": 16844
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This change makes sense to me because `growthThreshold`'s Scaladoc says \"The map will be expanded once the number of keys exceeds this threshold\" and here we're considering the impact of adding an additional key (so this could have also been written as `(numKeys + 1) > growthThreshold`).",
    "commit": "8f098aa762a711dc6b8f915ae22887b61b641f49",
    "createdAt": "2017-02-16T18:31:23Z",
    "diffHunk": "@@ -698,7 +698,7 @@ public boolean append(Object kbase, long koff, int klen, Object vbase, long voff\n       if (numKeys == MAX_CAPACITY\n         // The map could be reused from last spill (because of no enough memory to grow),\n         // then we don't try to grow again if hit the `growthThreshold`.\n-        || !canGrowArray && numKeys > growthThreshold) {\n+        || !canGrowArray && numKeys >= growthThreshold) {",
    "line": 5
  }],
  "prId": 16844
}]