[{
  "comments": [{
    "author": {
      "login": "smurakozi"
    },
    "body": "This is a new class, why should we include these deprecated methods? ",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-08T09:59:10Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated"
  }, {
    "author": {
      "login": "stoader"
    },
    "body": "Removed deprecated methods.",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-09T22:09:44Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated"
  }],
  "prId": 19775
}, {
  "comments": [{
    "author": {
      "login": "smurakozi"
    },
    "body": "It should be private.",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-08T10:04:16Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(CollectorRegistry registry, String job, String instance) throws IOException {\n+        push(registry, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and instance.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(Collector collector, String job, String instance) throws IOException {\n+        push(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     * @deprecated use {@link #pushAdd(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void pushAdd(Collector collector, String job, String instance) throws IOException {\n+        pushAdd(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * This uses the DELETE HTTP method.\n+     * @deprecated use {@link #delete(String, Map)}\n+     */\n+    @Deprecated\n+    public void delete(String job, String instance) throws IOException {\n+        delete(job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    void doRequest(CollectorRegistry registry, String job, Map<String,"
  }, {
    "author": {
      "login": "stoader"
    },
    "body": "Changed it to private.",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-09T22:09:42Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(CollectorRegistry registry, String job, String instance) throws IOException {\n+        push(registry, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and instance.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(Collector collector, String job, String instance) throws IOException {\n+        push(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     * @deprecated use {@link #pushAdd(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void pushAdd(Collector collector, String job, String instance) throws IOException {\n+        pushAdd(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * This uses the DELETE HTTP method.\n+     * @deprecated use {@link #delete(String, Map)}\n+     */\n+    @Deprecated\n+    public void delete(String job, String instance) throws IOException {\n+        delete(job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    void doRequest(CollectorRegistry registry, String job, Map<String,"
  }],
  "prId": 19775
}, {
  "comments": [{
    "author": {
      "login": "smurakozi"
    },
    "body": "Nit: extra line",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-08T10:46:13Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(CollectorRegistry registry, String job, String instance) throws IOException {\n+        push(registry, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and instance.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(Collector collector, String job, String instance) throws IOException {\n+        push(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     * @deprecated use {@link #pushAdd(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void pushAdd(Collector collector, String job, String instance) throws IOException {\n+        pushAdd(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * This uses the DELETE HTTP method.\n+     * @deprecated use {@link #delete(String, Map)}\n+     */\n+    @Deprecated\n+    public void delete(String job, String instance) throws IOException {\n+        delete(job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    void doRequest(CollectorRegistry registry, String job, Map<String,\n+            String> groupingKey, String method, String timestamp) throws IOException {\n+        String url = address + \"/metrics/job/\" + URLEncoder.encode(job, \"UTF-8\");\n+        if (groupingKey != null) {\n+            for (Map.Entry<String, String> entry: groupingKey.entrySet()) {\n+                url += \"/\" + entry.getKey() + \"/\" + URLEncoder.encode(entry.getValue(), \"UTF-8\");\n+            }\n+        }\n+\n+        logger.info(\"Sending metrics data to '{}'\", url);\n+\n+        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n+        connection.setRequestProperty(\"Content-Type\", TextFormatWithTimestamp.CONTENT_TYPE_004);\n+        if (!method.equals(\"DELETE\")) {\n+            connection.setDoOutput(true);\n+        }\n+        connection.setRequestMethod(method);\n+\n+        connection.setConnectTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.setReadTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.connect();\n+\n+        try {\n+            if (!method.equals(\"DELETE\")) {\n+                BufferedWriter writer =\n+                        new BufferedWriter(\n+                                new OutputStreamWriter(connection.getOutputStream(), \"UTF-8\"));\n+                TextFormatWithTimestamp.write004(writer,\n+                                                registry.metricFamilySamples(), timestamp);\n+                writer.flush();\n+                writer.close();\n+            }\n+\n+            int response = connection.getResponseCode();\n+            if (response != HttpURLConnection.HTTP_ACCEPTED) {\n+                throw new IOException(\"Response code from \" + url + \" was \" + response);\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"Sending metrics failed due to: \", ex);\n+        }\n+"
  }, {
    "author": {
      "login": "stoader"
    },
    "body": "Removed extra line.",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-09T22:09:39Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(CollectorRegistry registry, String job, String instance) throws IOException {\n+        push(registry, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and instance.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(Collector collector, String job, String instance) throws IOException {\n+        push(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     * @deprecated use {@link #pushAdd(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void pushAdd(Collector collector, String job, String instance) throws IOException {\n+        pushAdd(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * This uses the DELETE HTTP method.\n+     * @deprecated use {@link #delete(String, Map)}\n+     */\n+    @Deprecated\n+    public void delete(String job, String instance) throws IOException {\n+        delete(job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    void doRequest(CollectorRegistry registry, String job, Map<String,\n+            String> groupingKey, String method, String timestamp) throws IOException {\n+        String url = address + \"/metrics/job/\" + URLEncoder.encode(job, \"UTF-8\");\n+        if (groupingKey != null) {\n+            for (Map.Entry<String, String> entry: groupingKey.entrySet()) {\n+                url += \"/\" + entry.getKey() + \"/\" + URLEncoder.encode(entry.getValue(), \"UTF-8\");\n+            }\n+        }\n+\n+        logger.info(\"Sending metrics data to '{}'\", url);\n+\n+        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n+        connection.setRequestProperty(\"Content-Type\", TextFormatWithTimestamp.CONTENT_TYPE_004);\n+        if (!method.equals(\"DELETE\")) {\n+            connection.setDoOutput(true);\n+        }\n+        connection.setRequestMethod(method);\n+\n+        connection.setConnectTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.setReadTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.connect();\n+\n+        try {\n+            if (!method.equals(\"DELETE\")) {\n+                BufferedWriter writer =\n+                        new BufferedWriter(\n+                                new OutputStreamWriter(connection.getOutputStream(), \"UTF-8\"));\n+                TextFormatWithTimestamp.write004(writer,\n+                                                registry.metricFamilySamples(), timestamp);\n+                writer.flush();\n+                writer.close();\n+            }\n+\n+            int response = connection.getResponseCode();\n+            if (response != HttpURLConnection.HTTP_ACCEPTED) {\n+                throw new IOException(\"Response code from \" + url + \" was \" + response);\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"Sending metrics failed due to: \", ex);\n+        }\n+"
  }],
  "prId": 19775
}, {
  "comments": [{
    "author": {
      "login": "smurakozi"
    },
    "body": "`connection` can be null if `new URL(url).openConnection()` at line 272 threw an exception.",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-08T10:46:59Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(CollectorRegistry registry, String job, String instance) throws IOException {\n+        push(registry, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and instance.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(Collector collector, String job, String instance) throws IOException {\n+        push(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     * @deprecated use {@link #pushAdd(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void pushAdd(Collector collector, String job, String instance) throws IOException {\n+        pushAdd(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * This uses the DELETE HTTP method.\n+     * @deprecated use {@link #delete(String, Map)}\n+     */\n+    @Deprecated\n+    public void delete(String job, String instance) throws IOException {\n+        delete(job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    void doRequest(CollectorRegistry registry, String job, Map<String,\n+            String> groupingKey, String method, String timestamp) throws IOException {\n+        String url = address + \"/metrics/job/\" + URLEncoder.encode(job, \"UTF-8\");\n+        if (groupingKey != null) {\n+            for (Map.Entry<String, String> entry: groupingKey.entrySet()) {\n+                url += \"/\" + entry.getKey() + \"/\" + URLEncoder.encode(entry.getValue(), \"UTF-8\");\n+            }\n+        }\n+\n+        logger.info(\"Sending metrics data to '{}'\", url);\n+\n+        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n+        connection.setRequestProperty(\"Content-Type\", TextFormatWithTimestamp.CONTENT_TYPE_004);\n+        if (!method.equals(\"DELETE\")) {\n+            connection.setDoOutput(true);\n+        }\n+        connection.setRequestMethod(method);\n+\n+        connection.setConnectTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.setReadTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.connect();\n+\n+        try {\n+            if (!method.equals(\"DELETE\")) {\n+                BufferedWriter writer =\n+                        new BufferedWriter(\n+                                new OutputStreamWriter(connection.getOutputStream(), \"UTF-8\"));\n+                TextFormatWithTimestamp.write004(writer,\n+                                                registry.metricFamilySamples(), timestamp);\n+                writer.flush();\n+                writer.close();\n+            }\n+\n+            int response = connection.getResponseCode();\n+            if (response != HttpURLConnection.HTTP_ACCEPTED) {\n+                throw new IOException(\"Response code from \" + url + \" was \" + response);\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"Sending metrics failed due to: \", ex);\n+        }\n+\n+        finally {\n+            connection.disconnect();"
  }, {
    "author": {
      "login": "stoader"
    },
    "body": "The `new URL(url).openConnection()` is outside of the `try-catch-block` this in case it throws an exception it exist `doRequest()` before reaching ```finally {\r\n            connection.disconnect();```",
    "commit": "344c4647fc84da8f265d9b8d66f0e9424b41359f",
    "createdAt": "2018-02-09T22:00:21Z",
    "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.metrics.prometheus.client.exporter;\n+\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.CollectorRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+/**\n+ * Export metrics via the Prometheus Pushgateway.\n+ * <p>\n+ * The Prometheus Pushgateway exists to allow ephemeral and\n+ * batch jobs to expose their metrics to Prometheus.\n+ * Since these kinds of jobs may not exist long enough to be scraped,\n+ * they can instead push their metrics to a Pushgateway.\n+ * This class allows pushing the contents of a {@link CollectorRegistry} to\n+ * a Pushgateway.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * {@code\n+ *   void executeBatchJob() throws Exception {\n+ *     CollectorRegistry registry = new CollectorRegistry();\n+ *     Gauge duration = Gauge.build()\n+ *         .name(\"my_batch_job_duration_seconds\")\n+ *         .help(\"Duration of my batch job in seconds.\")\n+ *         .register(registry);\n+ *     Gauge.Timer durationTimer = duration.startTimer();\n+ *     try {\n+ *       // Your code here.\n+ *\n+ *       // This is only added to the registry after success,\n+ *       // so that a previous success in the Pushgateway isn't overwritten on failure.\n+ *       Gauge lastSuccess = Gauge.build()\n+ *           .name(\"my_batch_job_last_success\")\n+ *           .help(\"Last time my batch job succeeded, in unixtime.\")\n+ *           .register(registry);\n+ *       lastSuccess.setToCurrentTime();\n+ *     } finally {\n+ *       durationTimer.setDuration();\n+ *       PushGatewayWithTimestamp pg = new PushGatewayWithTimestamp(\"127.0.0.1:9091\");\n+ *       pg.pushAdd(registry, \"my_batch_job\");\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>\n+ * See <a href=\"https://github.com/prometheus/pushgateway\">\n+ *     https://github.com/prometheus/pushgateway</a>\n+ */\n+public class PushGatewayWithTimestamp {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PushGatewayWithTimestamp.class);\n+    private final String address;\n+    private static final int SECONDS_PER_MILLISECOND = 1000;\n+    /**\n+     * Construct a Pushgateway, with the given address.\n+     * <p>\n+     * @param address  host:port or ip:port of the Pushgateway.\n+     */\n+    public PushGatewayWithTimestamp(String address) {\n+        this.address = address;\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry, String job) throws IOException {\n+        doRequest(registry, job, null, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing all those with the same job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing all those with the same job and grouping key.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(CollectorRegistry registry,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(registry, job, groupingKey, \"PUT\", null);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     */\n+    public void push(Collector collector,\n+                     String job, Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        push(registry, job, groupingKey);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,\n+                        String job, String timestamp) throws IOException {\n+        doRequest(registry, job, null, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name and job and no grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, \"\");\n+    }\n+\n+    /**\n+     * Pushes all metrics in a registry,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(CollectorRegistry registry,String job,\n+                        Map<String, String> groupingKey, String timestamp) throws IOException {\n+        doRequest(registry, job, groupingKey, \"POST\", timestamp);\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name, job and grouping key.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     */\n+    public void pushAdd(Collector collector, String job,\n+                        Map<String, String> groupingKey) throws IOException {\n+        CollectorRegistry registry = new CollectorRegistry();\n+        collector.register(registry);\n+        pushAdd(registry, job, groupingKey, null);\n+    }\n+\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with no grouping key and the provided job.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job) throws IOException {\n+        doRequest(null, job, null, \"DELETE\", null);\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * Deletes metrics with the provided job and grouping key.\n+     * This uses the DELETE HTTP method.\n+     */\n+    public void delete(String job, Map<String, String> groupingKey) throws IOException {\n+        doRequest(null, job, groupingKey, \"DELETE\", null);\n+    }\n+\n+\n+    /**\n+     * Pushes all metrics in a registry, replacing all those with the same job and instance.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(CollectorRegistry, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(CollectorRegistry registry, String job, String instance) throws IOException {\n+        push(registry, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector, replacing all those with the same job and instance.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the PUT HTTP method.\n+     * @deprecated use {@link #push(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void push(Collector collector, String job, String instance) throws IOException {\n+        push(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Pushes all metrics in a Collector,\n+     * replacing only previously pushed metrics of the same name.\n+     * <p>\n+     * This is useful for pushing a single Gauge.\n+     * <p>\n+     * This uses the POST HTTP method.\n+     * @deprecated use {@link #pushAdd(Collector, String, Map)}\n+     */\n+    @Deprecated\n+    public void pushAdd(Collector collector, String job, String instance) throws IOException {\n+        pushAdd(collector, job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    /**\n+     * Deletes metrics from the Pushgateway.\n+     * <p>\n+     * This uses the DELETE HTTP method.\n+     * @deprecated use {@link #delete(String, Map)}\n+     */\n+    @Deprecated\n+    public void delete(String job, String instance) throws IOException {\n+        delete(job, Collections.singletonMap(\"instance\", instance));\n+    }\n+\n+    void doRequest(CollectorRegistry registry, String job, Map<String,\n+            String> groupingKey, String method, String timestamp) throws IOException {\n+        String url = address + \"/metrics/job/\" + URLEncoder.encode(job, \"UTF-8\");\n+        if (groupingKey != null) {\n+            for (Map.Entry<String, String> entry: groupingKey.entrySet()) {\n+                url += \"/\" + entry.getKey() + \"/\" + URLEncoder.encode(entry.getValue(), \"UTF-8\");\n+            }\n+        }\n+\n+        logger.info(\"Sending metrics data to '{}'\", url);\n+\n+        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n+        connection.setRequestProperty(\"Content-Type\", TextFormatWithTimestamp.CONTENT_TYPE_004);\n+        if (!method.equals(\"DELETE\")) {\n+            connection.setDoOutput(true);\n+        }\n+        connection.setRequestMethod(method);\n+\n+        connection.setConnectTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.setReadTimeout(10 * SECONDS_PER_MILLISECOND);\n+        connection.connect();\n+\n+        try {\n+            if (!method.equals(\"DELETE\")) {\n+                BufferedWriter writer =\n+                        new BufferedWriter(\n+                                new OutputStreamWriter(connection.getOutputStream(), \"UTF-8\"));\n+                TextFormatWithTimestamp.write004(writer,\n+                                                registry.metricFamilySamples(), timestamp);\n+                writer.flush();\n+                writer.close();\n+            }\n+\n+            int response = connection.getResponseCode();\n+            if (response != HttpURLConnection.HTTP_ACCEPTED) {\n+                throw new IOException(\"Response code from \" + url + \" was \" + response);\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"Sending metrics failed due to: \", ex);\n+        }\n+\n+        finally {\n+            connection.disconnect();"
  }],
  "prId": 19775
}]