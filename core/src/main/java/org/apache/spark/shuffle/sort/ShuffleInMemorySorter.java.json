[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Don't necessarily have to wrap this line.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T23:53:08Z",
    "diffHunk": "@@ -37,33 +37,52 @@ public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n    * {@link PackedRecordPointer}. The sort operates on this array instead of directly manipulating\n    * records.\n    */\n-  private long[] pointerArray;\n+  private long[] array;\n \n   /**\n    * The position in the pointer array where new records can be inserted.\n    */\n-  private int pointerArrayInsertPosition = 0;\n+  private int pos = 0;\n \n   public ShuffleInMemorySorter(int initialSize) {\n     assert (initialSize > 0);\n-    this.pointerArray = new long[initialSize];\n-    this.sorter = new Sorter<PackedRecordPointer, long[]>(ShuffleSortDataFormat.INSTANCE);\n+    this.array = new long[initialSize];\n+    this.sorter = new Sorter<>(ShuffleSortDataFormat.INSTANCE);\n   }\n \n-  public void expandPointerArray() {\n-    final long[] oldArray = pointerArray;\n+  public int numRecords() {\n+    return pos;\n+  }\n+\n+  public void reset() {\n+    pos = 0;\n+  }\n+\n+  private int newLength() {\n     // Guard against overflow:\n-    final int newLength = oldArray.length * 2 > 0 ? (oldArray.length * 2) : Integer.MAX_VALUE;\n-    pointerArray = new long[newLength];\n-    System.arraycopy(oldArray, 0, pointerArray, 0, oldArray.length);\n+    return array.length <= Integer.MAX_VALUE / 2 ?\n+      (array.length * 2) : Integer.MAX_VALUE;"
  }],
  "prId": 9241
}]