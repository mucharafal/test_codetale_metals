[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we should make this a static class to facilitate inlining. (might want to check whether this is inlined for real later)\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T00:27:00Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {"
  }],
  "prId": 5868
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "add some comment saying this is only safe because partition id is a small range (i.e. no risk of overflowing)\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T00:27:24Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {\n+      @Override\n+      public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+        return left.getPartitionId() - right.getPartitionId();"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "`getPartitionId()` returns an integer, so isn't this immune from overflow?  There are overflow concerns that are internal to `PackedRecordPointer`, such as the fact that we have an upper limit of ~10 million partitions.  Would it be okay if I commented on those overflow issues inside of `PackedRecordPointer` and left this line unchanged?\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T01:06:09Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {\n+      @Override\n+      public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+        return left.getPartitionId() - right.getPartitionId();"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "the overflow concern is when we do the subtraction ?\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T01:08:35Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {\n+      @Override\n+      public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+        return left.getPartitionId() - right.getPartitionId();"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "We're subtracting two positive integers that are less than Int.max.  I think we'd only have to be concerned about overflow if the operands had different signs.  Is this what you wanted to clarify?\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T01:11:48Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {\n+      @Override\n+      public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+        return left.getPartitionId() - right.getPartitionId();"
  }],
  "prId": 5868
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "there isn't next() anywhere is there?\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T00:33:24Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {\n+      @Override\n+      public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+        return left.getPartitionId() - right.getPartitionId();\n+      }\n+    };\n+  }\n+\n+  public void expandSortBuffer() {\n+    final long[] oldBuffer = sortBuffer;\n+    sortBuffer = new long[oldBuffer.length * 2];\n+    System.arraycopy(oldBuffer, 0, sortBuffer, 0, oldBuffer.length);\n+  }\n+\n+  public boolean hasSpaceForAnotherRecord() {\n+    return sortBufferInsertPosition + 1 < sortBuffer.length;\n+  }\n+\n+  public long getMemoryUsage() {\n+    return sortBuffer.length * 8L;\n+  }\n+\n+  // TODO: clairify assumption that pointer points to record length.\n+  public void insertRecord(long recordPointer, int partitionId) {\n+    if (!hasSpaceForAnotherRecord()) {\n+      expandSortBuffer();\n+    }\n+    sortBuffer[sortBufferInsertPosition] =\n+        PackedRecordPointer.packPointer(recordPointer, partitionId);\n+    sortBufferInsertPosition++;\n+  }\n+\n+  public static abstract class UnsafeShuffleSorterIterator {\n+\n+    final PackedRecordPointer packedRecordPointer = new PackedRecordPointer();\n+\n+    public abstract boolean hasNext();\n+\n+    public abstract void loadNext();\n+\n+  }\n+\n+  /**\n+   * Return an iterator over record pointers in sorted order. For efficiency, all calls to\n+   * {@code next()} will return the same mutable object."
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "This comment is out-of-date; this method originally returned an `Iterator` subclass.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-07T00:37:12Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+public final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private final Comparator<PackedRecordPointer> sortComparator;\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter =\n+      new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+    this.sortComparator = new Comparator<PackedRecordPointer>() {\n+      @Override\n+      public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+        return left.getPartitionId() - right.getPartitionId();\n+      }\n+    };\n+  }\n+\n+  public void expandSortBuffer() {\n+    final long[] oldBuffer = sortBuffer;\n+    sortBuffer = new long[oldBuffer.length * 2];\n+    System.arraycopy(oldBuffer, 0, sortBuffer, 0, oldBuffer.length);\n+  }\n+\n+  public boolean hasSpaceForAnotherRecord() {\n+    return sortBufferInsertPosition + 1 < sortBuffer.length;\n+  }\n+\n+  public long getMemoryUsage() {\n+    return sortBuffer.length * 8L;\n+  }\n+\n+  // TODO: clairify assumption that pointer points to record length.\n+  public void insertRecord(long recordPointer, int partitionId) {\n+    if (!hasSpaceForAnotherRecord()) {\n+      expandSortBuffer();\n+    }\n+    sortBuffer[sortBufferInsertPosition] =\n+        PackedRecordPointer.packPointer(recordPointer, partitionId);\n+    sortBufferInsertPosition++;\n+  }\n+\n+  public static abstract class UnsafeShuffleSorterIterator {\n+\n+    final PackedRecordPointer packedRecordPointer = new PackedRecordPointer();\n+\n+    public abstract boolean hasNext();\n+\n+    public abstract void loadNext();\n+\n+  }\n+\n+  /**\n+   * Return an iterator over record pointers in sorted order. For efficiency, all calls to\n+   * {@code next()} will return the same mutable object."
  }],
  "prId": 5868
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "It's better to use `long newLength = oldBuffer.length * 2 > 0 ? (oldBuffer.length * 2) : Integer.MAX_VALUE;`. Just for safety.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T00:26:42Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private static final class SortComparator implements Comparator<PackedRecordPointer> {\n+    @Override\n+    public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+      return left.getPartitionId() - right.getPartitionId();\n+    }\n+  }\n+  private static final SortComparator SORT_COMPARATOR = new SortComparator();\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter = new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+  }\n+\n+  public void expandSortBuffer() {\n+    final long[] oldBuffer = sortBuffer;\n+    sortBuffer = new long[oldBuffer.length * 2];"
  }],
  "prId": 5868
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maybe add comment to explain why we don't just use scala or java iterator?\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T06:11:54Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private static final class SortComparator implements Comparator<PackedRecordPointer> {\n+    @Override\n+    public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+      return left.getPartitionId() - right.getPartitionId();\n+    }\n+  }\n+  private static final SortComparator SORT_COMPARATOR = new SortComparator();\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter = new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+  }\n+\n+  public void expandSortBuffer() {\n+    final long[] oldBuffer = sortBuffer;\n+    sortBuffer = new long[oldBuffer.length * 2];\n+    System.arraycopy(oldBuffer, 0, sortBuffer, 0, oldBuffer.length);\n+  }\n+\n+  public boolean hasSpaceForAnotherRecord() {\n+    return sortBufferInsertPosition + 1 < sortBuffer.length;\n+  }\n+\n+  public long getMemoryUsage() {\n+    return sortBuffer.length * 8L;\n+  }\n+\n+  /**\n+   * Inserts a record to be sorted.\n+   *\n+   * @param recordPointer a pointer to the record, encoded by the task memory manager. Due to\n+   *                      certain pointer compression techniques used by the sorter, the sort can\n+   *                      only operate on pointers that point to locations in the first\n+   *                      {@link PackedRecordPointer#MAXIMUM_PAGE_SIZE_BYTES} bytes of a data page.\n+   * @param partitionId the partition id, which must be less than or equal to\n+   *                    {@link PackedRecordPointer#MAXIMUM_PARTITION_ID}.\n+   */\n+  public void insertRecord(long recordPointer, int partitionId) {\n+    if (!hasSpaceForAnotherRecord()) {\n+      expandSortBuffer();\n+    }\n+    sortBuffer[sortBufferInsertPosition] =\n+        PackedRecordPointer.packPointer(recordPointer, partitionId);\n+    sortBufferInsertPosition++;\n+  }\n+\n+  public static abstract class UnsafeShuffleSorterIterator {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "This was originally introduced as part of some old merge code where this class had two subclasses, one for in-memory data and one for spilled data.  Now that we use a fast non-record-oriented merge, this isn't strictly necessary.  However, I think that I'll leave this in due to potential perf. impacts w.r.t. inlining; we can remove it later if it doesn't offer any benefit.\n\nI _will_ refactor this to remove the subclass and have it just be a static final class.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T19:01:48Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private static final class SortComparator implements Comparator<PackedRecordPointer> {\n+    @Override\n+    public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+      return left.getPartitionId() - right.getPartitionId();\n+    }\n+  }\n+  private static final SortComparator SORT_COMPARATOR = new SortComparator();\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter = new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+  }\n+\n+  public void expandSortBuffer() {\n+    final long[] oldBuffer = sortBuffer;\n+    sortBuffer = new long[oldBuffer.length * 2];\n+    System.arraycopy(oldBuffer, 0, sortBuffer, 0, oldBuffer.length);\n+  }\n+\n+  public boolean hasSpaceForAnotherRecord() {\n+    return sortBufferInsertPosition + 1 < sortBuffer.length;\n+  }\n+\n+  public long getMemoryUsage() {\n+    return sortBuffer.length * 8L;\n+  }\n+\n+  /**\n+   * Inserts a record to be sorted.\n+   *\n+   * @param recordPointer a pointer to the record, encoded by the task memory manager. Due to\n+   *                      certain pointer compression techniques used by the sorter, the sort can\n+   *                      only operate on pointers that point to locations in the first\n+   *                      {@link PackedRecordPointer#MAXIMUM_PAGE_SIZE_BYTES} bytes of a data page.\n+   * @param partitionId the partition id, which must be less than or equal to\n+   *                    {@link PackedRecordPointer#MAXIMUM_PARTITION_ID}.\n+   */\n+  public void insertRecord(long recordPointer, int partitionId) {\n+    if (!hasSpaceForAnotherRecord()) {\n+      expandSortBuffer();\n+    }\n+    sortBuffer[sortBufferInsertPosition] =\n+        PackedRecordPointer.packPointer(recordPointer, partitionId);\n+    sortBufferInsertPosition++;\n+  }\n+\n+  public static abstract class UnsafeShuffleSorterIterator {"
  }],
  "prId": 5868
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think it'd be more clear if we have an explicit sort function here.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T06:26:47Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+final class UnsafeShuffleSorter {\n+\n+  private final Sorter<PackedRecordPointer, long[]> sorter;\n+  private static final class SortComparator implements Comparator<PackedRecordPointer> {\n+    @Override\n+    public int compare(PackedRecordPointer left, PackedRecordPointer right) {\n+      return left.getPartitionId() - right.getPartitionId();\n+    }\n+  }\n+  private static final SortComparator SORT_COMPARATOR = new SortComparator();\n+\n+  private long[] sortBuffer;\n+\n+  /**\n+   * The position in the sort buffer where new records can be inserted.\n+   */\n+  private int sortBufferInsertPosition = 0;\n+\n+  public UnsafeShuffleSorter(int initialSize) {\n+    assert (initialSize > 0);\n+    this.sortBuffer = new long[initialSize];\n+    this.sorter = new Sorter<PackedRecordPointer, long[]>(UnsafeShuffleSortDataFormat.INSTANCE);\n+  }\n+\n+  public void expandSortBuffer() {\n+    final long[] oldBuffer = sortBuffer;\n+    sortBuffer = new long[oldBuffer.length * 2];\n+    System.arraycopy(oldBuffer, 0, sortBuffer, 0, oldBuffer.length);\n+  }\n+\n+  public boolean hasSpaceForAnotherRecord() {\n+    return sortBufferInsertPosition + 1 < sortBuffer.length;\n+  }\n+\n+  public long getMemoryUsage() {\n+    return sortBuffer.length * 8L;\n+  }\n+\n+  /**\n+   * Inserts a record to be sorted.\n+   *\n+   * @param recordPointer a pointer to the record, encoded by the task memory manager. Due to\n+   *                      certain pointer compression techniques used by the sorter, the sort can\n+   *                      only operate on pointers that point to locations in the first\n+   *                      {@link PackedRecordPointer#MAXIMUM_PAGE_SIZE_BYTES} bytes of a data page.\n+   * @param partitionId the partition id, which must be less than or equal to\n+   *                    {@link PackedRecordPointer#MAXIMUM_PARTITION_ID}.\n+   */\n+  public void insertRecord(long recordPointer, int partitionId) {\n+    if (!hasSpaceForAnotherRecord()) {\n+      expandSortBuffer();\n+    }\n+    sortBuffer[sortBufferInsertPosition] =\n+        PackedRecordPointer.packPointer(recordPointer, partitionId);\n+    sortBufferInsertPosition++;\n+  }\n+\n+  public static abstract class UnsafeShuffleSorterIterator {\n+\n+    final PackedRecordPointer packedRecordPointer = new PackedRecordPointer();\n+\n+    public abstract boolean hasNext();\n+\n+    public abstract void loadNext();\n+\n+  }\n+\n+  /**\n+   * Return an iterator over record pointers in sorted order.\n+   */\n+  public UnsafeShuffleSorterIterator getSortedIterator() {"
  }],
  "prId": 5868
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "might be better to name this UnsafeInMemorySorter to differentiate it clearly vs UnsafeExternalSorter.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T07:25:56Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Comparator;\n+\n+import org.apache.spark.util.collection.Sorter;\n+\n+final class UnsafeShuffleSorter {"
  }],
  "prId": 5868
}]