[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: wrong import grouping.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T17:25:16Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This description is a bit weird. Why the restriction on what method can be called on the input?\r\n\r\nThat sounds to me like the abstraction is wrong, and this interface maybe shouldn't exist, and instead plugins should be returning a `WritableByteChannel`.\r\n\r\nThat way the input is never exposed to the plugin and whatever problem that restriction is expected to solve would not exist.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T17:39:58Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "We discussed why this can't return a `WritableByteChannel` in this thread: https://github.com/palantir/spark/pull/535#discussion_r280193123",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T21:24:15Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "Let me try to summarize the discussion from that thread here so that we have some record of the decision in the mainline repository.\r\n\r\nBasically this comes from a need to block the `close` method from closing the underlying channel, but still keeping the optimization of `FileChannel#transferTo(otherFileChannel)`.\r\n\r\nWe can't return any custom implementation of `WritableByteChannel` here that shields closing, because `FileChannel#transferTo(writableByteChannel)` needs to specifically receive a `WritableByteChannel` that is an instance of `FileChannel`. But if the `WritableByteChannel` is indeed an instance of `FileChannel`, then `FileChannel#close()` will force the underlying channel to close, which is not what we want to do particularly for the local disk storage implementation given here.\r\n\r\nI agree that the abstraction here is convoluted. I proposed having an abstraction on top of the input `FileChannel` to prevent the plugin system from calling arbitrary methods on the input, but we decided that wasn't necessary in https://github.com/palantir/spark/pull/535#discussion_r280282920.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T21:30:41Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "> Basically this comes from a need to block the close method from closing the underlying channel\r\n\r\nI see. Still this is a really convoluted interface, which makes me more strongly prefer that this be hidden as an optimization in the internal, local file implementation, instead of being exposed in the public API.\r\n\r\nIf really exposing this in the public API, I think it would be better to have an interface that makes it clear what's the intent here: provide a `FileChannel` (and not any other kind of channel) that, depending on the plugin, should not be closed. So something like:\r\n\r\n```\r\ninterface FileChannelWrapper {\r\n\r\n  FileChannel openChannel();\r\n\r\n  boolean shouldClose();\r\n\r\n}\r\n```\r\n\r\nPlugins by default would just return a `null` wrapper, and then the code calling this could do:\r\n\r\n```\r\nFileChannel channel = transferToEnabled ? writer.fileChannelWrapper() : null;\r\nif (channel != null) {\r\n  Utils.copyBlahBlahBlah();\r\n  if (channel.shouldClose()) channel.close();\r\n} else {\r\n  // non-nio code path.\r\n}\r\n```\r\n\r\nIt's not great, but it's (i) less code than you have here and (ii) much clearer what's the actual intent of this API, without the restrictions about what methods should and should not be called.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T22:17:02Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Another option is to just return the `FileChannel` from `ShufflePartitionWriter`, and have the shuffle code never close the returned channel. Instead, the `ShuffleMapOutputWriter` would do it when it's safe to do so.\r\n\r\nThat's a little awkward though since it would basically codify into the interface what is just a suggestion in `openStream()` (where it says you should override `close()` if you don't want the underlying stream to be closed).\r\n\r\nBut that kinda gives me an idea for tweaking the above interface a bit; have this in `ShufflePartitionWriter` instead:\r\n\r\n```\r\nFileChannel openChannel();\r\n\r\ndefault void closeChannel(FileChannel channel) = { channel.close(); }\r\n```\r\n\r\nIf you do the same for the `openStream()` method (i.e. have a `closeStream()`), then the API is symmetrical, and you avoid the use of stream wrappers to block the call to `close()`.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T22:46:21Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "I went with a different sort of abstraction that captures the spirit of this idea in the latest patch. Please take a look and let me know what you think.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T23:21:31Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "Ah I didn't see your follow-up comment. I'm not as fond of passing the resource back to the plugin to ask the plugin to close it? I'm not sure, that isn't a very common programming idiom with respect to streams and resources - usually the `close` method is attached to the closeable resource itself.\r\n\r\nI liked the channel wrapper abstraction. We used to have the `close` method attached to the `ShufflePartitionWriter` and only closed the partition writer itself and not the channel, but that seemed prone to error on the plugin writer's side - since the partition writer returns a closeable resource itself, should the plugin expect the closeable resource it returns to be closed, or should it expect `ShufflePartitionWriter#close` to close the resource? Making `openStream` and `openChannel` return closeable resources is clearer with respect to the lifecycle of the returned resource.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T23:28:30Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Commenting here to keep context, even though this code doesn't exist anymore.\r\n\r\nI see you implemented basically my first suggestion. I think that if you instead make `ShufflePartitionWriter` implement `Closeable`, you can achieve the same goal with less things for people to implement. (`openChannel()` would just return a `WritableByteChannel`, and `close()` would close whatever was opened by either `open` call.)\r\n\r\nIt could even simplify some code in `BypassMergeSortShuffleWriter` since now the `close()` call would be the same regardless of whether it's a stream or a channel.\r\n\r\nBut that's minor now, and I'm just trying to reduce the amount of code needed for this optimization to work. Current version seems fine otherwise.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-25T00:02:57Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "I prefer this approach over making `ShufflePartitionWriter` implement `Closeable`, because `ShufflePartitionWriter` would return a `Closeable` resource (`OutputStream` or `WritableByteChannel`) that itself is not closed by the caller. That's why we originally went with `TransferrableWritableByteChannel` which itself is `Closeable` and doesn't return any `Closeable` objects. I think this is an in-between version, but it's unfortunate that `WritableByteChannelWrapper` itself returns a `WritableByteChannel` that itself isn't closed.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-25T01:57:21Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import org.apache.spark.annotation.Private;\n+\n+/**\n+ * :: Private ::\n+ * Represents an output byte channel that can copy bytes from input file channels to some\n+ * arbitrary storage system.\n+ * <p>\n+ * This API is provided for advanced users who can transfer bytes from a file channel to\n+ * some output sink without copying data into memory. Most users should not need to use\n+ * this functionality; this is primarily provided for the built-in shuffle storage backends\n+ * that persist shuffle files on local disk.\n+ * <p>\n+ * For a simpler alternative, see {@link ShufflePartitionWriter}.\n+ *\n+ * @since 3.0.0\n+ */\n+@Private\n+public interface TransferrableWritableByteChannel extends Closeable {\n+\n+  /**\n+   * Copy all bytes from the source readable byte channel into this byte channel.\n+   * <p>\n+   * This method should block until all of the bytes from the source (that is, up until\n+   * numBytesToTransfer) are available in the output storage layer.\n+   *\n+   * @param source File to transfer bytes from. Do not call anything on this channel other than"
  }],
  "prId": 25007
}]