[{
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "Isn't the MIN_VALUE overloaded, so it could be either a null or a literal min value? I think you might need to modify the prefix generation code in SortOrder.scala, rather than change the comparators.\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-01T17:52:19Z",
    "diffHunk": "@@ -69,49 +100,161 @@ public static long computePrefix(double value) {\n    * ordering they define is compatible with radix sort.\n    */\n   public abstract static class RadixSortSupport extends PrefixComparator {\n+\n     /** @return Whether the sort should be descending in binary sort order. */\n     public abstract boolean sortDescending();\n \n     /** @return Whether the sort should take into account the sign bit. */\n     public abstract boolean sortSigned();\n+\n+    /** @return Whether the sort should put null first or last. */\n+    public abstract NullOrder nullOrder();\n   }\n \n   //\n   // Standard prefix comparator implementations\n   //\n \n+  // unsigned asc null first (default)\n   public static final class UnsignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n     public int compare(long aPrefix, long bPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (aPrefix == 0L) {\n+        return -1;\n+      } else if (bPrefix == 0L) {\n+        return 1;\n+      }\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // unsigned asc null last\n+  public static final class UnsignedPrefixComparatorNullLast extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return false; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public NullOrder nullOrder() { return NullOrder.LAST; }\n+    public int compare(long aPrefix, long bPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (aPrefix == 0L) {\n+        return 1;\n+      } else if (bPrefix == 0L) {\n+        return -1;\n+      }\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null first\n+  public static final class UnsignedPrefixComparatorDescNullFirst extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return true; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n+    public int compare(long bPrefix, long aPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (bPrefix == 0L) {\n+        return -1;\n+      } else if (aPrefix == 0L) {\n+        return 1;\n+      }\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null last (default)\n   public static final class UnsignedPrefixComparatorDesc extends RadixSortSupport {\n     @Override public boolean sortDescending() { return true; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public NullOrder nullOrder() { return NullOrder.LAST; }\n     public int compare(long bPrefix, long aPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (bPrefix == 0L) {\n+        return 1;\n+      } else if (aPrefix == 0L) {\n+        return -1;\n+      }\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // signed asc null first (default)\n   public static final class SignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return true; }\n-    @Override\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n+    public int compare(long a, long b) {\n+        if (a == Long.MIN_VALUE && b == Long.MIN_VALUE) {\n+          return 0;\n+        }\n+        if (a == Long.MIN_VALUE) {\n+          return -1;\n+        } else if (b == Long.MIN_VALUE) {\n+          return 1;\n+        }\n+      return (a < b) ? -1 : (a > b) ? 1 : 0;\n+    }\n+  }\n+\n+  // signed asc null last\n+  public static final class SignedPrefixComparatorNullLast extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return false; }\n+    @Override public boolean sortSigned() { return true; }\n+    @Override public NullOrder nullOrder() { return NullOrder.LAST; }\n     public int compare(long a, long b) {\n+      if (a == Long.MIN_VALUE && b == Long.MIN_VALUE) {\n+        return 0;\n+      }\n+      if (a == Long.MIN_VALUE) {\n+        return 1;\n+      } else if (b == Long.MIN_VALUE) {\n+        return -1;\n+      }\n+      return (a < b) ? -1 : (a > b) ? 1 : 0;\n+    }\n+  }\n+\n+  // signed desc null first\n+  public static final class SignedPrefixComparatorDescNullFirst extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return true; }\n+    @Override public boolean sortSigned() { return true; }\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n+    public int compare(long b, long a) {\n+        if (a == Long.MIN_VALUE && b == Long.MIN_VALUE) {"
  }, {
    "author": {
      "login": "xwu0226"
    },
    "body": "The fact that MIN_VALUE could be also literal min value was also my concern too. I will check what I can in SortOrder.scala. Thanks!\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-01T18:21:39Z",
    "diffHunk": "@@ -69,49 +100,161 @@ public static long computePrefix(double value) {\n    * ordering they define is compatible with radix sort.\n    */\n   public abstract static class RadixSortSupport extends PrefixComparator {\n+\n     /** @return Whether the sort should be descending in binary sort order. */\n     public abstract boolean sortDescending();\n \n     /** @return Whether the sort should take into account the sign bit. */\n     public abstract boolean sortSigned();\n+\n+    /** @return Whether the sort should put null first or last. */\n+    public abstract NullOrder nullOrder();\n   }\n \n   //\n   // Standard prefix comparator implementations\n   //\n \n+  // unsigned asc null first (default)\n   public static final class UnsignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n     public int compare(long aPrefix, long bPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (aPrefix == 0L) {\n+        return -1;\n+      } else if (bPrefix == 0L) {\n+        return 1;\n+      }\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // unsigned asc null last\n+  public static final class UnsignedPrefixComparatorNullLast extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return false; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public NullOrder nullOrder() { return NullOrder.LAST; }\n+    public int compare(long aPrefix, long bPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (aPrefix == 0L) {\n+        return 1;\n+      } else if (bPrefix == 0L) {\n+        return -1;\n+      }\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null first\n+  public static final class UnsignedPrefixComparatorDescNullFirst extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return true; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n+    public int compare(long bPrefix, long aPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (bPrefix == 0L) {\n+        return -1;\n+      } else if (aPrefix == 0L) {\n+        return 1;\n+      }\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null last (default)\n   public static final class UnsignedPrefixComparatorDesc extends RadixSortSupport {\n     @Override public boolean sortDescending() { return true; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public NullOrder nullOrder() { return NullOrder.LAST; }\n     public int compare(long bPrefix, long aPrefix) {\n+      if (aPrefix == 0L && bPrefix == 0L) {\n+        return 0;\n+      }\n+      if (bPrefix == 0L) {\n+        return 1;\n+      } else if (aPrefix == 0L) {\n+        return -1;\n+      }\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // signed asc null first (default)\n   public static final class SignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return true; }\n-    @Override\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n+    public int compare(long a, long b) {\n+        if (a == Long.MIN_VALUE && b == Long.MIN_VALUE) {\n+          return 0;\n+        }\n+        if (a == Long.MIN_VALUE) {\n+          return -1;\n+        } else if (b == Long.MIN_VALUE) {\n+          return 1;\n+        }\n+      return (a < b) ? -1 : (a > b) ? 1 : 0;\n+    }\n+  }\n+\n+  // signed asc null last\n+  public static final class SignedPrefixComparatorNullLast extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return false; }\n+    @Override public boolean sortSigned() { return true; }\n+    @Override public NullOrder nullOrder() { return NullOrder.LAST; }\n     public int compare(long a, long b) {\n+      if (a == Long.MIN_VALUE && b == Long.MIN_VALUE) {\n+        return 0;\n+      }\n+      if (a == Long.MIN_VALUE) {\n+        return 1;\n+      } else if (b == Long.MIN_VALUE) {\n+        return -1;\n+      }\n+      return (a < b) ? -1 : (a > b) ? 1 : 0;\n+    }\n+  }\n+\n+  // signed desc null first\n+  public static final class SignedPrefixComparatorDescNullFirst extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return true; }\n+    @Override public boolean sortSigned() { return true; }\n+    @Override public NullOrder nullOrder() { return NullOrder.FIRST; }\n+    public int compare(long b, long a) {\n+        if (a == Long.MIN_VALUE && b == Long.MIN_VALUE) {"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "You can revert these changes now right?\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T00:55:20Z",
    "diffHunk": "@@ -27,14 +27,45 @@\n public class PrefixComparators {\n   private PrefixComparators() {}\n \n-  public static final PrefixComparator STRING = new UnsignedPrefixComparator();\n-  public static final PrefixComparator STRING_DESC = new UnsignedPrefixComparatorDesc();\n-  public static final PrefixComparator BINARY = new UnsignedPrefixComparator();\n-  public static final PrefixComparator BINARY_DESC = new UnsignedPrefixComparatorDesc();\n-  public static final PrefixComparator LONG = new SignedPrefixComparator();\n-  public static final PrefixComparator LONG_DESC = new SignedPrefixComparatorDesc();\n-  public static final PrefixComparator DOUBLE = new UnsignedPrefixComparator();\n-  public static final PrefixComparator DOUBLE_DESC = new UnsignedPrefixComparatorDesc();"
  }, {
    "author": {
      "login": "xwu0226"
    },
    "body": "Oh. yeah. I will remove the new lines. \n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T01:08:23Z",
    "diffHunk": "@@ -27,14 +27,45 @@\n public class PrefixComparators {\n   private PrefixComparators() {}\n \n-  public static final PrefixComparator STRING = new UnsignedPrefixComparator();\n-  public static final PrefixComparator STRING_DESC = new UnsignedPrefixComparatorDesc();\n-  public static final PrefixComparator BINARY = new UnsignedPrefixComparator();\n-  public static final PrefixComparator BINARY_DESC = new UnsignedPrefixComparatorDesc();\n-  public static final PrefixComparator LONG = new SignedPrefixComparator();\n-  public static final PrefixComparator LONG_DESC = new SignedPrefixComparatorDesc();\n-  public static final PrefixComparator DOUBLE = new UnsignedPrefixComparator();\n-  public static final PrefixComparator DOUBLE_DESC = new UnsignedPrefixComparatorDesc();"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "STRING_NULLS_LAST?\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:51:23Z",
    "diffHunk": "@@ -28,12 +28,31 @@\n   private PrefixComparators() {}\n \n   public static final PrefixComparator STRING = new UnsignedPrefixComparator();\n+  public static final PrefixComparator STRING_NULLLAST = new UnsignedPrefixComparatorNullLast();"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "It might be more readable to ignore the line length limit here.\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:51:46Z",
    "diffHunk": "@@ -28,12 +28,31 @@\n   private PrefixComparators() {}\n \n   public static final PrefixComparator STRING = new UnsignedPrefixComparator();\n+  public static final PrefixComparator STRING_NULLLAST = new UnsignedPrefixComparatorNullLast();\n+\n+  public static final PrefixComparator STRING_DESC_NULLFIRST =\n+          new UnsignedPrefixComparatorDescNullFirst();"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "nit: \"nullsFirst\"?\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:52:11Z",
    "diffHunk": "@@ -69,48 +86,96 @@ public static long computePrefix(double value) {\n    * ordering they define is compatible with radix sort.\n    */\n   public abstract static class RadixSortSupport extends PrefixComparator {\n+\n     /** @return Whether the sort should be descending in binary sort order. */\n     public abstract boolean sortDescending();\n \n     /** @return Whether the sort should take into account the sign bit. */\n     public abstract boolean sortSigned();\n+\n+    /** @return Whether the sort should put null first or last. */\n+    public abstract boolean nullFirst();"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "undo this change?\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:52:22Z",
    "diffHunk": "@@ -43,9 +62,7 @@ public static long computePrefix(UTF8String value) {\n   }\n \n   public static final class BinaryPrefixComparator {\n-    public static long computePrefix(byte[] bytes) {\n-      return ByteArray.getPrefix(bytes);\n-    }\n+    public static long computePrefix(byte[] bytes) { return ByteArray.getPrefix(bytes); }"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "nit: remove these comments\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:52:35Z",
    "diffHunk": "@@ -69,48 +86,96 @@ public static long computePrefix(double value) {\n    * ordering they define is compatible with radix sort.\n    */\n   public abstract static class RadixSortSupport extends PrefixComparator {\n+\n     /** @return Whether the sort should be descending in binary sort order. */\n     public abstract boolean sortDescending();\n \n     /** @return Whether the sort should take into account the sign bit. */\n     public abstract boolean sortSigned();\n+\n+    /** @return Whether the sort should put null first or last. */\n+    public abstract boolean nullFirst();\n   }\n \n   //\n   // Standard prefix comparator implementations\n   //\n \n+  // unsigned asc null first (default)\n   public static final class UnsignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public boolean nullFirst() { return true; }\n     public int compare(long aPrefix, long bPrefix) {\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // unsigned asc null last"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "nit: missing space before return\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:53:10Z",
    "diffHunk": "@@ -69,48 +86,96 @@ public static long computePrefix(double value) {\n    * ordering they define is compatible with radix sort.\n    */\n   public abstract static class RadixSortSupport extends PrefixComparator {\n+\n     /** @return Whether the sort should be descending in binary sort order. */\n     public abstract boolean sortDescending();\n \n     /** @return Whether the sort should take into account the sign bit. */\n     public abstract boolean sortSigned();\n+\n+    /** @return Whether the sort should put null first or last. */\n+    public abstract boolean nullFirst();\n   }\n \n   //\n   // Standard prefix comparator implementations\n   //\n \n+  // unsigned asc null first (default)\n   public static final class UnsignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public boolean nullFirst() { return true; }\n     public int compare(long aPrefix, long bPrefix) {\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // unsigned asc null last\n+  public static final class UnsignedPrefixComparatorNullLast extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return false; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public boolean nullFirst() { return false; }\n+    public int compare(long aPrefix, long bPrefix) {\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null first\n+  public static final class UnsignedPrefixComparatorDescNullFirst extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return true; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public boolean nullFirst() {return true;}"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "Should we be consistent and use the plural form of null(s) everywhere?\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:54:00Z",
    "diffHunk": "@@ -69,48 +86,96 @@ public static long computePrefix(double value) {\n    * ordering they define is compatible with radix sort.\n    */\n   public abstract static class RadixSortSupport extends PrefixComparator {\n+\n     /** @return Whether the sort should be descending in binary sort order. */\n     public abstract boolean sortDescending();\n \n     /** @return Whether the sort should take into account the sign bit. */\n     public abstract boolean sortSigned();\n+\n+    /** @return Whether the sort should put null first or last. */\n+    public abstract boolean nullFirst();\n   }\n \n   //\n   // Standard prefix comparator implementations\n   //\n \n+  // unsigned asc null first (default)\n   public static final class UnsignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public boolean nullFirst() { return true; }\n     public int compare(long aPrefix, long bPrefix) {\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // unsigned asc null last\n+  public static final class UnsignedPrefixComparatorNullLast extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return false; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public boolean nullFirst() { return false; }\n+    public int compare(long aPrefix, long bPrefix) {\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null first\n+  public static final class UnsignedPrefixComparatorDescNullFirst extends RadixSortSupport {\n+    @Override public boolean sortDescending() { return true; }\n+    @Override public boolean sortSigned() { return false; }\n+    @Override public boolean nullFirst() {return true;}\n+    public int compare(long bPrefix, long aPrefix) {\n+      return UnsignedLongs.compare(aPrefix, bPrefix);\n+    }\n+  }\n+\n+  // unsigned desc null last (default)\n   public static final class UnsignedPrefixComparatorDesc extends RadixSortSupport {\n     @Override public boolean sortDescending() { return true; }\n     @Override public boolean sortSigned() { return false; }\n-    @Override\n+    @Override public boolean nullFirst() { return false; }\n     public int compare(long bPrefix, long aPrefix) {\n       return UnsignedLongs.compare(aPrefix, bPrefix);\n     }\n   }\n \n+  // signed asc null first (default)\n   public static final class SignedPrefixComparator extends RadixSortSupport {\n     @Override public boolean sortDescending() { return false; }\n     @Override public boolean sortSigned() { return true; }\n-    @Override\n+    @Override public boolean nullFirst() { return true; }\n     public int compare(long a, long b) {\n       return (a < b) ? -1 : (a > b) ? 1 : 0;\n     }\n   }\n \n+  // signed asc null last\n+  public static final class SignedPrefixComparatorNullLast extends RadixSortSupport {"
  }],
  "prId": 14842
}, {
  "comments": [{
    "author": {
      "login": "ericl"
    },
    "body": "Probably better to order as LONG, LONG_DESC, LONG_NULL_LAST, LONG_DESC_NULL_LAST here and elsewhere\n",
    "commit": "5153ce5261752cf6c33b8f48759de495ed8890c3",
    "createdAt": "2016-09-10T02:56:15Z",
    "diffHunk": "@@ -28,12 +28,31 @@\n   private PrefixComparators() {}\n \n   public static final PrefixComparator STRING = new UnsignedPrefixComparator();\n+  public static final PrefixComparator STRING_NULLLAST = new UnsignedPrefixComparatorNullLast();\n+\n+  public static final PrefixComparator STRING_DESC_NULLFIRST =\n+          new UnsignedPrefixComparatorDescNullFirst();\n   public static final PrefixComparator STRING_DESC = new UnsignedPrefixComparatorDesc();\n+\n   public static final PrefixComparator BINARY = new UnsignedPrefixComparator();\n+  public static final PrefixComparator BINARY_NULLLAST = new UnsignedPrefixComparatorNullLast();\n+\n+  public static final PrefixComparator BINARY_DESC_NULLFIRST =\n+          new UnsignedPrefixComparatorDescNullFirst();\n   public static final PrefixComparator BINARY_DESC = new UnsignedPrefixComparatorDesc();\n+\n   public static final PrefixComparator LONG = new SignedPrefixComparator();\n+  public static final PrefixComparator LONG_NULLLAST = new SignedPrefixComparatorNullLast();\n+\n+  public static final PrefixComparator LONG_DESC_NULLFIRST =\n+          new SignedPrefixComparatorDescNullFirst();\n   public static final PrefixComparator LONG_DESC = new SignedPrefixComparatorDesc();"
  }],
  "prId": 14842
}]