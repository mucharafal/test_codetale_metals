[{
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "Should length of (Integer.MAX_VALUE / 2) be allowed ?\n",
    "commit": "6beb4674999820126861fdac99fb84f8ea5d57ff",
    "createdAt": "2015-07-16T23:22:39Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection.unsafe.sort;\n+\n+import org.apache.spark.util.collection.SortDataFormat;\n+\n+/**\n+ * Supports sorting an array of (record pointer, key prefix) pairs.\n+ * Used in {@link UnsafeInMemorySorter}.\n+ * <p>\n+ * Within each long[] buffer, position {@code 2 * i} holds a pointer pointer to the record at\n+ * index {@code i}, while position {@code 2 * i + 1} in the array holds an 8-byte key prefix.\n+ */\n+final class UnsafeSortDataFormat extends SortDataFormat<RecordPointerAndKeyPrefix, long[]> {\n+\n+  public static final UnsafeSortDataFormat INSTANCE = new UnsafeSortDataFormat();\n+\n+  private UnsafeSortDataFormat() { }\n+\n+  @Override\n+  public RecordPointerAndKeyPrefix getKey(long[] data, int pos) {\n+    // Since we re-use keys, this method shouldn't be called.\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public RecordPointerAndKeyPrefix newKey() {\n+    return new RecordPointerAndKeyPrefix();\n+  }\n+\n+  @Override\n+  public RecordPointerAndKeyPrefix getKey(long[] data, int pos, RecordPointerAndKeyPrefix reuse) {\n+    reuse.recordPointer = data[pos * 2];\n+    reuse.keyPrefix = data[pos * 2 + 1];\n+    return reuse;\n+  }\n+\n+  @Override\n+  public void swap(long[] data, int pos0, int pos1) {\n+    long tempPointer = data[pos0 * 2];\n+    long tempKeyPrefix = data[pos0 * 2 + 1];\n+    data[pos0 * 2] = data[pos1 * 2];\n+    data[pos0 * 2 + 1] = data[pos1 * 2 + 1];\n+    data[pos1 * 2] = tempPointer;\n+    data[pos1 * 2 + 1] = tempKeyPrefix;\n+  }\n+\n+  @Override\n+  public void copyElement(long[] src, int srcPos, long[] dst, int dstPos) {\n+    dst[dstPos * 2] = src[srcPos * 2];\n+    dst[dstPos * 2 + 1] = src[srcPos * 2 + 1];\n+  }\n+\n+  @Override\n+  public void copyRange(long[] src, int srcPos, long[] dst, int dstPos, int length) {\n+    System.arraycopy(src, srcPos * 2, dst, dstPos * 2, length * 2);\n+  }\n+\n+  @Override\n+  public long[] allocate(int length) {\n+    assert (length < Integer.MAX_VALUE / 2) : \"Length \" + length + \" is too large\";",
    "line": 76
  }],
  "prId": 6444
}]