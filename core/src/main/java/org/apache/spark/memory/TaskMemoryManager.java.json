[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Could be final.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-27T21:08:19Z",
    "diffHunk": "@@ -101,27 +106,95 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private HashMap<MemoryConsumer, Long> consumers;"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Add an assert to make sure `size >= 0`?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-27T21:10:04Z",
    "diffHunk": "@@ -101,27 +106,95 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      long old = 0L;\n+      if (consumers.containsKey(consumer)) {\n+        old = consumers.get(consumer);\n+      }\n+      consumers.put(consumer, got + old);\n+\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n-    memoryManager.releaseExecutionMemory(size, taskAttemptId);\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "done\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T21:07:01Z",
    "diffHunk": "@@ -101,27 +106,95 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      long old = 0L;\n+      if (consumers.containsKey(consumer)) {\n+        old = consumers.get(consumer);\n+      }\n+      consumers.put(consumer, got + old);\n+\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n-    memoryManager.releaseExecutionMemory(size, taskAttemptId);\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Space before `for`\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-27T21:10:36Z",
    "diffHunk": "@@ -101,27 +106,95 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      long old = 0L;\n+      if (consumers.containsKey(consumer)) {\n+        old = consumers.get(consumer);\n+      }\n+      consumers.put(consumer, got + old);\n+\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n-    memoryManager.releaseExecutionMemory(size, taskAttemptId);\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {\n+    if (size == 0) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (consumers.containsKey(consumer)) {\n+        long old = consumers.get(consumer);\n+        if (old > size) {\n+          consumers.put(consumer, old - size);\n+        } else {\n+          if (old < size) {\n+            if (Utils.isTesting()) {\n+              Platform.throwException(\n+                new SparkException(\"Release more memory \" + size + \"than acquired \" + old + \" for \"\n+                  + consumer));\n+            } else {\n+              logger.warn(\"Release more memory \" + size + \" than acquired \" + old + \"for \""
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "what if consumer is the only one in consumers ?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T20:15:25Z",
    "diffHunk": "@@ -101,27 +106,97 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got, consumer);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got, consumer);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Then this call will be no-op, could be avoided.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T21:06:50Z",
    "diffHunk": "@@ -101,27 +106,97 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got, consumer);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got, consumer);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);"
  }, {
    "author": {
      "login": "tedyu"
    },
    "body": "My point was that got may not be equal to size coming out of the loop.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T21:09:29Z",
    "diffHunk": "@@ -101,27 +106,97 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got, consumer);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got, consumer);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "This function does not garantee that `got` will be equal to `size`, after call spill().\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T21:18:10Z",
    "diffHunk": "@@ -101,27 +106,97 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got, consumer);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got, consumer);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "not existed -> non-existent\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T20:19:31Z",
    "diffHunk": "@@ -101,27 +106,97 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got, consumer);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got, consumer);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      long old = 0L;\n+      if (consumers.containsKey(consumer)) {\n+        old = consumers.get(consumer);\n+      }\n+      consumers.put(consumer, got + old);\n+\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n-    memoryManager.releaseExecutionMemory(size, taskAttemptId);\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {\n+    assert(size >= 0);\n+    if (size == 0) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (consumers.containsKey(consumer)) {\n+        long old = consumers.get(consumer);\n+        if (old > size) {\n+          consumers.put(consumer, old - size);\n+        } else {\n+          if (old < size) {\n+            if (Utils.isTesting()) {\n+              Platform.throwException(\n+                new SparkException(\"Release more memory \" + size + \"than acquired \" + old + \" for \"\n+                  + consumer));\n+            } else {\n+              logger.warn(\"Release more memory \" + size + \" than acquired \" + old + \" for \"\n+                + consumer);\n+            }\n+          }\n+          consumers.remove(consumer);\n+        }\n+      } else {\n+        if (Utils.isTesting()) {\n+          Platform.throwException(\n+            new SparkException(\"Release memory \" + size + \" for not existed \" + consumer));"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "Maybe add new method to Utils, accepting message String, which covers lines 191 to 196\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-28T20:20:42Z",
    "diffHunk": "@@ -101,27 +106,97 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long size, MemoryConsumer consumer) throws IOException {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+\n+      // call spill() on itself to release some memory\n+      if (got < size && consumer != null) {\n+        consumer.spill(size - got, consumer);\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      if (got < size) {\n+        long needed = size - got;\n+        // call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers.keySet()) {\n+          if (c != null && c != consumer) {\n+            needed -= c.spill(size - got, consumer);\n+            if (needed < 0) {\n+              break;\n+            }\n+          }\n+        }\n+        got += memoryManager.acquireExecutionMemory(size - got, taskAttemptId);\n+      }\n+\n+      long old = 0L;\n+      if (consumers.containsKey(consumer)) {\n+        old = consumers.get(consumer);\n+      }\n+      consumers.put(consumer, got + old);\n+\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n-    memoryManager.releaseExecutionMemory(size, taskAttemptId);\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {\n+    assert(size >= 0);\n+    if (size == 0) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (consumers.containsKey(consumer)) {\n+        long old = consumers.get(consumer);\n+        if (old > size) {\n+          consumers.put(consumer, old - size);\n+        } else {\n+          if (old < size) {\n+            if (Utils.isTesting()) {\n+              Platform.throwException(\n+                new SparkException(\"Release more memory \" + size + \"than acquired \" + old + \" for \"\n+                  + consumer));\n+            } else {\n+              logger.warn(\"Release more memory \" + size + \" than acquired \" + old + \" for \"\n+                + consumer);\n+            }\n+          }\n+          consumers.remove(consumer);\n+        }\n+      } else {\n+        if (Utils.isTesting()) {\n+          Platform.throwException("
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Rather than maintaining a separate bookkeeping map, why not track the amount of memory granted to each `MemoryConsumer` inside of the consumer itself, then expose a method to let us retrieve that size from the consumer instance?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:45:54Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "This could potentially simplify some of the code in the transferMemory and releaseMemory methods down below.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:51:53Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "How do we wind up with null keys in the consumers map?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:48:31Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "There could be some cases the memory is acquire not by a consumer, it will be null.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T21:54:12Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Instead of using string concatenation to pass the IOException's message, why not use regular exception chaining here? Does `OutOfMemoryError` not support that?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:49:24Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {\n+            try {\n+              long released = c.spill(required - got, consumer);\n+              if (released > 0) {\n+                logger.info(\"Task {} released {} from {} for {}\", taskAttemptId,\n+                  Utils.bytesToString(released), c, consumer);\n+                got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+                if (got >= required) {\n+                  break;\n+                }\n+              }\n+            } catch (IOException e) {\n+              logger.error(\"error while calling spill() on \" + c, e);\n+              throw new OutOfMemoryError(\"error while calling spill() on \" + c + \" : \"\n+                + e.getMessage());",
    "line": 72
  }, {
    "author": {
      "login": "davies"
    },
    "body": "It does not support that.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T21:53:05Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {\n+            try {\n+              long released = c.spill(required - got, consumer);\n+              if (released > 0) {\n+                logger.info(\"Task {} released {} from {} for {}\", taskAttemptId,\n+                  Utils.bytesToString(released), c, consumer);\n+                got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+                if (got >= required) {\n+                  break;\n+                }\n+              }\n+            } catch (IOException e) {\n+              logger.error(\"error while calling spill() on \" + c, e);\n+              throw new OutOfMemoryError(\"error while calling spill() on \" + c + \" : \"\n+                + e.getMessage());",
    "line": 72
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Is the `else` branch here supposed to be an error case?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:51:30Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {\n+            try {\n+              long released = c.spill(required - got, consumer);\n+              if (released > 0) {\n+                logger.info(\"Task {} released {} from {} for {}\", taskAttemptId,\n+                  Utils.bytesToString(released), c, consumer);\n+                got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+                if (got >= required) {\n+                  break;\n+                }\n+              }\n+            } catch (IOException e) {\n+              logger.error(\"error while calling spill() on \" + c, e);\n+              throw new OutOfMemoryError(\"error while calling spill() on \" + c + \" : \"\n+                + e.getMessage());\n+            }\n+          }\n+        }\n+      }\n+\n+      // call spill() on itself\n+      if (got < required && consumer != null) {\n+        try {\n+          long released = consumer.spill(required - got, consumer);\n+          if (released > 0) {\n+            logger.info(\"Task {} released {} from itself ({})\", taskAttemptId,\n+              Utils.bytesToString(released), consumer);\n+            got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+          }\n+        } catch (IOException e) {\n+          logger.error(\"error while calling spill() on \" + consumer, e);\n+          throw new OutOfMemoryError(\"error while calling spill() on \" + consumer + \" : \"\n+            + e.getMessage());\n+        }\n+      }\n+\n+      // Update the accounting, even consumer is null\n+      if (got > 0) {\n+        long old = 0L;\n+        if (consumers.containsKey(consumer)) {\n+          old = consumers.get(consumer);\n+        }\n+        consumers.put(consumer, got + old);\n+      }\n+\n+      logger.debug(\"Task {} acquire {} for {}\", taskAttemptId, Utils.bytesToString(got), consumer);\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {\n+    assert(size >= 0);\n+    if (size == 0) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (consumers.containsKey(consumer)) {\n+        long old = consumers.get(consumer);\n+        if (old > size) {\n+          consumers.put(consumer, old - size);\n+        } else {\n+          if (old < size) {\n+            String msg = \"Release \" + size + \" bytes memory (more than acquired \" + old + \") for \"\n+              + consumer;\n+            logger.warn(msg);\n+            if (Utils.isTesting()) {\n+              Platform.throwException(new SparkException(msg));\n+            }\n+          }\n+          consumers.remove(consumer);\n+        }\n+      } else {\n+        String msg = \"Release \" + size + \" bytes memory for non-existent \" + consumer;\n+        logger.warn(msg);\n+        if (Utils.isTesting()) {\n+          Platform.throwException(new SparkException(msg));\n+        }\n+      }\n+    }\n+\n+    logger.debug(\"Task {} release {} from {}\", taskAttemptId, Utils.bytesToString(size), consumer);\n     memoryManager.releaseExecutionMemory(size, taskAttemptId);\n   }\n \n+  public void transferOwnership(long size, MemoryConsumer from, MemoryConsumer to) {\n+    assert(size >= 0);\n+    synchronized (this) {\n+      if (consumers.containsKey(from)) {\n+        long old = consumers.get(from);\n+        if (old > size) {\n+          consumers.put(from, old - size);\n+        } else {\n+          consumers.remove(from);\n+        }\n+        if (consumers.containsKey(to)) {\n+          old = consumers.get(to);\n+        } else {\n+          old = 0L;\n+        }\n+        consumers.put(to, old + size);\n+      }"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Just to clarify: is the memory leaked by these consumers also accounted for in the value returned by `releaseAllExecutionMemoryForTask`? Just want to make sure that this method's return value doesn't under- or over-count leaked memory.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:53:31Z",
    "diffHunk": "@@ -261,17 +397,14 @@ public long getOffsetInPage(long pagePlusOffsetAddress) {\n    * value can be used to detect memory leaks.\n    */\n   public long cleanUpAllAllocatedMemory() {\n-    long freedBytes = 0;\n-    for (MemoryBlock page : pageTable) {\n-      if (page != null) {\n-        freedBytes += page.size();\n-        freePage(page);\n+    synchronized (this) {\n+      Arrays.fill(pageTable, null);\n+      for (MemoryConsumer c: consumers.keySet()) {\n+        logger.warn(\"leak \" + Utils.bytesToString(consumers.get(c)) + \" memory from \" + c);"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "It looks like this method isn't used anywhere?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T20:57:43Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {\n+            try {\n+              long released = c.spill(required - got, consumer);\n+              if (released > 0) {\n+                logger.info(\"Task {} released {} from {} for {}\", taskAttemptId,\n+                  Utils.bytesToString(released), c, consumer);\n+                got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+                if (got >= required) {\n+                  break;\n+                }\n+              }\n+            } catch (IOException e) {\n+              logger.error(\"error while calling spill() on \" + c, e);\n+              throw new OutOfMemoryError(\"error while calling spill() on \" + c + \" : \"\n+                + e.getMessage());\n+            }\n+          }\n+        }\n+      }\n+\n+      // call spill() on itself\n+      if (got < required && consumer != null) {\n+        try {\n+          long released = consumer.spill(required - got, consumer);\n+          if (released > 0) {\n+            logger.info(\"Task {} released {} from itself ({})\", taskAttemptId,\n+              Utils.bytesToString(released), consumer);\n+            got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+          }\n+        } catch (IOException e) {\n+          logger.error(\"error while calling spill() on \" + consumer, e);\n+          throw new OutOfMemoryError(\"error while calling spill() on \" + consumer + \" : \"\n+            + e.getMessage());\n+        }\n+      }\n+\n+      // Update the accounting, even consumer is null\n+      if (got > 0) {\n+        long old = 0L;\n+        if (consumers.containsKey(consumer)) {\n+          old = consumers.get(consumer);\n+        }\n+        consumers.put(consumer, got + old);\n+      }\n+\n+      logger.debug(\"Task {} acquire {} for {}\", taskAttemptId, Utils.bytesToString(got), consumer);\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {\n+    assert(size >= 0);\n+    if (size == 0) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (consumers.containsKey(consumer)) {\n+        long old = consumers.get(consumer);\n+        if (old > size) {\n+          consumers.put(consumer, old - size);\n+        } else {\n+          if (old < size) {\n+            String msg = \"Release \" + size + \" bytes memory (more than acquired \" + old + \") for \"\n+              + consumer;\n+            logger.warn(msg);\n+            if (Utils.isTesting()) {\n+              Platform.throwException(new SparkException(msg));\n+            }\n+          }\n+          consumers.remove(consumer);\n+        }\n+      } else {\n+        String msg = \"Release \" + size + \" bytes memory for non-existent \" + consumer;\n+        logger.warn(msg);\n+        if (Utils.isTesting()) {\n+          Platform.throwException(new SparkException(msg));\n+        }\n+      }\n+    }\n+\n+    logger.debug(\"Task {} release {} from {}\", taskAttemptId, Utils.bytesToString(size), consumer);\n     memoryManager.releaseExecutionMemory(size, taskAttemptId);\n   }\n \n+  public void transferOwnership(long size, MemoryConsumer from, MemoryConsumer to) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Yes, will be removed.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T21:02:09Z",
    "diffHunk": "@@ -101,29 +107,161 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashMap<MemoryConsumer, Long> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashMap<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // consumers could be modified by spill(), so we should have a copy here.\n+        MemoryConsumer[] cs = new MemoryConsumer[consumers.size()];\n+        consumers.keySet().toArray(cs);\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: cs) {\n+          if (c != null && c != consumer) {\n+            try {\n+              long released = c.spill(required - got, consumer);\n+              if (released > 0) {\n+                logger.info(\"Task {} released {} from {} for {}\", taskAttemptId,\n+                  Utils.bytesToString(released), c, consumer);\n+                got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+                if (got >= required) {\n+                  break;\n+                }\n+              }\n+            } catch (IOException e) {\n+              logger.error(\"error while calling spill() on \" + c, e);\n+              throw new OutOfMemoryError(\"error while calling spill() on \" + c + \" : \"\n+                + e.getMessage());\n+            }\n+          }\n+        }\n+      }\n+\n+      // call spill() on itself\n+      if (got < required && consumer != null) {\n+        try {\n+          long released = consumer.spill(required - got, consumer);\n+          if (released > 0) {\n+            logger.info(\"Task {} released {} from itself ({})\", taskAttemptId,\n+              Utils.bytesToString(released), consumer);\n+            got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+          }\n+        } catch (IOException e) {\n+          logger.error(\"error while calling spill() on \" + consumer, e);\n+          throw new OutOfMemoryError(\"error while calling spill() on \" + consumer + \" : \"\n+            + e.getMessage());\n+        }\n+      }\n+\n+      // Update the accounting, even consumer is null\n+      if (got > 0) {\n+        long old = 0L;\n+        if (consumers.containsKey(consumer)) {\n+          old = consumers.get(consumer);\n+        }\n+        consumers.put(consumer, got + old);\n+      }\n+\n+      logger.debug(\"Task {} acquire {} for {}\", taskAttemptId, Utils.bytesToString(got), consumer);\n+      return got;\n+    }\n   }\n \n   /**\n-   * Release N bytes of execution memory.\n+   * Release N bytes of execution memory for a MemoryConsumer.\n    */\n-  public void releaseExecutionMemory(long size) {\n+  public void releaseExecutionMemory(long size, MemoryConsumer consumer) {\n+    assert(size >= 0);\n+    if (size == 0) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (consumers.containsKey(consumer)) {\n+        long old = consumers.get(consumer);\n+        if (old > size) {\n+          consumers.put(consumer, old - size);\n+        } else {\n+          if (old < size) {\n+            String msg = \"Release \" + size + \" bytes memory (more than acquired \" + old + \") for \"\n+              + consumer;\n+            logger.warn(msg);\n+            if (Utils.isTesting()) {\n+              Platform.throwException(new SparkException(msg));\n+            }\n+          }\n+          consumers.remove(consumer);\n+        }\n+      } else {\n+        String msg = \"Release \" + size + \" bytes memory for non-existent \" + consumer;\n+        logger.warn(msg);\n+        if (Utils.isTesting()) {\n+          Platform.throwException(new SparkException(msg));\n+        }\n+      }\n+    }\n+\n+    logger.debug(\"Task {} release {} from {}\", taskAttemptId, Utils.bytesToString(size), consumer);\n     memoryManager.releaseExecutionMemory(size, taskAttemptId);\n   }\n \n+  public void transferOwnership(long size, MemoryConsumer from, MemoryConsumer to) {"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Good idea.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T21:03:42Z",
    "diffHunk": "@@ -261,17 +397,14 @@ public long getOffsetInPage(long pagePlusOffsetAddress) {\n    * value can be used to detect memory leaks.\n    */\n   public long cleanUpAllAllocatedMemory() {\n-    long freedBytes = 0;\n-    for (MemoryBlock page : pageTable) {\n-      if (page != null) {\n-        freedBytes += page.size();\n-        freePage(page);\n+    synchronized (this) {\n+      Arrays.fill(pageTable, null);",
    "line": 211
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Does this approach still have the same concern about concurrent modification of `consumers` while iterating over it?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T23:18:51Z",
    "diffHunk": "@@ -101,29 +105,103 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashSet<MemoryConsumer> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashSet<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers) {",
    "line": 57
  }, {
    "author": {
      "login": "davies"
    },
    "body": "No, we never remove it, and it will not add more under this lock.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T23:40:10Z",
    "diffHunk": "@@ -101,29 +105,103 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashSet<MemoryConsumer> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashSet<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers) {",
    "line": 57
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Add a comment to explain that this field is guarded by synchronizing on `this` (or use `@GuardedBy(\"this\")`).\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-29T23:32:44Z",
    "diffHunk": "@@ -101,29 +105,103 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  private final HashSet<MemoryConsumer> consumers;"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "Should this catch clause be moved to wrap c.spill() at line 142 ?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-30T23:14:28Z",
    "diffHunk": "@@ -101,29 +106,104 @@\n   private final boolean inHeap;\n \n   /**\n+   * The size of memory granted to each consumer.\n+   */\n+  @GuardedBy(\"this\")\n+  private final HashSet<MemoryConsumer> consumers;\n+\n+  /**\n    * Construct a new TaskMemoryManager.\n    */\n   public TaskMemoryManager(MemoryManager memoryManager, long taskAttemptId) {\n     this.inHeap = memoryManager.tungstenMemoryIsAllocatedInHeap();\n     this.memoryManager = memoryManager;\n     this.taskAttemptId = taskAttemptId;\n+    this.consumers = new HashSet<>();\n   }\n \n   /**\n-   * Acquire N bytes of memory for execution, evicting cached blocks if necessary.\n+   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\n+   * spill() of consumers to release more memory.\n+   *\n    * @return number of bytes successfully granted (<= N).\n    */\n-  public long acquireExecutionMemory(long size) {\n-    return memoryManager.acquireExecutionMemory(size, taskAttemptId);\n+  public long acquireExecutionMemory(long required, MemoryConsumer consumer) {\n+    assert(required >= 0);\n+    synchronized (this) {\n+      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId);\n+\n+      // try to release memory from other consumers first, then we can reduce the frequency of\n+      // spilling, avoid to have too many spilled files.\n+      if (got < required) {\n+        // Call spill() on other consumers to release memory\n+        for (MemoryConsumer c: consumers) {\n+          if (c != null && c != consumer && c.getUsed() > 0) {\n+            try {\n+              long released = c.spill(required - got, consumer);\n+              if (released > 0) {\n+                logger.info(\"Task {} released {} from {} for {}\", taskAttemptId,\n+                  Utils.bytesToString(released), c, consumer);\n+                got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId);\n+                if (got >= required) {\n+                  break;\n+                }\n+              }\n+            } catch (IOException e) {",
    "line": 69
  }],
  "prId": 9241
}]