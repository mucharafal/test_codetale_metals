[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "What happens if `await()` throws an exception? Is it ok not to update `isWaiting`?",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-10T06:48:44Z",
    "diffHunk": "@@ -232,7 +229,9 @@ private void waitForAsyncReadComplete() throws IOException {\n     stateChangeLock.lock();\n     try {\n       while (readInProgress) {\n+        isWaiting.set(true);\n         asyncReadComplete.await();\n+        isWaiting.set(false);"
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "Good catch, I added `isWaiting.set(false)` to the finally branch.\r\nActually, since the whole implementation assumes that there is only one reader, I removed the while() loop, since there is no other reader to race with us to trigger another read.\r\n\r\nIn practice I think not updating `isWaiting` it would have been benign, as after the exception the query will be going down with an `InterruptedException`, or elsewise anyone upstream handling that exception would most probably declare that stream as unusable afterwards anyway.",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-12T18:51:46Z",
    "diffHunk": "@@ -232,7 +229,9 @@ private void waitForAsyncReadComplete() throws IOException {\n     stateChangeLock.lock();\n     try {\n       while (readInProgress) {\n+        isWaiting.set(true);\n         asyncReadComplete.await();\n+        isWaiting.set(false);"
  }],
  "prId": 20555
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Is it good to use `read-ahead` instead of `read ahead` in comments for ease of reading?",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-10T07:07:02Z",
    "diffHunk": "@@ -258,54 +262,43 @@ public int read(byte[] b, int offset, int len) throws IOException {\n     if (len == 0) {\n       return 0;\n     }\n-    stateChangeLock.lock();\n-    try {\n-      return readInternal(b, offset, len);\n-    } finally {\n-      stateChangeLock.unlock();\n-    }\n-  }\n-\n-  /**\n-   * flip the active and read ahead buffer\n-   */\n-  private void swapBuffers() {\n-    ByteBuffer temp = activeBuffer;\n-    activeBuffer = readAheadBuffer;\n-    readAheadBuffer = temp;\n-  }\n \n-  /**\n-   * Internal read function which should be called only from read() api. The assumption is that\n-   * the stateChangeLock is already acquired in the caller before calling this function.\n-   */\n-  private int readInternal(byte[] b, int offset, int len) throws IOException {\n-    assert (stateChangeLock.isLocked());\n     if (!activeBuffer.hasRemaining()) {\n-      waitForAsyncReadComplete();\n-      if (readAheadBuffer.hasRemaining()) {\n-        swapBuffers();\n-      } else {\n-        // The first read or activeBuffer is skipped.\n-        readAsync();\n+      // No remaining in active buffer - lock and switch to write ahead buffer.\n+      stateChangeLock.lock();\n+      try {\n         waitForAsyncReadComplete();\n-        if (isEndOfStream()) {\n-          return -1;\n+        if (!readAheadBuffer.hasRemaining()) {\n+          // The first read or activeBuffer is skipped.\n+          readAsync();\n+          waitForAsyncReadComplete();\n+          if (isEndOfStream()) {\n+            return -1;\n+          }\n         }\n+        // Swap the newly read read ahead buffer in place of empty active buffer.",
    "line": 162
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "Other existing places in comments in the file use `read ahead`.",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-12T18:36:47Z",
    "diffHunk": "@@ -258,54 +262,43 @@ public int read(byte[] b, int offset, int len) throws IOException {\n     if (len == 0) {\n       return 0;\n     }\n-    stateChangeLock.lock();\n-    try {\n-      return readInternal(b, offset, len);\n-    } finally {\n-      stateChangeLock.unlock();\n-    }\n-  }\n-\n-  /**\n-   * flip the active and read ahead buffer\n-   */\n-  private void swapBuffers() {\n-    ByteBuffer temp = activeBuffer;\n-    activeBuffer = readAheadBuffer;\n-    readAheadBuffer = temp;\n-  }\n \n-  /**\n-   * Internal read function which should be called only from read() api. The assumption is that\n-   * the stateChangeLock is already acquired in the caller before calling this function.\n-   */\n-  private int readInternal(byte[] b, int offset, int len) throws IOException {\n-    assert (stateChangeLock.isLocked());\n     if (!activeBuffer.hasRemaining()) {\n-      waitForAsyncReadComplete();\n-      if (readAheadBuffer.hasRemaining()) {\n-        swapBuffers();\n-      } else {\n-        // The first read or activeBuffer is skipped.\n-        readAsync();\n+      // No remaining in active buffer - lock and switch to write ahead buffer.\n+      stateChangeLock.lock();\n+      try {\n         waitForAsyncReadComplete();\n-        if (isEndOfStream()) {\n-          return -1;\n+        if (!readAheadBuffer.hasRemaining()) {\n+          // The first read or activeBuffer is skipped.\n+          readAsync();\n+          waitForAsyncReadComplete();\n+          if (isEndOfStream()) {\n+            return -1;\n+          }\n         }\n+        // Swap the newly read read ahead buffer in place of empty active buffer.",
    "line": 162
  }],
  "prId": 20555
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "unrelated question: what does `activeBuffer is skipped` mean?",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-13T10:44:12Z",
    "diffHunk": "@@ -258,54 +263,43 @@ public int read(byte[] b, int offset, int len) throws IOException {\n     if (len == 0) {\n       return 0;\n     }\n-    stateChangeLock.lock();\n-    try {\n-      return readInternal(b, offset, len);\n-    } finally {\n-      stateChangeLock.unlock();\n-    }\n-  }\n \n-  /**\n-   * flip the active and read ahead buffer\n-   */\n-  private void swapBuffers() {\n-    ByteBuffer temp = activeBuffer;\n-    activeBuffer = readAheadBuffer;\n-    readAheadBuffer = temp;\n-  }\n-\n-  /**\n-   * Internal read function which should be called only from read() api. The assumption is that\n-   * the stateChangeLock is already acquired in the caller before calling this function.\n-   */\n-  private int readInternal(byte[] b, int offset, int len) throws IOException {\n-    assert (stateChangeLock.isLocked());\n     if (!activeBuffer.hasRemaining()) {\n-      waitForAsyncReadComplete();\n-      if (readAheadBuffer.hasRemaining()) {\n-        swapBuffers();\n-      } else {\n-        // The first read or activeBuffer is skipped.\n-        readAsync();\n+      // No remaining in active buffer - lock and switch to write ahead buffer.\n+      stateChangeLock.lock();\n+      try {\n         waitForAsyncReadComplete();\n-        if (isEndOfStream()) {\n-          return -1;\n+        if (!readAheadBuffer.hasRemaining()) {\n+          // The first read or activeBuffer is skipped."
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "skipped using `skip()`.\r\nI moved the comment over from a few lines above, but looking at `skip()` now I don't think it can happen - the skip would trigger an `readAsync` read in that case.\r\nI'll update the comment.",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-13T19:16:15Z",
    "diffHunk": "@@ -258,54 +263,43 @@ public int read(byte[] b, int offset, int len) throws IOException {\n     if (len == 0) {\n       return 0;\n     }\n-    stateChangeLock.lock();\n-    try {\n-      return readInternal(b, offset, len);\n-    } finally {\n-      stateChangeLock.unlock();\n-    }\n-  }\n \n-  /**\n-   * flip the active and read ahead buffer\n-   */\n-  private void swapBuffers() {\n-    ByteBuffer temp = activeBuffer;\n-    activeBuffer = readAheadBuffer;\n-    readAheadBuffer = temp;\n-  }\n-\n-  /**\n-   * Internal read function which should be called only from read() api. The assumption is that\n-   * the stateChangeLock is already acquired in the caller before calling this function.\n-   */\n-  private int readInternal(byte[] b, int offset, int len) throws IOException {\n-    assert (stateChangeLock.isLocked());\n     if (!activeBuffer.hasRemaining()) {\n-      waitForAsyncReadComplete();\n-      if (readAheadBuffer.hasRemaining()) {\n-        swapBuffers();\n-      } else {\n-        // The first read or activeBuffer is skipped.\n-        readAsync();\n+      // No remaining in active buffer - lock and switch to write ahead buffer.\n+      stateChangeLock.lock();\n+      try {\n         waitForAsyncReadComplete();\n-        if (isEndOfStream()) {\n-          return -1;\n+        if (!readAheadBuffer.hasRemaining()) {\n+          // The first read or activeBuffer is skipped."
  }],
  "prId": 20555
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "The while loop here is to handle [spurious wakeup](https://en.wikipedia.org/wiki/Spurious_wakeup).",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-13T21:31:57Z",
    "diffHunk": "@@ -230,24 +227,32 @@ private void signalAsyncReadComplete() {\n \n   private void waitForAsyncReadComplete() throws IOException {\n     stateChangeLock.lock();\n+    isWaiting.set(true);\n     try {\n-      while (readInProgress) {\n+      if (readInProgress) {"
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "Good catch, thanks!",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-14T00:41:53Z",
    "diffHunk": "@@ -230,24 +227,32 @@ private void signalAsyncReadComplete() {\n \n   private void waitForAsyncReadComplete() throws IOException {\n     stateChangeLock.lock();\n+    isWaiting.set(true);\n     try {\n-      while (readInProgress) {\n+      if (readInProgress) {"
  }],
  "prId": 20555
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "You can just use `volatile` here",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-13T23:30:29Z",
    "diffHunk": "@@ -78,9 +79,8 @@\n   // whether there is a read ahead task running,\n   private boolean isReading;\n \n-  // If the remaining data size in the current buffer is below this threshold,\n-  // we issue an async read from the underlying input stream.\n-  private final int readAheadThresholdInBytes;\n+  // whether there is a reader waiting for data.\n+  private AtomicBoolean isWaiting = new AtomicBoolean(false);",
    "line": 16
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "I'll leave it be - should compile to basically the same, and with using `AtomicBoolean` the intent seems more readable to me.",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-14T00:42:47Z",
    "diffHunk": "@@ -78,9 +79,8 @@\n   // whether there is a read ahead task running,\n   private boolean isReading;\n \n-  // If the remaining data size in the current buffer is below this threshold,\n-  // we issue an async read from the underlying input stream.\n-  private final int readAheadThresholdInBytes;\n+  // whether there is a reader waiting for data.\n+  private AtomicBoolean isWaiting = new AtomicBoolean(false);",
    "line": 16
  }],
  "prId": 20555
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we add a comment about spurious wakeup? Otherwise someone else may still mistakenly remove it in the future.",
    "commit": "b6852aa8a7f0e053985d5b89ba4020792d648f82",
    "createdAt": "2018-02-14T02:52:13Z",
    "diffHunk": "@@ -230,6 +227,7 @@ private void signalAsyncReadComplete() {\n \n   private void waitForAsyncReadComplete() throws IOException {\n     stateChangeLock.lock();\n+    isWaiting.set(true);\n     try {\n       while (readInProgress) {"
  }],
  "prId": 20555
}]