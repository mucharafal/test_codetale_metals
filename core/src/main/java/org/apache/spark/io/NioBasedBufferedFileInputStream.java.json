[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`private final`\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T18:38:33Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T20:48:44Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Would it be reasonable to establish a default constructor with some default buffer size, like `BufferedInputStream`?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T18:39:00Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "that makes sense, changed accordingly.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T20:49:03Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I'm not entirely sure about this, but seems so from reading the source: closing the channel won't free the file descriptor? can you just hang on to this ref as well to close it in `close()` for completeness?\n\nBetter yet, can't we just use `FileChannel.open(...)` and not bother with the stream?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T19:16:59Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "changed accordingly.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T20:49:17Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`private`?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T19:17:27Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);\n+    ch = f.getChannel();\n+    ch.read(bb);\n+    bb.flip();\n+  }\n+\n+  public boolean refill() throws IOException {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T20:49:23Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);\n+    ch = f.getChannel();\n+    ch.read(bb);\n+    bb.flip();\n+  }\n+\n+  public boolean refill() throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think you'll want to implement `skip()` and `available()` too.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T19:23:25Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);\n+    ch = f.getChannel();\n+    ch.read(bb);\n+    bb.flip();\n+  }\n+\n+  public boolean refill() throws IOException {\n+    if (!bb.hasRemaining()) {\n+      bb.clear();\n+      int nRead = ch.read(bb);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      bb.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return bb.get();\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, bb.remaining());\n+    bb.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ch.close();\n+  }\n+}"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "`skip()` is already implemented by underlying `InputStream` so that is not needed. Implemented `available()` . \n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-09T20:50:22Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);\n+    ch = f.getChannel();\n+    ch.read(bb);\n+    bb.flip();\n+  }\n+\n+  public boolean refill() throws IOException {\n+    if (!bb.hasRemaining()) {\n+      bb.clear();\n+      int nRead = ch.read(bb);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      bb.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return bb.get();\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, bb.remaining());\n+    bb.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ch.close();\n+  }\n+}"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "`skip()` in InputStream will call `read()`,  this is not the optimal solution\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T01:39:08Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);\n+    ch = f.getChannel();\n+    ch.read(bb);\n+    bb.flip();\n+  }\n+\n+  public boolean refill() throws IOException {\n+    if (!bb.hasRemaining()) {\n+      bb.clear();\n+      int nRead = ch.read(bb);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      bb.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return bb.get();\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, bb.remaining());\n+    bb.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ch.close();\n+  }\n+}"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "Although, we are not using `skip()` anywhere, but I implemented an optimal version of it anyways. \n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T03:44:46Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  ByteBuffer bb;\n+\n+  FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    FileInputStream f = new FileInputStream(file);\n+    ch = f.getChannel();\n+    ch.read(bb);\n+    bb.flip();\n+  }\n+\n+  public boolean refill() throws IOException {\n+    if (!bb.hasRemaining()) {\n+      bb.clear();\n+      int nRead = ch.read(bb);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      bb.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return bb.get();\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, bb.remaining());\n+    bb.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ch.close();\n+  }\n+}"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "You should add a test suite specifically for this.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T00:20:58Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "Added a test suite for this.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T03:43:47Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Great - thanks. Just FYI in general I find ScalaTest to be a better framework than JUnit, so it is a good idea to write tests in Scala even if the class is implemented in Java. Not a big deal though.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:33:38Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "`ch.read(bb);` can be removed\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T01:43:39Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer bb;\n+\n+  private final FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    ch = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    ch.read(bb);\n+    bb.flip();"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "removed, thanks!\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T03:43:35Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer bb;\n+\n+  private final FileChannel ch;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    bb = ByteBuffer.allocateDirect(bufferSize);\n+    ch = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    ch.read(bb);\n+    bb.flip();"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we don't do this consistently, but would be useful to rename this DEFAULT_BUFFER_SIZE_BYTES so it is clear what the unit is\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:34:10Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "changed.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:30:29Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "here too, bufferSizeInBytes\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:34:18Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:30:21Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "document this function and explain what the ret value means?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:36:54Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:30:17Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "off -> offset\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:37:58Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:30:12Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "remove one blank line\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:38:22Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:30:07Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "one question: how is this used? AFAIK InputStream always return 0 for this. Is this used somewhere else for performance improvements?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:39:34Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "It's a standard API method for `InputStream`, so if something does call it, it's better to return a useful answer because it's pretty easy to do so.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:48:01Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "I agree, InputStream simply has a stub impl (just like read(byte[]) loops through read). Providing .remaining() can be useful\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T19:06:19Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nit: add a space after if\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:40:00Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:29:55Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "move else to previous line\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:41:58Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {\n+    long currentFilePosition = fileChannel.position();\n+    long size = fileChannel.size();\n+    if (currentFilePosition + n > size) {\n+      fileChannel.position(size);\n+      return size - currentFilePosition;\n+    }\n+    else {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:29:49Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {\n+    long currentFilePosition = fileChannel.position();\n+    long size = fileChannel.size();\n+    if (currentFilePosition + n > size) {\n+      fileChannel.position(size);\n+      return size - currentFilePosition;\n+    }\n+    else {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maybe just inline this in the previous method, and add an else case so both cases are indented the same level?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:42:35Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "actually never mind this comment\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:42:49Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "do we need to free the buffer or anything?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:43:13Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {\n+    long currentFilePosition = fileChannel.position();\n+    long size = fileChannel.size();\n+    if (currentFilePosition + n > size) {\n+      fileChannel.position(size);\n+      return size - currentFilePosition;\n+    }\n+    else {\n+      fileChannel.position(currentFilePosition + n);\n+      return n;\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    fileChannel.close();"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "No, there is a cleaner in DirectByteBuffer which frees up the memory when the object is garbage collected. \n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:29:38Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {\n+    long currentFilePosition = fileChannel.position();\n+    long size = fileChannel.size();\n+    if (currentFilePosition + n > size) {\n+      fileChannel.position(size);\n+      return size - currentFilePosition;\n+    }\n+    else {\n+      fileChannel.position(currentFilePosition + n);\n+      return n;\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    fileChannel.close();"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Ah OK. I vaguely remember Spark ran into an issue in ~ Spark 1.0 that the direct bytebuffers were not cleared fast enough (because the life cycle is decoupled from GC). We introduced StorageUtils.dispose and made buffer clearing more aggressive. It might be good to call that here too, just in case.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:57:20Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {\n+    long currentFilePosition = fileChannel.position();\n+    long size = fileChannel.size();\n+    if (currentFilePosition + n > size) {\n+      fileChannel.position(size);\n+      return size - currentFilePosition;\n+    }\n+    else {\n+      fileChannel.position(currentFilePosition + n);\n+      return n;\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    fileChannel.close();"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "I see...that makes sense. Added an explicit call to cleanup the byte buffer. \n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T18:14:28Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {\n+      // The buffered content is enough to skip\n+      byteBuffer.position(byteBuffer.position() + (int) n);\n+      return n;\n+    }\n+    long toSkip = n - byteBuffer.remaining();\n+    // Discard everything we have read in the buffer.\n+    byteBuffer.position(0);\n+    byteBuffer.flip();\n+    return skipFromFileChannel(toSkip);\n+  }\n+\n+  private long skipFromFileChannel(long n) throws IOException {\n+    long currentFilePosition = fileChannel.position();\n+    long size = fileChannel.size();\n+    if (currentFilePosition + n > size) {\n+      fileChannel.position(size);\n+      return size - currentFilePosition;\n+    }\n+    else {\n+      fileChannel.position(currentFilePosition + n);\n+      return n;\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    fileChannel.close();"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "> = n ? or did I miss something obvious?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T07:48:21Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "If we have enough data in the bytebuffer to skip then we can skip from the buffer and no need to skip from the file. Looks good to me. \n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:27:23Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Oh, my comment rendered incorrectly. I'm asking if the condition can be `>= n`. If there are exactly `n` bytes remaining then you can skip the entire buffer, right? it need not be `> n`?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:29:18Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "Yes, we can change the condition to be `>=n`. Although the behavior remains the same because skipping 0 bytes from the underlying file channel is essentially a no-op. But changed it avoid confusion. \n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T17:41:17Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSize) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSize);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, off, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if(n < 0L) {\n+      return 0L;\n+    }\n+    if (byteBuffer.remaining() > n) {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "<= instead ?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T19:09:43Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE_BYTES);\n+  }\n+\n+  /**\n+   * Checks weather data is left to be read from the input stream.\n+   * @return true if data is left, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int offset, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, offset, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if (n < 0L) {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-11T00:22:31Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE_BYTES);\n+  }\n+\n+  /**\n+   * Checks weather data is left to be read from the input stream.\n+   * @return true if data is left, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {\n+        return false;\n+      }\n+      byteBuffer.flip();\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    return byteBuffer.get() & 0xFF;\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int offset, int len) throws IOException {\n+    if (!refill()) {\n+      return -1;\n+    }\n+    len = Math.min(len, byteBuffer.remaining());\n+    byteBuffer.get(b, offset, len);\n+    return len;\n+  }\n+\n+  @Override\n+  public int available() throws IOException {\n+    return byteBuffer.remaining();\n+  }\n+\n+  @Override\n+  public long skip(long n) throws IOException {\n+    if (n < 0L) {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "NioBasedBufferedFileInputStream  -> NioBufferedFileInputStream ?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T19:12:11Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "Might also be a good idea to add ability to read to a ByteBuffer .. though that can come later.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T19:14:31Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "<= 0 ?\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T19:20:00Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE_BYTES);\n+  }\n+\n+  /**\n+   * Checks weather data is left to be read from the input stream.\n+   * @return true if data is left, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {"
  }, {
    "author": {
      "login": "sitalkedia"
    },
    "body": "done\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-11T00:22:15Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE_BYTES);\n+  }\n+\n+  /**\n+   * Checks weather data is left to be read from the input stream.\n+   * @return true if data is left, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Hm, https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer) suggests that 0 doesn't mean EOF, just 0 bytes read, but, I'm also not sure what to do if the channel won't actually give any bytes at this point. I think that can only happen if the buffer is full but that won't happen here. `<= 0` seems reasonable AFAIK.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-11T05:22:12Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE_BYTES);\n+  }\n+\n+  /**\n+   * Checks weather data is left to be read from the input stream.\n+   * @return true if data is left, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "It is possible to read 0 bytes and then next time able to read more than 0 bytes.\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-11T06:47:03Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);\n+    fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+    byteBuffer.flip();\n+  }\n+\n+  public NioBasedBufferedFileInputStream(File file) throws IOException {\n+    this(file, DEFAULT_BUFFER_SIZE_BYTES);\n+  }\n+\n+  /**\n+   * Checks weather data is left to be read from the input stream.\n+   * @return true if data is left, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean refill() throws IOException {\n+    if (!byteBuffer.hasRemaining()) {\n+      byteBuffer.clear();\n+      int nRead = fileChannel.read(byteBuffer);\n+      if (nRead == -1) {"
  }],
  "prId": 15408
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "@rxin Is it possible to use netty's pooled bytebuffer allocater here instead of directly allocating ?\n(Given the cost of allocating/freeing direct buffers)\n",
    "commit": "5306fb097ecef7ff69c3281f33f221826879ef04",
    "createdAt": "2016-10-10T19:30:55Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.io;\n+\n+import org.apache.spark.storage.StorageUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.StandardOpenOption;\n+\n+/**\n+ * {@link InputStream} implementation which uses direct buffer\n+ * to read a file to avoid extra copy of data between Java and\n+ * native memory which happens when using {@link java.io.BufferedInputStream}.\n+ * Unfortunately, this is not something already available in JDK,\n+ * {@link sun.nio.ch.ChannelInputStream} supports reading a file using nio,\n+ * but does not support buffering.\n+ *\n+ */\n+public final class NioBasedBufferedFileInputStream extends InputStream {\n+\n+  private static int DEFAULT_BUFFER_SIZE_BYTES = 8192;\n+\n+  private final ByteBuffer byteBuffer;\n+\n+  private final FileChannel fileChannel;\n+\n+  public NioBasedBufferedFileInputStream(File file, int bufferSizeInBytes) throws IOException {\n+    byteBuffer = ByteBuffer.allocateDirect(bufferSizeInBytes);"
  }],
  "prId": 15408
}]