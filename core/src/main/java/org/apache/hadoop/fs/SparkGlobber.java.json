[{
  "comments": [{
    "author": {
      "login": "xuanyuanking"
    },
    "body": "This file folk org.apache.hadoop.fs.Globber from hadoop-common-2.7.2, I only add the logic from line 257 to 266 which control the expanding logic for candidates dirs. ",
    "commit": "95726e9e26f16f41a69db16450469559540e5ddf",
    "createdAt": "2018-07-26T14:27:30Z",
    "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.logging.Log;\n+\n+/**\n+ * This is based on hadoop-common-2.7.2\n+ * {@link org.apache.hadoop.fs.Globber}.\n+ * This class exposes globWithThreshold which can be used glob path in parallel.\n+ */\n+public class SparkGlobber {\n+  public static final Log LOG = LogFactory.getLog(SparkGlobber.class.getName());\n+\n+  private final FileSystem fs;\n+  private final FileContext fc;\n+  private final Path pathPattern;\n+\n+  public SparkGlobber(FileSystem fs, Path pathPattern) {\n+    this.fs = fs;\n+    this.fc = null;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  public SparkGlobber(FileContext fc, Path pathPattern) {\n+    this.fs = null;\n+    this.fc = fc;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  private FileStatus getFileStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.getFileStatus(path);\n+      } else {\n+        return fc.getFileStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return null;\n+    }\n+  }\n+\n+  private FileStatus[] listStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.listStatus(path);\n+      } else {\n+        return fc.util().listStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return new FileStatus[0];\n+    }\n+  }\n+\n+  private Path fixRelativePart(Path path) {\n+    if (fs != null) {\n+      return fs.fixRelativePart(path);\n+    } else {\n+      return fc.fixRelativePart(path);\n+    }\n+  }\n+\n+  /**\n+   * Convert a path component that contains backslash ecape sequences to a\n+   * literal string.  This is necessary when you want to explicitly refer to a\n+   * path that contains globber metacharacters.\n+   */\n+  private static String unescapePathComponent(String name) {\n+    return name.replaceAll(\"\\\\\\\\(.)\", \"$1\");\n+  }\n+\n+  /**\n+   * Translate an absolute path into a list of path components.\n+   * We merge double slashes into a single slash here.\n+   * POSIX root path, i.e. '/', does not get an entry in the list.\n+   */\n+  private static List<String> getPathComponents(String path)\n+      throws IOException {\n+    ArrayList<String> ret = new ArrayList<String>();\n+    for (String component : path.split(Path.SEPARATOR)) {\n+      if (!component.isEmpty()) {\n+        ret.add(component);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  private String schemeFromPath(Path path) throws IOException {\n+    String scheme = path.toUri().getScheme();\n+    if (scheme == null) {\n+      if (fs != null) {\n+        scheme = fs.getUri().getScheme();\n+      } else {\n+        scheme = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getScheme();\n+      }\n+    }\n+    return scheme;\n+  }\n+\n+  private String authorityFromPath(Path path) throws IOException {\n+    String authority = path.toUri().getAuthority();\n+    if (authority == null) {\n+      if (fs != null) {\n+        authority = fs.getUri().getAuthority();\n+      } else {\n+        authority = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getAuthority();\n+      }\n+    }\n+    return authority ;\n+  }\n+\n+  public FileStatus[] globWithThreshold(int threshold) throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme = schemeFromPath(pathPattern);\n+    String authority = authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString = pathPattern.toUri().getPath();\n+    List<String> flattenedPatterns = GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we'll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList<FileStatus> results =\n+        new ArrayList<FileStatus>(flattenedPatterns.size());\n+    boolean sawWildcard = false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn't do\n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern = fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List<String> components =\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList<FileStatus> candidates = new ArrayList<FileStatus>(1);\n+      // To get the \"real\" FileStatus of root, we'd have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we'll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n+      if (Path.WINDOWS && !components.isEmpty()\n+          && Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter = components.remove(0);\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n+      } else {\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n+      }\n+      candidates.add(rootPlaceholder);\n+\n+      for (int componentIdx = 0; componentIdx < components.size();\n+         componentIdx++) {\n+        ArrayList<FileStatus> newCandidates =\n+            new ArrayList<FileStatus>(candidates.size());\n+        GlobFilter globFilter = new GlobFilter(components.get(componentIdx));\n+        String component = unescapePathComponent(components.get(componentIdx));\n+        if (globFilter.hasPattern()) {\n+          sawWildcard = true;\n+        }\n+        if (candidates.isEmpty() && sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining\n+          // the path components.  We can only do this if we've already seen\n+          // a wildcard component-- otherwise, we still need to visit all path\n+          // components in case one of them is a wildcard.\n+          break;\n+        }\n+        if ((componentIdx < components.size() - 1) &&\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we\n+          // are not matching against a glob, assume that it exists.  If it\n+          // doesn't exist, we'll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children = listStatus(candidate.getPath());\n+            if (children.length == 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can't just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we'd\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n+            }\n+            for (FileStatus child : children) {\n+              if (componentIdx < components.size() - 1) {\n+                // Don't try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue;\n+              }\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                  child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus\n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus = getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus != null) {\n+              newCandidates.add(childStatus);\n+            }\n+          }\n+        }\n+        candidates = newCandidates;\n+        // When size of candidates has reached the threshold, stop expanding other",
    "line": 257
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "IMHO I just a bit worry about maintainability about this class...  btw, there is no test for this class in hadoop-common?",
    "commit": "95726e9e26f16f41a69db16450469559540e5ddf",
    "createdAt": "2018-09-08T03:08:44Z",
    "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.logging.Log;\n+\n+/**\n+ * This is based on hadoop-common-2.7.2\n+ * {@link org.apache.hadoop.fs.Globber}.\n+ * This class exposes globWithThreshold which can be used glob path in parallel.\n+ */\n+public class SparkGlobber {\n+  public static final Log LOG = LogFactory.getLog(SparkGlobber.class.getName());\n+\n+  private final FileSystem fs;\n+  private final FileContext fc;\n+  private final Path pathPattern;\n+\n+  public SparkGlobber(FileSystem fs, Path pathPattern) {\n+    this.fs = fs;\n+    this.fc = null;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  public SparkGlobber(FileContext fc, Path pathPattern) {\n+    this.fs = null;\n+    this.fc = fc;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  private FileStatus getFileStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.getFileStatus(path);\n+      } else {\n+        return fc.getFileStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return null;\n+    }\n+  }\n+\n+  private FileStatus[] listStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.listStatus(path);\n+      } else {\n+        return fc.util().listStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return new FileStatus[0];\n+    }\n+  }\n+\n+  private Path fixRelativePart(Path path) {\n+    if (fs != null) {\n+      return fs.fixRelativePart(path);\n+    } else {\n+      return fc.fixRelativePart(path);\n+    }\n+  }\n+\n+  /**\n+   * Convert a path component that contains backslash ecape sequences to a\n+   * literal string.  This is necessary when you want to explicitly refer to a\n+   * path that contains globber metacharacters.\n+   */\n+  private static String unescapePathComponent(String name) {\n+    return name.replaceAll(\"\\\\\\\\(.)\", \"$1\");\n+  }\n+\n+  /**\n+   * Translate an absolute path into a list of path components.\n+   * We merge double slashes into a single slash here.\n+   * POSIX root path, i.e. '/', does not get an entry in the list.\n+   */\n+  private static List<String> getPathComponents(String path)\n+      throws IOException {\n+    ArrayList<String> ret = new ArrayList<String>();\n+    for (String component : path.split(Path.SEPARATOR)) {\n+      if (!component.isEmpty()) {\n+        ret.add(component);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  private String schemeFromPath(Path path) throws IOException {\n+    String scheme = path.toUri().getScheme();\n+    if (scheme == null) {\n+      if (fs != null) {\n+        scheme = fs.getUri().getScheme();\n+      } else {\n+        scheme = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getScheme();\n+      }\n+    }\n+    return scheme;\n+  }\n+\n+  private String authorityFromPath(Path path) throws IOException {\n+    String authority = path.toUri().getAuthority();\n+    if (authority == null) {\n+      if (fs != null) {\n+        authority = fs.getUri().getAuthority();\n+      } else {\n+        authority = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getAuthority();\n+      }\n+    }\n+    return authority ;\n+  }\n+\n+  public FileStatus[] globWithThreshold(int threshold) throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme = schemeFromPath(pathPattern);\n+    String authority = authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString = pathPattern.toUri().getPath();\n+    List<String> flattenedPatterns = GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we'll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList<FileStatus> results =\n+        new ArrayList<FileStatus>(flattenedPatterns.size());\n+    boolean sawWildcard = false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn't do\n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern = fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List<String> components =\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList<FileStatus> candidates = new ArrayList<FileStatus>(1);\n+      // To get the \"real\" FileStatus of root, we'd have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we'll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n+      if (Path.WINDOWS && !components.isEmpty()\n+          && Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter = components.remove(0);\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n+      } else {\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n+      }\n+      candidates.add(rootPlaceholder);\n+\n+      for (int componentIdx = 0; componentIdx < components.size();\n+         componentIdx++) {\n+        ArrayList<FileStatus> newCandidates =\n+            new ArrayList<FileStatus>(candidates.size());\n+        GlobFilter globFilter = new GlobFilter(components.get(componentIdx));\n+        String component = unescapePathComponent(components.get(componentIdx));\n+        if (globFilter.hasPattern()) {\n+          sawWildcard = true;\n+        }\n+        if (candidates.isEmpty() && sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining\n+          // the path components.  We can only do this if we've already seen\n+          // a wildcard component-- otherwise, we still need to visit all path\n+          // components in case one of them is a wildcard.\n+          break;\n+        }\n+        if ((componentIdx < components.size() - 1) &&\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we\n+          // are not matching against a glob, assume that it exists.  If it\n+          // doesn't exist, we'll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children = listStatus(candidate.getPath());\n+            if (children.length == 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can't just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we'd\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n+            }\n+            for (FileStatus child : children) {\n+              if (componentIdx < components.size() - 1) {\n+                // Don't try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue;\n+              }\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                  child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus\n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus = getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus != null) {\n+              newCandidates.add(childStatus);\n+            }\n+          }\n+        }\n+        candidates = newCandidates;\n+        // When size of candidates has reached the threshold, stop expanding other",
    "line": 257
  }, {
    "author": {
      "login": "xuanyuanking"
    },
    "body": "There is test for `hadoop.fs.Globber` in [TestGlobExpander.java](https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestGlobExpander.java) and [TestGlobPattern.java](https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestGlobPattern.java).",
    "commit": "95726e9e26f16f41a69db16450469559540e5ddf",
    "createdAt": "2018-09-08T15:15:30Z",
    "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.logging.Log;\n+\n+/**\n+ * This is based on hadoop-common-2.7.2\n+ * {@link org.apache.hadoop.fs.Globber}.\n+ * This class exposes globWithThreshold which can be used glob path in parallel.\n+ */\n+public class SparkGlobber {\n+  public static final Log LOG = LogFactory.getLog(SparkGlobber.class.getName());\n+\n+  private final FileSystem fs;\n+  private final FileContext fc;\n+  private final Path pathPattern;\n+\n+  public SparkGlobber(FileSystem fs, Path pathPattern) {\n+    this.fs = fs;\n+    this.fc = null;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  public SparkGlobber(FileContext fc, Path pathPattern) {\n+    this.fs = null;\n+    this.fc = fc;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  private FileStatus getFileStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.getFileStatus(path);\n+      } else {\n+        return fc.getFileStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return null;\n+    }\n+  }\n+\n+  private FileStatus[] listStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.listStatus(path);\n+      } else {\n+        return fc.util().listStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return new FileStatus[0];\n+    }\n+  }\n+\n+  private Path fixRelativePart(Path path) {\n+    if (fs != null) {\n+      return fs.fixRelativePart(path);\n+    } else {\n+      return fc.fixRelativePart(path);\n+    }\n+  }\n+\n+  /**\n+   * Convert a path component that contains backslash ecape sequences to a\n+   * literal string.  This is necessary when you want to explicitly refer to a\n+   * path that contains globber metacharacters.\n+   */\n+  private static String unescapePathComponent(String name) {\n+    return name.replaceAll(\"\\\\\\\\(.)\", \"$1\");\n+  }\n+\n+  /**\n+   * Translate an absolute path into a list of path components.\n+   * We merge double slashes into a single slash here.\n+   * POSIX root path, i.e. '/', does not get an entry in the list.\n+   */\n+  private static List<String> getPathComponents(String path)\n+      throws IOException {\n+    ArrayList<String> ret = new ArrayList<String>();\n+    for (String component : path.split(Path.SEPARATOR)) {\n+      if (!component.isEmpty()) {\n+        ret.add(component);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  private String schemeFromPath(Path path) throws IOException {\n+    String scheme = path.toUri().getScheme();\n+    if (scheme == null) {\n+      if (fs != null) {\n+        scheme = fs.getUri().getScheme();\n+      } else {\n+        scheme = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getScheme();\n+      }\n+    }\n+    return scheme;\n+  }\n+\n+  private String authorityFromPath(Path path) throws IOException {\n+    String authority = path.toUri().getAuthority();\n+    if (authority == null) {\n+      if (fs != null) {\n+        authority = fs.getUri().getAuthority();\n+      } else {\n+        authority = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getAuthority();\n+      }\n+    }\n+    return authority ;\n+  }\n+\n+  public FileStatus[] globWithThreshold(int threshold) throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme = schemeFromPath(pathPattern);\n+    String authority = authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString = pathPattern.toUri().getPath();\n+    List<String> flattenedPatterns = GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we'll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList<FileStatus> results =\n+        new ArrayList<FileStatus>(flattenedPatterns.size());\n+    boolean sawWildcard = false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn't do\n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern = fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List<String> components =\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList<FileStatus> candidates = new ArrayList<FileStatus>(1);\n+      // To get the \"real\" FileStatus of root, we'd have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we'll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n+      if (Path.WINDOWS && !components.isEmpty()\n+          && Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter = components.remove(0);\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n+      } else {\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n+      }\n+      candidates.add(rootPlaceholder);\n+\n+      for (int componentIdx = 0; componentIdx < components.size();\n+         componentIdx++) {\n+        ArrayList<FileStatus> newCandidates =\n+            new ArrayList<FileStatus>(candidates.size());\n+        GlobFilter globFilter = new GlobFilter(components.get(componentIdx));\n+        String component = unescapePathComponent(components.get(componentIdx));\n+        if (globFilter.hasPattern()) {\n+          sawWildcard = true;\n+        }\n+        if (candidates.isEmpty() && sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining\n+          // the path components.  We can only do this if we've already seen\n+          // a wildcard component-- otherwise, we still need to visit all path\n+          // components in case one of them is a wildcard.\n+          break;\n+        }\n+        if ((componentIdx < components.size() - 1) &&\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we\n+          // are not matching against a glob, assume that it exists.  If it\n+          // doesn't exist, we'll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children = listStatus(candidate.getPath());\n+            if (children.length == 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can't just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we'd\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n+            }\n+            for (FileStatus child : children) {\n+              if (componentIdx < components.size() - 1) {\n+                // Don't try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue;\n+              }\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                  child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus\n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus = getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus != null) {\n+              newCandidates.add(childStatus);\n+            }\n+          }\n+        }\n+        candidates = newCandidates;\n+        // When size of candidates has reached the threshold, stop expanding other",
    "line": 257
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "If we modify this class in the spark-side in future, how we should check if these tests passed?",
    "commit": "95726e9e26f16f41a69db16450469559540e5ddf",
    "createdAt": "2018-09-10T00:30:24Z",
    "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.logging.Log;\n+\n+/**\n+ * This is based on hadoop-common-2.7.2\n+ * {@link org.apache.hadoop.fs.Globber}.\n+ * This class exposes globWithThreshold which can be used glob path in parallel.\n+ */\n+public class SparkGlobber {\n+  public static final Log LOG = LogFactory.getLog(SparkGlobber.class.getName());\n+\n+  private final FileSystem fs;\n+  private final FileContext fc;\n+  private final Path pathPattern;\n+\n+  public SparkGlobber(FileSystem fs, Path pathPattern) {\n+    this.fs = fs;\n+    this.fc = null;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  public SparkGlobber(FileContext fc, Path pathPattern) {\n+    this.fs = null;\n+    this.fc = fc;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  private FileStatus getFileStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.getFileStatus(path);\n+      } else {\n+        return fc.getFileStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return null;\n+    }\n+  }\n+\n+  private FileStatus[] listStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.listStatus(path);\n+      } else {\n+        return fc.util().listStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return new FileStatus[0];\n+    }\n+  }\n+\n+  private Path fixRelativePart(Path path) {\n+    if (fs != null) {\n+      return fs.fixRelativePart(path);\n+    } else {\n+      return fc.fixRelativePart(path);\n+    }\n+  }\n+\n+  /**\n+   * Convert a path component that contains backslash ecape sequences to a\n+   * literal string.  This is necessary when you want to explicitly refer to a\n+   * path that contains globber metacharacters.\n+   */\n+  private static String unescapePathComponent(String name) {\n+    return name.replaceAll(\"\\\\\\\\(.)\", \"$1\");\n+  }\n+\n+  /**\n+   * Translate an absolute path into a list of path components.\n+   * We merge double slashes into a single slash here.\n+   * POSIX root path, i.e. '/', does not get an entry in the list.\n+   */\n+  private static List<String> getPathComponents(String path)\n+      throws IOException {\n+    ArrayList<String> ret = new ArrayList<String>();\n+    for (String component : path.split(Path.SEPARATOR)) {\n+      if (!component.isEmpty()) {\n+        ret.add(component);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  private String schemeFromPath(Path path) throws IOException {\n+    String scheme = path.toUri().getScheme();\n+    if (scheme == null) {\n+      if (fs != null) {\n+        scheme = fs.getUri().getScheme();\n+      } else {\n+        scheme = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getScheme();\n+      }\n+    }\n+    return scheme;\n+  }\n+\n+  private String authorityFromPath(Path path) throws IOException {\n+    String authority = path.toUri().getAuthority();\n+    if (authority == null) {\n+      if (fs != null) {\n+        authority = fs.getUri().getAuthority();\n+      } else {\n+        authority = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getAuthority();\n+      }\n+    }\n+    return authority ;\n+  }\n+\n+  public FileStatus[] globWithThreshold(int threshold) throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme = schemeFromPath(pathPattern);\n+    String authority = authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString = pathPattern.toUri().getPath();\n+    List<String> flattenedPatterns = GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we'll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList<FileStatus> results =\n+        new ArrayList<FileStatus>(flattenedPatterns.size());\n+    boolean sawWildcard = false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn't do\n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern = fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List<String> components =\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList<FileStatus> candidates = new ArrayList<FileStatus>(1);\n+      // To get the \"real\" FileStatus of root, we'd have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we'll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n+      if (Path.WINDOWS && !components.isEmpty()\n+          && Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter = components.remove(0);\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n+      } else {\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n+      }\n+      candidates.add(rootPlaceholder);\n+\n+      for (int componentIdx = 0; componentIdx < components.size();\n+         componentIdx++) {\n+        ArrayList<FileStatus> newCandidates =\n+            new ArrayList<FileStatus>(candidates.size());\n+        GlobFilter globFilter = new GlobFilter(components.get(componentIdx));\n+        String component = unescapePathComponent(components.get(componentIdx));\n+        if (globFilter.hasPattern()) {\n+          sawWildcard = true;\n+        }\n+        if (candidates.isEmpty() && sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining\n+          // the path components.  We can only do this if we've already seen\n+          // a wildcard component-- otherwise, we still need to visit all path\n+          // components in case one of them is a wildcard.\n+          break;\n+        }\n+        if ((componentIdx < components.size() - 1) &&\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we\n+          // are not matching against a glob, assume that it exists.  If it\n+          // doesn't exist, we'll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children = listStatus(candidate.getPath());\n+            if (children.length == 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can't just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we'd\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n+            }\n+            for (FileStatus child : children) {\n+              if (componentIdx < components.size() - 1) {\n+                // Don't try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue;\n+              }\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                  child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus\n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus = getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus != null) {\n+              newCandidates.add(childStatus);\n+            }\n+          }\n+        }\n+        candidates = newCandidates;\n+        // When size of candidates has reached the threshold, stop expanding other",
    "line": 257
  }, {
    "author": {
      "login": "xuanyuanking"
    },
    "body": "Is it also necessary port the UT? I think maybe enough comment and limit change is enough cause UT still has maintenance cost. What's your opinion?",
    "commit": "95726e9e26f16f41a69db16450469559540e5ddf",
    "createdAt": "2018-09-11T08:38:47Z",
    "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.logging.Log;\n+\n+/**\n+ * This is based on hadoop-common-2.7.2\n+ * {@link org.apache.hadoop.fs.Globber}.\n+ * This class exposes globWithThreshold which can be used glob path in parallel.\n+ */\n+public class SparkGlobber {\n+  public static final Log LOG = LogFactory.getLog(SparkGlobber.class.getName());\n+\n+  private final FileSystem fs;\n+  private final FileContext fc;\n+  private final Path pathPattern;\n+\n+  public SparkGlobber(FileSystem fs, Path pathPattern) {\n+    this.fs = fs;\n+    this.fc = null;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  public SparkGlobber(FileContext fc, Path pathPattern) {\n+    this.fs = null;\n+    this.fc = fc;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  private FileStatus getFileStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.getFileStatus(path);\n+      } else {\n+        return fc.getFileStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return null;\n+    }\n+  }\n+\n+  private FileStatus[] listStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.listStatus(path);\n+      } else {\n+        return fc.util().listStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return new FileStatus[0];\n+    }\n+  }\n+\n+  private Path fixRelativePart(Path path) {\n+    if (fs != null) {\n+      return fs.fixRelativePart(path);\n+    } else {\n+      return fc.fixRelativePart(path);\n+    }\n+  }\n+\n+  /**\n+   * Convert a path component that contains backslash ecape sequences to a\n+   * literal string.  This is necessary when you want to explicitly refer to a\n+   * path that contains globber metacharacters.\n+   */\n+  private static String unescapePathComponent(String name) {\n+    return name.replaceAll(\"\\\\\\\\(.)\", \"$1\");\n+  }\n+\n+  /**\n+   * Translate an absolute path into a list of path components.\n+   * We merge double slashes into a single slash here.\n+   * POSIX root path, i.e. '/', does not get an entry in the list.\n+   */\n+  private static List<String> getPathComponents(String path)\n+      throws IOException {\n+    ArrayList<String> ret = new ArrayList<String>();\n+    for (String component : path.split(Path.SEPARATOR)) {\n+      if (!component.isEmpty()) {\n+        ret.add(component);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  private String schemeFromPath(Path path) throws IOException {\n+    String scheme = path.toUri().getScheme();\n+    if (scheme == null) {\n+      if (fs != null) {\n+        scheme = fs.getUri().getScheme();\n+      } else {\n+        scheme = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getScheme();\n+      }\n+    }\n+    return scheme;\n+  }\n+\n+  private String authorityFromPath(Path path) throws IOException {\n+    String authority = path.toUri().getAuthority();\n+    if (authority == null) {\n+      if (fs != null) {\n+        authority = fs.getUri().getAuthority();\n+      } else {\n+        authority = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getAuthority();\n+      }\n+    }\n+    return authority ;\n+  }\n+\n+  public FileStatus[] globWithThreshold(int threshold) throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme = schemeFromPath(pathPattern);\n+    String authority = authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString = pathPattern.toUri().getPath();\n+    List<String> flattenedPatterns = GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we'll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList<FileStatus> results =\n+        new ArrayList<FileStatus>(flattenedPatterns.size());\n+    boolean sawWildcard = false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn't do\n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern = fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List<String> components =\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList<FileStatus> candidates = new ArrayList<FileStatus>(1);\n+      // To get the \"real\" FileStatus of root, we'd have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we'll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n+      if (Path.WINDOWS && !components.isEmpty()\n+          && Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter = components.remove(0);\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n+      } else {\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n+      }\n+      candidates.add(rootPlaceholder);\n+\n+      for (int componentIdx = 0; componentIdx < components.size();\n+         componentIdx++) {\n+        ArrayList<FileStatus> newCandidates =\n+            new ArrayList<FileStatus>(candidates.size());\n+        GlobFilter globFilter = new GlobFilter(components.get(componentIdx));\n+        String component = unescapePathComponent(components.get(componentIdx));\n+        if (globFilter.hasPattern()) {\n+          sawWildcard = true;\n+        }\n+        if (candidates.isEmpty() && sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining\n+          // the path components.  We can only do this if we've already seen\n+          // a wildcard component-- otherwise, we still need to visit all path\n+          // components in case one of them is a wildcard.\n+          break;\n+        }\n+        if ((componentIdx < components.size() - 1) &&\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we\n+          // are not matching against a glob, assume that it exists.  If it\n+          // doesn't exist, we'll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children = listStatus(candidate.getPath());\n+            if (children.length == 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can't just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we'd\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n+            }\n+            for (FileStatus child : children) {\n+              if (componentIdx < components.size() - 1) {\n+                // Don't try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue;\n+              }\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                  child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus\n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus = getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus != null) {\n+              newCandidates.add(childStatus);\n+            }\n+          }\n+        }\n+        candidates = newCandidates;\n+        // When size of candidates has reached the threshold, stop expanding other",
    "line": 257
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "cc: @cloud-fan",
    "commit": "95726e9e26f16f41a69db16450469559540e5ddf",
    "createdAt": "2018-09-18T10:08:38Z",
    "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.logging.Log;\n+\n+/**\n+ * This is based on hadoop-common-2.7.2\n+ * {@link org.apache.hadoop.fs.Globber}.\n+ * This class exposes globWithThreshold which can be used glob path in parallel.\n+ */\n+public class SparkGlobber {\n+  public static final Log LOG = LogFactory.getLog(SparkGlobber.class.getName());\n+\n+  private final FileSystem fs;\n+  private final FileContext fc;\n+  private final Path pathPattern;\n+\n+  public SparkGlobber(FileSystem fs, Path pathPattern) {\n+    this.fs = fs;\n+    this.fc = null;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  public SparkGlobber(FileContext fc, Path pathPattern) {\n+    this.fs = null;\n+    this.fc = fc;\n+    this.pathPattern = pathPattern;\n+  }\n+\n+  private FileStatus getFileStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.getFileStatus(path);\n+      } else {\n+        return fc.getFileStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return null;\n+    }\n+  }\n+\n+  private FileStatus[] listStatus(Path path) throws IOException {\n+    try {\n+      if (fs != null) {\n+        return fs.listStatus(path);\n+      } else {\n+        return fc.util().listStatus(path);\n+      }\n+    } catch (FileNotFoundException e) {\n+      return new FileStatus[0];\n+    }\n+  }\n+\n+  private Path fixRelativePart(Path path) {\n+    if (fs != null) {\n+      return fs.fixRelativePart(path);\n+    } else {\n+      return fc.fixRelativePart(path);\n+    }\n+  }\n+\n+  /**\n+   * Convert a path component that contains backslash ecape sequences to a\n+   * literal string.  This is necessary when you want to explicitly refer to a\n+   * path that contains globber metacharacters.\n+   */\n+  private static String unescapePathComponent(String name) {\n+    return name.replaceAll(\"\\\\\\\\(.)\", \"$1\");\n+  }\n+\n+  /**\n+   * Translate an absolute path into a list of path components.\n+   * We merge double slashes into a single slash here.\n+   * POSIX root path, i.e. '/', does not get an entry in the list.\n+   */\n+  private static List<String> getPathComponents(String path)\n+      throws IOException {\n+    ArrayList<String> ret = new ArrayList<String>();\n+    for (String component : path.split(Path.SEPARATOR)) {\n+      if (!component.isEmpty()) {\n+        ret.add(component);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  private String schemeFromPath(Path path) throws IOException {\n+    String scheme = path.toUri().getScheme();\n+    if (scheme == null) {\n+      if (fs != null) {\n+        scheme = fs.getUri().getScheme();\n+      } else {\n+        scheme = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getScheme();\n+      }\n+    }\n+    return scheme;\n+  }\n+\n+  private String authorityFromPath(Path path) throws IOException {\n+    String authority = path.toUri().getAuthority();\n+    if (authority == null) {\n+      if (fs != null) {\n+        authority = fs.getUri().getAuthority();\n+      } else {\n+        authority = fc.getFSofPath(fc.fixRelativePart(path)).getUri().getAuthority();\n+      }\n+    }\n+    return authority ;\n+  }\n+\n+  public FileStatus[] globWithThreshold(int threshold) throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme = schemeFromPath(pathPattern);\n+    String authority = authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString = pathPattern.toUri().getPath();\n+    List<String> flattenedPatterns = GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we'll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList<FileStatus> results =\n+        new ArrayList<FileStatus>(flattenedPatterns.size());\n+    boolean sawWildcard = false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn't do\n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern = fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List<String> components =\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList<FileStatus> candidates = new ArrayList<FileStatus>(1);\n+      // To get the \"real\" FileStatus of root, we'd have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we'll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n+      if (Path.WINDOWS && !components.isEmpty()\n+          && Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter = components.remove(0);\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n+      } else {\n+        rootPlaceholder = new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n+      }\n+      candidates.add(rootPlaceholder);\n+\n+      for (int componentIdx = 0; componentIdx < components.size();\n+         componentIdx++) {\n+        ArrayList<FileStatus> newCandidates =\n+            new ArrayList<FileStatus>(candidates.size());\n+        GlobFilter globFilter = new GlobFilter(components.get(componentIdx));\n+        String component = unescapePathComponent(components.get(componentIdx));\n+        if (globFilter.hasPattern()) {\n+          sawWildcard = true;\n+        }\n+        if (candidates.isEmpty() && sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining\n+          // the path components.  We can only do this if we've already seen\n+          // a wildcard component-- otherwise, we still need to visit all path\n+          // components in case one of them is a wildcard.\n+          break;\n+        }\n+        if ((componentIdx < components.size() - 1) &&\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we\n+          // are not matching against a glob, assume that it exists.  If it\n+          // doesn't exist, we'll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children = listStatus(candidate.getPath());\n+            if (children.length == 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can't just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we'd\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n+            }\n+            for (FileStatus child : children) {\n+              if (componentIdx < components.size() - 1) {\n+                // Don't try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue;\n+              }\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                  child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus\n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus = getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus != null) {\n+              newCandidates.add(childStatus);\n+            }\n+          }\n+        }\n+        candidates = newCandidates;\n+        // When size of candidates has reached the threshold, stop expanding other",
    "line": 257
  }],
  "prId": 21618
}]