[{
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "Nit: empty line not needed",
    "commit": "1a0a3e9439df7490f7fb3a1f3451a463ad67be5b",
    "createdAt": "2019-03-18T15:58:51Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.metrics.source\n+\n+import com.codahale.metrics.MetricRegistry\n+\n+import org.apache.spark.executor.ExecutorMetrics\n+\n+private[spark] class MemorySource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+  override val sourceName = \"MemoryMetrics\"\n+\n+  val METRIC_JVM_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMHeapMemory\"))\n+  val METRIC_JVM_OFF_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMOffHeapMemory\"))\n+  val METRIC_JVM_ON_HEAP_EXECUTION_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapExecutionMemory\"))\n+  val METRIC_JVM_ON_HEAP_STORAGE_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapStorageMemory\"))\n+  val METRIC_JVM_ON_HEAP_UNIFIED_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapUnifiedMemory\"))\n+  val METRIC_JVM_OFF_HEAP_EXECUTION_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapExecutionMemory\"))\n+  val METRIC_JVM_OFF_HEAP_STORAGE_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapStorageMemory\"))\n+  val METRIC_JVM_OFF_HEAP_UNIFIED_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapUnifiedMemory\"))\n+  val METRIC_JVM_DIRECT_POOL_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"DirectPoolMemory\"))\n+  val METRIC_JVM_MAPPED_POOL_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"MappedPoolMemory\"))\n+\n+  // GarbageCollectionMetrics\n+  val METRIC_MINOR_GC_COUNT =\n+    metricRegistry.counter(MetricRegistry.name(\"MinorGCCount\"))\n+  val METRIC_MINOR_GC_TIME =\n+    metricRegistry.counter(MetricRegistry.name(\"MinorGCTime\"))\n+  val METRIC_MAJOR_GC_COUNT =\n+    metricRegistry.counter(MetricRegistry.name(\"MajorGCCount\"))\n+  val METRIC_MAJOR_GC_TIME =\n+    metricRegistry.counter(MetricRegistry.name(\"MajorGCTime\"))\n+\n+  // ProcessTreeMetrics\n+  val METRIC_PROCESS_TREE_JVM_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeJVMVMemory\"))\n+  val METRIC_PROCESS_TREE_JVM_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeJVMRSSMemory\"))\n+  val METRIC_PROCESS_TREE_PYTHON_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreePythonVMemory\"))\n+  val METRIC_PROCESS_TREE_PYTHON_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreePythonRSSMemory\"))\n+  val METRIC_PROCESS_TREE_OTHER_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherVMemory\"))\n+  val METRIC_PROCESS_TREE_OTHER_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherRSSMemory\"))\n+\n+  def updateCounters(memorySource: MemorySource,\n+                     metricsUpdates: ExecutorMetrics): Unit = {\n+"
  }],
  "prId": 24132
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "The updateCounters is a member function and it should use the counters of its own instance. So the `memorySource` argument is not needed.\r\n\r\nThis way `memorySource.updateCounters(memorySource, executorUpdates)` will be just `memorySource.updateCounters(executorUpdates)`\r\n",
    "commit": "1a0a3e9439df7490f7fb3a1f3451a463ad67be5b",
    "createdAt": "2019-03-18T16:04:05Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.metrics.source\n+\n+import com.codahale.metrics.MetricRegistry\n+\n+import org.apache.spark.executor.ExecutorMetrics\n+\n+private[spark] class MemorySource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+  override val sourceName = \"MemoryMetrics\"\n+\n+  val METRIC_JVM_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMHeapMemory\"))\n+  val METRIC_JVM_OFF_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMOffHeapMemory\"))\n+  val METRIC_JVM_ON_HEAP_EXECUTION_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapExecutionMemory\"))\n+  val METRIC_JVM_ON_HEAP_STORAGE_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapStorageMemory\"))\n+  val METRIC_JVM_ON_HEAP_UNIFIED_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapUnifiedMemory\"))\n+  val METRIC_JVM_OFF_HEAP_EXECUTION_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapExecutionMemory\"))\n+  val METRIC_JVM_OFF_HEAP_STORAGE_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapStorageMemory\"))\n+  val METRIC_JVM_OFF_HEAP_UNIFIED_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapUnifiedMemory\"))\n+  val METRIC_JVM_DIRECT_POOL_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"DirectPoolMemory\"))\n+  val METRIC_JVM_MAPPED_POOL_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"MappedPoolMemory\"))\n+\n+  // GarbageCollectionMetrics\n+  val METRIC_MINOR_GC_COUNT =\n+    metricRegistry.counter(MetricRegistry.name(\"MinorGCCount\"))\n+  val METRIC_MINOR_GC_TIME =\n+    metricRegistry.counter(MetricRegistry.name(\"MinorGCTime\"))\n+  val METRIC_MAJOR_GC_COUNT =\n+    metricRegistry.counter(MetricRegistry.name(\"MajorGCCount\"))\n+  val METRIC_MAJOR_GC_TIME =\n+    metricRegistry.counter(MetricRegistry.name(\"MajorGCTime\"))\n+\n+  // ProcessTreeMetrics\n+  val METRIC_PROCESS_TREE_JVM_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeJVMVMemory\"))\n+  val METRIC_PROCESS_TREE_JVM_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeJVMRSSMemory\"))\n+  val METRIC_PROCESS_TREE_PYTHON_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreePythonVMemory\"))\n+  val METRIC_PROCESS_TREE_PYTHON_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreePythonRSSMemory\"))\n+  val METRIC_PROCESS_TREE_OTHER_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherVMemory\"))\n+  val METRIC_PROCESS_TREE_OTHER_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherRSSMemory\"))\n+\n+  def updateCounters(memorySource: MemorySource,"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "Indeed. Thanks for the comment.",
    "commit": "1a0a3e9439df7490f7fb3a1f3451a463ad67be5b",
    "createdAt": "2019-03-18T16:13:24Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.metrics.source\n+\n+import com.codahale.metrics.MetricRegistry\n+\n+import org.apache.spark.executor.ExecutorMetrics\n+\n+private[spark] class MemorySource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+  override val sourceName = \"MemoryMetrics\"\n+\n+  val METRIC_JVM_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMHeapMemory\"))\n+  val METRIC_JVM_OFF_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMOffHeapMemory\"))\n+  val METRIC_JVM_ON_HEAP_EXECUTION_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapExecutionMemory\"))\n+  val METRIC_JVM_ON_HEAP_STORAGE_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapStorageMemory\"))\n+  val METRIC_JVM_ON_HEAP_UNIFIED_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OnHeapUnifiedMemory\"))\n+  val METRIC_JVM_OFF_HEAP_EXECUTION_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapExecutionMemory\"))\n+  val METRIC_JVM_OFF_HEAP_STORAGE_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapStorageMemory\"))\n+  val METRIC_JVM_OFF_HEAP_UNIFIED_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"OffHeapUnifiedMemory\"))\n+  val METRIC_JVM_DIRECT_POOL_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"DirectPoolMemory\"))\n+  val METRIC_JVM_MAPPED_POOL_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"MappedPoolMemory\"))\n+\n+  // GarbageCollectionMetrics\n+  val METRIC_MINOR_GC_COUNT =\n+    metricRegistry.counter(MetricRegistry.name(\"MinorGCCount\"))\n+  val METRIC_MINOR_GC_TIME =\n+    metricRegistry.counter(MetricRegistry.name(\"MinorGCTime\"))\n+  val METRIC_MAJOR_GC_COUNT =\n+    metricRegistry.counter(MetricRegistry.name(\"MajorGCCount\"))\n+  val METRIC_MAJOR_GC_TIME =\n+    metricRegistry.counter(MetricRegistry.name(\"MajorGCTime\"))\n+\n+  // ProcessTreeMetrics\n+  val METRIC_PROCESS_TREE_JVM_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeJVMVMemory\"))\n+  val METRIC_PROCESS_TREE_JVM_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeJVMRSSMemory\"))\n+  val METRIC_PROCESS_TREE_PYTHON_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreePythonVMemory\"))\n+  val METRIC_PROCESS_TREE_PYTHON_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreePythonRSSMemory\"))\n+  val METRIC_PROCESS_TREE_OTHER_VMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherVMemory\"))\n+  val METRIC_PROCESS_TREE_OTHER_RSSMEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherRSSMemory\"))\n+\n+  def updateCounters(memorySource: MemorySource,"
  }],
  "prId": 24132
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "The `this.` is not needed as implicitly there when you leave it out.",
    "commit": "1a0a3e9439df7490f7fb3a1f3451a463ad67be5b",
    "createdAt": "2019-03-18T16:30:46Z",
    "diffHunk": "@@ -71,75 +71,73 @@ private[spark] class MemorySource extends Source {\n   val METRIC_PROCESS_TREE_OTHER_RSSMEMORY =\n     metricRegistry.counter(MetricRegistry.name(\"ProcessTreeOtherRSSMemory\"))\n \n-  def updateCounters(memorySource: MemorySource,\n-                     metricsUpdates: ExecutorMetrics): Unit = {\n-\n-    memorySource.METRIC_JVM_HEAP_MEMORY.inc(\n+  def updateCounters(metricsUpdates: ExecutorMetrics): Unit = {\n+    this.METRIC_JVM_HEAP_MEMORY.inc("
  }],
  "prId": 24132
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "`ExecutorMetricType.metricToOffset` lets you avoid all of this boilerplate -- I think you could replace all of this with\r\n\r\n```scala\r\n  val nameToCodahaleMetric = ExecutorMetricType.metricToOffset.map { case (name, _) =>\r\n      name -> metricRegistry.counter(MetricRegistry.name(name))\r\n  }\r\n\r\n  def updateCounters(metricsUpdates: ExecutorMetrics): Unit = {\r\n    nameToCodahaleMetric.foreach { case (name, counter) =>\r\n      val prevValue = counter.getCount()\r\n      counter.inc(metricsUpdates.getMetricValue(name) - prevValue)\r\n    }\r\n  }\r\n```",
    "commit": "1a0a3e9439df7490f7fb3a1f3451a463ad67be5b",
    "createdAt": "2019-03-27T16:28:06Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.metrics.source\n+\n+import com.codahale.metrics.MetricRegistry\n+\n+import org.apache.spark.executor.ExecutorMetrics\n+\n+private[spark] class MemorySource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+  override val sourceName = \"MemoryMetrics\"\n+\n+  val METRIC_JVM_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMHeapMemory\"))"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "Excellent suggestion, thanks!",
    "commit": "1a0a3e9439df7490f7fb3a1f3451a463ad67be5b",
    "createdAt": "2019-03-27T20:01:20Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.metrics.source\n+\n+import com.codahale.metrics.MetricRegistry\n+\n+import org.apache.spark.executor.ExecutorMetrics\n+\n+private[spark] class MemorySource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+  override val sourceName = \"MemoryMetrics\"\n+\n+  val METRIC_JVM_HEAP_MEMORY =\n+    metricRegistry.counter(MetricRegistry.name(\"JVMHeapMemory\"))"
  }],
  "prId": 24132
}]