[{
  "comments": [{
    "author": {
      "login": "ifilonenko"
    },
    "body": "Should a `require(driver.isDefined)` be thrown here to ensure that the driver sends the updates?",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-08T19:24:47Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "YARN starts the token renewer before there is a driver reference available; the AM gets that later (when it connects back to the driver in client mode, or when the user code is started in cluster mode).\r\n\r\nI've been trying to come up with a better API here that would avoid these checks, but haven't figure it out yet.\r\n\r\nBasically for the YARN case you would need:\r\n\r\n- an initial call to login and fetch delegation tokens, before the driver is even known (the fix for SPARK-23361)\r\n- a call to start the renewal task, which needs information retrieved in the above call (the renewal interval)\r\n\r\nSo breaking it into two calls would need some state to be kept between the calls. Not sure whether that would be much cleaner than what's here now.\r\n\r\nTrying to follow the Mesos way (where the driver itself manages the renewer, instead of the AM code in YARN) would probably not work in YARN, because the AM tries to connect to HDFS (for distributed cache functionality) before the driver is running, so it needs those tokens. It might be possible to rework some of the YARN backend internals to avoid that, I think, but it needs more thought and would be better left as a separate / future enhancement. \r\n\r\nAt some point I'd also like to change the client mode on YARN to be more like the Mesos case (where the driver manages the login, not the AM), maybe all this could be cleaned up at that time.",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-08T20:51:53Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {"
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "What about extending this start() method with a boolean flag sendingInitialToken so it would be clear why this functionality is here and also this would not be controlled by the having driver registered beforehand (would be easy to see for Mesos this is a must have so the require can be used too in the if body).",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T09:26:01Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "> What about extending this start() method with a boolean flag sendingInitialToken\r\n\r\nThat is just as awkward, because then you'd have to set the driver ref before calling start with that flag set to true.\r\n\r\nThe API is just going to be a little awkward until we refactor the way the YARN code deals with tokens. The goal here is not to fix the API, but to share all the rest of the logic.",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T16:06:39Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {"
  }],
  "prId": 22624
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "Why not a typesafe Option here? \r\nIf `createAndUpdateTokens()` is extracted from AbstractCredentialRenewer this would be always defined.\r\n",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T07:47:36Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService ="
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "`Option` doesn't add anything useful here.\r\n\r\nI want `createAndUpdateTokens` here because it will be useful for k8s client mode and for when the YARN code is refactored. Just like it is in Mesos today.",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T16:08:10Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService ="
  }],
  "prId": 22624
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "As the obtainDelegationTokens always called with a freshly created Credentials (which is more like an output variable) does it make sense to move Credentials construction within this method and giving back a tuple of Credentials and Long? (If such a function is passed as an argument even the inheritance can be saved.)",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T08:34:24Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {\n+      val tokens = SparkHadoopUtil.get.serialize(creds)\n+      driver.send(UpdateDelegationTokens(tokens))\n+    }\n+\n+    // Transfer the original user's tokens to the new user, since it may contain needed tokens\n+    // (such as those user to connect to YARN). Explicitly avoid overwriting tokens that already\n+    // exist in the current user's credentials, since those were freshly obtained above\n+    // (see SPARK-23361).\n+    val existing = ugi.getCredentials()\n+    existing.mergeAll(originalCreds)\n+    ugi.addCredentials(existing)\n+    ugi\n+  }\n+\n+  def stop(): Unit = {\n+    if (renewalExecutor != null) {\n+      renewalExecutor.shutdown()\n+    }\n+  }\n+\n+  /** Create new tokens for the current user and distribute them to the driver. */\n+  protected def createAndUpdateTokens(): Unit = {\n+    val driver = driverRef.get()\n+    require(driver != null, \"Driver endpoint not set.\")\n+\n+    val creds = new Credentials()\n+    obtainDelegationTokens(creds)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+\n+    val tokens = SparkHadoopUtil.get.serialize(creds)\n+    driver.send(UpdateDelegationTokens(tokens))\n+  }\n+\n+  /**\n+   * Fetch new delegation tokens for configured services, storing them in the given credentials.\n+   *\n+   * @return The time by which the tokens must be renewed.\n+   */\n+  protected def obtainDelegationTokens(creds: Credentials): Long"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "This makes it more flexible. I also really dislike returning tuples.",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T16:09:05Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {\n+      val tokens = SparkHadoopUtil.get.serialize(creds)\n+      driver.send(UpdateDelegationTokens(tokens))\n+    }\n+\n+    // Transfer the original user's tokens to the new user, since it may contain needed tokens\n+    // (such as those user to connect to YARN). Explicitly avoid overwriting tokens that already\n+    // exist in the current user's credentials, since those were freshly obtained above\n+    // (see SPARK-23361).\n+    val existing = ugi.getCredentials()\n+    existing.mergeAll(originalCreds)\n+    ugi.addCredentials(existing)\n+    ugi\n+  }\n+\n+  def stop(): Unit = {\n+    if (renewalExecutor != null) {\n+      renewalExecutor.shutdown()\n+    }\n+  }\n+\n+  /** Create new tokens for the current user and distribute them to the driver. */\n+  protected def createAndUpdateTokens(): Unit = {\n+    val driver = driverRef.get()\n+    require(driver != null, \"Driver endpoint not set.\")\n+\n+    val creds = new Credentials()\n+    obtainDelegationTokens(creds)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+\n+    val tokens = SparkHadoopUtil.get.serialize(creds)\n+    driver.send(UpdateDelegationTokens(tokens))\n+  }\n+\n+  /**\n+   * Fetch new delegation tokens for configured services, storing them in the given credentials.\n+   *\n+   * @return The time by which the tokens must be renewed.\n+   */\n+  protected def obtainDelegationTokens(creds: Credentials): Long"
  }],
  "prId": 22624
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "Why not extracting the `createAndUpdateTokens()` (along with `obtainDelegationTokens`) functionality into a separate class which would be used by this `Renewer` as well. So `Renewer` would be non-abstract class and the `renewalEnabled` and all the conditions using it would go away. Even giving a principal would be required so could be checked at the member val. ",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T08:42:57Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "The goal is to make it simple for scheduler backends to use token functionality. Adding more classes that the backends need to deal with complicates things instead of making them simpler.",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T16:09:49Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will"
  }],
  "prId": 22624
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "why reading this config value every time? (As I have seen other places this is extracted to member vals).",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T09:30:59Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {\n+      val tokens = SparkHadoopUtil.get.serialize(creds)\n+      driver.send(UpdateDelegationTokens(tokens))\n+    }\n+\n+    // Transfer the original user's tokens to the new user, since it may contain needed tokens\n+    // (such as those user to connect to YARN). Explicitly avoid overwriting tokens that already\n+    // exist in the current user's credentials, since those were freshly obtained above\n+    // (see SPARK-23361).\n+    val existing = ugi.getCredentials()\n+    existing.mergeAll(originalCreds)\n+    ugi.addCredentials(existing)\n+    ugi\n+  }\n+\n+  def stop(): Unit = {\n+    if (renewalExecutor != null) {\n+      renewalExecutor.shutdown()\n+    }\n+  }\n+\n+  /** Create new tokens for the current user and distribute them to the driver. */\n+  protected def createAndUpdateTokens(): Unit = {\n+    val driver = driverRef.get()\n+    require(driver != null, \"Driver endpoint not set.\")\n+\n+    val creds = new Credentials()\n+    obtainDelegationTokens(creds)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+\n+    val tokens = SparkHadoopUtil.get.serialize(creds)\n+    driver.send(UpdateDelegationTokens(tokens))\n+  }\n+\n+  /**\n+   * Fetch new delegation tokens for configured services, storing them in the given credentials.\n+   *\n+   * @return The time by which the tokens must be renewed.\n+   */\n+  protected def obtainDelegationTokens(creds: Credentials): Long\n+\n+  private def scheduleRenewal(delay: Long): Unit = {\n+    val _delay = math.max(0, delay)\n+    logInfo(s\"Scheduling login from keytab in ${UIUtils.formatDuration(delay)}.\")\n+\n+    val renewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        updateTokensTask()\n+      }\n+    }\n+    renewalExecutor.schedule(renewalTask, _delay, TimeUnit.MILLISECONDS)\n+  }\n+\n+  /**\n+   * Periodic task to login to the KDC and create new delegation tokens. Re-schedules itself\n+   * to fetch the next set of tokens when needed.\n+   */\n+  private def updateTokensTask(): Unit = {\n+    try {\n+      val freshUGI = doLogin()\n+      val creds = obtainTokensAndScheduleRenewal(freshUGI)\n+      val tokens = SparkHadoopUtil.get.serialize(creds)\n+\n+      val driver = driverRef.get()\n+      if (driver != null) {\n+        logInfo(\"Updating delegation tokens.\")\n+        driver.send(UpdateDelegationTokens(tokens))\n+      } else {\n+        // This shouldn't really happen, since the driver should register way before tokens expire.\n+        logWarning(\"Delegation tokens close to expiration but no driver has registered yet.\")\n+        SparkHadoopUtil.get.addDelegationTokens(tokens, sparkConf)\n+      }\n+    } catch {\n+      case e: Exception =>\n+        val delay = TimeUnit.SECONDS.toMillis(sparkConf.get(CREDENTIALS_RENEWAL_RETRY_WAIT))\n+        logWarning(s\"Failed to update tokens, will try again in ${UIUtils.formatDuration(delay)}!\" +\n+          \" If this happens too often tasks will fail.\", e)\n+        scheduleRenewal(delay)\n+    }\n+  }\n+\n+  /**\n+   * Obtain new delegation tokens from the available providers. Schedules a new task to fetch\n+   * new tokens before the new set expires.\n+   *\n+   * @return Credentials containing the new tokens.\n+   */\n+  private def obtainTokensAndScheduleRenewal(ugi: UserGroupInformation): Credentials = {\n+    ugi.doAs(new PrivilegedExceptionAction[Credentials]() {\n+      override def run(): Credentials = {\n+        val creds = new Credentials()\n+        val nextRenewal = obtainDelegationTokens(creds)\n+\n+        // Calculate the time when new credentials should be created, based on the configured\n+        // ratio.\n+        val now = System.currentTimeMillis\n+        val ratio = sparkConf.get(CREDENTIALS_RENEWAL_INTERVAL_RATIO)"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "What is the advantage to stashing it in a field? It just decouples the code that is reading the config from the code that is using it.",
    "commit": "88fe6cb9105d140d5ebb250baee2623bb07650ce",
    "createdAt": "2018-10-09T16:10:51Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.deploy.security\n+\n+import java.io.File\n+import java.security.PrivilegedExceptionAction\n+import java.util.concurrent.{ScheduledExecutorService, TimeUnit}\n+import java.util.concurrent.atomic.AtomicReference\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.security.{Credentials, UserGroupInformation}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.internal.config._\n+import org.apache.spark.rpc.RpcEndpointRef\n+import org.apache.spark.scheduler.cluster.CoarseGrainedClusterMessages.UpdateDelegationTokens\n+import org.apache.spark.ui.UIUtils\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * Base class for periodically updating delegation tokens needed by the application.\n+ *\n+ * When configured with a principal and a keytab, this manager will make sure long-running apps\n+ * (such as Spark Streaming apps) can run without interruption while accessing secured services. It\n+ * periodically logs in to the KDC with user-provided credentials, and contacts all the configured\n+ * secure services to obtain delegation tokens to be distributed to the rest of the application.\n+ *\n+ * This class will manage the kerberos login, by renewing the TGT when needed. Because the UGI API\n+ * does not expose the TTL of the TGT, a configuration controls how often to check that a relogin is\n+ * necessary. This is done reasonably often since the check is a no-op when the relogin is not yet\n+ * needed. The check period can be overridden in the configuration.\n+ *\n+ * New delegation tokens are created once 75% of the renewal interval of the original tokens has\n+ * elapsed. The new tokens are sent to the Spark driver endpoint once it's registered with the AM.\n+ * The driver is tasked with distributing the tokens to other processes that might need them.\n+ *\n+ * This class can also be used when without a principal and keytab, in which case token renewal will\n+ * not be available. It provides a different API in that case (see `createAndUpdateTokens()`), which\n+ * automates the distribution of tokens to the different processes in the Spark app.\n+ */\n+private[spark] abstract class AbstractCredentialRenewer(\n+    protected val sparkConf: SparkConf,\n+    protected val hadoopConf: Configuration) extends Logging {\n+\n+  private val principal = sparkConf.get(PRINCIPAL).orNull\n+  private val keytab = sparkConf.get(KEYTAB).orNull\n+\n+  if (principal != null) {\n+    require(keytab != null, \"Kerberos principal specified without a keytab.\")\n+    require(new File(keytab).isFile(), s\"Cannot find keytab at $keytab.\")\n+  }\n+\n+  private val renewalExecutor: ScheduledExecutorService =\n+    if (principal != null) {\n+      ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"Credential Renewal Thread\")\n+    } else {\n+      null\n+    }\n+\n+  private val driverRef = new AtomicReference[RpcEndpointRef]()\n+\n+  protected def setDriverRef(ref: RpcEndpointRef): Unit = {\n+    driverRef.set(ref)\n+  }\n+\n+  protected def renewalEnabled: Boolean = principal != null\n+\n+  /**\n+   * Start the token renewer. Upon start, if a principal has been configured, the renewer will:\n+   *\n+   * - log in the configured principal, and set up a task to keep that user's ticket renewed\n+   * - obtain delegation tokens from all available providers\n+   * - schedule a periodic task to update the tokens when needed.\n+   *\n+   * @return The newly logged in user.\n+   */\n+  def start(): UserGroupInformation = {\n+    require(renewalEnabled, \"Token renewal is disabled.\")\n+\n+    val originalCreds = UserGroupInformation.getCurrentUser().getCredentials()\n+    val ugi = doLogin()\n+\n+    val tgtRenewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        ugi.checkTGTAndReloginFromKeytab()\n+      }\n+    }\n+    val tgtRenewalPeriod = sparkConf.get(KERBEROS_RELOGIN_PERIOD)\n+    renewalExecutor.scheduleAtFixedRate(tgtRenewalTask, tgtRenewalPeriod, tgtRenewalPeriod,\n+      TimeUnit.SECONDS)\n+\n+    val creds = obtainTokensAndScheduleRenewal(ugi)\n+    ugi.addCredentials(creds)\n+\n+    val driver = driverRef.get()\n+    if (driver != null) {\n+      val tokens = SparkHadoopUtil.get.serialize(creds)\n+      driver.send(UpdateDelegationTokens(tokens))\n+    }\n+\n+    // Transfer the original user's tokens to the new user, since it may contain needed tokens\n+    // (such as those user to connect to YARN). Explicitly avoid overwriting tokens that already\n+    // exist in the current user's credentials, since those were freshly obtained above\n+    // (see SPARK-23361).\n+    val existing = ugi.getCredentials()\n+    existing.mergeAll(originalCreds)\n+    ugi.addCredentials(existing)\n+    ugi\n+  }\n+\n+  def stop(): Unit = {\n+    if (renewalExecutor != null) {\n+      renewalExecutor.shutdown()\n+    }\n+  }\n+\n+  /** Create new tokens for the current user and distribute them to the driver. */\n+  protected def createAndUpdateTokens(): Unit = {\n+    val driver = driverRef.get()\n+    require(driver != null, \"Driver endpoint not set.\")\n+\n+    val creds = new Credentials()\n+    obtainDelegationTokens(creds)\n+    UserGroupInformation.getCurrentUser.addCredentials(creds)\n+\n+    val tokens = SparkHadoopUtil.get.serialize(creds)\n+    driver.send(UpdateDelegationTokens(tokens))\n+  }\n+\n+  /**\n+   * Fetch new delegation tokens for configured services, storing them in the given credentials.\n+   *\n+   * @return The time by which the tokens must be renewed.\n+   */\n+  protected def obtainDelegationTokens(creds: Credentials): Long\n+\n+  private def scheduleRenewal(delay: Long): Unit = {\n+    val _delay = math.max(0, delay)\n+    logInfo(s\"Scheduling login from keytab in ${UIUtils.formatDuration(delay)}.\")\n+\n+    val renewalTask = new Runnable() {\n+      override def run(): Unit = {\n+        updateTokensTask()\n+      }\n+    }\n+    renewalExecutor.schedule(renewalTask, _delay, TimeUnit.MILLISECONDS)\n+  }\n+\n+  /**\n+   * Periodic task to login to the KDC and create new delegation tokens. Re-schedules itself\n+   * to fetch the next set of tokens when needed.\n+   */\n+  private def updateTokensTask(): Unit = {\n+    try {\n+      val freshUGI = doLogin()\n+      val creds = obtainTokensAndScheduleRenewal(freshUGI)\n+      val tokens = SparkHadoopUtil.get.serialize(creds)\n+\n+      val driver = driverRef.get()\n+      if (driver != null) {\n+        logInfo(\"Updating delegation tokens.\")\n+        driver.send(UpdateDelegationTokens(tokens))\n+      } else {\n+        // This shouldn't really happen, since the driver should register way before tokens expire.\n+        logWarning(\"Delegation tokens close to expiration but no driver has registered yet.\")\n+        SparkHadoopUtil.get.addDelegationTokens(tokens, sparkConf)\n+      }\n+    } catch {\n+      case e: Exception =>\n+        val delay = TimeUnit.SECONDS.toMillis(sparkConf.get(CREDENTIALS_RENEWAL_RETRY_WAIT))\n+        logWarning(s\"Failed to update tokens, will try again in ${UIUtils.formatDuration(delay)}!\" +\n+          \" If this happens too often tasks will fail.\", e)\n+        scheduleRenewal(delay)\n+    }\n+  }\n+\n+  /**\n+   * Obtain new delegation tokens from the available providers. Schedules a new task to fetch\n+   * new tokens before the new set expires.\n+   *\n+   * @return Credentials containing the new tokens.\n+   */\n+  private def obtainTokensAndScheduleRenewal(ugi: UserGroupInformation): Credentials = {\n+    ugi.doAs(new PrivilegedExceptionAction[Credentials]() {\n+      override def run(): Credentials = {\n+        val creds = new Credentials()\n+        val nextRenewal = obtainDelegationTokens(creds)\n+\n+        // Calculate the time when new credentials should be created, based on the configured\n+        // ratio.\n+        val now = System.currentTimeMillis\n+        val ratio = sparkConf.get(CREDENTIALS_RENEWAL_INTERVAL_RATIO)"
  }],
  "prId": 22624
}]