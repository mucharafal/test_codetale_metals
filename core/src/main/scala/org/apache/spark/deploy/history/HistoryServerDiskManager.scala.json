[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I like the change to track committed space.  I'm wondering if we should log more here, even at Info level, summarizing the available space (I can see users complaining that they configured it to 10GB but its taking 12GB and wanting an explanation -- would be nice if the logs already had all the relevant info).  Maybe something like\r\n\r\n```\r\nval totalNeeded = size\r\nvar activeSize = 0\r\n...\r\nif (!isActive) {\r\n  evicted += info\r\n  needed -= info.size\r\n} else {\r\n  activeSize += info.size\r\n}\r\n...\r\nlogInfo(s\"Deleted ${evicted.size} apps to free ${Utils.bytesToString(needed)})\r\nif (needed > 0) {\r\n  val current = currentUsage.get()\r\n  val leased = Utils.bytesToString(current - committedUsage.get())\r\n  logInfo(s\"Did not free requested ${Utils.bytesToString(totalNeeded)}.  Current usage is ${Utils.bytesToString(current).  $leased (estimated) used by apps actively updating their kvstores; ${Utils.bytesToString(active)} used by active applications.\")\r\n}",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T23:18:45Z",
    "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+import java.nio.file.Files\n+import java.nio.file.attribute.PosixFilePermissions\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.{HashMap, ListBuffer}\n+\n+import org.apache.commons.io.FileUtils\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.status.KVUtils._\n+import org.apache.spark.util.{Clock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+/**\n+ * A class used to keep track of disk usage by the SHS, allowing application data to be deleted\n+ * from disk when usage exceeds a configurable threshold.\n+ *\n+ * The goal of the class is not to guarantee that usage will never exceed the threshold; because of\n+ * how application data is written, disk usage may temporarily go higher. But, eventually, it\n+ * should fall back under the threshold.\n+ *\n+ * @param conf Spark configuration.\n+ * @param path Path where to store application data.\n+ * @param listing The listing store, used to persist usage data.\n+ * @param clock Clock instance to use.\n+ */\n+private class HistoryServerDiskManager(\n+    conf: SparkConf,\n+    path: File,\n+    listing: KVStore,\n+    clock: Clock) extends Logging {\n+\n+  import config._\n+\n+  private val appStoreDir = new File(path, \"apps\")\n+  if (!appStoreDir.isDirectory() && !appStoreDir.mkdir()) {\n+    throw new IllegalArgumentException(s\"Failed to create app directory ($appStoreDir).\")\n+  }\n+\n+  private val tmpStoreDir = new File(path, \"temp\")\n+  if (!tmpStoreDir.isDirectory() && !tmpStoreDir.mkdir()) {\n+    throw new IllegalArgumentException(s\"Failed to create temp directory ($tmpStoreDir).\")\n+  }\n+\n+  private val maxUsage = conf.get(MAX_LOCAL_DISK_USAGE)\n+  private val currentUsage = new AtomicLong(0L)\n+  private val committedUsage = new AtomicLong(0L)\n+  private val active = new HashMap[(String, Option[String]), Long]()\n+\n+  def initialize(): Unit = {\n+    updateUsage(sizeOf(appStoreDir), committed = true)\n+\n+    // Clean up any temporary stores during start up. This assumes that they're leftover from other\n+    // instances and are not useful.\n+    tmpStoreDir.listFiles().foreach(FileUtils.deleteQuietly)\n+\n+    // Go through the recorded store directories and remove any that may have been removed by\n+    // external code.\n+    val orphans = listing.view(classOf[ApplicationStoreInfo]).asScala.filter { info =>\n+      !new File(info.path).exists()\n+    }.toSeq\n+\n+    orphans.foreach { info =>\n+      listing.delete(info.getClass(), info.path)\n+    }\n+  }\n+\n+  /**\n+   * Lease some space from the store. The leased space is calculated as a fraction of the given\n+   * event log size; this is an approximation, and doesn't mean the application store cannot\n+   * outgrow the lease.\n+   *\n+   * If there's not enough space for the lease, other applications might be evicted to make room.\n+   * This method always returns a lease, meaning that it's possible for local disk usage to grow\n+   * past the configured threshold if there aren't enough idle applications to evict.\n+   *\n+   * While the lease is active, the data is written to a temporary location, so `openStore()`\n+   * will still return `None` for the application.\n+   */\n+  def lease(eventLogSize: Long, isCompressed: Boolean = false): Lease = {\n+    val needed = approximateSize(eventLogSize, isCompressed)\n+    makeRoom(needed)\n+\n+    val perms = PosixFilePermissions.fromString(\"rwx------\")\n+    val tmp = Files.createTempDirectory(tmpStoreDir.toPath(), \"appstore\",\n+      PosixFilePermissions.asFileAttribute(perms)).toFile()\n+\n+    updateUsage(needed)\n+    new Lease(tmp, needed)\n+  }\n+\n+  /**\n+   * Returns the location of an application store if it's still available. Marks the store as\n+   * being used so that it's not evicted when running out of designated space.\n+   */\n+  def openStore(appId: String, attemptId: Option[String]): Option[File] = {\n+    val storePath = active.synchronized {\n+      val path = appStorePath(appId, attemptId)\n+      if (path.isDirectory()) {\n+        active(appId -> attemptId) = sizeOf(path)\n+        Some(path)\n+      } else {\n+        None\n+      }\n+    }\n+\n+    storePath.foreach { path =>\n+      updateAccessTime(appId, attemptId)\n+    }\n+\n+    storePath\n+  }\n+\n+  /**\n+   * Tell the disk manager that the store for the given application is not being used anymore.\n+   *\n+   * @param delete Whether to delete the store from disk.\n+   */\n+  def release(appId: String, attemptId: Option[String], delete: Boolean = false): Unit = {\n+    // Because LevelDB may modify the structure of the store files even when just reading, update\n+    // the accounting for this application when it's closed.\n+    val oldSizeOpt = active.synchronized {\n+      active.remove(appId -> attemptId)\n+    }\n+\n+    oldSizeOpt.foreach { oldSize =>\n+      val path = appStorePath(appId, attemptId)\n+      updateUsage(-oldSize, committed = true)\n+      if (path.isDirectory()) {\n+        if (delete) {\n+          deleteStore(path)\n+        } else {\n+          val newSize = sizeOf(path)\n+          val newInfo = listing.read(classOf[ApplicationStoreInfo], path.getAbsolutePath())\n+            .copy(size = newSize)\n+          listing.write(newInfo)\n+          updateUsage(newSize, committed = true)\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A non-scientific approximation of how large an app state store will be given the size of the\n+   * event log.\n+   */\n+  def approximateSize(eventLogSize: Long, isCompressed: Boolean): Long = {\n+    if (isCompressed) {\n+      // For compressed logs, assume that compression reduces the log size a lot, and the disk\n+      // store will actually grow compared to the log size.\n+      eventLogSize * 2\n+    } else {\n+      // For non-compressed logs, assume the disk store will end up at approximately 50% of the\n+      // size of the logs. This is loosely based on empirical evidence.\n+      eventLogSize / 2\n+    }\n+  }\n+\n+  /** Current free space. Considers space currently leased out too. */\n+  def free(): Long = {\n+    math.max(maxUsage - currentUsage.get(), 0L)\n+  }\n+\n+  /** Current committed space. */\n+  def committed(): Long = committedUsage.get()\n+\n+  private def deleteStore(path: File): Unit = {\n+    FileUtils.deleteDirectory(path)\n+    listing.delete(classOf[ApplicationStoreInfo], path.getAbsolutePath())\n+  }\n+\n+  private def makeRoom(size: Long): Unit = {\n+    if (free() < size) {\n+      logDebug(s\"Not enough free space, looking at candidates for deletion...\")\n+      val evicted = new ListBuffer[ApplicationStoreInfo]()\n+      Utils.tryWithResource(\n+        listing.view(classOf[ApplicationStoreInfo]).index(\"lastAccess\").closeableIterator()\n+      ) { iter =>\n+        var needed = size\n+        while (needed > 0 && iter.hasNext()) {\n+          val info = iter.next()\n+          val isActive = active.synchronized {\n+            active.contains(info.appId -> info.attemptId)\n+          }\n+          if (!isActive) {\n+            evicted += info\n+            needed -= info.size\n+          }\n+        }\n+      }\n+\n+      evicted.foreach { info =>\n+        logInfo(s\"Deleting store for ${info.appId}/${info.attemptId}.\")\n+        deleteStore(new File(info.path))\n+        updateUsage(-info.size, committed = true)\n+      }"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Yeah, I'll add some more logs.",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T23:31:45Z",
    "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+import java.nio.file.Files\n+import java.nio.file.attribute.PosixFilePermissions\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.{HashMap, ListBuffer}\n+\n+import org.apache.commons.io.FileUtils\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.status.KVUtils._\n+import org.apache.spark.util.{Clock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+/**\n+ * A class used to keep track of disk usage by the SHS, allowing application data to be deleted\n+ * from disk when usage exceeds a configurable threshold.\n+ *\n+ * The goal of the class is not to guarantee that usage will never exceed the threshold; because of\n+ * how application data is written, disk usage may temporarily go higher. But, eventually, it\n+ * should fall back under the threshold.\n+ *\n+ * @param conf Spark configuration.\n+ * @param path Path where to store application data.\n+ * @param listing The listing store, used to persist usage data.\n+ * @param clock Clock instance to use.\n+ */\n+private class HistoryServerDiskManager(\n+    conf: SparkConf,\n+    path: File,\n+    listing: KVStore,\n+    clock: Clock) extends Logging {\n+\n+  import config._\n+\n+  private val appStoreDir = new File(path, \"apps\")\n+  if (!appStoreDir.isDirectory() && !appStoreDir.mkdir()) {\n+    throw new IllegalArgumentException(s\"Failed to create app directory ($appStoreDir).\")\n+  }\n+\n+  private val tmpStoreDir = new File(path, \"temp\")\n+  if (!tmpStoreDir.isDirectory() && !tmpStoreDir.mkdir()) {\n+    throw new IllegalArgumentException(s\"Failed to create temp directory ($tmpStoreDir).\")\n+  }\n+\n+  private val maxUsage = conf.get(MAX_LOCAL_DISK_USAGE)\n+  private val currentUsage = new AtomicLong(0L)\n+  private val committedUsage = new AtomicLong(0L)\n+  private val active = new HashMap[(String, Option[String]), Long]()\n+\n+  def initialize(): Unit = {\n+    updateUsage(sizeOf(appStoreDir), committed = true)\n+\n+    // Clean up any temporary stores during start up. This assumes that they're leftover from other\n+    // instances and are not useful.\n+    tmpStoreDir.listFiles().foreach(FileUtils.deleteQuietly)\n+\n+    // Go through the recorded store directories and remove any that may have been removed by\n+    // external code.\n+    val orphans = listing.view(classOf[ApplicationStoreInfo]).asScala.filter { info =>\n+      !new File(info.path).exists()\n+    }.toSeq\n+\n+    orphans.foreach { info =>\n+      listing.delete(info.getClass(), info.path)\n+    }\n+  }\n+\n+  /**\n+   * Lease some space from the store. The leased space is calculated as a fraction of the given\n+   * event log size; this is an approximation, and doesn't mean the application store cannot\n+   * outgrow the lease.\n+   *\n+   * If there's not enough space for the lease, other applications might be evicted to make room.\n+   * This method always returns a lease, meaning that it's possible for local disk usage to grow\n+   * past the configured threshold if there aren't enough idle applications to evict.\n+   *\n+   * While the lease is active, the data is written to a temporary location, so `openStore()`\n+   * will still return `None` for the application.\n+   */\n+  def lease(eventLogSize: Long, isCompressed: Boolean = false): Lease = {\n+    val needed = approximateSize(eventLogSize, isCompressed)\n+    makeRoom(needed)\n+\n+    val perms = PosixFilePermissions.fromString(\"rwx------\")\n+    val tmp = Files.createTempDirectory(tmpStoreDir.toPath(), \"appstore\",\n+      PosixFilePermissions.asFileAttribute(perms)).toFile()\n+\n+    updateUsage(needed)\n+    new Lease(tmp, needed)\n+  }\n+\n+  /**\n+   * Returns the location of an application store if it's still available. Marks the store as\n+   * being used so that it's not evicted when running out of designated space.\n+   */\n+  def openStore(appId: String, attemptId: Option[String]): Option[File] = {\n+    val storePath = active.synchronized {\n+      val path = appStorePath(appId, attemptId)\n+      if (path.isDirectory()) {\n+        active(appId -> attemptId) = sizeOf(path)\n+        Some(path)\n+      } else {\n+        None\n+      }\n+    }\n+\n+    storePath.foreach { path =>\n+      updateAccessTime(appId, attemptId)\n+    }\n+\n+    storePath\n+  }\n+\n+  /**\n+   * Tell the disk manager that the store for the given application is not being used anymore.\n+   *\n+   * @param delete Whether to delete the store from disk.\n+   */\n+  def release(appId: String, attemptId: Option[String], delete: Boolean = false): Unit = {\n+    // Because LevelDB may modify the structure of the store files even when just reading, update\n+    // the accounting for this application when it's closed.\n+    val oldSizeOpt = active.synchronized {\n+      active.remove(appId -> attemptId)\n+    }\n+\n+    oldSizeOpt.foreach { oldSize =>\n+      val path = appStorePath(appId, attemptId)\n+      updateUsage(-oldSize, committed = true)\n+      if (path.isDirectory()) {\n+        if (delete) {\n+          deleteStore(path)\n+        } else {\n+          val newSize = sizeOf(path)\n+          val newInfo = listing.read(classOf[ApplicationStoreInfo], path.getAbsolutePath())\n+            .copy(size = newSize)\n+          listing.write(newInfo)\n+          updateUsage(newSize, committed = true)\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A non-scientific approximation of how large an app state store will be given the size of the\n+   * event log.\n+   */\n+  def approximateSize(eventLogSize: Long, isCompressed: Boolean): Long = {\n+    if (isCompressed) {\n+      // For compressed logs, assume that compression reduces the log size a lot, and the disk\n+      // store will actually grow compared to the log size.\n+      eventLogSize * 2\n+    } else {\n+      // For non-compressed logs, assume the disk store will end up at approximately 50% of the\n+      // size of the logs. This is loosely based on empirical evidence.\n+      eventLogSize / 2\n+    }\n+  }\n+\n+  /** Current free space. Considers space currently leased out too. */\n+  def free(): Long = {\n+    math.max(maxUsage - currentUsage.get(), 0L)\n+  }\n+\n+  /** Current committed space. */\n+  def committed(): Long = committedUsage.get()\n+\n+  private def deleteStore(path: File): Unit = {\n+    FileUtils.deleteDirectory(path)\n+    listing.delete(classOf[ApplicationStoreInfo], path.getAbsolutePath())\n+  }\n+\n+  private def makeRoom(size: Long): Unit = {\n+    if (free() < size) {\n+      logDebug(s\"Not enough free space, looking at candidates for deletion...\")\n+      val evicted = new ListBuffer[ApplicationStoreInfo]()\n+      Utils.tryWithResource(\n+        listing.view(classOf[ApplicationStoreInfo]).index(\"lastAccess\").closeableIterator()\n+      ) { iter =>\n+        var needed = size\n+        while (needed > 0 && iter.hasNext()) {\n+          val info = iter.next()\n+          val isActive = active.synchronized {\n+            active.contains(info.appId -> info.attemptId)\n+          }\n+          if (!isActive) {\n+            evicted += info\n+            needed -= info.size\n+          }\n+        }\n+      }\n+\n+      evicted.foreach { info =>\n+        logInfo(s\"Deleting store for ${info.appId}/${info.attemptId}.\")\n+        deleteStore(new File(info.path))\n+        updateUsage(-info.size, committed = true)\n+      }"
  }],
  "prId": 20011
}]