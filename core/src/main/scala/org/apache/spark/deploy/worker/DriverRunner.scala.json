[{
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "~~I opted not to use an AtomicReference on the `process` variable, although it is shared with the ShutdownHookManager, I think if the hook is invoked then it's not an issue at that point because it means the JVM is exiting right?~~\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-03-16T01:26:40Z",
    "diffHunk": "@@ -48,13 +48,16 @@ private[deploy] class DriverRunner(\n     val securityManager: SecurityManager)\n   extends Logging {\n \n-  @volatile private var process: Option[Process] = None\n-  @volatile private var killed = false\n+  private var workerThread: Thread = null\n+  private var process: Process = null"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "From what I could tell, `DriverRunner.kill` is not always called, like if the driver completes on its own. I remove the hook here so that this wouldn't cause the DriverRunner object to be hanging around because the ShutdownHookManager is holding on to a reference.\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-03-16T01:32:26Z",
    "diffHunk": "@@ -67,56 +70,67 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            killProcessAndFinalize(DriverState.KILLED, new SparkException(\"Worker shutting down\"))\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n+          // prepare driver jars, launch driver and set final state from process exit code\n+          val exitCode = prepareAndLaunchDriver()\n+          finalState = if (exitCode == 0) Some(DriverState.FINISHED) else Some(DriverState.FAILED)\n         }\n         catch {\n-          case e: Exception => finalException = Some(e)\n+          case interrupted: InterruptedException =>\n+            logInfo(\"Runner thread for driver \" + driverId + \" interrupted\")\n+            killProcessAndFinalize(DriverState.KILLED, interrupted)\n+          case e: Exception =>\n+            killProcessAndFinalize(DriverState.ERROR, e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "`shutdownHook` can be just a local var\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-03-24T22:00:28Z",
    "diffHunk": "@@ -49,13 +49,16 @@ private[deploy] class DriverRunner(\n     val securityManager: SecurityManager)\n   extends Logging {\n \n-  @volatile private var process: Option[Process] = None\n-  @volatile private var killed = false\n+  private var workerThread: Thread = null\n+  private var process: Process = null\n+  private var shutdownHook: AnyRef = null"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: extra space\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-03-24T22:15:30Z",
    "diffHunk": "@@ -181,42 +211,43 @@ private[deploy] class DriverRunner(\n     runCommandWithRetry(ProcessBuilderLike(builder), initialize, supervise)\n   }\n \n-  def runCommandWithRetry(\n-      command: ProcessBuilderLike, initialize: Process => Unit, supervise: Boolean): Unit = {\n+  private[worker] def runCommandWithRetry(\n+      command: ProcessBuilderLike, initialize: Process => Unit, supervise: Boolean): Int = {\n     // Time to wait between submission retries.\n     var waitSeconds = 1\n     // A run of this many seconds resets the exponential back-off.\n     val successfulRunDuration = 5\n+    var attemptRun = true\n+    var exitCode = -1\n \n-    var keepTrying = !killed\n-\n-    while (keepTrying) {\n+    while (attemptRun) {\n       logInfo(\"Launch Command: \" + command.command.mkString(\"\\\"\", \"\\\" \\\"\", \"\\\"\"))\n \n-      synchronized {\n-        if (killed) { return }\n-        process = Some(command.start())\n-        initialize(process.get)\n-      }\n+      process = command.start()\n+      initialize(process)\n \n       val processStart = clock.getTimeMillis()\n-      val exitCode = process.get.waitFor()\n-      if (clock.getTimeMillis() - processStart > successfulRunDuration * 1000) {\n-        waitSeconds = 1\n-      }\n \n-      if (supervise && exitCode != 0 && !killed) {\n+      exitCode = process.waitFor()\n+      process = null\n+\n+      // check if attempting another run\n+      attemptRun = supervise && exitCode != 0\n+      if (attemptRun) {\n+        if (clock.getTimeMillis() - processStart > successfulRunDuration * 1000) {\n+          waitSeconds = 1\n+        }\n         logInfo(s\"Command exited with status $exitCode, re-launching after $waitSeconds s.\")\n         sleeper.sleep(waitSeconds)\n         waitSeconds = waitSeconds * 2 // exponential back-off\n       }\n-\n-      keepTrying = supervise && exitCode != 0 && !killed\n-      finalExitCode = Some(exitCode)\n     }\n+\n+    exitCode\n   }\n }\n \n+"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "There is a race condition here: if this shutdown hook is running while the thread is starting the driver process, the shutdown hook may miss that.\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-03-24T22:38:57Z",
    "diffHunk": "@@ -68,56 +71,67 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            killProcessAndFinalize(DriverState.KILLED, new SparkException(\"Worker shutting down\"))"
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "Yeah, you're right, I should have seen that.. I'll fix that up.\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-03-25T04:35:45Z",
    "diffHunk": "@@ -68,56 +71,67 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            killProcessAndFinalize(DriverState.KILLED, new SparkException(\"Worker shutting down\"))"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "There is a dead lock. If you join with a lock here, workerThread won't be able to get the lock. Then if it happens to reach the `synchronized` line, it will block forever.\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-04-14T01:44:06Z",
    "diffHunk": "@@ -68,56 +70,72 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n+          // prepare driver jars, launch driver and set final state from process exit code\n+          val exitCode = prepareAndLaunchDriver()\n+          finalState = if (exitCode == 0) Some(DriverState.FINISHED) else Some(DriverState.FAILED)\n         }\n         catch {\n-          case e: Exception => finalException = Some(e)\n+          case interrupted: InterruptedException =>\n+            logInfo(\"Runner thread for driver \" + driverId + \" interrupted\")\n+            killProcessAndFinalize(DriverState.KILLED, interrupted)\n+          case e: Exception =>\n+            killProcessAndFinalize(DriverState.ERROR, e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)\n         }\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n-          } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n-          }\n+        // notify worker of final driver state, possible exception\n+        worker.send(DriverStateChanged(driverId, finalState.get, finalException))\n+      }\n \n+      // kill the process if started, set shared finalizing variables\n+      def killProcessAndFinalize(state: DriverState.DriverState, e: Exception): Unit = {\n+        killProcess()\n         finalState = Some(state)\n+        finalException = Some(e)\n+      }\n+    }\n+\n+    workerThread.start()\n+  }\n \n-        worker.send(DriverStateChanged(driverId, state, finalException))\n+  /** Kill driver process and wait for it to exit. */\n+  private def killProcess(): Unit = {\n+    if (process != null) {\n+      logInfo(\"Killing driver process!\")\n+      val exitCode = Utils.terminateProcess(process, DRIVER_TERMINATE_TIMEOUT_MS)\n+      if (exitCode.isEmpty) {\n+        logWarning(\"Failed to terminate driver process: \" + process +\n+            \". This process will likely be orphaned.\")\n       }\n-    }.start()\n+    }\n   }\n \n-  /** Terminate this driver (or prevent it from ever starting if not yet started) */\n-  private[worker] def kill() {\n-    synchronized {\n-      process.foreach(p => p.destroy())\n-      killed = true\n+  /** Stop this driver, including the process it launched */\n+  private[worker] def kill(): Unit = {\n+    if (workerThread != null) {\n+      // make sure process does not start if being interrupted\n+      this.synchronized {\n+        // the workerThread will kill the child process when interrupted\n+        workerThread.interrupt()\n+        workerThread.join()"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "This doesn't fix the race condition. Image the following execution order:\n\n| Time | DriverRunner.start | ShutdownHook |\n| :-: | :-: | :-: |\n| 1 |  | if (workerThread != null) { |\n| 2 | workerThread = ... |  |\n| 3 | workerThread.start() |  |\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-04-14T01:49:15Z",
    "diffHunk": "@@ -68,56 +70,72 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n+          // prepare driver jars, launch driver and set final state from process exit code\n+          val exitCode = prepareAndLaunchDriver()\n+          finalState = if (exitCode == 0) Some(DriverState.FINISHED) else Some(DriverState.FAILED)\n         }\n         catch {\n-          case e: Exception => finalException = Some(e)\n+          case interrupted: InterruptedException =>\n+            logInfo(\"Runner thread for driver \" + driverId + \" interrupted\")\n+            killProcessAndFinalize(DriverState.KILLED, interrupted)\n+          case e: Exception =>\n+            killProcessAndFinalize(DriverState.ERROR, e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)\n         }\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n-          } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n-          }\n+        // notify worker of final driver state, possible exception\n+        worker.send(DriverStateChanged(driverId, finalState.get, finalException))\n+      }\n \n+      // kill the process if started, set shared finalizing variables\n+      def killProcessAndFinalize(state: DriverState.DriverState, e: Exception): Unit = {\n+        killProcess()\n         finalState = Some(state)\n+        finalException = Some(e)\n+      }\n+    }\n+\n+    workerThread.start()\n+  }\n \n-        worker.send(DriverStateChanged(driverId, state, finalException))\n+  /** Kill driver process and wait for it to exit. */\n+  private def killProcess(): Unit = {\n+    if (process != null) {\n+      logInfo(\"Killing driver process!\")\n+      val exitCode = Utils.terminateProcess(process, DRIVER_TERMINATE_TIMEOUT_MS)\n+      if (exitCode.isEmpty) {\n+        logWarning(\"Failed to terminate driver process: \" + process +\n+            \". This process will likely be orphaned.\")\n       }\n-    }.start()\n+    }\n   }\n \n-  /** Terminate this driver (or prevent it from ever starting if not yet started) */\n-  private[worker] def kill() {\n-    synchronized {\n-      process.foreach(p => p.destroy())\n-      killed = true\n+  /** Stop this driver, including the process it launched */\n+  private[worker] def kill(): Unit = {\n+    if (workerThread != null) {\n+      // make sure process does not start if being interrupted\n+      this.synchronized {\n+        // the workerThread will kill the child process when interrupted\n+        workerThread.interrupt()\n+        workerThread.join()"
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "> This doesn't fix the race condition. Image the following execution order:\n\nThat order can't happen because the ShutdownHook isn't added until the thread is started, so `workerThread` will be assigned at that point.\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-04-14T02:56:48Z",
    "diffHunk": "@@ -68,56 +70,72 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n+          // prepare driver jars, launch driver and set final state from process exit code\n+          val exitCode = prepareAndLaunchDriver()\n+          finalState = if (exitCode == 0) Some(DriverState.FINISHED) else Some(DriverState.FAILED)\n         }\n         catch {\n-          case e: Exception => finalException = Some(e)\n+          case interrupted: InterruptedException =>\n+            logInfo(\"Runner thread for driver \" + driverId + \" interrupted\")\n+            killProcessAndFinalize(DriverState.KILLED, interrupted)\n+          case e: Exception =>\n+            killProcessAndFinalize(DriverState.ERROR, e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)\n         }\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n-          } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n-          }\n+        // notify worker of final driver state, possible exception\n+        worker.send(DriverStateChanged(driverId, finalState.get, finalException))\n+      }\n \n+      // kill the process if started, set shared finalizing variables\n+      def killProcessAndFinalize(state: DriverState.DriverState, e: Exception): Unit = {\n+        killProcess()\n         finalState = Some(state)\n+        finalException = Some(e)\n+      }\n+    }\n+\n+    workerThread.start()\n+  }\n \n-        worker.send(DriverStateChanged(driverId, state, finalException))\n+  /** Kill driver process and wait for it to exit. */\n+  private def killProcess(): Unit = {\n+    if (process != null) {\n+      logInfo(\"Killing driver process!\")\n+      val exitCode = Utils.terminateProcess(process, DRIVER_TERMINATE_TIMEOUT_MS)\n+      if (exitCode.isEmpty) {\n+        logWarning(\"Failed to terminate driver process: \" + process +\n+            \". This process will likely be orphaned.\")\n       }\n-    }.start()\n+    }\n   }\n \n-  /** Terminate this driver (or prevent it from ever starting if not yet started) */\n-  private[worker] def kill() {\n-    synchronized {\n-      process.foreach(p => p.destroy())\n-      killed = true\n+  /** Stop this driver, including the process it launched */\n+  private[worker] def kill(): Unit = {\n+    if (workerThread != null) {\n+      // make sure process does not start if being interrupted\n+      this.synchronized {\n+        // the workerThread will kill the child process when interrupted\n+        workerThread.interrupt()\n+        workerThread.join()"
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "> There is a dead lock. If you join with a lock here, workerThread won't be able to get the lock. Then if it happens to reach the synchronized line, it will block forever.\n\nI thought that might be the case, so I forced this condition to happen and the workerThread was still able to interrupt when waiting for the lock.  I can investigate this more though..\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-04-14T02:59:34Z",
    "diffHunk": "@@ -68,56 +70,72 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n+          // prepare driver jars, launch driver and set final state from process exit code\n+          val exitCode = prepareAndLaunchDriver()\n+          finalState = if (exitCode == 0) Some(DriverState.FINISHED) else Some(DriverState.FAILED)\n         }\n         catch {\n-          case e: Exception => finalException = Some(e)\n+          case interrupted: InterruptedException =>\n+            logInfo(\"Runner thread for driver \" + driverId + \" interrupted\")\n+            killProcessAndFinalize(DriverState.KILLED, interrupted)\n+          case e: Exception =>\n+            killProcessAndFinalize(DriverState.ERROR, e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)\n         }\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n-          } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n-          }\n+        // notify worker of final driver state, possible exception\n+        worker.send(DriverStateChanged(driverId, finalState.get, finalException))\n+      }\n \n+      // kill the process if started, set shared finalizing variables\n+      def killProcessAndFinalize(state: DriverState.DriverState, e: Exception): Unit = {\n+        killProcess()\n         finalState = Some(state)\n+        finalException = Some(e)\n+      }\n+    }\n+\n+    workerThread.start()\n+  }\n \n-        worker.send(DriverStateChanged(driverId, state, finalException))\n+  /** Kill driver process and wait for it to exit. */\n+  private def killProcess(): Unit = {\n+    if (process != null) {\n+      logInfo(\"Killing driver process!\")\n+      val exitCode = Utils.terminateProcess(process, DRIVER_TERMINATE_TIMEOUT_MS)\n+      if (exitCode.isEmpty) {\n+        logWarning(\"Failed to terminate driver process: \" + process +\n+            \". This process will likely be orphaned.\")\n       }\n-    }.start()\n+    }\n   }\n \n-  /** Terminate this driver (or prevent it from ever starting if not yet started) */\n-  private[worker] def kill() {\n-    synchronized {\n-      process.foreach(p => p.destroy())\n-      killed = true\n+  /** Stop this driver, including the process it launched */\n+  private[worker] def kill(): Unit = {\n+    if (workerThread != null) {\n+      // make sure process does not start if being interrupted\n+      this.synchronized {\n+        // the workerThread will kill the child process when interrupted\n+        workerThread.interrupt()\n+        workerThread.join()"
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "Yeah, your are right, this can cause deadlock.  I'm also having doubts that relying on interrupting the thread to kill the process was a good idea and maybe the current implementation is better.  I'll work on it some more and get these issues ironed out.  Thanks for taking a look!\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-04-14T21:58:39Z",
    "diffHunk": "@@ -68,56 +70,72 @@ private[deploy] class DriverRunner(\n \n   private var clock: Clock = new SystemClock()\n   private var sleeper = new Sleeper {\n-    def sleep(seconds: Int): Unit = (0 until seconds).takeWhile(f => {Thread.sleep(1000); !killed})\n+    def sleep(seconds: Int): Unit = Thread.sleep(seconds * 1000)\n   }\n \n   /** Starts a thread to run and manage the driver. */\n   private[worker] def start() = {\n-    new Thread(\"DriverRunner for \" + driverId) {\n+    workerThread = new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n+          // prepare driver jars, launch driver and set final state from process exit code\n+          val exitCode = prepareAndLaunchDriver()\n+          finalState = if (exitCode == 0) Some(DriverState.FINISHED) else Some(DriverState.FAILED)\n         }\n         catch {\n-          case e: Exception => finalException = Some(e)\n+          case interrupted: InterruptedException =>\n+            logInfo(\"Runner thread for driver \" + driverId + \" interrupted\")\n+            killProcessAndFinalize(DriverState.KILLED, interrupted)\n+          case e: Exception =>\n+            killProcessAndFinalize(DriverState.ERROR, e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)\n         }\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n-          } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n-          }\n+        // notify worker of final driver state, possible exception\n+        worker.send(DriverStateChanged(driverId, finalState.get, finalException))\n+      }\n \n+      // kill the process if started, set shared finalizing variables\n+      def killProcessAndFinalize(state: DriverState.DriverState, e: Exception): Unit = {\n+        killProcess()\n         finalState = Some(state)\n+        finalException = Some(e)\n+      }\n+    }\n+\n+    workerThread.start()\n+  }\n \n-        worker.send(DriverStateChanged(driverId, state, finalException))\n+  /** Kill driver process and wait for it to exit. */\n+  private def killProcess(): Unit = {\n+    if (process != null) {\n+      logInfo(\"Killing driver process!\")\n+      val exitCode = Utils.terminateProcess(process, DRIVER_TERMINATE_TIMEOUT_MS)\n+      if (exitCode.isEmpty) {\n+        logWarning(\"Failed to terminate driver process: \" + process +\n+            \". This process will likely be orphaned.\")\n       }\n-    }.start()\n+    }\n   }\n \n-  /** Terminate this driver (or prevent it from ever starting if not yet started) */\n-  private[worker] def kill() {\n-    synchronized {\n-      process.foreach(p => p.destroy())\n-      killed = true\n+  /** Stop this driver, including the process it launched */\n+  private[worker] def kill(): Unit = {\n+    if (workerThread != null) {\n+      // make sure process does not start if being interrupted\n+      this.synchronized {\n+        // the workerThread will kill the child process when interrupted\n+        workerThread.interrupt()\n+        workerThread.join()"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: move to previous line\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:33:32Z",
    "diffHunk": "@@ -78,49 +80,53 @@ private[deploy] class DriverRunner(\n   private[worker] def start() = {\n     new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n-        }\n-        catch {\n-          case e: Exception => finalException = Some(e)\n-        }\n+          // prepare driver jars and launch driver\n+          val exitCode = prepareAndLaunchDriver()\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n+          // set final state depending on if forcibly killed and process exit code\n+          finalState = if (exitCode == 0) {\n+            Some(DriverState.FINISHED)\n+          } else if (killed) {\n+            Some(DriverState.KILLED)\n           } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n+            Some(DriverState.FAILED)\n           }\n+        }\n+        catch {"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: move to previous line\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:33:47Z",
    "diffHunk": "@@ -78,49 +80,53 @@ private[deploy] class DriverRunner(\n   private[worker] def start() = {\n     new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n-        }\n-        catch {\n-          case e: Exception => finalException = Some(e)\n-        }\n+          // prepare driver jars and launch driver\n+          val exitCode = prepareAndLaunchDriver()\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n+          // set final state depending on if forcibly killed and process exit code\n+          finalState = if (exitCode == 0) {\n+            Some(DriverState.FINISHED)\n+          } else if (killed) {\n+            Some(DriverState.KILLED)\n           } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n+            Some(DriverState.FAILED)\n           }\n+        }\n+        catch {\n+          case e: Exception =>\n+            kill()\n+            finalState = Some(DriverState.ERROR)\n+            finalException = Some(e)\n+        }\n+        finally {"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: use long form\n\n```\nif (foo) {\n  do something\n}\n```\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:34:24Z",
    "diffHunk": "@@ -78,49 +80,53 @@ private[deploy] class DriverRunner(\n   private[worker] def start() = {\n     new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n-        }\n-        catch {\n-          case e: Exception => finalException = Some(e)\n-        }\n+          // prepare driver jars and launch driver\n+          val exitCode = prepareAndLaunchDriver()\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n+          // set final state depending on if forcibly killed and process exit code\n+          finalState = if (exitCode == 0) {\n+            Some(DriverState.FINISHED)\n+          } else if (killed) {\n+            Some(DriverState.KILLED)\n           } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n+            Some(DriverState.FAILED)\n           }\n+        }\n+        catch {\n+          case e: Exception =>\n+            kill()\n+            finalState = Some(DriverState.ERROR)\n+            finalException = Some(e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: `.foreach { p =>`\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:34:53Z",
    "diffHunk": "@@ -78,49 +80,53 @@ private[deploy] class DriverRunner(\n   private[worker] def start() = {\n     new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n-        }\n-        catch {\n-          case e: Exception => finalException = Some(e)\n-        }\n+          // prepare driver jars and launch driver\n+          val exitCode = prepareAndLaunchDriver()\n \n-        val state =\n-          if (killed) {\n-            DriverState.KILLED\n-          } else if (finalException.isDefined) {\n-            DriverState.ERROR\n+          // set final state depending on if forcibly killed and process exit code\n+          finalState = if (exitCode == 0) {\n+            Some(DriverState.FINISHED)\n+          } else if (killed) {\n+            Some(DriverState.KILLED)\n           } else {\n-            finalExitCode match {\n-              case Some(0) => DriverState.FINISHED\n-              case _ => DriverState.FAILED\n-            }\n+            Some(DriverState.FAILED)\n           }\n+        }\n+        catch {\n+          case e: Exception =>\n+            kill()\n+            finalState = Some(DriverState.ERROR)\n+            finalException = Some(e)\n+        }\n+        finally {\n+          if (shutdownHook != null) ShutdownHookManager.removeShutdownHook(shutdownHook)\n+        }\n \n-        finalState = Some(state)\n-\n-        worker.send(DriverStateChanged(driverId, state, finalException))\n+        // notify worker of final driver state, possible exception\n+        worker.send(DriverStateChanged(driverId, finalState.get, finalException))\n       }\n     }.start()\n   }\n \n   /** Terminate this driver (or prevent it from ever starting if not yet started) */\n-  private[worker] def kill() {\n+  private[worker] def kill(): Unit = {\n+    logInfo(\"Killing driver process!\")\n+    killed = true\n     synchronized {\n-      process.foreach(_.destroy())\n-      killed = true\n+      process.foreach(p => {"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Does this need to be an option? You call `.get` on it unconditionally.\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:35:52Z",
    "diffHunk": "@@ -53,9 +53,11 @@ private[deploy] class DriverRunner(\n   @volatile private var killed = false\n \n   // Populated once finished\n-  private[worker] var finalState: Option[DriverState] = None\n-  private[worker] var finalException: Option[Exception] = None\n-  private var finalExitCode: Option[Int] = None\n+  @volatile private[worker] var finalState: Option[DriverState] = None",
    "line": 16
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "It's actually called by `WorkerPage.scala` which uses the `Option` to show that the driver is \"running\"\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T23:06:24Z",
    "diffHunk": "@@ -53,9 +53,11 @@ private[deploy] class DriverRunner(\n   @volatile private var killed = false\n \n   // Populated once finished\n-  private[worker] var finalState: Option[DriverState] = None\n-  private[worker] var finalException: Option[Exception] = None\n-  private var finalExitCode: Option[Int] = None\n+  @volatile private[worker] var finalState: Option[DriverState] = None",
    "line": 16
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: it's a little weird for a method that returns an exit code to be called \"Launch\". Maybe `prepareAndRunDriver`?\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:56:04Z",
    "diffHunk": "@@ -78,49 +80,53 @@ private[deploy] class DriverRunner(\n   private[worker] def start() = {\n     new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n-        }\n-        catch {\n-          case e: Exception => finalException = Some(e)\n-        }\n+          // prepare driver jars and launch driver\n+          val exitCode = prepareAndLaunchDriver()"
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "yup, sounds good!\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T23:09:28Z",
    "diffHunk": "@@ -78,49 +80,53 @@ private[deploy] class DriverRunner(\n   private[worker] def start() = {\n     new Thread(\"DriverRunner for \" + driverId) {\n       override def run() {\n+        var shutdownHook: AnyRef = null\n         try {\n-          val driverDir = createWorkingDirectory()\n-          val localJarFilename = downloadUserJar(driverDir)\n-\n-          def substituteVariables(argument: String): String = argument match {\n-            case \"{{WORKER_URL}}\" => workerUrl\n-            case \"{{USER_JAR}}\" => localJarFilename\n-            case other => other\n+          shutdownHook = ShutdownHookManager.addShutdownHook { () =>\n+            logInfo(s\"Worker shutting down, killing driver $driverId\")\n+            kill()\n           }\n \n-          // TODO: If we add ability to submit multiple jars they should also be added here\n-          val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n-            driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n-          launchDriver(builder, driverDir, driverDesc.supervise)\n-        }\n-        catch {\n-          case e: Exception => finalException = Some(e)\n-        }\n+          // prepare driver jars and launch driver\n+          val exitCode = prepareAndLaunchDriver()"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Similar. `runDriver` instead of `launchDriver`?\n",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2016-08-05T22:57:12Z",
    "diffHunk": "@@ -168,7 +173,24 @@ private[deploy] class DriverRunner(\n     localJarFilename\n   }\n \n-  private def launchDriver(builder: ProcessBuilder, baseDir: File, supervise: Boolean) {\n+  private[worker] def prepareAndLaunchDriver(): Int = {\n+    val driverDir = createWorkingDirectory()\n+    val localJarFilename = downloadUserJar(driverDir)\n+\n+    def substituteVariables(argument: String): String = argument match {\n+      case \"{{WORKER_URL}}\" => workerUrl\n+      case \"{{USER_JAR}}\" => localJarFilename\n+      case other => other\n+    }\n+\n+    // TODO: If we add ability to submit multiple jars they should also be added here\n+    val builder = CommandUtils.buildProcessBuilder(driverDesc.command, securityManager,\n+      driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)\n+\n+    launchDriver(builder, driverDir, driverDesc.supervise)\n+  }\n+\n+  private def launchDriver(builder: ProcessBuilder, baseDir: File, supervise: Boolean): Int = {"
  }],
  "prId": 11746
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think we should make this configurable for each application.",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2017-05-25T17:47:04Z",
    "diffHunk": "@@ -53,9 +53,11 @@ private[deploy] class DriverRunner(\n   @volatile private var killed = false\n \n   // Populated once finished\n-  private[worker] var finalState: Option[DriverState] = None\n-  private[worker] var finalException: Option[Exception] = None\n-  private var finalExitCode: Option[Int] = None\n+  @volatile private[worker] var finalState: Option[DriverState] = None\n+  @volatile private[worker] var finalException: Option[Exception] = None\n+\n+  // Timeout to wait for when trying to terminate a driver.\n+  private val DRIVER_TERMINATE_TIMEOUT_MS = 10 * 1000",
    "line": 20
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "@cloud-fan Make sense. However, it requires designing an approach to set configurations for launching driver JVM.",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2017-05-25T17:54:46Z",
    "diffHunk": "@@ -53,9 +53,11 @@ private[deploy] class DriverRunner(\n   @volatile private var killed = false\n \n   // Populated once finished\n-  private[worker] var finalState: Option[DriverState] = None\n-  private[worker] var finalException: Option[Exception] = None\n-  private var finalExitCode: Option[Int] = None\n+  @volatile private[worker] var finalState: Option[DriverState] = None\n+  @volatile private[worker] var finalException: Option[Exception] = None\n+\n+  // Timeout to wait for when trying to terminate a driver.\n+  private val DRIVER_TERMINATE_TIMEOUT_MS = 10 * 1000",
    "line": 20
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "Can't this just be a property added to `SparkConf`?  Btw, this timeout is also hard-coded in `ExecutorRunner`",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2017-05-26T17:24:06Z",
    "diffHunk": "@@ -53,9 +53,11 @@ private[deploy] class DriverRunner(\n   @volatile private var killed = false\n \n   // Populated once finished\n-  private[worker] var finalState: Option[DriverState] = None\n-  private[worker] var finalException: Option[Exception] = None\n-  private var finalExitCode: Option[Int] = None\n+  @volatile private[worker] var finalState: Option[DriverState] = None\n+  @volatile private[worker] var finalException: Option[Exception] = None\n+\n+  // Timeout to wait for when trying to terminate a driver.\n+  private val DRIVER_TERMINATE_TIMEOUT_MS = 10 * 1000",
    "line": 20
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "> Can't this just be a property added to SparkConf?\r\n\r\nIt will be a whole cluster conf.",
    "commit": "6d8f4f6ef7e73fab0a6955a25eee30b0df49d5a6",
    "createdAt": "2017-05-26T17:57:33Z",
    "diffHunk": "@@ -53,9 +53,11 @@ private[deploy] class DriverRunner(\n   @volatile private var killed = false\n \n   // Populated once finished\n-  private[worker] var finalState: Option[DriverState] = None\n-  private[worker] var finalException: Option[Exception] = None\n-  private var finalExitCode: Option[Int] = None\n+  @volatile private[worker] var finalState: Option[DriverState] = None\n+  @volatile private[worker] var finalException: Option[Exception] = None\n+\n+  // Timeout to wait for when trying to terminate a driver.\n+  private val DRIVER_TERMINATE_TIMEOUT_MS = 10 * 1000",
    "line": 20
  }],
  "prId": 11746
}]