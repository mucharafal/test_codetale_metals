[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Indented too far.",
    "commit": "0d6f85e9f1df41ab9e7df518b814ea3da9cd6274",
    "createdAt": "2017-06-08T18:49:06Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import scala.collection.JavaConverters._\n+\n+import com.codahale.metrics.{Counter, Gauge, Metric, MetricFilter, MetricRegistry, Timer}\n+\n+import org.apache.spark.metrics.source.Source\n+import org.apache.spark.util.Clock\n+\n+/**\n+ * An abstract implementation of the metrics [[Source]] trait with some common operations for\n+ * retrieving entries; the `toString()` operation dumps all counters and gauges.\n+ */\n+private[history] abstract class HistoryMetricSource(val prefix: String) extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  /**\n+   * Register a sequence of metrics\n+   * @param metrics sequence of metrics to register\n+   */\n+  def register(metrics: Seq[(String, Metric)]): Unit = {\n+    metrics.foreach { case (name, metric) =>\n+      metricRegistry.register(fullname(name), metric)\n+    }\n+  }\n+\n+  /**\n+   * Create the full name of a metric by prepending the prefix to the name\n+   * @param name short name\n+   * @return the full name to use in registration\n+   */\n+  def fullname(name: String): String = {\n+    MetricRegistry.name(prefix, name)\n+  }\n+\n+  /**\n+   * Dump the counters and gauges.\n+   * @return a string for logging and diagnostics -not for parsing by machines.\n+   */\n+  override def toString: String = {\n+    val sb = new StringBuilder(s\"Metrics for $sourceName:\\n\")\n+    def robustAppend(s : => Long) = {\n+      try {\n+        sb.append(s)\n+      } catch {\n+        case e: Exception =>\n+          sb.append(s\"(exception: $e)\")\n+      }\n+    }\n+\n+    sb.append(\"  Counters\\n\")\n+\n+    metricRegistry.getCounters.asScala.foreach { case (name, counter) =>\n+        sb.append(\"    \").append(name).append(\" = \")"
  }],
  "prId": 17747
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`robustAppend`?",
    "commit": "0d6f85e9f1df41ab9e7df518b814ea3da9cd6274",
    "createdAt": "2017-06-08T18:49:47Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import scala.collection.JavaConverters._\n+\n+import com.codahale.metrics.{Counter, Gauge, Metric, MetricFilter, MetricRegistry, Timer}\n+\n+import org.apache.spark.metrics.source.Source\n+import org.apache.spark.util.Clock\n+\n+/**\n+ * An abstract implementation of the metrics [[Source]] trait with some common operations for\n+ * retrieving entries; the `toString()` operation dumps all counters and gauges.\n+ */\n+private[history] abstract class HistoryMetricSource(val prefix: String) extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  /**\n+   * Register a sequence of metrics\n+   * @param metrics sequence of metrics to register\n+   */\n+  def register(metrics: Seq[(String, Metric)]): Unit = {\n+    metrics.foreach { case (name, metric) =>\n+      metricRegistry.register(fullname(name), metric)\n+    }\n+  }\n+\n+  /**\n+   * Create the full name of a metric by prepending the prefix to the name\n+   * @param name short name\n+   * @return the full name to use in registration\n+   */\n+  def fullname(name: String): String = {\n+    MetricRegistry.name(prefix, name)\n+  }\n+\n+  /**\n+   * Dump the counters and gauges.\n+   * @return a string for logging and diagnostics -not for parsing by machines.\n+   */\n+  override def toString: String = {\n+    val sb = new StringBuilder(s\"Metrics for $sourceName:\\n\")\n+    def robustAppend(s : => Long) = {\n+      try {\n+        sb.append(s)\n+      } catch {\n+        case e: Exception =>\n+          sb.append(s\"(exception: $e)\")\n+      }\n+    }\n+\n+    sb.append(\"  Counters\\n\")\n+\n+    metricRegistry.getCounters.asScala.foreach { case (name, counter) =>\n+        sb.append(\"    \").append(name).append(\" = \")\n+            .append(counter.getCount).append('\\n')\n+    }\n+    sb.append(\"  Gauges\\n\")\n+    metricRegistry.getGauges.asScala.foreach { case (name, gauge) =>\n+      sb.append(\"    \").append(name).append(\" = \")\n+      try {\n+        sb.append(gauge.getValue)"
  }, {
    "author": {
      "login": "steveloughran"
    },
    "body": "yes, I'm trying to work why I *didn't* use that method given it was there. Widened it to a generic type and used. It's probably overkill, but as anything can be a Gauge, its possible that they will NPE or similar, and that just ruins logging & debugging.",
    "commit": "0d6f85e9f1df41ab9e7df518b814ea3da9cd6274",
    "createdAt": "2017-06-15T16:59:11Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import scala.collection.JavaConverters._\n+\n+import com.codahale.metrics.{Counter, Gauge, Metric, MetricFilter, MetricRegistry, Timer}\n+\n+import org.apache.spark.metrics.source.Source\n+import org.apache.spark.util.Clock\n+\n+/**\n+ * An abstract implementation of the metrics [[Source]] trait with some common operations for\n+ * retrieving entries; the `toString()` operation dumps all counters and gauges.\n+ */\n+private[history] abstract class HistoryMetricSource(val prefix: String) extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  /**\n+   * Register a sequence of metrics\n+   * @param metrics sequence of metrics to register\n+   */\n+  def register(metrics: Seq[(String, Metric)]): Unit = {\n+    metrics.foreach { case (name, metric) =>\n+      metricRegistry.register(fullname(name), metric)\n+    }\n+  }\n+\n+  /**\n+   * Create the full name of a metric by prepending the prefix to the name\n+   * @param name short name\n+   * @return the full name to use in registration\n+   */\n+  def fullname(name: String): String = {\n+    MetricRegistry.name(prefix, name)\n+  }\n+\n+  /**\n+   * Dump the counters and gauges.\n+   * @return a string for logging and diagnostics -not for parsing by machines.\n+   */\n+  override def toString: String = {\n+    val sb = new StringBuilder(s\"Metrics for $sourceName:\\n\")\n+    def robustAppend(s : => Long) = {\n+      try {\n+        sb.append(s)\n+      } catch {\n+        case e: Exception =>\n+          sb.append(s\"(exception: $e)\")\n+      }\n+    }\n+\n+    sb.append(\"  Counters\\n\")\n+\n+    metricRegistry.getCounters.asScala.foreach { case (name, counter) =>\n+        sb.append(\"    \").append(name).append(\" = \")\n+            .append(counter.getCount).append('\\n')\n+    }\n+    sb.append(\"  Gauges\\n\")\n+    metricRegistry.getGauges.asScala.foreach { case (name, gauge) =>\n+      sb.append(\"    \").append(name).append(\" = \")\n+      try {\n+        sb.append(gauge.getValue)"
  }],
  "prId": 17747
}]