[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Do you need `askAndReplyExecutionContext` anymore? It seems now all the heavy lifting is being done in the RPC thread pool, and the `andThen` code could just use `ThreadUtils.sameThreadExecutionContext` since it doesn't do much.\n",
    "commit": "0772e8195443566d37c9837798ef075eaa79c66b",
    "createdAt": "2016-08-26T00:20:09Z",
    "diffHunk": "@@ -220,19 +225,13 @@ private[spark] class StandaloneAppClient(\n         endpointRef: RpcEndpointRef,\n         context: RpcCallContext,\n         msg: T): Unit = {\n-      // Create a thread to ask a message and reply with the result.  Allow thread to be\n+      // Ask a message and create a thread to reply with the result.  Allow thread to be\n       // interrupted during shutdown, otherwise context must be notified of NonFatal errors.\n-      askAndReplyThreadPool.execute(new Runnable {\n-        override def run(): Unit = {\n-          try {\n-            context.reply(endpointRef.askWithRetry[Boolean](msg))\n-          } catch {\n-            case ie: InterruptedException => // Cancelled\n-            case NonFatal(t) =>\n-              context.sendFailure(t)\n-          }\n-        }\n-      })\n+      endpointRef.ask[Boolean](msg).andThen {\n+        case Success(b) => context.reply(b)\n+        case Failure(ie: InterruptedException) => // Cancelled\n+        case Failure(NonFatal(t)) => context.sendFailure(t)\n+      }(askAndReplyExecutionContext)"
  }],
  "prId": 14710
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: unused import\n",
    "commit": "0772e8195443566d37c9837798ef075eaa79c66b",
    "createdAt": "2016-08-30T23:35:53Z",
    "diffHunk": "@@ -21,6 +21,8 @@ import java.util.concurrent._\n import java.util.concurrent.{Future => JFuture, ScheduledFuture => JScheduledFuture}\n import java.util.concurrent.atomic.{AtomicBoolean, AtomicReference}\n \n+import scala.concurrent.{ExecutionContext, Future}"
  }],
  "prId": 14710
}]