[{
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "I'd disable the scalastyle here so that it doesn't produce build errors. In this case I think it's fine to violate the line limit:\nhttp://www.scalastyle.org/configuration.html\n\nalso there is a different way to do multline strings in scala - but up to you...\nhttp://downgra.de/2010/09/14/multi-line_strings_with_scala/\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T03:20:35Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null\n+\n+  loadEnvVars()\n+  parseArgs(args.toList)\n+\n+  def loadEnvVars() {\n+    master = System.getenv(\"MASTER\")\n+    deployMode = System.getenv(\"DEPLOY_MODE\")\n+  }\n+\n+  def parseArgs(args: List[String]) {\n+    primaryResource = args(0)\n+    parseOpts(args.tail)\n+  }\n+\n+  def parseOpts(opts: List[String]): Unit = opts match {\n+    case (\"--name\") :: value :: tail =>\n+      name = value\n+      parseOpts(tail)\n+\n+    case (\"--master\") :: value :: tail =>\n+      master = value\n+      parseOpts(tail)\n+\n+    case (\"--class\") :: value :: tail =>\n+      mainClass = value\n+      parseOpts(tail)\n+\n+    case (\"--deploy-mode\") :: value :: tail =>\n+      if (value != \"client\" && value != \"cluster\") {\n+        System.err.println(\"--deploy-mode must be either \\\"client\\\" or \\\"cluster\\\"\")\n+        System.exit(1)\n+      }\n+      deployMode = value\n+      parseOpts(tail)\n+\n+    case (\"--num-executors\") :: value :: tail =>\n+      numExecutors = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-cores\") :: value :: tail =>\n+      executorCores = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-memory\") :: value :: tail =>\n+      executorMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--driver-memory\") :: value :: tail =>\n+      driverMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--supervise\") :: tail =>\n+      supervise = true\n+      parseOpts(tail)\n+\n+    case (\"--queue\") :: value :: tail =>\n+      queue = value\n+      parseOpts(tail)\n+\n+    case (\"--files\") :: value :: tail =>\n+      files = value\n+      parseOpts(tail)\n+\n+    case (\"--archives\") :: value :: tail =>\n+      archives = value\n+      parseOpts(tail)\n+\n+    case (\"--arg\") :: value :: tail =>\n+      childArgs += value\n+      parseOpts(tail)\n+\n+    case (\"--more-jars\") :: value :: tail =>\n+      moreJars = value\n+      parseOpts(tail)\n+\n+    case (\"--client-classpath\") :: value :: tail =>\n+      clientClasspath = value\n+      parseOpts(tail)\n+\n+    case (\"--help\" | \"-h\") :: tail =>\n+      printUsageAndExit(0)\n+\n+    case Nil =>\n+\n+    case _ =>\n+      printUsageAndExit(1, opts)\n+  }\n+\n+  def printUsageAndExit(exitCode: Int, unknownParam: Any = null) {\n+    if (unknownParam != null) {\n+      System.err.println(\"Unknown/unsupported param \" + unknownParam)\n+    }\n+    System.err.println(\n+      \"Usage: spark-app <primary binary> [options] \\n\" +\n+        \"Options:\\n\" +\n+        \"  --master MASTER_URL        spark://host:port, mesos://host:port, yarn, or local\\n\" +"
  }],
  "prId": 86
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Hey @sryza a lot these are YARN-only so maybe it makes sense to have a small header: \"YARN only\" then list them all under that. Right now a few places say \"Only works with YARN\" but it doesn't say this everywhere. A header might be simpler.\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T03:38:40Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null\n+\n+  loadEnvVars()\n+  parseArgs(args.toList)\n+\n+  def loadEnvVars() {\n+    master = System.getenv(\"MASTER\")\n+    deployMode = System.getenv(\"DEPLOY_MODE\")\n+  }\n+\n+  def parseArgs(args: List[String]) {\n+    primaryResource = args(0)\n+    parseOpts(args.tail)\n+  }\n+\n+  def parseOpts(opts: List[String]): Unit = opts match {\n+    case (\"--name\") :: value :: tail =>\n+      name = value\n+      parseOpts(tail)\n+\n+    case (\"--master\") :: value :: tail =>\n+      master = value\n+      parseOpts(tail)\n+\n+    case (\"--class\") :: value :: tail =>\n+      mainClass = value\n+      parseOpts(tail)\n+\n+    case (\"--deploy-mode\") :: value :: tail =>\n+      if (value != \"client\" && value != \"cluster\") {\n+        System.err.println(\"--deploy-mode must be either \\\"client\\\" or \\\"cluster\\\"\")\n+        System.exit(1)\n+      }\n+      deployMode = value\n+      parseOpts(tail)\n+\n+    case (\"--num-executors\") :: value :: tail =>\n+      numExecutors = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-cores\") :: value :: tail =>\n+      executorCores = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-memory\") :: value :: tail =>\n+      executorMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--driver-memory\") :: value :: tail =>\n+      driverMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--supervise\") :: tail =>\n+      supervise = true\n+      parseOpts(tail)\n+\n+    case (\"--queue\") :: value :: tail =>\n+      queue = value\n+      parseOpts(tail)\n+\n+    case (\"--files\") :: value :: tail =>\n+      files = value\n+      parseOpts(tail)\n+\n+    case (\"--archives\") :: value :: tail =>\n+      archives = value\n+      parseOpts(tail)\n+\n+    case (\"--arg\") :: value :: tail =>\n+      childArgs += value\n+      parseOpts(tail)\n+\n+    case (\"--more-jars\") :: value :: tail =>\n+      moreJars = value\n+      parseOpts(tail)\n+\n+    case (\"--client-classpath\") :: value :: tail =>\n+      clientClasspath = value\n+      parseOpts(tail)\n+\n+    case (\"--help\" | \"-h\") :: tail =>\n+      printUsageAndExit(0)\n+\n+    case Nil =>\n+\n+    case _ =>\n+      printUsageAndExit(1, opts)\n+  }\n+\n+  def printUsageAndExit(exitCode: Int, unknownParam: Any = null) {\n+    if (unknownParam != null) {\n+      System.err.println(\"Unknown/unsupported param \" + unknownParam)\n+    }\n+    System.err.println(\n+      \"Usage: spark-app <primary binary> [options] \\n\" +\n+        \"Options:\\n\" +\n+        \"  --master MASTER_URL        spark://host:port, mesos://host:port, yarn, or local\\n\" +\n+        \"  --deploy-mode DEPLOY_MODE  Mode to deploy the app in, either \\\"client\\\" or \\\"cluster\\\"\\n\" +\n+        \"  --class CLASS_NAME         Name of your application's main class (required for Java apps)\\n\" +\n+        \"  --arg ARG                  Argument to be passed to your application's main class.\\n\" +\n+        \"                             Multiple invocations are possible, each will be passed, in order.\\n\" +\n+        \"  --num-executors NUM        Number of executors to start (Default: 2)\\n\" +\n+        \"  --executor-cores NUM       Number of cores per executor (Default: 1)\\n\" +\n+        \"  --executor-memory MEM      Memory per executor (e.g. 1000M, 2G) (Default: 1G)\\n\" +\n+        \"  --driver-memory MEM        Memory for driver (e.g. 1000M, 2G) (Default: 512 Mb)\\n\" +\n+        \"  --name NAME                The name of your application (Default: Spark)\\n\" +"
  }],
  "prId": 86
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "This doesn't seem fully fleshed out yet, but is the idea here to launch a new JVM when running in client mode? One reason that might be necessary is that we'd want to set the amount of memory used by the driver (which btw will require getting something like https://github.com/apache/incubator-spark/pull/615/ merged). But for the classpath I think we might be able to merge (https://github.com/apache/incubator-spark/pull/299) and then if the user calls addJar it will be added to the driver program as well.\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T04:06:45Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null\n+\n+  loadEnvVars()\n+  parseArgs(args.toList)\n+\n+  def loadEnvVars() {\n+    master = System.getenv(\"MASTER\")\n+    deployMode = System.getenv(\"DEPLOY_MODE\")\n+  }\n+\n+  def parseArgs(args: List[String]) {\n+    primaryResource = args(0)\n+    parseOpts(args.tail)\n+  }\n+\n+  def parseOpts(opts: List[String]): Unit = opts match {\n+    case (\"--name\") :: value :: tail =>\n+      name = value\n+      parseOpts(tail)\n+\n+    case (\"--master\") :: value :: tail =>\n+      master = value\n+      parseOpts(tail)\n+\n+    case (\"--class\") :: value :: tail =>\n+      mainClass = value\n+      parseOpts(tail)\n+\n+    case (\"--deploy-mode\") :: value :: tail =>\n+      if (value != \"client\" && value != \"cluster\") {\n+        System.err.println(\"--deploy-mode must be either \\\"client\\\" or \\\"cluster\\\"\")\n+        System.exit(1)\n+      }\n+      deployMode = value\n+      parseOpts(tail)\n+\n+    case (\"--num-executors\") :: value :: tail =>\n+      numExecutors = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-cores\") :: value :: tail =>\n+      executorCores = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-memory\") :: value :: tail =>\n+      executorMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--driver-memory\") :: value :: tail =>\n+      driverMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--supervise\") :: tail =>\n+      supervise = true\n+      parseOpts(tail)\n+\n+    case (\"--queue\") :: value :: tail =>\n+      queue = value\n+      parseOpts(tail)\n+\n+    case (\"--files\") :: value :: tail =>\n+      files = value\n+      parseOpts(tail)\n+\n+    case (\"--archives\") :: value :: tail =>\n+      archives = value\n+      parseOpts(tail)\n+\n+    case (\"--arg\") :: value :: tail =>\n+      childArgs += value\n+      parseOpts(tail)\n+\n+    case (\"--more-jars\") :: value :: tail =>\n+      moreJars = value\n+      parseOpts(tail)\n+\n+    case (\"--client-classpath\") :: value :: tail =>\n+      clientClasspath = value\n+      parseOpts(tail)\n+\n+    case (\"--help\" | \"-h\") :: tail =>\n+      printUsageAndExit(0)\n+\n+    case Nil =>\n+\n+    case _ =>\n+      printUsageAndExit(1, opts)\n+  }\n+\n+  def printUsageAndExit(exitCode: Int, unknownParam: Any = null) {\n+    if (unknownParam != null) {\n+      System.err.println(\"Unknown/unsupported param \" + unknownParam)\n+    }\n+    System.err.println(\n+      \"Usage: spark-app <primary binary> [options] \\n\" +\n+        \"Options:\\n\" +\n+        \"  --master MASTER_URL        spark://host:port, mesos://host:port, yarn, or local\\n\" +\n+        \"  --deploy-mode DEPLOY_MODE  Mode to deploy the app in, either \\\"client\\\" or \\\"cluster\\\"\\n\" +\n+        \"  --class CLASS_NAME         Name of your application's main class (required for Java apps)\\n\" +\n+        \"  --arg ARG                  Argument to be passed to your application's main class.\\n\" +\n+        \"                             Multiple invocations are possible, each will be passed, in order.\\n\" +\n+        \"  --num-executors NUM        Number of executors to start (Default: 2)\\n\" +\n+        \"  --executor-cores NUM       Number of cores per executor (Default: 1)\\n\" +\n+        \"  --executor-memory MEM      Memory per executor (e.g. 1000M, 2G) (Default: 1G)\\n\" +\n+        \"  --driver-memory MEM        Memory for driver (e.g. 1000M, 2G) (Default: 512 Mb)\\n\" +\n+        \"  --name NAME                The name of your application (Default: Spark)\\n\" +\n+        \"  --queue QUEUE              The YARN queue to use for allocation requests (Default: 'default')\\n\" +\n+        \"  --more-jars jars           For \\\"cluster\\\" deploy mode, comma separated list of local jars\\n\" +\n+        \"                             that you want SparkContext.addJar to work with. Only works with YARN.\\n\" +\n+        \"  --files files              Comma separated list of files to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --archives archives        Comma separated list of archives to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --client-classpath ENTRIES Entries to be placed on the client JVM's classpath\""
  }, {
    "author": {
      "login": "sryza"
    },
    "body": "Right.  The reasons I realized we probably need a new JVM are for the driver memory and for setting environment variables (surprisingly, there's no System.setenv or equivalent).\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T04:33:30Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null\n+\n+  loadEnvVars()\n+  parseArgs(args.toList)\n+\n+  def loadEnvVars() {\n+    master = System.getenv(\"MASTER\")\n+    deployMode = System.getenv(\"DEPLOY_MODE\")\n+  }\n+\n+  def parseArgs(args: List[String]) {\n+    primaryResource = args(0)\n+    parseOpts(args.tail)\n+  }\n+\n+  def parseOpts(opts: List[String]): Unit = opts match {\n+    case (\"--name\") :: value :: tail =>\n+      name = value\n+      parseOpts(tail)\n+\n+    case (\"--master\") :: value :: tail =>\n+      master = value\n+      parseOpts(tail)\n+\n+    case (\"--class\") :: value :: tail =>\n+      mainClass = value\n+      parseOpts(tail)\n+\n+    case (\"--deploy-mode\") :: value :: tail =>\n+      if (value != \"client\" && value != \"cluster\") {\n+        System.err.println(\"--deploy-mode must be either \\\"client\\\" or \\\"cluster\\\"\")\n+        System.exit(1)\n+      }\n+      deployMode = value\n+      parseOpts(tail)\n+\n+    case (\"--num-executors\") :: value :: tail =>\n+      numExecutors = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-cores\") :: value :: tail =>\n+      executorCores = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-memory\") :: value :: tail =>\n+      executorMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--driver-memory\") :: value :: tail =>\n+      driverMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--supervise\") :: tail =>\n+      supervise = true\n+      parseOpts(tail)\n+\n+    case (\"--queue\") :: value :: tail =>\n+      queue = value\n+      parseOpts(tail)\n+\n+    case (\"--files\") :: value :: tail =>\n+      files = value\n+      parseOpts(tail)\n+\n+    case (\"--archives\") :: value :: tail =>\n+      archives = value\n+      parseOpts(tail)\n+\n+    case (\"--arg\") :: value :: tail =>\n+      childArgs += value\n+      parseOpts(tail)\n+\n+    case (\"--more-jars\") :: value :: tail =>\n+      moreJars = value\n+      parseOpts(tail)\n+\n+    case (\"--client-classpath\") :: value :: tail =>\n+      clientClasspath = value\n+      parseOpts(tail)\n+\n+    case (\"--help\" | \"-h\") :: tail =>\n+      printUsageAndExit(0)\n+\n+    case Nil =>\n+\n+    case _ =>\n+      printUsageAndExit(1, opts)\n+  }\n+\n+  def printUsageAndExit(exitCode: Int, unknownParam: Any = null) {\n+    if (unknownParam != null) {\n+      System.err.println(\"Unknown/unsupported param \" + unknownParam)\n+    }\n+    System.err.println(\n+      \"Usage: spark-app <primary binary> [options] \\n\" +\n+        \"Options:\\n\" +\n+        \"  --master MASTER_URL        spark://host:port, mesos://host:port, yarn, or local\\n\" +\n+        \"  --deploy-mode DEPLOY_MODE  Mode to deploy the app in, either \\\"client\\\" or \\\"cluster\\\"\\n\" +\n+        \"  --class CLASS_NAME         Name of your application's main class (required for Java apps)\\n\" +\n+        \"  --arg ARG                  Argument to be passed to your application's main class.\\n\" +\n+        \"                             Multiple invocations are possible, each will be passed, in order.\\n\" +\n+        \"  --num-executors NUM        Number of executors to start (Default: 2)\\n\" +\n+        \"  --executor-cores NUM       Number of cores per executor (Default: 1)\\n\" +\n+        \"  --executor-memory MEM      Memory per executor (e.g. 1000M, 2G) (Default: 1G)\\n\" +\n+        \"  --driver-memory MEM        Memory for driver (e.g. 1000M, 2G) (Default: 512 Mb)\\n\" +\n+        \"  --name NAME                The name of your application (Default: Spark)\\n\" +\n+        \"  --queue QUEUE              The YARN queue to use for allocation requests (Default: 'default')\\n\" +\n+        \"  --more-jars jars           For \\\"cluster\\\" deploy mode, comma separated list of local jars\\n\" +\n+        \"                             that you want SparkContext.addJar to work with. Only works with YARN.\\n\" +\n+        \"  --files files              Comma separated list of files to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --archives archives        Comma separated list of archives to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --client-classpath ENTRIES Entries to be placed on the client JVM's classpath\""
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "I think they might be immutable once you start the JVM.\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T04:48:42Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null\n+\n+  loadEnvVars()\n+  parseArgs(args.toList)\n+\n+  def loadEnvVars() {\n+    master = System.getenv(\"MASTER\")\n+    deployMode = System.getenv(\"DEPLOY_MODE\")\n+  }\n+\n+  def parseArgs(args: List[String]) {\n+    primaryResource = args(0)\n+    parseOpts(args.tail)\n+  }\n+\n+  def parseOpts(opts: List[String]): Unit = opts match {\n+    case (\"--name\") :: value :: tail =>\n+      name = value\n+      parseOpts(tail)\n+\n+    case (\"--master\") :: value :: tail =>\n+      master = value\n+      parseOpts(tail)\n+\n+    case (\"--class\") :: value :: tail =>\n+      mainClass = value\n+      parseOpts(tail)\n+\n+    case (\"--deploy-mode\") :: value :: tail =>\n+      if (value != \"client\" && value != \"cluster\") {\n+        System.err.println(\"--deploy-mode must be either \\\"client\\\" or \\\"cluster\\\"\")\n+        System.exit(1)\n+      }\n+      deployMode = value\n+      parseOpts(tail)\n+\n+    case (\"--num-executors\") :: value :: tail =>\n+      numExecutors = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-cores\") :: value :: tail =>\n+      executorCores = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-memory\") :: value :: tail =>\n+      executorMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--driver-memory\") :: value :: tail =>\n+      driverMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--supervise\") :: tail =>\n+      supervise = true\n+      parseOpts(tail)\n+\n+    case (\"--queue\") :: value :: tail =>\n+      queue = value\n+      parseOpts(tail)\n+\n+    case (\"--files\") :: value :: tail =>\n+      files = value\n+      parseOpts(tail)\n+\n+    case (\"--archives\") :: value :: tail =>\n+      archives = value\n+      parseOpts(tail)\n+\n+    case (\"--arg\") :: value :: tail =>\n+      childArgs += value\n+      parseOpts(tail)\n+\n+    case (\"--more-jars\") :: value :: tail =>\n+      moreJars = value\n+      parseOpts(tail)\n+\n+    case (\"--client-classpath\") :: value :: tail =>\n+      clientClasspath = value\n+      parseOpts(tail)\n+\n+    case (\"--help\" | \"-h\") :: tail =>\n+      printUsageAndExit(0)\n+\n+    case Nil =>\n+\n+    case _ =>\n+      printUsageAndExit(1, opts)\n+  }\n+\n+  def printUsageAndExit(exitCode: Int, unknownParam: Any = null) {\n+    if (unknownParam != null) {\n+      System.err.println(\"Unknown/unsupported param \" + unknownParam)\n+    }\n+    System.err.println(\n+      \"Usage: spark-app <primary binary> [options] \\n\" +\n+        \"Options:\\n\" +\n+        \"  --master MASTER_URL        spark://host:port, mesos://host:port, yarn, or local\\n\" +\n+        \"  --deploy-mode DEPLOY_MODE  Mode to deploy the app in, either \\\"client\\\" or \\\"cluster\\\"\\n\" +\n+        \"  --class CLASS_NAME         Name of your application's main class (required for Java apps)\\n\" +\n+        \"  --arg ARG                  Argument to be passed to your application's main class.\\n\" +\n+        \"                             Multiple invocations are possible, each will be passed, in order.\\n\" +\n+        \"  --num-executors NUM        Number of executors to start (Default: 2)\\n\" +\n+        \"  --executor-cores NUM       Number of cores per executor (Default: 1)\\n\" +\n+        \"  --executor-memory MEM      Memory per executor (e.g. 1000M, 2G) (Default: 1G)\\n\" +\n+        \"  --driver-memory MEM        Memory for driver (e.g. 1000M, 2G) (Default: 512 Mb)\\n\" +\n+        \"  --name NAME                The name of your application (Default: Spark)\\n\" +\n+        \"  --queue QUEUE              The YARN queue to use for allocation requests (Default: 'default')\\n\" +\n+        \"  --more-jars jars           For \\\"cluster\\\" deploy mode, comma separated list of local jars\\n\" +\n+        \"                             that you want SparkContext.addJar to work with. Only works with YARN.\\n\" +\n+        \"  --files files              Comma separated list of files to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --archives archives        Comma separated list of archives to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --client-classpath ENTRIES Entries to be placed on the client JVM's classpath\""
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "Instead of environment vars, couldn't we do everything through system properties? SparkConf already initializes from system properties by default, and any environment vars that we might need to set could be given a system property to do the same thing (some YARN settings might currently only use env vars). For setting env vars on the workers it's possible to do it in all of the cluster managers that Spark supports.\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T06:20:15Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null\n+\n+  loadEnvVars()\n+  parseArgs(args.toList)\n+\n+  def loadEnvVars() {\n+    master = System.getenv(\"MASTER\")\n+    deployMode = System.getenv(\"DEPLOY_MODE\")\n+  }\n+\n+  def parseArgs(args: List[String]) {\n+    primaryResource = args(0)\n+    parseOpts(args.tail)\n+  }\n+\n+  def parseOpts(opts: List[String]): Unit = opts match {\n+    case (\"--name\") :: value :: tail =>\n+      name = value\n+      parseOpts(tail)\n+\n+    case (\"--master\") :: value :: tail =>\n+      master = value\n+      parseOpts(tail)\n+\n+    case (\"--class\") :: value :: tail =>\n+      mainClass = value\n+      parseOpts(tail)\n+\n+    case (\"--deploy-mode\") :: value :: tail =>\n+      if (value != \"client\" && value != \"cluster\") {\n+        System.err.println(\"--deploy-mode must be either \\\"client\\\" or \\\"cluster\\\"\")\n+        System.exit(1)\n+      }\n+      deployMode = value\n+      parseOpts(tail)\n+\n+    case (\"--num-executors\") :: value :: tail =>\n+      numExecutors = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-cores\") :: value :: tail =>\n+      executorCores = value\n+      parseOpts(tail)\n+\n+    case (\"--executor-memory\") :: value :: tail =>\n+      executorMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--driver-memory\") :: value :: tail =>\n+      driverMemory = value\n+      parseOpts(tail)\n+\n+    case (\"--supervise\") :: tail =>\n+      supervise = true\n+      parseOpts(tail)\n+\n+    case (\"--queue\") :: value :: tail =>\n+      queue = value\n+      parseOpts(tail)\n+\n+    case (\"--files\") :: value :: tail =>\n+      files = value\n+      parseOpts(tail)\n+\n+    case (\"--archives\") :: value :: tail =>\n+      archives = value\n+      parseOpts(tail)\n+\n+    case (\"--arg\") :: value :: tail =>\n+      childArgs += value\n+      parseOpts(tail)\n+\n+    case (\"--more-jars\") :: value :: tail =>\n+      moreJars = value\n+      parseOpts(tail)\n+\n+    case (\"--client-classpath\") :: value :: tail =>\n+      clientClasspath = value\n+      parseOpts(tail)\n+\n+    case (\"--help\" | \"-h\") :: tail =>\n+      printUsageAndExit(0)\n+\n+    case Nil =>\n+\n+    case _ =>\n+      printUsageAndExit(1, opts)\n+  }\n+\n+  def printUsageAndExit(exitCode: Int, unknownParam: Any = null) {\n+    if (unknownParam != null) {\n+      System.err.println(\"Unknown/unsupported param \" + unknownParam)\n+    }\n+    System.err.println(\n+      \"Usage: spark-app <primary binary> [options] \\n\" +\n+        \"Options:\\n\" +\n+        \"  --master MASTER_URL        spark://host:port, mesos://host:port, yarn, or local\\n\" +\n+        \"  --deploy-mode DEPLOY_MODE  Mode to deploy the app in, either \\\"client\\\" or \\\"cluster\\\"\\n\" +\n+        \"  --class CLASS_NAME         Name of your application's main class (required for Java apps)\\n\" +\n+        \"  --arg ARG                  Argument to be passed to your application's main class.\\n\" +\n+        \"                             Multiple invocations are possible, each will be passed, in order.\\n\" +\n+        \"  --num-executors NUM        Number of executors to start (Default: 2)\\n\" +\n+        \"  --executor-cores NUM       Number of cores per executor (Default: 1)\\n\" +\n+        \"  --executor-memory MEM      Memory per executor (e.g. 1000M, 2G) (Default: 1G)\\n\" +\n+        \"  --driver-memory MEM        Memory for driver (e.g. 1000M, 2G) (Default: 512 Mb)\\n\" +\n+        \"  --name NAME                The name of your application (Default: Spark)\\n\" +\n+        \"  --queue QUEUE              The YARN queue to use for allocation requests (Default: 'default')\\n\" +\n+        \"  --more-jars jars           For \\\"cluster\\\" deploy mode, comma separated list of local jars\\n\" +\n+        \"                             that you want SparkContext.addJar to work with. Only works with YARN.\\n\" +\n+        \"  --files files              Comma separated list of files to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --archives archives        Comma separated list of archives to be placed next to all executors.\\n\" +\n+        \"                             Only works with YARN.\\n\" +\n+        \"  --client-classpath ENTRIES Entries to be placed on the client JVM's classpath\""
  }],
  "prId": 86
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "clientClasspath is not used ?\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T06:15:07Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "Also, what is the expectation - this will be uploaded by users to dfs or the client would do it for them via distributed cache or dfs when running in cluster ?\nCurrently it is a bit of a mess.\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T06:16:23Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null"
  }, {
    "author": {
      "login": "sryza"
    },
    "body": "My bad; took this property out entirely.\n",
    "commit": "d428d857971866aa5c8f75970a9655071bf016fd",
    "createdAt": "2014-03-06T20:59:09Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[spark] class SparkAppArguments(args: Array[String]) {\n+  var master: String = null\n+  var deployMode: String = null\n+  var executorMemory: String = null\n+  var executorCores: String = null\n+  var driverMemory: String = null\n+  var supervise: Boolean = false\n+  var queue: String = null\n+  var numExecutors: String = null\n+  var files: String = null\n+  var archives: String = null\n+  var mainClass: String = null\n+  var primaryResource: String = null\n+  var name: String = null\n+  var childArgs: ArrayBuffer[String] = new ArrayBuffer[String]()\n+  var moreJars: String = null\n+  var clientClasspath: String = null"
  }],
  "prId": 86
}]