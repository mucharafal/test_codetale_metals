[{
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "@vanzin , do we need to remove all the system properties after `mainMethod` is finished?",
    "commit": "191513542da1c11f66dd96cca472babe68b4f630",
    "createdAt": "2017-10-23T02:02:17Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import java.lang.reflect.Modifier\n+\n+import org.apache.spark.SparkConf\n+\n+/**\n+ * Entry point for a Spark application. Implementations must provide a no-argument constructor.\n+ */\n+private[spark] trait SparkApplication {\n+\n+  def start(args: Array[String], conf: SparkConf): Unit\n+\n+}\n+\n+/**\n+ * Implementation of SparkApplication that wraps a standard Java class with a \"main\" method.\n+ *\n+ * Configuration is propagated to the application via system properties, so running multiple\n+ * of these in the same JVM may lead to undefined behavior due to configuration leaks.\n+ */\n+private[deploy] class JavaMainApplication(klass: Class[_]) extends SparkApplication {\n+\n+  override def start(args: Array[String], conf: SparkConf): Unit = {\n+    val mainMethod = klass.getMethod(\"main\", new Array[String](0).getClass)\n+    if (!Modifier.isStatic(mainMethod.getModifiers)) {\n+      throw new IllegalStateException(\"The main method in the given main class must be static\")\n+    }\n+\n+    val sysProps = conf.getAll.toMap\n+    sysProps.foreach { case (k, v) =>\n+      sys.props(k) = v\n+    }\n+\n+    mainMethod.invoke(null, args)\n+  }",
    "line": 53
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "That's dangerous, because you don't know what the user code is doing. What if it spawns a thread and that separate thread creates the `SparkContext`? Then you may be clearing system properties before the user app had the chance to read them.",
    "commit": "191513542da1c11f66dd96cca472babe68b4f630",
    "createdAt": "2017-10-23T17:08:29Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import java.lang.reflect.Modifier\n+\n+import org.apache.spark.SparkConf\n+\n+/**\n+ * Entry point for a Spark application. Implementations must provide a no-argument constructor.\n+ */\n+private[spark] trait SparkApplication {\n+\n+  def start(args: Array[String], conf: SparkConf): Unit\n+\n+}\n+\n+/**\n+ * Implementation of SparkApplication that wraps a standard Java class with a \"main\" method.\n+ *\n+ * Configuration is propagated to the application via system properties, so running multiple\n+ * of these in the same JVM may lead to undefined behavior due to configuration leaks.\n+ */\n+private[deploy] class JavaMainApplication(klass: Class[_]) extends SparkApplication {\n+\n+  override def start(args: Array[String], conf: SparkConf): Unit = {\n+    val mainMethod = klass.getMethod(\"main\", new Array[String](0).getClass)\n+    if (!Modifier.isStatic(mainMethod.getModifiers)) {\n+      throw new IllegalStateException(\"The main method in the given main class must be static\")\n+    }\n+\n+    val sysProps = conf.getAll.toMap\n+    sysProps.foreach { case (k, v) =>\n+      sys.props(k) = v\n+    }\n+\n+    mainMethod.invoke(null, args)\n+  }",
    "line": 53
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "But based on your comment \"allow multiple applications to be started in the same JVM\", will this system properties contaminate follow-up applications? Sorry if I misunderstood your scenario.",
    "commit": "191513542da1c11f66dd96cca472babe68b4f630",
    "createdAt": "2017-10-25T01:15:14Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import java.lang.reflect.Modifier\n+\n+import org.apache.spark.SparkConf\n+\n+/**\n+ * Entry point for a Spark application. Implementations must provide a no-argument constructor.\n+ */\n+private[spark] trait SparkApplication {\n+\n+  def start(args: Array[String], conf: SparkConf): Unit\n+\n+}\n+\n+/**\n+ * Implementation of SparkApplication that wraps a standard Java class with a \"main\" method.\n+ *\n+ * Configuration is propagated to the application via system properties, so running multiple\n+ * of these in the same JVM may lead to undefined behavior due to configuration leaks.\n+ */\n+private[deploy] class JavaMainApplication(klass: Class[_]) extends SparkApplication {\n+\n+  override def start(args: Array[String], conf: SparkConf): Unit = {\n+    val mainMethod = klass.getMethod(\"main\", new Array[String](0).getClass)\n+    if (!Modifier.isStatic(mainMethod.getModifiers)) {\n+      throw new IllegalStateException(\"The main method in the given main class must be static\")\n+    }\n+\n+    val sysProps = conf.getAll.toMap\n+    sysProps.foreach { case (k, v) =>\n+      sys.props(k) = v\n+    }\n+\n+    mainMethod.invoke(null, args)\n+  }",
    "line": 53
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Yes, and there's not much we can do in that case. The main use case will be to make cluster mode applications do the right thing first, and warn about starting in-process client mode applications through the launcher API.\r\n\r\nIf you have a better solution I'm all ears.",
    "commit": "191513542da1c11f66dd96cca472babe68b4f630",
    "createdAt": "2017-10-25T01:19:36Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import java.lang.reflect.Modifier\n+\n+import org.apache.spark.SparkConf\n+\n+/**\n+ * Entry point for a Spark application. Implementations must provide a no-argument constructor.\n+ */\n+private[spark] trait SparkApplication {\n+\n+  def start(args: Array[String], conf: SparkConf): Unit\n+\n+}\n+\n+/**\n+ * Implementation of SparkApplication that wraps a standard Java class with a \"main\" method.\n+ *\n+ * Configuration is propagated to the application via system properties, so running multiple\n+ * of these in the same JVM may lead to undefined behavior due to configuration leaks.\n+ */\n+private[deploy] class JavaMainApplication(klass: Class[_]) extends SparkApplication {\n+\n+  override def start(args: Array[String], conf: SparkConf): Unit = {\n+    val mainMethod = klass.getMethod(\"main\", new Array[String](0).getClass)\n+    if (!Modifier.isStatic(mainMethod.getModifiers)) {\n+      throw new IllegalStateException(\"The main method in the given main class must be static\")\n+    }\n+\n+    val sysProps = conf.getAll.toMap\n+    sysProps.foreach { case (k, v) =>\n+      sys.props(k) = v\n+    }\n+\n+    mainMethod.invoke(null, args)\n+  }",
    "line": 53
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "I see, thanks for explanation. I cannot figure out a solution which doesn't break the current semantics of `SparkConf`, this might be the only choice. ",
    "commit": "191513542da1c11f66dd96cca472babe68b4f630",
    "createdAt": "2017-10-25T01:46:26Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy\n+\n+import java.lang.reflect.Modifier\n+\n+import org.apache.spark.SparkConf\n+\n+/**\n+ * Entry point for a Spark application. Implementations must provide a no-argument constructor.\n+ */\n+private[spark] trait SparkApplication {\n+\n+  def start(args: Array[String], conf: SparkConf): Unit\n+\n+}\n+\n+/**\n+ * Implementation of SparkApplication that wraps a standard Java class with a \"main\" method.\n+ *\n+ * Configuration is propagated to the application via system properties, so running multiple\n+ * of these in the same JVM may lead to undefined behavior due to configuration leaks.\n+ */\n+private[deploy] class JavaMainApplication(klass: Class[_]) extends SparkApplication {\n+\n+  override def start(args: Array[String], conf: SparkConf): Unit = {\n+    val mainMethod = klass.getMethod(\"main\", new Array[String](0).getClass)\n+    if (!Modifier.isStatic(mainMethod.getModifiers)) {\n+      throw new IllegalStateException(\"The main method in the given main class must be static\")\n+    }\n+\n+    val sysProps = conf.getAll.toMap\n+    sysProps.foreach { case (k, v) =>\n+      sys.props(k) = v\n+    }\n+\n+    mainMethod.invoke(null, args)\n+  }",
    "line": 53
  }],
  "prId": 19519
}]