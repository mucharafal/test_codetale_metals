[{
  "comments": [{
    "author": {
      "login": "uncleGen"
    },
    "body": "FYI: This class is moved from `org.apache.spark.streaming.ui.StreamingPage` with a new added function.",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-10-24T02:10:39Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(",
    "line": 41
  }],
  "prId": 26201
}, {
  "comments": [{
    "author": {
      "login": "uncleGen"
    },
    "body": "FYI: newly added ",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-10-24T02:11:27Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(",
    "line": 93
  }],
  "prId": 26201
}, {
  "comments": [{
    "author": {
      "login": "uncleGen"
    },
    "body": "FYI: This class is moved from `org.apache.spark.streaming.ui.StreamingPage`",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-10-24T02:20:04Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")\n+        .mkString(\",\")\n+      s\"\"\"{x: \"${UIUtils.formatBatchTime(x, 1, showYYYYMMSS = false)}\", $s}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    val jsForLabels = operationLabels.mkString(\"[\\\"\", \"\\\",\\\"\", \"\\\"]\")\n+    val (maxX, minX, maxY, minY) = if (values != null && values.length > 0) {\n+      (values.map(_._1.toLong).max,\n+        values.map(_._1.toLong).min,\n+        values.map(_._2.asScala.toSeq.map(_._2.toLong).sum).max,\n+        values.map(_._2.asScala.toSeq.map(_._2.toLong).sum).min)\n+    } else {\n+      (0L, 0L, 0L, 0L)\n+    }\n+\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+    val labels = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $labels = $jsForLabels;\")\n+    jsCollector.addStatement(\n+      s\"drawAreaStack('#$timelineDivId', $labels, $dataJavaScriptName, $minX, $maxX, $minY, $maxY)\")\n+    <div id={timelineDivId}></div>\n+  }\n+}\n+\n+/**\n+ * A helper class that allows the user to add JavaScript statements which will be executed when the\n+ * DOM has finished loading.\n+ */\n+private[spark] class JsCollector {",
    "line": 126
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "And, there is no change?",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-10-24T19:50:19Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")\n+        .mkString(\",\")\n+      s\"\"\"{x: \"${UIUtils.formatBatchTime(x, 1, showYYYYMMSS = false)}\", $s}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    val jsForLabels = operationLabels.mkString(\"[\\\"\", \"\\\",\\\"\", \"\\\"]\")\n+    val (maxX, minX, maxY, minY) = if (values != null && values.length > 0) {\n+      (values.map(_._1.toLong).max,\n+        values.map(_._1.toLong).min,\n+        values.map(_._2.asScala.toSeq.map(_._2.toLong).sum).max,\n+        values.map(_._2.asScala.toSeq.map(_._2.toLong).sum).min)\n+    } else {\n+      (0L, 0L, 0L, 0L)\n+    }\n+\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+    val labels = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $labels = $jsForLabels;\")\n+    jsCollector.addStatement(\n+      s\"drawAreaStack('#$timelineDivId', $labels, $dataJavaScriptName, $minX, $maxX, $minY, $maxY)\")\n+    <div id={timelineDivId}></div>\n+  }\n+}\n+\n+/**\n+ * A helper class that allows the user to add JavaScript statements which will be executed when the\n+ * DOM has finished loading.\n+ */\n+private[spark] class JsCollector {",
    "line": 126
  }, {
    "author": {
      "login": "uncleGen"
    },
    "body": "no change",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-10-25T02:34:59Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")\n+        .mkString(\",\")\n+      s\"\"\"{x: \"${UIUtils.formatBatchTime(x, 1, showYYYYMMSS = false)}\", $s}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    val jsForLabels = operationLabels.mkString(\"[\\\"\", \"\\\",\\\"\", \"\\\"]\")\n+    val (maxX, minX, maxY, minY) = if (values != null && values.length > 0) {\n+      (values.map(_._1.toLong).max,\n+        values.map(_._1.toLong).min,\n+        values.map(_._2.asScala.toSeq.map(_._2.toLong).sum).max,\n+        values.map(_._2.asScala.toSeq.map(_._2.toLong).sum).min)\n+    } else {\n+      (0L, 0L, 0L, 0L)\n+    }\n+\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+    val labels = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $labels = $jsForLabels;\")\n+    jsCollector.addStatement(\n+      s\"drawAreaStack('#$timelineDivId', $labels, $dataJavaScriptName, $minX, $maxX, $minY, $maxY)\")\n+    <div id={timelineDivId}></div>\n+  }\n+}\n+\n+/**\n+ * A helper class that allows the user to add JavaScript statements which will be executed when the\n+ * DOM has finished loading.\n+ */\n+private[spark] class JsCollector {",
    "line": 126
  }],
  "prId": 26201
}, {
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "What about having local variables for below to deduplicate and avoid redundant work?\r\n\r\n* `values.map(_._1.toLong)`\r\n* `values.map(_._2.asScala.toSeq.map(_._2.toLong).sum)`",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-11-20T05:58:59Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")\n+        .mkString(\",\")\n+      s\"\"\"{x: \"${UIUtils.formatBatchTime(x, 1, showYYYYMMSS = false)}\", $s}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    val jsForLabels = operationLabels.mkString(\"[\\\"\", \"\\\",\\\"\", \"\\\"]\")\n+    val (maxX, minX, maxY, minY) = if (values != null && values.length > 0) {\n+      (values.map(_._1.toLong).max,"
  }, {
    "author": {
      "login": "uncleGen"
    },
    "body": "ok",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-11-21T06:38:17Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")\n+        .mkString(\",\")\n+      s\"\"\"{x: \"${UIUtils.formatBatchTime(x, 1, showYYYYMMSS = false)}\", $s}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    val jsForLabels = operationLabels.mkString(\"[\\\"\", \"\\\",\\\"\", \"\\\"]\")\n+    val (maxX, minX, maxY, minY) = if (values != null && values.length > 0) {\n+      (values.map(_._1.toLong).max,"
  }],
  "prId": 26201
}, {
  "comments": [{
    "author": {
      "login": "sarutak"
    },
    "body": "nit:\r\n``` \r\nval s =\r\n  y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\").mkString(\",\")\r\n```\r\n\r\nmight be more pretty.",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-11-20T10:48:37Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")"
  }, {
    "author": {
      "login": "uncleGen"
    },
    "body": "ok",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-11-21T07:57:16Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +\n+          s\"'#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY, '$unitY',\" +\n+          s\" ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawTimeline('#$timelineDivId', $dataJavaScriptName, $minX, $maxX, $minY, $maxY,\" +\n+          s\" '$unitY');\")\n+    }\n+    <div id={timelineDivId}></div>\n+  }\n+\n+  def generateHistogramHtml(jsCollector: JsCollector): Seq[Node] = {\n+    val histogramData = s\"$dataJavaScriptName.map(function(d) { return d.y; })\"\n+    jsCollector.addPreparedStatement(s\"registerHistogram($histogramData, $minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawHistogram(\" +\n+          s\"'#$histogramDivId', $histogramData, $minY, $maxY, '$unitY', ${batchInterval.get}\" +\n+          \");\")\n+    } else {\n+      jsCollector.addStatement(\n+        s\"drawHistogram('#$histogramDivId', $histogramData, $minY, $maxY, '$unitY');\")\n+    }\n+    <div id={histogramDivId}></div>\n+  }\n+\n+  def generateAreaStackHtmlWithData(\n+      jsCollector: JsCollector,\n+      values: Array[(Long, ju.Map[String, JLong])],\n+      operationLabels: Seq[String]): Seq[Node] = {\n+    val jsForData = values.map { case (x, y) =>\n+      val s = y.asScala.toSeq.sortBy(_._1).map(e => s\"\"\"\"${e._1}\": \"${e._2.toDouble}\"\"\"\")"
  }],
  "prId": 26201
}, {
  "comments": [{
    "author": {
      "login": "sarutak"
    },
    "body": "We can't just reuse existing `drawTimeline` because `onclick` action is not implemented in this page.\r\nIf we click a data point in the graph, we'll get error.\r\n\r\n<img width=\"1428\" alt=\"スクリーンショット 2019-11-25 19 59 38\" src=\"https://user-images.githubusercontent.com/4736016/69534957-2c521080-0fbe-11ea-91a4-3ad923912e46.png\">\r\n",
    "commit": "6de18cc2e20bd8ef0167a52c869c7706f67014a2",
    "createdAt": "2019-11-25T11:13:48Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.{util => ju}\n+import java.lang.{Long => JLong}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.xml.{Node, Unparsed}\n+\n+/**\n+ * A helper class to generate JavaScript and HTML for both timeline and histogram graphs.\n+ *\n+ * @param timelineDivId the timeline `id` used in the html `div` tag\n+ * @param histogramDivId the timeline `id` used in the html `div` tag\n+ * @param data the data for the graph\n+ * @param minX the min value of X axis\n+ * @param maxX the max value of X axis\n+ * @param minY the min value of Y axis\n+ * @param maxY the max value of Y axis\n+ * @param unitY the unit of Y axis\n+ * @param batchInterval if `batchInterval` is not None, we will draw a line for `batchInterval` in\n+ *                      the graph\n+ */\n+private[spark] class GraphUIData(\n+    timelineDivId: String,\n+    histogramDivId: String,\n+    data: Seq[(Long, Double)],\n+    minX: Long,\n+    maxX: Long,\n+    minY: Double,\n+    maxY: Double,\n+    unitY: String,\n+    batchInterval: Option[Double] = None) {\n+\n+  private var dataJavaScriptName: String = _\n+\n+  def generateDataJs(jsCollector: JsCollector): Unit = {\n+    val jsForData = data.map { case (x, y) =>\n+      s\"\"\"{\"x\": $x, \"y\": $y}\"\"\"\n+    }.mkString(\"[\", \",\", \"]\")\n+    dataJavaScriptName = jsCollector.nextVariableName\n+    jsCollector.addPreparedStatement(s\"var $dataJavaScriptName = $jsForData;\")\n+  }\n+\n+  def generateTimelineHtml(jsCollector: JsCollector): Seq[Node] = {\n+    jsCollector.addPreparedStatement(s\"registerTimeline($minY, $maxY);\")\n+    if (batchInterval.isDefined) {\n+      jsCollector.addStatement(\n+        \"drawTimeline(\" +",
    "line": 66
  }],
  "prId": 26201
}]