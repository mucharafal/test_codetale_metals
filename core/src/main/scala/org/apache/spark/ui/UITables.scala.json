[{
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "super nit: import ordering\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-21T17:49:43Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}"
  }],
  "prId": 2852
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "I think this should be indented 4 spaces, not two (which is what we do elsewhere for function declarations) -- same for many of the other functions defined here\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-21T17:53:59Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}\n+\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Describes how to render a column of values in a web UI table.\n+ *\n+ * @param name the name / title of this column\n+ * @param formatter function that formats values for display in the table\n+ * @param sortable if false, this column will not be sortable\n+ * @param sortKey optional function for sorting by a key other than `formatter(value)`\n+ * @param fieldExtractor function for extracting this field's value from the table's row data type\n+ * @tparam T the table's row data type\n+ * @tparam V this column's value type\n+ */\n+private case class UITableColumn[T, V](\n+  name: String,\n+  formatter: V => String,\n+  sortable: Boolean,\n+  sortKey: Option[V => String],\n+  fieldExtractor: T => V) {\n+\n+  /** Render the TD tag for this row */\n+  def renderCell(row: T): Seq[Node] =  {\n+    val data = fieldExtractor(row)\n+    val cellContents = renderCellContents(data)\n+    <td sorttable_customkey={sortKey.map(k => Text(k(data)))}>\n+      {cellContents}\n+    </td>\n+  }\n+\n+  /** Render the contents of the TD tag for this row.  The contents may be a string or HTML */\n+  def renderCellContents(data: V): Seq[Node] = {\n+    Text(formatter(data))\n+  }\n+}\n+\n+/**\n+ * Describes how to render a table to display rows of type `T`.\n+ * @param cols a sequence of UITableColumns that describe how each column should be rendered\n+ * @param fixedWidth if true, all columns of this table will be displayed with the same width\n+ * @tparam T the row data type\n+ */\n+private[spark] class UITable[T] (cols: Seq[UITableColumn[T, _]], fixedWidth: Boolean) {\n+\n+  private val tableClass = if (fixedWidth) {\n+    UIUtils.TABLE_CLASS + \" table-fixed\"\n+  } else {\n+    UIUtils.TABLE_CLASS\n+  }\n+\n+  private val colWidthAttr = if (fixedWidth) Some(Text((100.toDouble / cols.size) + \"%\")) else None\n+\n+  private val headerRow: Seq[Node] = {\n+    val headers = cols.map(_.name)\n+    // if none of the headers have \"\\n\" in them\n+    if (headers.forall(!_.contains(\"\\n\"))) {\n+      // represent header as simple text\n+      headers.map(h => <th width={colWidthAttr}>{h}</th>)\n+    } else {\n+      // represent header text as list while respecting \"\\n\"\n+      headers.map { case h =>\n+        <th width={colWidthAttr}>\n+          <ul class=\"unstyled\">\n+            { h.split(\"\\n\").map { case t => <li> {t} </li> } }\n+          </ul>\n+        </th>\n+      }\n+    }\n+  }\n+\n+  private def renderRow(row: T): Seq[Node] = {\n+    val tds = cols.map(_.renderCell(row))\n+    <tr>{ tds }</tr>\n+  }\n+\n+  /** Render the table with the given data */\n+  def render(data: Iterable[T]): Seq[Node] = {\n+    val rows = data.map(renderRow)\n+    <table class={tableClass}>\n+      <thead>{headerRow}</thead>\n+      <tbody>\n+        {rows}\n+      </tbody>\n+    </table>\n+  }\n+}\n+\n+/**\n+ * Builder for constructing web UI tables.  This builder offers several advantages over constructing\n+ * tables by hand using raw XML:\n+ *\n+ *  - All of the table's data and formatting logic can live in one place; the table headers and\n+ *    rows aren't described in separate code.  This prevents several common errors, like changing\n+ *    the ordering of two column headers but forgetting to re-order the corresponding TD tags.\n+ *\n+ *  - No repetition of code for type-specific display rules: common column types like \"memory\",\n+ *    \"duration\", and \"time\" have convenience methods that implement the right formatting logic.\n+ *\n+ *  - Details of our specific markup are generally abstracted away.  For example, the markup for\n+ *    setting a custom sort key on a column now lives in one place, rather than being repeated\n+ *    in each table.\n+ *\n+ * The recommended way of using this class:\n+ *\n+ *  - Create a new builder that is parametrized by the type (`T`) of data that you want to render.\n+ *    In many cases, there may be some record type like `WorkerInfo` that holds all of the\n+ *    information needed to render a particular row.  If the data for each table row comes from\n+ *    several objects, you can combine those objects into a tuple or case-class.\n+ *\n+ *  - Use the `col` methods to add columns to this builder.  The final argument of each `col` method\n+ *    is a function that extracts the column's field from a row object of type `T`.  Columns are\n+ *    displayed in the order that they are added to the builder.  For most columns, you can write\n+ *    code like\n+ *\n+ *      builder.col(\"Id\") { _.id }\n+ *      builder.memCol(\"Memory\" { _.memory }\n+ *\n+ *    Columns have additional options, such as controlling their sort keys; see the individual\n+ *    methods' documentation for more details.\n+ *\n+ *  - Call `build` to construct an immutable object which can be used to render tables.\n+ *   *\n+ * To remove some of the boilerplate here, you can statically import the `col` methods; for example:\n+ *\n+ *    val myTable: UITable[MyRowDataType] = {\n+ *      val builder = new UITableBuilder[MyRowDataType]()\n+ *      import builder._\n+ *      col(\"Name\") { _.name }\n+ *      [...]\n+ *      build\n+ *    }\n+ *\n+ * There are many other features, including support for arbitrary markup in custom column types;\n+ * see the actual uses in the web UI code for more details.\n+ *\n+ * @param fixedWidth if true, all columns will be rendered with the same width\n+ * @tparam T the type of the data items that will be used to render individual rows\n+ */\n+private[spark] class UITableBuilder[T](fixedWidth: Boolean = false) {\n+  private val cols = mutable.Buffer[UITableColumn[T, _]]()\n+\n+  /**\n+   * Display a column with custom HTML markup.  The markup should only describe how to\n+   * render the contents of the TD tag, not the TD tag itself.\n+   */\n+  def customCol[V](\n+    name: String,"
  }],
  "prId": 2852
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "Can this be sizeCol instead? It seems like a column describing data size on disk (which we need in a few places) should use the same format\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-21T17:54:37Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}\n+\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Describes how to render a column of values in a web UI table.\n+ *\n+ * @param name the name / title of this column\n+ * @param formatter function that formats values for display in the table\n+ * @param sortable if false, this column will not be sortable\n+ * @param sortKey optional function for sorting by a key other than `formatter(value)`\n+ * @param fieldExtractor function for extracting this field's value from the table's row data type\n+ * @tparam T the table's row data type\n+ * @tparam V this column's value type\n+ */\n+private case class UITableColumn[T, V](\n+  name: String,\n+  formatter: V => String,\n+  sortable: Boolean,\n+  sortKey: Option[V => String],\n+  fieldExtractor: T => V) {\n+\n+  /** Render the TD tag for this row */\n+  def renderCell(row: T): Seq[Node] =  {\n+    val data = fieldExtractor(row)\n+    val cellContents = renderCellContents(data)\n+    <td sorttable_customkey={sortKey.map(k => Text(k(data)))}>\n+      {cellContents}\n+    </td>\n+  }\n+\n+  /** Render the contents of the TD tag for this row.  The contents may be a string or HTML */\n+  def renderCellContents(data: V): Seq[Node] = {\n+    Text(formatter(data))\n+  }\n+}\n+\n+/**\n+ * Describes how to render a table to display rows of type `T`.\n+ * @param cols a sequence of UITableColumns that describe how each column should be rendered\n+ * @param fixedWidth if true, all columns of this table will be displayed with the same width\n+ * @tparam T the row data type\n+ */\n+private[spark] class UITable[T] (cols: Seq[UITableColumn[T, _]], fixedWidth: Boolean) {\n+\n+  private val tableClass = if (fixedWidth) {\n+    UIUtils.TABLE_CLASS + \" table-fixed\"\n+  } else {\n+    UIUtils.TABLE_CLASS\n+  }\n+\n+  private val colWidthAttr = if (fixedWidth) Some(Text((100.toDouble / cols.size) + \"%\")) else None\n+\n+  private val headerRow: Seq[Node] = {\n+    val headers = cols.map(_.name)\n+    // if none of the headers have \"\\n\" in them\n+    if (headers.forall(!_.contains(\"\\n\"))) {\n+      // represent header as simple text\n+      headers.map(h => <th width={colWidthAttr}>{h}</th>)\n+    } else {\n+      // represent header text as list while respecting \"\\n\"\n+      headers.map { case h =>\n+        <th width={colWidthAttr}>\n+          <ul class=\"unstyled\">\n+            { h.split(\"\\n\").map { case t => <li> {t} </li> } }\n+          </ul>\n+        </th>\n+      }\n+    }\n+  }\n+\n+  private def renderRow(row: T): Seq[Node] = {\n+    val tds = cols.map(_.renderCell(row))\n+    <tr>{ tds }</tr>\n+  }\n+\n+  /** Render the table with the given data */\n+  def render(data: Iterable[T]): Seq[Node] = {\n+    val rows = data.map(renderRow)\n+    <table class={tableClass}>\n+      <thead>{headerRow}</thead>\n+      <tbody>\n+        {rows}\n+      </tbody>\n+    </table>\n+  }\n+}\n+\n+/**\n+ * Builder for constructing web UI tables.  This builder offers several advantages over constructing\n+ * tables by hand using raw XML:\n+ *\n+ *  - All of the table's data and formatting logic can live in one place; the table headers and\n+ *    rows aren't described in separate code.  This prevents several common errors, like changing\n+ *    the ordering of two column headers but forgetting to re-order the corresponding TD tags.\n+ *\n+ *  - No repetition of code for type-specific display rules: common column types like \"memory\",\n+ *    \"duration\", and \"time\" have convenience methods that implement the right formatting logic.\n+ *\n+ *  - Details of our specific markup are generally abstracted away.  For example, the markup for\n+ *    setting a custom sort key on a column now lives in one place, rather than being repeated\n+ *    in each table.\n+ *\n+ * The recommended way of using this class:\n+ *\n+ *  - Create a new builder that is parametrized by the type (`T`) of data that you want to render.\n+ *    In many cases, there may be some record type like `WorkerInfo` that holds all of the\n+ *    information needed to render a particular row.  If the data for each table row comes from\n+ *    several objects, you can combine those objects into a tuple or case-class.\n+ *\n+ *  - Use the `col` methods to add columns to this builder.  The final argument of each `col` method\n+ *    is a function that extracts the column's field from a row object of type `T`.  Columns are\n+ *    displayed in the order that they are added to the builder.  For most columns, you can write\n+ *    code like\n+ *\n+ *      builder.col(\"Id\") { _.id }\n+ *      builder.memCol(\"Memory\" { _.memory }\n+ *\n+ *    Columns have additional options, such as controlling their sort keys; see the individual\n+ *    methods' documentation for more details.\n+ *\n+ *  - Call `build` to construct an immutable object which can be used to render tables.\n+ *   *\n+ * To remove some of the boilerplate here, you can statically import the `col` methods; for example:\n+ *\n+ *    val myTable: UITable[MyRowDataType] = {\n+ *      val builder = new UITableBuilder[MyRowDataType]()\n+ *      import builder._\n+ *      col(\"Name\") { _.name }\n+ *      [...]\n+ *      build\n+ *    }\n+ *\n+ * There are many other features, including support for arbitrary markup in custom column types;\n+ * see the actual uses in the web UI code for more details.\n+ *\n+ * @param fixedWidth if true, all columns will be rendered with the same width\n+ * @tparam T the type of the data items that will be used to render individual rows\n+ */\n+private[spark] class UITableBuilder[T](fixedWidth: Boolean = false) {\n+  private val cols = mutable.Buffer[UITableColumn[T, _]]()\n+\n+  /**\n+   * Display a column with custom HTML markup.  The markup should only describe how to\n+   * render the contents of the TD tag, not the TD tag itself.\n+   */\n+  def customCol[V](\n+    name: String,\n+    sortable: Boolean = true,\n+    sortKey: Option[T => String] = None)(renderer: T => Seq[Node]): UITableBuilder[T] = {\n+    val customColumn = new UITableColumn[T, T](name, null, sortable, sortKey, identity) {\n+      override def renderCellContents(row: T) = renderer(row)\n+    }\n+    cols.append(customColumn)\n+    this\n+  }\n+\n+  def col[V](\n+    name: String,\n+    formatter: V => String,\n+    sortable: Boolean = true,\n+    sortKey: Option[V => String] = None)(fieldExtractor: T => V): UITableBuilder[T] = {\n+    cols.append(UITableColumn(name, formatter, sortable, sortKey, fieldExtractor))\n+    this\n+  }\n+\n+  def col(\n+    name: String,\n+    sortable: Boolean = true,\n+    sortKey: Option[String => String] = None)(fieldExtractor: T => String): UITableBuilder[T] = {\n+    col[String](name, {x: String => x}, sortable, sortKey)(fieldExtractor)\n+  }\n+\n+  def intCol(\n+    name: String,\n+    formatter: Int => String = { x: Int => x.toString },\n+    sortable: Boolean = true)(fieldExtractor: T => Int): UITableBuilder[T] = {\n+    col[Int](name, formatter, sortable = sortable)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of memory sizes, in megabytes, as human-readable strings, such as \"4.0 MB\".\n+   */\n+  def memCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {"
  }],
  "prId": 2852
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "an extra star?\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-23T19:07:07Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}\n+\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Describes how to render a column of values in a web UI table.\n+ *\n+ * @param name the name / title of this column\n+ * @param formatter function that formats values for display in the table\n+ * @param sortable if false, this column will not be sortable\n+ * @param sortKey optional function for sorting by a key other than `formatter(value)`\n+ * @param fieldExtractor function for extracting this field's value from the table's row data type\n+ * @tparam T the table's row data type\n+ * @tparam V this column's value type\n+ */\n+private case class UITableColumn[T, V](\n+  name: String,\n+  formatter: V => String,\n+  sortable: Boolean,\n+  sortKey: Option[V => String],\n+  fieldExtractor: T => V) {\n+\n+  /** Render the TD tag for this row */\n+  def renderCell(row: T): Seq[Node] =  {\n+    val data = fieldExtractor(row)\n+    val cellContents = renderCellContents(data)\n+    <td sorttable_customkey={sortKey.map(k => Text(k(data)))}>\n+      {cellContents}\n+    </td>\n+  }\n+\n+  /** Render the contents of the TD tag for this row.  The contents may be a string or HTML */\n+  def renderCellContents(data: V): Seq[Node] = {\n+    Text(formatter(data))\n+  }\n+}\n+\n+/**\n+ * Describes how to render a table to display rows of type `T`.\n+ * @param cols a sequence of UITableColumns that describe how each column should be rendered\n+ * @param fixedWidth if true, all columns of this table will be displayed with the same width\n+ * @tparam T the row data type\n+ */\n+private[spark] class UITable[T] (cols: Seq[UITableColumn[T, _]], fixedWidth: Boolean) {\n+\n+  private val tableClass = if (fixedWidth) {\n+    UIUtils.TABLE_CLASS + \" table-fixed\"\n+  } else {\n+    UIUtils.TABLE_CLASS\n+  }\n+\n+  private val colWidthAttr = if (fixedWidth) Some(Text((100.toDouble / cols.size) + \"%\")) else None\n+\n+  private val headerRow: Seq[Node] = {\n+    val headers = cols.map(_.name)\n+    // if none of the headers have \"\\n\" in them\n+    if (headers.forall(!_.contains(\"\\n\"))) {\n+      // represent header as simple text\n+      headers.map(h => <th width={colWidthAttr}>{h}</th>)\n+    } else {\n+      // represent header text as list while respecting \"\\n\"\n+      headers.map { case h =>\n+        <th width={colWidthAttr}>\n+          <ul class=\"unstyled\">\n+            { h.split(\"\\n\").map { case t => <li> {t} </li> } }\n+          </ul>\n+        </th>\n+      }\n+    }\n+  }\n+\n+  private def renderRow(row: T): Seq[Node] = {\n+    val tds = cols.map(_.renderCell(row))\n+    <tr>{ tds }</tr>\n+  }\n+\n+  /** Render the table with the given data */\n+  def render(data: Iterable[T]): Seq[Node] = {\n+    val rows = data.map(renderRow)\n+    <table class={tableClass}>\n+      <thead>{headerRow}</thead>\n+      <tbody>\n+        {rows}\n+      </tbody>\n+    </table>\n+  }\n+}\n+\n+/**\n+ * Builder for constructing web UI tables.  This builder offers several advantages over constructing\n+ * tables by hand using raw XML:\n+ *\n+ *  - All of the table's data and formatting logic can live in one place; the table headers and\n+ *    rows aren't described in separate code.  This prevents several common errors, like changing\n+ *    the ordering of two column headers but forgetting to re-order the corresponding TD tags.\n+ *\n+ *  - No repetition of code for type-specific display rules: common column types like \"memory\",\n+ *    \"duration\", and \"time\" have convenience methods that implement the right formatting logic.\n+ *\n+ *  - Details of our specific markup are generally abstracted away.  For example, the markup for\n+ *    setting a custom sort key on a column now lives in one place, rather than being repeated\n+ *    in each table.\n+ *\n+ * The recommended way of using this class:\n+ *\n+ *  - Create a new builder that is parametrized by the type (`T`) of data that you want to render.\n+ *    In many cases, there may be some record type like `WorkerInfo` that holds all of the\n+ *    information needed to render a particular row.  If the data for each table row comes from\n+ *    several objects, you can combine those objects into a tuple or case-class.\n+ *\n+ *  - Use the `col` methods to add columns to this builder.  The final argument of each `col` method\n+ *    is a function that extracts the column's field from a row object of type `T`.  Columns are\n+ *    displayed in the order that they are added to the builder.  For most columns, you can write\n+ *    code like\n+ *\n+ *      builder.col(\"Id\") { _.id }\n+ *      builder.memCol(\"Memory\" { _.memory }\n+ *\n+ *    Columns have additional options, such as controlling their sort keys; see the individual\n+ *    methods' documentation for more details.\n+ *\n+ *  - Call `build` to construct an immutable object which can be used to render tables.\n+ *   *"
  }],
  "prId": 2852
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nit: add a new line\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-23T19:08:34Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}\n+\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Describes how to render a column of values in a web UI table.\n+ *\n+ * @param name the name / title of this column\n+ * @param formatter function that formats values for display in the table\n+ * @param sortable if false, this column will not be sortable\n+ * @param sortKey optional function for sorting by a key other than `formatter(value)`\n+ * @param fieldExtractor function for extracting this field's value from the table's row data type\n+ * @tparam T the table's row data type\n+ * @tparam V this column's value type\n+ */\n+private case class UITableColumn[T, V](\n+  name: String,\n+  formatter: V => String,\n+  sortable: Boolean,\n+  sortKey: Option[V => String],\n+  fieldExtractor: T => V) {\n+\n+  /** Render the TD tag for this row */\n+  def renderCell(row: T): Seq[Node] =  {\n+    val data = fieldExtractor(row)\n+    val cellContents = renderCellContents(data)\n+    <td sorttable_customkey={sortKey.map(k => Text(k(data)))}>\n+      {cellContents}\n+    </td>\n+  }\n+\n+  /** Render the contents of the TD tag for this row.  The contents may be a string or HTML */\n+  def renderCellContents(data: V): Seq[Node] = {\n+    Text(formatter(data))\n+  }\n+}\n+\n+/**\n+ * Describes how to render a table to display rows of type `T`.\n+ * @param cols a sequence of UITableColumns that describe how each column should be rendered\n+ * @param fixedWidth if true, all columns of this table will be displayed with the same width\n+ * @tparam T the row data type\n+ */\n+private[spark] class UITable[T] (cols: Seq[UITableColumn[T, _]], fixedWidth: Boolean) {\n+\n+  private val tableClass = if (fixedWidth) {\n+    UIUtils.TABLE_CLASS + \" table-fixed\"\n+  } else {\n+    UIUtils.TABLE_CLASS\n+  }\n+\n+  private val colWidthAttr = if (fixedWidth) Some(Text((100.toDouble / cols.size) + \"%\")) else None\n+\n+  private val headerRow: Seq[Node] = {\n+    val headers = cols.map(_.name)\n+    // if none of the headers have \"\\n\" in them\n+    if (headers.forall(!_.contains(\"\\n\"))) {\n+      // represent header as simple text\n+      headers.map(h => <th width={colWidthAttr}>{h}</th>)\n+    } else {\n+      // represent header text as list while respecting \"\\n\"\n+      headers.map { case h =>\n+        <th width={colWidthAttr}>\n+          <ul class=\"unstyled\">\n+            { h.split(\"\\n\").map { case t => <li> {t} </li> } }\n+          </ul>\n+        </th>\n+      }\n+    }\n+  }\n+\n+  private def renderRow(row: T): Seq[Node] = {\n+    val tds = cols.map(_.renderCell(row))\n+    <tr>{ tds }</tr>\n+  }\n+\n+  /** Render the table with the given data */\n+  def render(data: Iterable[T]): Seq[Node] = {\n+    val rows = data.map(renderRow)\n+    <table class={tableClass}>\n+      <thead>{headerRow}</thead>\n+      <tbody>\n+        {rows}\n+      </tbody>\n+    </table>\n+  }\n+}\n+\n+/**\n+ * Builder for constructing web UI tables.  This builder offers several advantages over constructing\n+ * tables by hand using raw XML:\n+ *\n+ *  - All of the table's data and formatting logic can live in one place; the table headers and\n+ *    rows aren't described in separate code.  This prevents several common errors, like changing\n+ *    the ordering of two column headers but forgetting to re-order the corresponding TD tags.\n+ *\n+ *  - No repetition of code for type-specific display rules: common column types like \"memory\",\n+ *    \"duration\", and \"time\" have convenience methods that implement the right formatting logic.\n+ *\n+ *  - Details of our specific markup are generally abstracted away.  For example, the markup for\n+ *    setting a custom sort key on a column now lives in one place, rather than being repeated\n+ *    in each table.\n+ *\n+ * The recommended way of using this class:\n+ *\n+ *  - Create a new builder that is parametrized by the type (`T`) of data that you want to render.\n+ *    In many cases, there may be some record type like `WorkerInfo` that holds all of the\n+ *    information needed to render a particular row.  If the data for each table row comes from\n+ *    several objects, you can combine those objects into a tuple or case-class.\n+ *\n+ *  - Use the `col` methods to add columns to this builder.  The final argument of each `col` method\n+ *    is a function that extracts the column's field from a row object of type `T`.  Columns are\n+ *    displayed in the order that they are added to the builder.  For most columns, you can write\n+ *    code like\n+ *\n+ *      builder.col(\"Id\") { _.id }\n+ *      builder.memCol(\"Memory\" { _.memory }\n+ *\n+ *    Columns have additional options, such as controlling their sort keys; see the individual\n+ *    methods' documentation for more details.\n+ *\n+ *  - Call `build` to construct an immutable object which can be used to render tables.\n+ *   *\n+ * To remove some of the boilerplate here, you can statically import the `col` methods; for example:\n+ *\n+ *    val myTable: UITable[MyRowDataType] = {\n+ *      val builder = new UITableBuilder[MyRowDataType]()\n+ *      import builder._\n+ *      col(\"Name\") { _.name }\n+ *      [...]\n+ *      build\n+ *    }\n+ *\n+ * There are many other features, including support for arbitrary markup in custom column types;\n+ * see the actual uses in the web UI code for more details.\n+ *\n+ * @param fixedWidth if true, all columns will be rendered with the same width\n+ * @tparam T the type of the data items that will be used to render individual rows\n+ */\n+private[spark] class UITableBuilder[T](fixedWidth: Boolean = false) {\n+  private val cols = mutable.Buffer[UITableColumn[T, _]]()\n+\n+  /**\n+   * Display a column with custom HTML markup.  The markup should only describe how to\n+   * render the contents of the TD tag, not the TD tag itself.\n+   */\n+  def customCol[V](\n+    name: String,\n+    sortable: Boolean = true,\n+    sortKey: Option[T => String] = None)(renderer: T => Seq[Node]): UITableBuilder[T] = {\n+    val customColumn = new UITableColumn[T, T](name, null, sortable, sortKey, identity) {\n+      override def renderCellContents(row: T) = renderer(row)\n+    }\n+    cols.append(customColumn)\n+    this\n+  }\n+\n+  def col[V](\n+    name: String,\n+    formatter: V => String,\n+    sortable: Boolean = true,\n+    sortKey: Option[V => String] = None)(fieldExtractor: T => V): UITableBuilder[T] = {\n+    cols.append(UITableColumn(name, formatter, sortable, sortKey, fieldExtractor))\n+    this\n+  }\n+\n+  def col(\n+    name: String,\n+    sortable: Boolean = true,\n+    sortKey: Option[String => String] = None)(fieldExtractor: T => String): UITableBuilder[T] = {\n+    col[String](name, {x: String => x}, sortable, sortKey)(fieldExtractor)\n+  }\n+\n+  def intCol(\n+    name: String,\n+    formatter: Int => String = { x: Int => x.toString },\n+    sortable: Boolean = true)(fieldExtractor: T => Int): UITableBuilder[T] = {\n+    col[Int](name, formatter, sortable = sortable)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of memory sizes, in megabytes, as human-readable strings, such as \"4.0 MB\".\n+   */\n+  def memCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {\n+    col[Long](\n+      name,\n+      formatter = Utils.megabytesToString,\n+      sortKey = Some(x => x.toString))(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of dates as yyyy/MM/dd HH:mm:ss format.\n+   */\n+  def dateCol(name: String)(fieldExtractor: T => Date): UITableBuilder[T] = {\n+    col[Date](name, formatter = UIUtils.formatDate)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of dates as yyyy/MM/dd HH:mm:ss format.\n+   */\n+  def epochDateCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {\n+    col[Long](name, formatter = UIUtils.formatDate)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of durations, in milliseconds, as human-readable strings, such as \"12 s\".\n+   */\n+  def durationCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {\n+    col[Long](name, formatter = UIUtils.formatDuration, sortKey = Some(_.toString))(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of optional durations, in milliseconds, as human-readable strings,\n+   * such as \"12 s\".  If the duration is None, then '-' will be displayed.\n+   */\n+  def optDurationCol(name: String)(fieldExtractor: T => Option[Long]): UITableBuilder[T] = {\n+    col[Option[Long]](\n+      name,\n+      formatter = { _.map(UIUtils.formatDuration).getOrElse(\"-\")},\n+      sortKey = Some(_.getOrElse(\"-\").toString)\n+    )(fieldExtractor)\n+  }\n+\n+  def build: UITable[T] = {\n+    val immutableCols: Seq[UITableColumn[T, _]] = cols.toSeq\n+    new UITable[T](immutableCols, fixedWidth)\n+  }\n+}"
  }],
  "prId": 2852
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "build should have parenthesis, and make sure you add that to everywhere you call it. otherwise it looks like we are just returning a variable called build\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-23T19:09:01Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}\n+\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Describes how to render a column of values in a web UI table.\n+ *\n+ * @param name the name / title of this column\n+ * @param formatter function that formats values for display in the table\n+ * @param sortable if false, this column will not be sortable\n+ * @param sortKey optional function for sorting by a key other than `formatter(value)`\n+ * @param fieldExtractor function for extracting this field's value from the table's row data type\n+ * @tparam T the table's row data type\n+ * @tparam V this column's value type\n+ */\n+private case class UITableColumn[T, V](\n+  name: String,\n+  formatter: V => String,\n+  sortable: Boolean,\n+  sortKey: Option[V => String],\n+  fieldExtractor: T => V) {\n+\n+  /** Render the TD tag for this row */\n+  def renderCell(row: T): Seq[Node] =  {\n+    val data = fieldExtractor(row)\n+    val cellContents = renderCellContents(data)\n+    <td sorttable_customkey={sortKey.map(k => Text(k(data)))}>\n+      {cellContents}\n+    </td>\n+  }\n+\n+  /** Render the contents of the TD tag for this row.  The contents may be a string or HTML */\n+  def renderCellContents(data: V): Seq[Node] = {\n+    Text(formatter(data))\n+  }\n+}\n+\n+/**\n+ * Describes how to render a table to display rows of type `T`.\n+ * @param cols a sequence of UITableColumns that describe how each column should be rendered\n+ * @param fixedWidth if true, all columns of this table will be displayed with the same width\n+ * @tparam T the row data type\n+ */\n+private[spark] class UITable[T] (cols: Seq[UITableColumn[T, _]], fixedWidth: Boolean) {\n+\n+  private val tableClass = if (fixedWidth) {\n+    UIUtils.TABLE_CLASS + \" table-fixed\"\n+  } else {\n+    UIUtils.TABLE_CLASS\n+  }\n+\n+  private val colWidthAttr = if (fixedWidth) Some(Text((100.toDouble / cols.size) + \"%\")) else None\n+\n+  private val headerRow: Seq[Node] = {\n+    val headers = cols.map(_.name)\n+    // if none of the headers have \"\\n\" in them\n+    if (headers.forall(!_.contains(\"\\n\"))) {\n+      // represent header as simple text\n+      headers.map(h => <th width={colWidthAttr}>{h}</th>)\n+    } else {\n+      // represent header text as list while respecting \"\\n\"\n+      headers.map { case h =>\n+        <th width={colWidthAttr}>\n+          <ul class=\"unstyled\">\n+            { h.split(\"\\n\").map { case t => <li> {t} </li> } }\n+          </ul>\n+        </th>\n+      }\n+    }\n+  }\n+\n+  private def renderRow(row: T): Seq[Node] = {\n+    val tds = cols.map(_.renderCell(row))\n+    <tr>{ tds }</tr>\n+  }\n+\n+  /** Render the table with the given data */\n+  def render(data: Iterable[T]): Seq[Node] = {\n+    val rows = data.map(renderRow)\n+    <table class={tableClass}>\n+      <thead>{headerRow}</thead>\n+      <tbody>\n+        {rows}\n+      </tbody>\n+    </table>\n+  }\n+}\n+\n+/**\n+ * Builder for constructing web UI tables.  This builder offers several advantages over constructing\n+ * tables by hand using raw XML:\n+ *\n+ *  - All of the table's data and formatting logic can live in one place; the table headers and\n+ *    rows aren't described in separate code.  This prevents several common errors, like changing\n+ *    the ordering of two column headers but forgetting to re-order the corresponding TD tags.\n+ *\n+ *  - No repetition of code for type-specific display rules: common column types like \"memory\",\n+ *    \"duration\", and \"time\" have convenience methods that implement the right formatting logic.\n+ *\n+ *  - Details of our specific markup are generally abstracted away.  For example, the markup for\n+ *    setting a custom sort key on a column now lives in one place, rather than being repeated\n+ *    in each table.\n+ *\n+ * The recommended way of using this class:\n+ *\n+ *  - Create a new builder that is parametrized by the type (`T`) of data that you want to render.\n+ *    In many cases, there may be some record type like `WorkerInfo` that holds all of the\n+ *    information needed to render a particular row.  If the data for each table row comes from\n+ *    several objects, you can combine those objects into a tuple or case-class.\n+ *\n+ *  - Use the `col` methods to add columns to this builder.  The final argument of each `col` method\n+ *    is a function that extracts the column's field from a row object of type `T`.  Columns are\n+ *    displayed in the order that they are added to the builder.  For most columns, you can write\n+ *    code like\n+ *\n+ *      builder.col(\"Id\") { _.id }\n+ *      builder.memCol(\"Memory\" { _.memory }\n+ *\n+ *    Columns have additional options, such as controlling their sort keys; see the individual\n+ *    methods' documentation for more details.\n+ *\n+ *  - Call `build` to construct an immutable object which can be used to render tables.\n+ *   *\n+ * To remove some of the boilerplate here, you can statically import the `col` methods; for example:\n+ *\n+ *    val myTable: UITable[MyRowDataType] = {\n+ *      val builder = new UITableBuilder[MyRowDataType]()\n+ *      import builder._\n+ *      col(\"Name\") { _.name }\n+ *      [...]\n+ *      build\n+ *    }\n+ *\n+ * There are many other features, including support for arbitrary markup in custom column types;\n+ * see the actual uses in the web UI code for more details.\n+ *\n+ * @param fixedWidth if true, all columns will be rendered with the same width\n+ * @tparam T the type of the data items that will be used to render individual rows\n+ */\n+private[spark] class UITableBuilder[T](fixedWidth: Boolean = false) {\n+  private val cols = mutable.Buffer[UITableColumn[T, _]]()\n+\n+  /**\n+   * Display a column with custom HTML markup.  The markup should only describe how to\n+   * render the contents of the TD tag, not the TD tag itself.\n+   */\n+  def customCol[V](\n+    name: String,\n+    sortable: Boolean = true,\n+    sortKey: Option[T => String] = None)(renderer: T => Seq[Node]): UITableBuilder[T] = {\n+    val customColumn = new UITableColumn[T, T](name, null, sortable, sortKey, identity) {\n+      override def renderCellContents(row: T) = renderer(row)\n+    }\n+    cols.append(customColumn)\n+    this\n+  }\n+\n+  def col[V](\n+    name: String,\n+    formatter: V => String,\n+    sortable: Boolean = true,\n+    sortKey: Option[V => String] = None)(fieldExtractor: T => V): UITableBuilder[T] = {\n+    cols.append(UITableColumn(name, formatter, sortable, sortKey, fieldExtractor))\n+    this\n+  }\n+\n+  def col(\n+    name: String,\n+    sortable: Boolean = true,\n+    sortKey: Option[String => String] = None)(fieldExtractor: T => String): UITableBuilder[T] = {\n+    col[String](name, {x: String => x}, sortable, sortKey)(fieldExtractor)\n+  }\n+\n+  def intCol(\n+    name: String,\n+    formatter: Int => String = { x: Int => x.toString },\n+    sortable: Boolean = true)(fieldExtractor: T => Int): UITableBuilder[T] = {\n+    col[Int](name, formatter, sortable = sortable)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of memory sizes, in megabytes, as human-readable strings, such as \"4.0 MB\".\n+   */\n+  def memCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {\n+    col[Long](\n+      name,\n+      formatter = Utils.megabytesToString,\n+      sortKey = Some(x => x.toString))(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of dates as yyyy/MM/dd HH:mm:ss format.\n+   */\n+  def dateCol(name: String)(fieldExtractor: T => Date): UITableBuilder[T] = {\n+    col[Date](name, formatter = UIUtils.formatDate)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of dates as yyyy/MM/dd HH:mm:ss format.\n+   */\n+  def epochDateCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {\n+    col[Long](name, formatter = UIUtils.formatDate)(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of durations, in milliseconds, as human-readable strings, such as \"12 s\".\n+   */\n+  def durationCol(name: String)(fieldExtractor: T => Long): UITableBuilder[T] = {\n+    col[Long](name, formatter = UIUtils.formatDuration, sortKey = Some(_.toString))(fieldExtractor)\n+  }\n+\n+  /**\n+   * Display a column of optional durations, in milliseconds, as human-readable strings,\n+   * such as \"12 s\".  If the duration is None, then '-' will be displayed.\n+   */\n+  def optDurationCol(name: String)(fieldExtractor: T => Option[Long]): UITableBuilder[T] = {\n+    col[Option[Long]](\n+      name,\n+      formatter = { _.map(UIUtils.formatDuration).getOrElse(\"-\")},\n+      sortKey = Some(_.getOrElse(\"-\").toString)\n+    )(fieldExtractor)\n+  }\n+\n+  def build: UITable[T] = {"
  }],
  "prId": 2852
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "because this is a builder pattern, wouldn't it make more sense we call this addCustomCol, addCol, addIntCol...?\n",
    "commit": "1975cd6364d6403ec2d7f885743020b55b10fea9",
    "createdAt": "2014-10-23T19:18:23Z",
    "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.Date\n+\n+import scala.collection.mutable\n+import scala.xml.{Text, Node}\n+\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Describes how to render a column of values in a web UI table.\n+ *\n+ * @param name the name / title of this column\n+ * @param formatter function that formats values for display in the table\n+ * @param sortable if false, this column will not be sortable\n+ * @param sortKey optional function for sorting by a key other than `formatter(value)`\n+ * @param fieldExtractor function for extracting this field's value from the table's row data type\n+ * @tparam T the table's row data type\n+ * @tparam V this column's value type\n+ */\n+private case class UITableColumn[T, V](\n+  name: String,\n+  formatter: V => String,\n+  sortable: Boolean,\n+  sortKey: Option[V => String],\n+  fieldExtractor: T => V) {\n+\n+  /** Render the TD tag for this row */\n+  def renderCell(row: T): Seq[Node] =  {\n+    val data = fieldExtractor(row)\n+    val cellContents = renderCellContents(data)\n+    <td sorttable_customkey={sortKey.map(k => Text(k(data)))}>\n+      {cellContents}\n+    </td>\n+  }\n+\n+  /** Render the contents of the TD tag for this row.  The contents may be a string or HTML */\n+  def renderCellContents(data: V): Seq[Node] = {\n+    Text(formatter(data))\n+  }\n+}\n+\n+/**\n+ * Describes how to render a table to display rows of type `T`.\n+ * @param cols a sequence of UITableColumns that describe how each column should be rendered\n+ * @param fixedWidth if true, all columns of this table will be displayed with the same width\n+ * @tparam T the row data type\n+ */\n+private[spark] class UITable[T] (cols: Seq[UITableColumn[T, _]], fixedWidth: Boolean) {\n+\n+  private val tableClass = if (fixedWidth) {\n+    UIUtils.TABLE_CLASS + \" table-fixed\"\n+  } else {\n+    UIUtils.TABLE_CLASS\n+  }\n+\n+  private val colWidthAttr = if (fixedWidth) Some(Text((100.toDouble / cols.size) + \"%\")) else None\n+\n+  private val headerRow: Seq[Node] = {\n+    val headers = cols.map(_.name)\n+    // if none of the headers have \"\\n\" in them\n+    if (headers.forall(!_.contains(\"\\n\"))) {\n+      // represent header as simple text\n+      headers.map(h => <th width={colWidthAttr}>{h}</th>)\n+    } else {\n+      // represent header text as list while respecting \"\\n\"\n+      headers.map { case h =>\n+        <th width={colWidthAttr}>\n+          <ul class=\"unstyled\">\n+            { h.split(\"\\n\").map { case t => <li> {t} </li> } }\n+          </ul>\n+        </th>\n+      }\n+    }\n+  }\n+\n+  private def renderRow(row: T): Seq[Node] = {\n+    val tds = cols.map(_.renderCell(row))\n+    <tr>{ tds }</tr>\n+  }\n+\n+  /** Render the table with the given data */\n+  def render(data: Iterable[T]): Seq[Node] = {\n+    val rows = data.map(renderRow)\n+    <table class={tableClass}>\n+      <thead>{headerRow}</thead>\n+      <tbody>\n+        {rows}\n+      </tbody>\n+    </table>\n+  }\n+}\n+\n+/**\n+ * Builder for constructing web UI tables.  This builder offers several advantages over constructing\n+ * tables by hand using raw XML:\n+ *\n+ *  - All of the table's data and formatting logic can live in one place; the table headers and\n+ *    rows aren't described in separate code.  This prevents several common errors, like changing\n+ *    the ordering of two column headers but forgetting to re-order the corresponding TD tags.\n+ *\n+ *  - No repetition of code for type-specific display rules: common column types like \"memory\",\n+ *    \"duration\", and \"time\" have convenience methods that implement the right formatting logic.\n+ *\n+ *  - Details of our specific markup are generally abstracted away.  For example, the markup for\n+ *    setting a custom sort key on a column now lives in one place, rather than being repeated\n+ *    in each table.\n+ *\n+ * The recommended way of using this class:\n+ *\n+ *  - Create a new builder that is parametrized by the type (`T`) of data that you want to render.\n+ *    In many cases, there may be some record type like `WorkerInfo` that holds all of the\n+ *    information needed to render a particular row.  If the data for each table row comes from\n+ *    several objects, you can combine those objects into a tuple or case-class.\n+ *\n+ *  - Use the `col` methods to add columns to this builder.  The final argument of each `col` method\n+ *    is a function that extracts the column's field from a row object of type `T`.  Columns are\n+ *    displayed in the order that they are added to the builder.  For most columns, you can write\n+ *    code like\n+ *\n+ *      builder.col(\"Id\") { _.id }\n+ *      builder.memCol(\"Memory\" { _.memory }\n+ *\n+ *    Columns have additional options, such as controlling their sort keys; see the individual\n+ *    methods' documentation for more details.\n+ *\n+ *  - Call `build` to construct an immutable object which can be used to render tables.\n+ *   *\n+ * To remove some of the boilerplate here, you can statically import the `col` methods; for example:\n+ *\n+ *    val myTable: UITable[MyRowDataType] = {\n+ *      val builder = new UITableBuilder[MyRowDataType]()\n+ *      import builder._\n+ *      col(\"Name\") { _.name }\n+ *      [...]\n+ *      build\n+ *    }\n+ *\n+ * There are many other features, including support for arbitrary markup in custom column types;\n+ * see the actual uses in the web UI code for more details.\n+ *\n+ * @param fixedWidth if true, all columns will be rendered with the same width\n+ * @tparam T the type of the data items that will be used to render individual rows\n+ */\n+private[spark] class UITableBuilder[T](fixedWidth: Boolean = false) {\n+  private val cols = mutable.Buffer[UITableColumn[T, _]]()\n+\n+  /**\n+   * Display a column with custom HTML markup.  The markup should only describe how to\n+   * render the contents of the TD tag, not the TD tag itself.\n+   */\n+  def customCol[V]("
  }],
  "prId": 2852
}]