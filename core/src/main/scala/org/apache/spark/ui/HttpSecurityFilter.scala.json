[{
  "comments": [{
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "If other type of exception is coming, will there be a response sent to the client?",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T15:41:55Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You'll get an error 500.",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T18:18:04Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>"
  }],
  "prId": 23302
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "we didn't used to have this check.  Are you sure this is safe everywhere?  Eg. before if a param was `\"runtime>10ms\"` it would become `\"runtime&gt;10ms\"`, and with this change, it'll fail",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T16:25:31Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        // Do not allow the request to go further if any problem is detected.\n+        hres.setContentType(\"text/plain;charset=utf-8\")\n+        hres.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage())\n+        return\n+    }\n+\n+    // SPARK-10589 avoid frame-related click-jacking vulnerability, using X-Frame-Options\n+    // (see http://tools.ietf.org/html/rfc7034). By default allow framing only from the\n+    // same origin, but allow framing for a specific named URI.\n+    // Example: spark.ui.allowFramingFrom = https://example.com/\n+    val xFrameOptionsValue = conf.getOption(\"spark.ui.allowFramingFrom\")\n+      .map { uri => s\"ALLOW-FROM $uri\" }\n+      .getOrElse(\"SAMEORIGIN\")\n+\n+    hres.setHeader(\"X-Frame-Options\", xFrameOptionsValue)\n+    hres.setHeader(\"X-XSS-Protection\", conf.get(UI_X_XSS_PROTECTION))\n+    if (conf.get(UI_X_CONTENT_TYPE_OPTIONS)) {\n+      hres.setHeader(\"X-Content-Type-Options\", \"nosniff\")\n+    }\n+    if (hreq.getScheme() == \"https\") {\n+      conf.get(UI_STRICT_TRANSPORT_SECURITY).foreach(\n+        hres.setHeader(\"Strict-Transport-Security\", _))\n+    }\n+\n+    chain.doFilter(req, res)\n+  }\n+\n+  private def isSafe(str: String): Boolean = stripXSS(str) == str"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I'll take a look, but I don't remember any pages that use that sort of syntax.\r\n\r\n(I did find a separate issue with this filtering that I'll fix.)",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T18:52:19Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        // Do not allow the request to go further if any problem is detected.\n+        hres.setContentType(\"text/plain;charset=utf-8\")\n+        hres.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage())\n+        return\n+    }\n+\n+    // SPARK-10589 avoid frame-related click-jacking vulnerability, using X-Frame-Options\n+    // (see http://tools.ietf.org/html/rfc7034). By default allow framing only from the\n+    // same origin, but allow framing for a specific named URI.\n+    // Example: spark.ui.allowFramingFrom = https://example.com/\n+    val xFrameOptionsValue = conf.getOption(\"spark.ui.allowFramingFrom\")\n+      .map { uri => s\"ALLOW-FROM $uri\" }\n+      .getOrElse(\"SAMEORIGIN\")\n+\n+    hres.setHeader(\"X-Frame-Options\", xFrameOptionsValue)\n+    hres.setHeader(\"X-XSS-Protection\", conf.get(UI_X_XSS_PROTECTION))\n+    if (conf.get(UI_X_CONTENT_TYPE_OPTIONS)) {\n+      hres.setHeader(\"X-Content-Type-Options\", \"nosniff\")\n+    }\n+    if (hreq.getScheme() == \"https\") {\n+      conf.get(UI_STRICT_TRANSPORT_SECURITY).foreach(\n+        hres.setHeader(\"Strict-Transport-Security\", _))\n+    }\n+\n+    chain.doFilter(req, res)\n+  }\n+\n+  private def isSafe(str: String): Boolean = stripXSS(str) == str"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "It seems that while no pages I found use that syntax, the search boxes in the fancy task page (and probably other places) don't like this if you type an unexpected character.\r\n\r\nI'll have to think about how to fix that and still keep this logic centralized...",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T19:11:12Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        // Do not allow the request to go further if any problem is detected.\n+        hres.setContentType(\"text/plain;charset=utf-8\")\n+        hres.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage())\n+        return\n+    }\n+\n+    // SPARK-10589 avoid frame-related click-jacking vulnerability, using X-Frame-Options\n+    // (see http://tools.ietf.org/html/rfc7034). By default allow framing only from the\n+    // same origin, but allow framing for a specific named URI.\n+    // Example: spark.ui.allowFramingFrom = https://example.com/\n+    val xFrameOptionsValue = conf.getOption(\"spark.ui.allowFramingFrom\")\n+      .map { uri => s\"ALLOW-FROM $uri\" }\n+      .getOrElse(\"SAMEORIGIN\")\n+\n+    hres.setHeader(\"X-Frame-Options\", xFrameOptionsValue)\n+    hres.setHeader(\"X-XSS-Protection\", conf.get(UI_X_XSS_PROTECTION))\n+    if (conf.get(UI_X_CONTENT_TYPE_OPTIONS)) {\n+      hres.setHeader(\"X-Content-Type-Options\", \"nosniff\")\n+    }\n+    if (hreq.getScheme() == \"https\") {\n+      conf.get(UI_STRICT_TRANSPORT_SECURITY).foreach(\n+        hres.setHeader(\"Strict-Transport-Security\", _))\n+    }\n+\n+    chain.doFilter(req, res)\n+  }\n+\n+  private def isSafe(str: String): Boolean = stripXSS(str) == str"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "I see, the reason you don't just update the params is that the `HttpServletRequest` doesn't let you?\r\n\r\nThe only workaround I can think of is to stuff the modified values into an attribute of the ServletContext, and then have a style rule to ban directly accessing them.",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T19:43:24Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        // Do not allow the request to go further if any problem is detected.\n+        hres.setContentType(\"text/plain;charset=utf-8\")\n+        hres.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage())\n+        return\n+    }\n+\n+    // SPARK-10589 avoid frame-related click-jacking vulnerability, using X-Frame-Options\n+    // (see http://tools.ietf.org/html/rfc7034). By default allow framing only from the\n+    // same origin, but allow framing for a specific named URI.\n+    // Example: spark.ui.allowFramingFrom = https://example.com/\n+    val xFrameOptionsValue = conf.getOption(\"spark.ui.allowFramingFrom\")\n+      .map { uri => s\"ALLOW-FROM $uri\" }\n+      .getOrElse(\"SAMEORIGIN\")\n+\n+    hres.setHeader(\"X-Frame-Options\", xFrameOptionsValue)\n+    hres.setHeader(\"X-XSS-Protection\", conf.get(UI_X_XSS_PROTECTION))\n+    if (conf.get(UI_X_CONTENT_TYPE_OPTIONS)) {\n+      hres.setHeader(\"X-Content-Type-Options\", \"nosniff\")\n+    }\n+    if (hreq.getScheme() == \"https\") {\n+      conf.get(UI_STRICT_TRANSPORT_SECURITY).foreach(\n+        hres.setHeader(\"Strict-Transport-Security\", _))\n+    }\n+\n+    chain.doFilter(req, res)\n+  }\n+\n+  private def isSafe(str: String): Boolean = stripXSS(str) == str"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I can use an `HttpServletRequestWrapper` to do that, I just thought it would be better (and easier) to just error out instead of modifying the request. I'll go that route instead, at least we know the behavior will be the same and won't break something inadvertently...",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T19:49:24Z",
    "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import javax.servlet._\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.commons.lang3.StringEscapeUtils\n+\n+import org.apache.spark.{SecurityManager, SparkConf}\n+import org.apache.spark.internal.config._\n+\n+/**\n+ * A servlet filter that implements HTTP security features. The following actions are taken\n+ * for every request:\n+ *\n+ * - perform access control of authenticated requests.\n+ * - check request data for disallowed content (e.g. things that could be used to create XSS\n+ *   attacks).\n+ * - set response headers to prevent certain kinds of attacks.\n+ */\n+private class HttpSecurityFilter(\n+    conf: SparkConf,\n+    securityMgr: SecurityManager) extends Filter {\n+\n+  private val NEWLINE_AND_SINGLE_QUOTE_REGEX = raw\"(?i)(\\r\\n|\\n|\\r|%0D%0A|%0A|%0D|'|%27)\".r\n+\n+  override def destroy(): Unit = { }\n+\n+  override def init(config: FilterConfig): Unit = { }\n+\n+  override def doFilter(req: ServletRequest, res: ServletResponse, chain: FilterChain): Unit = {\n+    val hreq = req.asInstanceOf[HttpServletRequest]\n+    val hres = res.asInstanceOf[HttpServletResponse]\n+    hres.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+\n+    if (!securityMgr.checkUIViewPermissions(hreq.getRemoteUser())) {\n+      hres.sendError(HttpServletResponse.SC_FORBIDDEN,\n+        \"User is not authorized to access this page.\")\n+      return\n+    }\n+\n+    // Check if any disallowed content is in the incoming headers or parameters. This filters\n+    // out content that could be used for XSS attacks from even making it to the UI handlers.\n+    try {\n+      hreq.getHeaderNames().asScala.foreach { k =>\n+        require(isSafe(k), \"Request header name contains disallowed content.\")\n+        hreq.getHeaders(k).asScala.foreach { v =>\n+          require(isSafe(v), s\"Header value for $k contains disallowed content.\")\n+        }\n+      }\n+\n+      hreq.getParameterMap().asScala.foreach { case (k, values) =>\n+        require(isSafe(k), \"Parameter name contains disallowed content.\")\n+        values.foreach { v =>\n+          require(isSafe(v), s\"Parameter value for $k contains disallowed content.\")\n+        }\n+      }\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        // Do not allow the request to go further if any problem is detected.\n+        hres.setContentType(\"text/plain;charset=utf-8\")\n+        hres.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage())\n+        return\n+    }\n+\n+    // SPARK-10589 avoid frame-related click-jacking vulnerability, using X-Frame-Options\n+    // (see http://tools.ietf.org/html/rfc7034). By default allow framing only from the\n+    // same origin, but allow framing for a specific named URI.\n+    // Example: spark.ui.allowFramingFrom = https://example.com/\n+    val xFrameOptionsValue = conf.getOption(\"spark.ui.allowFramingFrom\")\n+      .map { uri => s\"ALLOW-FROM $uri\" }\n+      .getOrElse(\"SAMEORIGIN\")\n+\n+    hres.setHeader(\"X-Frame-Options\", xFrameOptionsValue)\n+    hres.setHeader(\"X-XSS-Protection\", conf.get(UI_X_XSS_PROTECTION))\n+    if (conf.get(UI_X_CONTENT_TYPE_OPTIONS)) {\n+      hres.setHeader(\"X-Content-Type-Options\", \"nosniff\")\n+    }\n+    if (hreq.getScheme() == \"https\") {\n+      conf.get(UI_STRICT_TRANSPORT_SECURITY).foreach(\n+        hres.setHeader(\"Strict-Transport-Security\", _))\n+    }\n+\n+    chain.doFilter(req, res)\n+  }\n+\n+  private def isSafe(str: String): Boolean = stripXSS(str) == str"
  }],
  "prId": 23302
}]