[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "We don't want to use .toString for sorting order of numeric columns, right?\n",
    "commit": "39dad9080b1dcece2f10eeee1f5d85b2964afa33",
    "createdAt": "2014-06-19T17:14:06Z",
    "diffHunk": "@@ -67,18 +67,20 @@ private[ui] class ExecutorTable(stageId: Int, parent: JobProgressTab) {\n     executorIdToSummary match {\n       case Some(x) =>\n         x.toSeq.sortBy(_._1).map { case (k, v) => {\n+          // scalastyle:off\n           <tr>\n             <td>{k}</td>\n             <td>{executorIdToAddress.getOrElse(k, \"CANNOT FIND ADDRESS\")}</td>\n-            <td>{UIUtils.formatDuration(v.taskTime)}</td>\n+            <td sorttable_customekey={v.taskTime.toString}>{UIUtils.formatDuration(v.taskTime)}</td>\n             <td>{v.failedTasks + v.succeededTasks}</td>\n             <td>{v.failedTasks}</td>\n             <td>{v.succeededTasks}</td>\n-            <td>{Utils.bytesToString(v.shuffleRead)}</td>\n-            <td>{Utils.bytesToString(v.shuffleWrite)}</td>\n-            <td>{Utils.bytesToString(v.memoryBytesSpilled)}</td>\n-            <td>{Utils.bytesToString(v.diskBytesSpilled)}</td>\n+            <td sorttable_customekey={v.shuffleRead.toString}>{Utils.bytesToString(v.shuffleRead)}</td>",
    "line": 17
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "There must be a string, or compile error.\n\n```\n[error] /Users/witgo/work/code/java/spark/core/src/main/scala/org/apache/spark/ui/jobs/ExecutorTable.scala:78: overloaded method constructor UnprefixedAttribute with alternatives:\n[error]   (key: String,value: Option[Seq[scala.xml.Node]],next: scala.xml.MetaData)scala.xml.UnprefixedAttribute <and>\n[error]   (key: String,value: String,next: scala.xml.MetaData)scala.xml.UnprefixedAttribute <and>\n[error]   (key: String,value: Seq[scala.xml.Node],next1: scala.xml.MetaData)scala.xml.UnprefixedAttribute\n[error]  cannot be applied to (String, Long, scala.xml.MetaData)\n[error]             <td sorttable_customekey={v.shuffleRead}>{Utils.bytesToString(v.shuffleRead)}</td>\n[error]           \n```\n",
    "commit": "39dad9080b1dcece2f10eeee1f5d85b2964afa33",
    "createdAt": "2014-06-20T02:40:38Z",
    "diffHunk": "@@ -67,18 +67,20 @@ private[ui] class ExecutorTable(stageId: Int, parent: JobProgressTab) {\n     executorIdToSummary match {\n       case Some(x) =>\n         x.toSeq.sortBy(_._1).map { case (k, v) => {\n+          // scalastyle:off\n           <tr>\n             <td>{k}</td>\n             <td>{executorIdToAddress.getOrElse(k, \"CANNOT FIND ADDRESS\")}</td>\n-            <td>{UIUtils.formatDuration(v.taskTime)}</td>\n+            <td sorttable_customekey={v.taskTime.toString}>{UIUtils.formatDuration(v.taskTime)}</td>\n             <td>{v.failedTasks + v.succeededTasks}</td>\n             <td>{v.failedTasks}</td>\n             <td>{v.succeededTasks}</td>\n-            <td>{Utils.bytesToString(v.shuffleRead)}</td>\n-            <td>{Utils.bytesToString(v.shuffleWrite)}</td>\n-            <td>{Utils.bytesToString(v.memoryBytesSpilled)}</td>\n-            <td>{Utils.bytesToString(v.diskBytesSpilled)}</td>\n+            <td sorttable_customekey={v.shuffleRead.toString}>{Utils.bytesToString(v.shuffleRead)}</td>",
    "line": 17
  }, {
    "author": {
      "login": "coderxiang"
    },
    "body": "Strangely in the RDD page, the sorting is also by string but it displays\ncorrectly. I haven't gone through all the implementation so I'm not sure\nabout why this happens. It looks like the sorttable_customkey only accepts\nstring as key, a not-so-good work around would be using fixed length string\nwith preceding zeros.\n\nOn Thu, Jun 19, 2014 at 7:40 PM, Guoqiang Li notifications@github.com\nwrote:\n\n> In core/src/main/scala/org/apache/spark/ui/jobs/ExecutorTable.scala:\n> \n> > ```\n> >          <td>{v.failedTasks + v.succeededTasks}</td>\n> >          <td>{v.failedTasks}</td>\n> >          <td>{v.succeededTasks}</td>\n> > ```\n> > -            <td>{Utils.bytesToString(v.shuffleRead)}</td>\n> > -            <td>{Utils.bytesToString(v.shuffleWrite)}</td>\n> > -            <td>{Utils.bytesToString(v.memoryBytesSpilled)}</td>\n> > -            <td>{Utils.bytesToString(v.diskBytesSpilled)}</td>\n> > -            <td sorttable_customekey={v.shuffleRead.toString}>{Utils.bytesToString(v.shuffleRead)}</td>\n> \n> There must be a string, or compile error.\n> \n> [error] /Users/witgo/work/code/java/spark/core/src/main/scala/org/apache/spark/ui/jobs/ExecutorTable.scala:78: overloaded method constructor UnprefixedAttribute with alternatives:\n> [error](key: String,value: Option[Seq[scala.xml.Node]],next: scala.xml.MetaData)scala.xml.UnprefixedAttribute <and>\n> [error](key: String,value: String,next: scala.xml.MetaData)scala.xml.UnprefixedAttribute <and>\n> [error](key: String,value: Seq[scala.xml.Node],next1: scala.xml.MetaData)scala.xml.UnprefixedAttribute\n> [error]  cannot be applied to (String, Long, scala.xml.MetaData)\n> [error]             <td sorttable_customekey={v.shuffleRead}>{Utils.bytesToString(v.shuffleRead)}</td>\n> [error]\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/apache/spark/pull/1135/files#r14005150.\n",
    "commit": "39dad9080b1dcece2f10eeee1f5d85b2964afa33",
    "createdAt": "2014-06-25T18:21:41Z",
    "diffHunk": "@@ -67,18 +67,20 @@ private[ui] class ExecutorTable(stageId: Int, parent: JobProgressTab) {\n     executorIdToSummary match {\n       case Some(x) =>\n         x.toSeq.sortBy(_._1).map { case (k, v) => {\n+          // scalastyle:off\n           <tr>\n             <td>{k}</td>\n             <td>{executorIdToAddress.getOrElse(k, \"CANNOT FIND ADDRESS\")}</td>\n-            <td>{UIUtils.formatDuration(v.taskTime)}</td>\n+            <td sorttable_customekey={v.taskTime.toString}>{UIUtils.formatDuration(v.taskTime)}</td>\n             <td>{v.failedTasks + v.succeededTasks}</td>\n             <td>{v.failedTasks}</td>\n             <td>{v.succeededTasks}</td>\n-            <td>{Utils.bytesToString(v.shuffleRead)}</td>\n-            <td>{Utils.bytesToString(v.shuffleWrite)}</td>\n-            <td>{Utils.bytesToString(v.memoryBytesSpilled)}</td>\n-            <td>{Utils.bytesToString(v.diskBytesSpilled)}</td>\n+            <td sorttable_customekey={v.shuffleRead.toString}>{Utils.bytesToString(v.shuffleRead)}</td>",
    "line": 17
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "sorttable accepts the custom keys as HTML attributes, so they are untyped (they are strings). However, I think it tries to infer the data type so it will e.g. correctly covert them to integers.\n\nThe issue in the code here is that Scala's XML DSL only allows you to interpolate string expressions. So I think it's fine to call \"toString\" on these when we pass them to XML. \n",
    "commit": "39dad9080b1dcece2f10eeee1f5d85b2964afa33",
    "createdAt": "2014-06-25T19:21:02Z",
    "diffHunk": "@@ -67,18 +67,20 @@ private[ui] class ExecutorTable(stageId: Int, parent: JobProgressTab) {\n     executorIdToSummary match {\n       case Some(x) =>\n         x.toSeq.sortBy(_._1).map { case (k, v) => {\n+          // scalastyle:off\n           <tr>\n             <td>{k}</td>\n             <td>{executorIdToAddress.getOrElse(k, \"CANNOT FIND ADDRESS\")}</td>\n-            <td>{UIUtils.formatDuration(v.taskTime)}</td>\n+            <td sorttable_customekey={v.taskTime.toString}>{UIUtils.formatDuration(v.taskTime)}</td>\n             <td>{v.failedTasks + v.succeededTasks}</td>\n             <td>{v.failedTasks}</td>\n             <td>{v.succeededTasks}</td>\n-            <td>{Utils.bytesToString(v.shuffleRead)}</td>\n-            <td>{Utils.bytesToString(v.shuffleWrite)}</td>\n-            <td>{Utils.bytesToString(v.memoryBytesSpilled)}</td>\n-            <td>{Utils.bytesToString(v.diskBytesSpilled)}</td>\n+            <td sorttable_customekey={v.shuffleRead.toString}>{Utils.bytesToString(v.shuffleRead)}</td>",
    "line": 17
  }],
  "prId": 1135
}]