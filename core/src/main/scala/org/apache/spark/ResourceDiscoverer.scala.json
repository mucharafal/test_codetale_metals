[{
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "could `Seq[JsonResourceInformation]` contain duplicated name? might be (very marginally) better to do \r\n`resource.toMap.map(...)`",
    "commit": "c046f07f2fb4850a75b954ec423e27c231b36aff",
    "createdAt": "2019-05-29T04:29:49Z",
    "diffHunk": "@@ -132,4 +132,20 @@ private[spark] object ResourceDiscoverer extends Logging {\n       }\n     }\n   }\n+\n+  def parseAllocatedFromJsonFile(resourcesFile: String): Map[String, ResourceInformation] = {\n+    implicit val formats = DefaultFormats\n+    // case class to make json4s parsing easy\n+    case class JsonResourceInformation(val name: String, val addresses: Array[String])\n+    val resourceInput = new BufferedInputStream(new FileInputStream(resourcesFile))\n+    val resources = try {\n+      parse(resourceInput).extract[Seq[JsonResourceInformation]]\n+    } catch {\n+      case e@(_: MappingException | _: MismatchedInputException | _: ClassCastException) =>\n+        throw new SparkException(s\"Exception parsing the resources in $resourcesFile\", e)\n+    } finally {\n+      resourceInput.close()\n+    }\n+    resources.map(r => (r.name, new ResourceInformation(r.name, r.addresses))).toMap",
    "line": 32
  }, {
    "author": {
      "login": "tgravescs"
    },
    "body": "Sorry, I'm missing what you are saying here with the toMap.map?  I can't do the toMap until I do the first map to (name, ResourceInformation), otherwise you just have a Seq[JsonResourceInformation] and toMap doesn't know how to make that a map. If there are 2 resource with the same name when the current code runs the toMap will choose the last one.\r\n\r\nI had actually tested this and found the json4s parse and extract actually are handling duplicates as well, looks like it chooses the last one, I couldn't find docs on that behavior though either. The resourcesfile is built by the standalone master/worker so it shouldn't really have duplicates.  I'm happy to update though to be explicit so just let me know.",
    "commit": "c046f07f2fb4850a75b954ec423e27c231b36aff",
    "createdAt": "2019-05-29T13:47:46Z",
    "diffHunk": "@@ -132,4 +132,20 @@ private[spark] object ResourceDiscoverer extends Logging {\n       }\n     }\n   }\n+\n+  def parseAllocatedFromJsonFile(resourcesFile: String): Map[String, ResourceInformation] = {\n+    implicit val formats = DefaultFormats\n+    // case class to make json4s parsing easy\n+    case class JsonResourceInformation(val name: String, val addresses: Array[String])\n+    val resourceInput = new BufferedInputStream(new FileInputStream(resourcesFile))\n+    val resources = try {\n+      parse(resourceInput).extract[Seq[JsonResourceInformation]]\n+    } catch {\n+      case e@(_: MappingException | _: MismatchedInputException | _: ClassCastException) =>\n+        throw new SparkException(s\"Exception parsing the resources in $resourcesFile\", e)\n+    } finally {\n+      resourceInput.close()\n+    }\n+    resources.map(r => (r.name, new ResourceInformation(r.name, r.addresses))).toMap",
    "line": 32
  }, {
    "author": {
      "login": "felixcheung"
    },
    "body": "ah yes ;) I just mean it walking through a `Seq` when the goal is a `Map`",
    "commit": "c046f07f2fb4850a75b954ec423e27c231b36aff",
    "createdAt": "2019-05-30T05:03:12Z",
    "diffHunk": "@@ -132,4 +132,20 @@ private[spark] object ResourceDiscoverer extends Logging {\n       }\n     }\n   }\n+\n+  def parseAllocatedFromJsonFile(resourcesFile: String): Map[String, ResourceInformation] = {\n+    implicit val formats = DefaultFormats\n+    // case class to make json4s parsing easy\n+    case class JsonResourceInformation(val name: String, val addresses: Array[String])\n+    val resourceInput = new BufferedInputStream(new FileInputStream(resourcesFile))\n+    val resources = try {\n+      parse(resourceInput).extract[Seq[JsonResourceInformation]]\n+    } catch {\n+      case e@(_: MappingException | _: MismatchedInputException | _: ClassCastException) =>\n+        throw new SparkException(s\"Exception parsing the resources in $resourcesFile\", e)\n+    } finally {\n+      resourceInput.close()\n+    }\n+    resources.map(r => (r.name, new ResourceInformation(r.name, r.addresses))).toMap",
    "line": 32
  }],
  "prId": 24730
}]