[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: indented too far (Spark's convention is 2 spaces for the continuation line).\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-05T21:39:06Z",
    "diffHunk": "@@ -42,28 +43,52 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true\n+}\n \n-private[spark] object CompressionCodec {\n+private[spark] object CompressionCodec extends Logging {\n \n+  private val configKey = \"spark.io.compression.codec\"\n   private val shortCompressionCodecNames = Map(\n     \"lz4\" -> classOf[LZ4CompressionCodec].getName,\n     \"lzf\" -> classOf[LZFCompressionCodec].getName,\n     \"snappy\" -> classOf[SnappyCompressionCodec].getName)\n \n   def createCodec(conf: SparkConf): CompressionCodec = {\n-    createCodec(conf, conf.get(\"spark.io.compression.codec\", DEFAULT_COMPRESSION_CODEC))\n+    conf.getOption(configKey)\n+        .map(createCodec(conf, _))"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I think this message will be a little confusing, since only the fallback codec would be listed and it might be easy to miss the warning log. Maybe rephrase it as \"No default compression codec implementation is available\"?\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-05T21:40:48Z",
    "diffHunk": "@@ -42,28 +43,52 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true\n+}\n \n-private[spark] object CompressionCodec {\n+private[spark] object CompressionCodec extends Logging {\n \n+  private val configKey = \"spark.io.compression.codec\"\n   private val shortCompressionCodecNames = Map(\n     \"lz4\" -> classOf[LZ4CompressionCodec].getName,\n     \"lzf\" -> classOf[LZFCompressionCodec].getName,\n     \"snappy\" -> classOf[SnappyCompressionCodec].getName)\n \n   def createCodec(conf: SparkConf): CompressionCodec = {\n-    createCodec(conf, conf.get(\"spark.io.compression.codec\", DEFAULT_COMPRESSION_CODEC))\n+    conf.getOption(configKey)\n+        .map(createCodec(conf, _))\n+        .orElse(createCodecFromName(conf, DEFAULT_COMPRESSION_CODEC))\n+        .orElse({\n+          logWarning(\"Default codec \" + DEFAULT_COMPRESSION_CODEC +\n+            \" is unavailable. Faling back to \" + FALLBACK_COMPRESSION_CODEC)\n+          createCodecFromName(conf, FALLBACK_COMPRESSION_CODEC)\n+        })\n+        .getOrElse(throw new IllegalArgumentException(\"The codec [\" +"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Interpolation is probably prettier here:\n\n```\ns\"The specified codec [$codecName] is not available.\"\n```\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-05T21:41:39Z",
    "diffHunk": "@@ -42,28 +43,52 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true\n+}\n \n-private[spark] object CompressionCodec {\n+private[spark] object CompressionCodec extends Logging {\n \n+  private val configKey = \"spark.io.compression.codec\"\n   private val shortCompressionCodecNames = Map(\n     \"lz4\" -> classOf[LZ4CompressionCodec].getName,\n     \"lzf\" -> classOf[LZFCompressionCodec].getName,\n     \"snappy\" -> classOf[SnappyCompressionCodec].getName)\n \n   def createCodec(conf: SparkConf): CompressionCodec = {\n-    createCodec(conf, conf.get(\"spark.io.compression.codec\", DEFAULT_COMPRESSION_CODEC))\n+    conf.getOption(configKey)\n+        .map(createCodec(conf, _))\n+        .orElse(createCodecFromName(conf, DEFAULT_COMPRESSION_CODEC))\n+        .orElse({\n+          logWarning(\"Default codec \" + DEFAULT_COMPRESSION_CODEC +\n+            \" is unavailable. Faling back to \" + FALLBACK_COMPRESSION_CODEC)\n+          createCodecFromName(conf, FALLBACK_COMPRESSION_CODEC)\n+        })\n+        .getOrElse(throw new IllegalArgumentException(\"The codec [\" +\n+          FALLBACK_COMPRESSION_CODEC + \"] is not available.\"))\n   }\n \n   def createCodec(conf: SparkConf, codecName: String): CompressionCodec = {\n+    createCodecFromName(conf, codecName)\n+      .getOrElse(throw new IllegalArgumentException(\"The specified codec [\" +"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: fits in previous line? (limit is 100 chars)\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-05T21:42:05Z",
    "diffHunk": "@@ -42,28 +43,52 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true\n+}\n \n-private[spark] object CompressionCodec {\n+private[spark] object CompressionCodec extends Logging {\n \n+  private val configKey = \"spark.io.compression.codec\"\n   private val shortCompressionCodecNames = Map(\n     \"lz4\" -> classOf[LZ4CompressionCodec].getName,\n     \"lzf\" -> classOf[LZFCompressionCodec].getName,\n     \"snappy\" -> classOf[SnappyCompressionCodec].getName)\n \n   def createCodec(conf: SparkConf): CompressionCodec = {\n-    createCodec(conf, conf.get(\"spark.io.compression.codec\", DEFAULT_COMPRESSION_CODEC))\n+    conf.getOption(configKey)\n+        .map(createCodec(conf, _))\n+        .orElse(createCodecFromName(conf, DEFAULT_COMPRESSION_CODEC))\n+        .orElse({\n+          logWarning(\"Default codec \" + DEFAULT_COMPRESSION_CODEC +\n+            \" is unavailable. Faling back to \" + FALLBACK_COMPRESSION_CODEC)\n+          createCodecFromName(conf, FALLBACK_COMPRESSION_CODEC)\n+        })\n+        .getOrElse(throw new IllegalArgumentException(\"The codec [\" +\n+          FALLBACK_COMPRESSION_CODEC + \"] is not available.\"))\n   }\n \n   def createCodec(conf: SparkConf, codecName: String): CompressionCodec = {\n+    createCodecFromName(conf, codecName)\n+      .getOrElse(throw new IllegalArgumentException(\"The specified codec [\" +\n+                  codecName + \"] is not available.\"))\n+  }\n+\n+  private def createCodecFromName(conf: SparkConf, codecName : String)\n+      : Option[CompressionCodec] = {\n     val codecClass = shortCompressionCodecNames.getOrElse(codecName.toLowerCase, codecName)\n-    val ctor = Class.forName(codecClass, true, Utils.getContextOrSparkClassLoader)\n-      .getConstructor(classOf[SparkConf])\n-    ctor.newInstance(conf).asInstanceOf[CompressionCodec]\n+    try {\n+      val ctor = Class.forName(codecClass, true, Utils.getContextOrSparkClassLoader)\n+        .getConstructor(classOf[SparkConf])\n+      Some(ctor.newInstance(conf).asInstanceOf[CompressionCodec])\n+        .filter(_.isAvailable())"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "So, I know I suggested this, but I think this doesn't do the same thing as the PR description says.\n\nIf the config option exists and the requested codec is not available, this will always try the default codecs. Instead, this should probably be something like:\n\n```\nif (conf.contains(configKey)) {\n   createCodec(...).getOrElse(throw new Blah(\"requested codec cannot be loaded\"))\n} else\n   createCodec(DEFAULT).orElse(createCodec(FALLBACK)).getOrElse(throw new Blah(\"cannot load defaults\"))\n}\n```\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-05T21:53:19Z",
    "diffHunk": "@@ -42,28 +43,52 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true\n+}\n \n-private[spark] object CompressionCodec {\n+private[spark] object CompressionCodec extends Logging {\n \n+  private val configKey = \"spark.io.compression.codec\"\n   private val shortCompressionCodecNames = Map(\n     \"lz4\" -> classOf[LZ4CompressionCodec].getName,\n     \"lzf\" -> classOf[LZFCompressionCodec].getName,\n     \"snappy\" -> classOf[SnappyCompressionCodec].getName)\n \n   def createCodec(conf: SparkConf): CompressionCodec = {\n-    createCodec(conf, conf.get(\"spark.io.compression.codec\", DEFAULT_COMPRESSION_CODEC))\n+    conf.getOption(configKey)\n+        .map(createCodec(conf, _))\n+        .orElse(createCodecFromName(conf, DEFAULT_COMPRESSION_CODEC))"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`extends Logging` is not needed anymore?\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-13T23:18:44Z",
    "diffHunk": "@@ -42,10 +43,11 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true\n+}\n \n-private[spark] object CompressionCodec {\n+private[spark] object CompressionCodec extends Logging {"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Hmm. This is fine, but one suggestion in the bug was to have extra wording for the case where the default codec is not available, suggesting to the user to change the configuration to set the codec to LZF instead. I think that would be a nice thing to have, since that's probably the most common case of this exception happening.\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-13T23:24:39Z",
    "diffHunk": "@@ -58,9 +60,15 @@ private[spark] object CompressionCodec {\n \n   def createCodec(conf: SparkConf, codecName: String): CompressionCodec = {\n     val codecClass = shortCompressionCodecNames.getOrElse(codecName.toLowerCase, codecName)\n-    val ctor = Class.forName(codecClass, true, Utils.getContextOrSparkClassLoader)\n-      .getConstructor(classOf[SparkConf])\n-    ctor.newInstance(conf).asInstanceOf[CompressionCodec]\n+    val codec = try {\n+      val ctor = Class.forName(codecClass, true, Utils.getContextOrSparkClassLoader)\n+        .getConstructor(classOf[SparkConf])\n+      Some(ctor.newInstance(conf).asInstanceOf[CompressionCodec])\n+    } catch {\n+      case e: ClassNotFoundException => None\n+    }\n+    codec.filter(_.isAvailable())\n+      .getOrElse(throw new IllegalArgumentException(s\"Codec [$codecName] is not available.\"))"
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "This seems like a good idea.\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-17T23:15:28Z",
    "diffHunk": "@@ -58,9 +60,15 @@ private[spark] object CompressionCodec {\n \n   def createCodec(conf: SparkConf, codecName: String): CompressionCodec = {\n     val codecClass = shortCompressionCodecNames.getOrElse(codecName.toLowerCase, codecName)\n-    val ctor = Class.forName(codecClass, true, Utils.getContextOrSparkClassLoader)\n-      .getConstructor(classOf[SparkConf])\n-    ctor.newInstance(conf).asInstanceOf[CompressionCodec]\n+    val codec = try {\n+      val ctor = Class.forName(codecClass, true, Utils.getContextOrSparkClassLoader)\n+        .getConstructor(classOf[SparkConf])\n+      Some(ctor.newInstance(conf).asInstanceOf[CompressionCodec])\n+    } catch {\n+      case e: ClassNotFoundException => None\n+    }\n+    codec.filter(_.isAvailable())\n+      .getOrElse(throw new IllegalArgumentException(s\"Codec [$codecName] is not available.\"))"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "This trait is exposed so adding a method here will actually break binary compatibility with any user-defined compression codecs. We've usually tried not to do this in the past unless we had a situation where there was no work around, so what about just dealing with this directly inside the Snappy codec? I.e. just check when the snappy codec is instantiated and throw this exception if it's not available. It's slightly less general, but a simpler patch and we don't risk breaking user-defined codecs.\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-24T22:57:57Z",
    "diffHunk": "@@ -42,27 +43,37 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true"
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "By the way - the fact that you cannot safely add a method with a default implementation to a trait is not intuitive at all. You can checkout this article for more information why this is:\n\nhttp://stackoverflow.com/questions/18366817/is-adding-a-trait-method-with-implementation-breaking-backward-compatibility\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-11-25T00:39:35Z",
    "diffHunk": "@@ -42,27 +43,37 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true"
  }, {
    "author": {
      "login": "ksakellis"
    },
    "body": "oh geez. thanks for the link. it makes sense but yes, not what you would expect from traits. I'll update the pr.\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-12-01T19:02:51Z",
    "diffHunk": "@@ -42,27 +43,37 @@ trait CompressionCodec {\n   def compressedOutputStream(s: OutputStream): OutputStream\n \n   def compressedInputStream(s: InputStream): InputStream\n-}\n \n+  def isAvailable() : Boolean = true"
  }],
  "prId": 3119
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Should we instead check for `Snappy.isLoaded()`? This way seems more roundabout.\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-12-15T22:58:58Z",
    "diffHunk": "@@ -120,6 +129,12 @@ class LZFCompressionCodec(conf: SparkConf) extends CompressionCodec {\n @DeveloperApi\n class SnappyCompressionCodec(conf: SparkConf) extends CompressionCodec {\n \n+  try {\n+    Snappy.getNativeLibraryVersion",
    "line": 58
  }, {
    "author": {
      "login": "ksakellis"
    },
    "body": "@pwendell can you point to the api you are talking about? \nhttps://github.com/xerial/snappy-java/tree/1.1.1.6/src/main/java/org/xerial/snappy\nI don't see a Snappy.isLoaded() API. There is a member variable in SnappyLoader but that is private. \n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-12-16T19:04:45Z",
    "diffHunk": "@@ -120,6 +129,12 @@ class LZFCompressionCodec(conf: SparkConf) extends CompressionCodec {\n @DeveloperApi\n class SnappyCompressionCodec(conf: SparkConf) extends CompressionCodec {\n \n+  try {\n+    Snappy.getNativeLibraryVersion",
    "line": 58
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "I was thinking about this, but it's private: https://github.com/xerial/snappy-java/blob/master/src/main/java/org/xerial/snappy/SnappyLoader.java#L83\n",
    "commit": "9709c7c605d607b19655ea8f592394be77cadb5b",
    "createdAt": "2014-12-22T21:06:31Z",
    "diffHunk": "@@ -120,6 +129,12 @@ class LZFCompressionCodec(conf: SparkConf) extends CompressionCodec {\n @DeveloperApi\n class SnappyCompressionCodec(conf: SparkConf) extends CompressionCodec {\n \n+  try {\n+    Snappy.getNativeLibraryVersion",
    "line": 58
  }],
  "prId": 3119
}]