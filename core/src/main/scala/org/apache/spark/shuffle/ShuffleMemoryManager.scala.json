[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "We should add Scaladoc here to clarify that this is asking the consumer to release memory but that the consumer might release more or less memory than we asked for (or none at all!). Should we give this method a different name that suggests this, such as `askToRelease()`?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-26T00:46:39Z",
    "diffHunk": "@@ -27,6 +29,11 @@ import org.apache.spark.memory.{StaticMemoryManager, MemoryManager}\n import org.apache.spark.storage.{BlockId, BlockStatus}\n import org.apache.spark.unsafe.array.ByteArrayMethods\n \n+abstract class MemoryConsumer {\n+  @throws[IOException]\n+  def release(numBytes: Long): Long"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Should we add an assert and guard against requesting a negative amount of memory, since that probably indicates a bug elsewhere?\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-26T00:49:21Z",
    "diffHunk": "@@ -90,33 +101,55 @@ class ShuffleMemoryManager protected (\n \n       // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n       // don't let it be negative\n-      val maxToGrant = math.min(numBytes, math.max(0, (maxMemory / numActiveTasks) - curMem))\n-      // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n-      val toGrant = math.min(maxToGrant, freeMemory)\n-\n-      if (curMem < maxMemory / (2 * numActiveTasks)) {\n-        // We want to let each task get at least 1 / (2 * numActiveTasks) before blocking;\n-        // if we can't give it this much now, wait for other tasks to free up memory\n-        // (this happens if older tasks allocated lots of memory before N grew)\n-        if (freeMemory >= math.min(maxToGrant, maxMemory / (2 * numActiveTasks) - curMem)) {\n-          return acquire(toGrant)\n+      // Only give it as much memory as is 1/4 of free, which might be none\n+      // if it reached 1 / numTasks\n+      val available = math.min(freeMemory, math.max(0, (maxMemory / numActiveTasks) - curMem))\n+      if (available >= numBytes) {\n+        return acquire(consumer, numBytes)\n+      }\n+      val needed = numBytes - available\n+      if (consumer != null && consumer.release(needed) >= needed) {\n+        return acquire(consumer, numBytes)\n+      }\n+      if (!released && taskConsumers.contains(taskAttemptId)) {\n+        // try to release more to make sure that we will got enough memory in next loop\n+        tryRelease(numBytes - available)\n+        released = true\n+      } else {\n+        if (curMem < maxMemory / (2 * numActiveTasks)) {\n+          return acquire(consumer, available)\n         } else {\n-          logInfo(\n-            s\"TID $taskAttemptId waiting for at least 1/2N of shuffle memory pool to be free\")\n+          // in case of memory is not balanced, try to protected the ones already have more memory\n+          // wait for other tasks to finished or fail (release memory)\n           memoryManager.wait()\n         }\n-      } else {\n-        return acquire(toGrant)\n       }\n     }\n     0L  // Never reached\n   }\n \n+  private def tryRelease(numBytes: Long): Long = {\n+    val taskAttemptId = currentTaskAttemptId()\n+    var released = 0L\n+    taskConsumers(taskAttemptId).foreach { case (consumer, used) =>\n+      if (consumer != null && used > 0) {\n+        released += consumer.release(numBytes - released)\n+        if (released >= numBytes) {\n+          return released\n+        }\n+      }\n+    }\n+    released\n+  }\n+\n   /**\n    * Acquire N bytes of execution memory from the memory manager for the current task.\n    * @return number of bytes actually acquired (<= N).\n    */\n-  private def acquire(numBytes: Long): Long = memoryManager.synchronized {\n+  private def acquire(consumer: MemoryConsumer, numBytes: Long): Long = memoryManager.synchronized {\n+    if (numBytes <= 0) {"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "If the `spark.testing` system property is set, then I think this warning should become an exception, since that will let us detect problems in unit tests.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-26T00:51:01Z",
    "diffHunk": "@@ -128,17 +161,31 @@ class ShuffleMemoryManager protected (\n       metrics.updatedBlocks = Some(lastUpdatedBlocks ++ evictedBlocks.toSeq)\n     }\n     taskMemory(taskAttemptId) += acquired\n+    val consumers = taskConsumers.getOrElseUpdate(taskAttemptId, new mutable.HashMap())\n+    consumers += consumer -> (consumers.getOrElse(consumer, 0L) + acquired)\n     acquired\n   }\n \n+  def release(numBytes: Long): Unit = release(numBytes, null)\n+\n   /** Release numBytes bytes for the current task. */\n-  def release(numBytes: Long): Unit = memoryManager.synchronized {\n+  def release(numBytes: Long, consumer: MemoryConsumer): Unit = memoryManager.synchronized {\n     val taskAttemptId = currentTaskAttemptId()\n     val curMem = taskMemory.getOrElse(taskAttemptId, 0L)\n     if (curMem < numBytes) {\n       throw new SparkException(\n         s\"Internal error: release called on $numBytes bytes but task only has $curMem\")\n     }\n+    taskConsumers.get(taskAttemptId).map { consumers =>\n+      if (consumers.contains(consumer)) {\n+        consumers(consumer) -= numBytes\n+        if (consumers(consumer) <= 0) {\n+          consumers.remove(consumer)\n+        }\n+      } else {\n+        logError(s\"BUG: release $numBytes from $consumer in task $taskAttemptId\")"
  }],
  "prId": 9241
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Same here; I think this should be an exception in unit tests and a warning in production.\n",
    "commit": "e943e745317bd4d13934a14026be5a7915706269",
    "createdAt": "2015-10-26T00:51:16Z",
    "diffHunk": "@@ -152,6 +199,11 @@ class ShuffleMemoryManager protected (\n     taskMemory.remove(taskAttemptId).foreach { numBytes =>\n       memoryManager.releaseExecutionMemory(numBytes)\n     }\n+    taskConsumers.remove(taskAttemptId).map { consumers =>\n+      consumers.foreach { case (consumer, numBytes) =>\n+        logWarning(s\"Memory leak in task $taskAttemptId: $consumer $numBytes bytes\")"
  }],
  "prId": 9241
}]