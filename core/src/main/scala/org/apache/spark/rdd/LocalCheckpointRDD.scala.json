[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Why do you need to take partitionIndices? Arent they always going to be  0 to numPartitions-1? \n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-07-24T03:20:04Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Partition, SparkContext, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.RDDBlockId\n+\n+/**\n+ * A dummy CheckpointRDD that exists to provide informative error messages during failures.\n+ *\n+ * This is simply a placeholder because the original checkpointed RDD is expected to be\n+ * fully cached. Only if an executor fails or if the user explicitly unpersists the original\n+ * RDD will Spark ever attempt to compute this CheckpointRDD. When this happens, however,\n+ * we must provide an informative error message.\n+ *\n+ * @param sc the active SparkContext\n+ * @param rddId the ID of the checkpointed RDD\n+ * @param partitionIndices the partition indices of the checkpointed RDD\n+ */\n+private[spark] class LocalCheckpointRDD[T: ClassTag](\n+    @transient sc: SparkContext,\n+    rddId: Int,\n+    partitionIndices: Array[Int])"
  }],
  "prId": 7279
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "The user does not know about any \"block\", so they will get confused. Better to say something like \"...the original data of locally checkpointed RDD is lost...you have to recompute the original RDD manually ...\"\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-07-24T03:22:18Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Partition, SparkContext, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.RDDBlockId\n+\n+/**\n+ * A dummy CheckpointRDD that exists to provide informative error messages during failures.\n+ *\n+ * This is simply a placeholder because the original checkpointed RDD is expected to be\n+ * fully cached. Only if an executor fails or if the user explicitly unpersists the original\n+ * RDD will Spark ever attempt to compute this CheckpointRDD. When this happens, however,\n+ * we must provide an informative error message.\n+ *\n+ * @param sc the active SparkContext\n+ * @param rddId the ID of the checkpointed RDD\n+ * @param partitionIndices the partition indices of the checkpointed RDD\n+ */\n+private[spark] class LocalCheckpointRDD[T: ClassTag](\n+    @transient sc: SparkContext,\n+    rddId: Int,\n+    partitionIndices: Array[Int])\n+  extends CheckpointRDD[T](sc) {\n+\n+  def this(rdd: RDD[T]) {\n+    this(rdd.context, rdd.id, rdd.partitions.map(_.index))\n+  }\n+\n+  protected override def getPartitions: Array[Partition] = {\n+    partitionIndices.map { i => new CheckpointRDDPartition(i) }\n+  }\n+\n+  /**\n+   * Throw an exception indicating that the relevant block is not found.\n+   *\n+   * This should only be called if the original RDD is explicitly unpersisted or if an\n+   * executor is lost. Under normal circumstances, however, the original RDD (our child)\n+   * is expected to be fully cached and so all partitions should already be computed and\n+   * available in the block storage.\n+   */\n+  override def compute(partition: Partition, context: TaskContext): Iterator[T] = {\n+    throw new SparkException(\n+      s\"Checkpoint block ${RDDBlockId(rddId, partition.index)} not found! Either the executor \" +\n+      s\"that originally checkpointed this block is no longer alive, or the original RDD is \" +"
  }],
  "prId": 7279
}]