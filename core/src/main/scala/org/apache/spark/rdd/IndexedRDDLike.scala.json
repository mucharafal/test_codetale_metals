[{
  "comments": [{
    "author": {
      "login": "ankurdave"
    },
    "body": "We should also override `PairRDDFunctions.lookup` to use this fast implementation.\n",
    "commit": "02a9bde62102facfd5f9146039a2d68cdc0f180b",
    "createdAt": "2014-07-14T22:40:26Z",
    "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.collection.immutable.LongMap\n+import scala.language.higherKinds\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark._\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.storage.StorageLevel\n+\n+import IndexedRDD.Id\n+\n+/**\n+ * Contains members that are shared among all variants of IndexedRDD (e.g., IndexedRDD,\n+ * VertexRDD).\n+ *\n+ * @tparam V the type of the values stored in the IndexedRDD\n+ * @tparam P the type of the partitions making up the IndexedRDD\n+ * @tparam Self the type of the implementing container. This allows transformation methods on any\n+ * implementing container to yield a result of the same type.\n+ */\n+private[spark] trait IndexedRDDLike[\n+    @specialized(Long, Int, Double) V,\n+    P[X] <: IndexedRDDPartitionLike[X, P],\n+    Self[X] <: IndexedRDDLike[X, P, Self]]\n+  extends RDD[(Id, V)] {\n+\n+  /** A generator for ClassTags of the value type V. */\n+  protected implicit def vTag: ClassTag[V]\n+\n+  /** A generator for ClassTags of the partition type P. */\n+  protected implicit def pTag[V2]: ClassTag[P[V2]]\n+\n+  /** Accessor for the IndexedRDD variant that is mixing in this trait. */\n+  protected def self: Self[V]\n+\n+  /** The underlying representation of the IndexedRDD as an RDD of partitions. */\n+  def partitionsRDD: RDD[P[V]]\n+  require(partitionsRDD.partitioner.isDefined)\n+\n+  def withPartitionsRDD[V2: ClassTag](partitionsRDD: RDD[P[V2]]): Self[V2]\n+\n+  override val partitioner = partitionsRDD.partitioner\n+\n+  override protected def getPartitions: Array[Partition] = partitionsRDD.partitions\n+\n+  override protected def getPreferredLocations(s: Partition): Seq[String] =\n+    partitionsRDD.preferredLocations(s)\n+\n+  override def persist(newLevel: StorageLevel): this.type = {\n+    partitionsRDD.persist(newLevel)\n+    this\n+  }\n+\n+  override def unpersist(blocking: Boolean = true): this.type = {\n+    partitionsRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  override def count(): Long = {\n+    partitionsRDD.map(_.size).reduce(_ + _)\n+  }\n+\n+  /** Provides the `RDD[(Id, V)]` equivalent output. */\n+  override def compute(part: Partition, context: TaskContext): Iterator[(Id, V)] = {\n+    firstParent[P[V]].iterator(part, context).next.iterator\n+  }\n+\n+  /** Gets the value corresponding to the specified key, if any. */\n+  def get(k: Id): Option[V] = multiget(Array(k)).get(k)",
    "line": 87
  }],
  "prId": 1297
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "would this be another use of the `bulkMultiget` I suggested in jira?\n",
    "commit": "02a9bde62102facfd5f9146039a2d68cdc0f180b",
    "createdAt": "2014-09-19T15:15:18Z",
    "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.collection.immutable.LongMap\n+import scala.language.higherKinds\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark._\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.storage.StorageLevel\n+\n+import IndexedRDD.Id\n+\n+/**\n+ * Contains members that are shared among all variants of IndexedRDD (e.g., IndexedRDD,\n+ * VertexRDD).\n+ *\n+ * @tparam V the type of the values stored in the IndexedRDD\n+ * @tparam P the type of the partitions making up the IndexedRDD\n+ * @tparam Self the type of the implementing container. This allows transformation methods on any\n+ * implementing container to yield a result of the same type.\n+ */\n+private[spark] trait IndexedRDDLike[\n+    @specialized(Long, Int, Double) V,\n+    P[X] <: IndexedRDDPartitionLike[X, P],\n+    Self[X] <: IndexedRDDLike[X, P, Self]]\n+  extends RDD[(Id, V)] {\n+\n+  /** A generator for ClassTags of the value type V. */\n+  protected implicit def vTag: ClassTag[V]\n+\n+  /** A generator for ClassTags of the partition type P. */\n+  protected implicit def pTag[V2]: ClassTag[P[V2]]\n+\n+  /** Accessor for the IndexedRDD variant that is mixing in this trait. */\n+  protected def self: Self[V]\n+\n+  /** The underlying representation of the IndexedRDD as an RDD of partitions. */\n+  def partitionsRDD: RDD[P[V]]\n+  require(partitionsRDD.partitioner.isDefined)\n+\n+  def withPartitionsRDD[V2: ClassTag](partitionsRDD: RDD[P[V2]]): Self[V2]\n+\n+  override val partitioner = partitionsRDD.partitioner\n+\n+  override protected def getPartitions: Array[Partition] = partitionsRDD.partitions\n+\n+  override protected def getPreferredLocations(s: Partition): Seq[String] =\n+    partitionsRDD.preferredLocations(s)\n+\n+  override def persist(newLevel: StorageLevel): this.type = {\n+    partitionsRDD.persist(newLevel)\n+    this\n+  }\n+\n+  override def unpersist(blocking: Boolean = true): this.type = {\n+    partitionsRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  override def count(): Long = {\n+    partitionsRDD.map(_.size).reduce(_ + _)\n+  }\n+\n+  /** Provides the `RDD[(Id, V)]` equivalent output. */\n+  override def compute(part: Partition, context: TaskContext): Iterator[(Id, V)] = {\n+    firstParent[P[V]].iterator(part, context).next.iterator\n+  }\n+\n+  /** Gets the value corresponding to the specified key, if any. */\n+  def get(k: Id): Option[V] = multiget(Array(k)).get(k)\n+\n+  /** Gets the values corresponding to the specified keys, if any. */\n+  def multiget(ks: Array[Id]): Map[Id, V] = {\n+    val ksByPartition = ks.groupBy(k => self.partitioner.get.getPartition(k))\n+    val partitions = ksByPartition.keys.toSeq\n+    def unionMaps(maps: TraversableOnce[LongMap[V]]): LongMap[V] = {\n+      maps.foldLeft(LongMap.empty[V]) {\n+        (accum, map) => accum.unionWith(map, (id, a, b) => a)\n+      }\n+    }\n+    // TODO: avoid sending all keys to all partitions by creating and zipping an RDD of keys",
    "line": 98
  }],
  "prId": 1297
}]