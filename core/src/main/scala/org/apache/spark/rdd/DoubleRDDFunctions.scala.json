[{
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Is this a documented Scala bug? If so - can we link to it?\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-06T01:26:51Z",
    "diffHunk": "@@ -109,7 +109,9 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n     }\n     val increment = (max-min)/bucketCount.toDouble\n     val range = if (increment != 0) {\n-      Range.Double.inclusive(min, max, increment)\n+      //Range.Double.inclusive(min, max, increment)\n+      //[SPARK-2862] The above code doesn't return inclusive range. Scala bug."
  }, {
    "author": {
      "login": "nrchandan"
    },
    "body": "I should have the Scala bug raised today. Will update it once done.\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-06T05:54:27Z",
    "diffHunk": "@@ -109,7 +109,9 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n     }\n     val increment = (max-min)/bucketCount.toDouble\n     val range = if (increment != 0) {\n-      Range.Double.inclusive(min, max, increment)\n+      //Range.Double.inclusive(min, max, increment)\n+      //[SPARK-2862] The above code doesn't return inclusive range. Scala bug."
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "K - thanks! if we cast link to an issue or something, would be great.\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-06T06:18:43Z",
    "diffHunk": "@@ -109,7 +109,9 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n     }\n     val increment = (max-min)/bucketCount.toDouble\n     val range = if (increment != 0) {\n-      Range.Double.inclusive(min, max, increment)\n+      //Range.Double.inclusive(min, max, increment)\n+      //[SPARK-2862] The above code doesn't return inclusive range. Scala bug."
  }],
  "prId": 1787
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We can save some FLOPs by computing the stepSize first:\n\n```\nval stepSize = (max - min) / steps\nRange.Int(0, steps, 1).map(s => min + s * stepSize) :+ max\n```\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-16T22:45:46Z",
    "diffHunk": "@@ -96,6 +96,10 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n    */\n   def histogram(bucketCount: Int): Pair[Array[Double], Array[Long]] = {\n     // Compute the minimum and the maxium\n+    def customRange(min: Double, max: Double, steps: Int): IndexedSeq[Double] = {\n+      val span = max - min"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I thought the order of operations would be important to get the result, so wrote it that way on purpose, but, it's actually fine this way too. I think the win here is not repeatedly adding 1/steps alone.\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-16T22:56:05Z",
    "diffHunk": "@@ -96,6 +96,10 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n    */\n   def histogram(bucketCount: Int): Pair[Array[Double], Array[Long]] = {\n     // Compute the minimum and the maxium\n+    def customRange(min: Double, max: Double, steps: Int): IndexedSeq[Double] = {\n+      val span = max - min"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Both approaches should give reasonable results because the last one is skipped. The edge case is that both min and max are very very small values (customRange1 computes stepSize first):\n\n```\nscala> customRange(1e-322, 2e-322, 10)\nres15: IndexedSeq[Double] = Vector(1.0E-322, 1.1E-322, 1.2E-322, 1.3E-322, 1.4E-322, 1.5E-322, 1.58E-322, 1.7E-322, 1.8E-322, 1.9E-322, 2.0E-322)\n\nscala> customRange1(1e-322, 2e-322, 10)\nres14: IndexedSeq[Double] = Vector(1.0E-322, 1.1E-322, 1.2E-322, 1.3E-322, 1.4E-322, 1.5E-322, 1.58E-322, 1.7E-322, 1.8E-322, 1.9E-322, 2.0E-322)\n\nscala> customRange(1e-323, 2e-323, 10)\nres12: IndexedSeq[Double] = Vector(1.0E-323, 1.0E-323, 1.0E-323, 1.5E-323, 1.5E-323, 1.5E-323, 1.5E-323, 1.5E-323, 2.0E-323, 2.0E-323, 2.0E-323)\n\nscala> customRange1(1e-323, 2e-323, 10)\nres13: IndexedSeq[Double] = Vector(1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 1.0E-323, 2.0E-323)\n```\n\nI think we can ignore this edge case.\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-16T23:22:57Z",
    "diffHunk": "@@ -96,6 +96,10 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n    */\n   def histogram(bucketCount: Int): Pair[Array[Double], Array[Long]] = {\n     // Compute the minimum and the maxium\n+    def customRange(min: Double, max: Double, steps: Int): IndexedSeq[Double] = {\n+      val span = max - min"
  }, {
    "author": {
      "login": "nrchandan"
    },
    "body": "customRange1 actually fails the original test case. Continuing with customRange code by @srowen \n\nscala> customRange1(1.0, 2.0, 10)\nres2: IndexedSeq[Double] = Vector(1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7000000000000002, 1.8, 1.9, 2.0)\n\nscala> customRange(1.0, 2.0, 10)\nres0: IndexedSeq[Double] = Vector(1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0)\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-18T06:01:36Z",
    "diffHunk": "@@ -96,6 +96,10 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n    */\n   def histogram(bucketCount: Int): Pair[Array[Double], Array[Long]] = {\n     // Compute the minimum and the maxium\n+    def customRange(min: Double, max: Double, steps: Int): IndexedSeq[Double] = {\n+      val span = max - min"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Actually both are correct in this case. This is why we should tolerate small numeric difference in tests. @srowen 's version looks good.\n",
    "commit": "a76bbf67dbe562e32ddcfa21f53b4914d1f520ff",
    "createdAt": "2014-08-18T08:21:32Z",
    "diffHunk": "@@ -96,6 +96,10 @@ class DoubleRDDFunctions(self: RDD[Double]) extends Logging with Serializable {\n    */\n   def histogram(bucketCount: Int): Pair[Array[Double], Array[Long]] = {\n     // Compute the minimum and the maxium\n+    def customRange(min: Double, max: Double, steps: Int): IndexedSeq[Double] = {\n+      val span = max - min"
  }],
  "prId": 1787
}]