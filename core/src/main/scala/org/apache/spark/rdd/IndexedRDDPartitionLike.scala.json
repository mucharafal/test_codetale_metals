[{
  "comments": [{
    "author": {
      "login": "ankurdave"
    },
    "body": "Optimization: we should batch updates to the same leaf node to avoid temporarily allocating up to 32x the needed memory\n",
    "commit": "02a9bde62102facfd5f9146039a2d68cdc0f180b",
    "createdAt": "2014-09-23T23:13:23Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.collection.immutable.LongMap\n+import scala.language.higherKinds\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.util.collection.BitSet\n+import org.apache.spark.util.collection.ImmutableBitSet\n+import org.apache.spark.util.collection.ImmutableLongOpenHashSet\n+import org.apache.spark.util.collection.ImmutableVector\n+import org.apache.spark.util.collection.OpenHashSet\n+import org.apache.spark.util.collection.PrimitiveKeyOpenHashMap\n+\n+import IndexedRDD.Id\n+import IndexedRDDPartition.Index\n+\n+/**\n+ * Contains members that are shared among all variants of IndexedRDDPartition (e.g.,\n+ * IndexedRDDPartition, ShippableVertexPartition).\n+ *\n+ * @tparam V the type of the values stored in the IndexedRDDPartition\n+ * @tparam Self the type of the implementing container. This allows transformation methods on any\n+ * implementing container to yield a result of the same type.\n+ */\n+private[spark] trait IndexedRDDPartitionLike[\n+    @specialized(Long, Int, Double) V,\n+    Self[X] <: IndexedRDDPartitionLike[X, Self]]\n+  extends Serializable with Logging {\n+\n+  /** A generator for ClassTags of the value type V. */\n+  implicit def vTag: ClassTag[V]\n+\n+  /** Accessor for the IndexedRDDPartition variant that is mixing in this trait. */\n+  def self: Self[V]\n+\n+  def index: Index\n+  def values: ImmutableVector[V]\n+  def mask: ImmutableBitSet\n+\n+  def withIndex(index: Index): Self[V]\n+  def withValues[V2: ClassTag](values: ImmutableVector[V2]): Self[V2]\n+  def withMask(mask: ImmutableBitSet): Self[V]\n+\n+  val capacity: Int = index.capacity\n+\n+  def size: Int = mask.cardinality()\n+\n+  /** Return the value for the given key. */\n+  def apply(k: Id): V = values(index.getPos(k))\n+\n+  def isDefined(k: Id): Boolean = {\n+    val pos = index.getPos(k)\n+    pos >= 0 && mask.get(pos)\n+  }\n+\n+  def iterator: Iterator[(Id, V)] =\n+    mask.iterator.map(ind => (index.getValue(ind), values(ind)))\n+\n+  /**\n+   * Gets the values corresponding to the specified keys, if any.\n+   */\n+  def multiget(ks: Array[Id]): LongMap[V] = {\n+    var result = LongMap.empty[V]\n+    var i = 0\n+    while (i < ks.length) {\n+      val k = ks(i)\n+      if (self.isDefined(k)) {\n+        result = result.updated(k, self(k))\n+      }\n+      i += 1\n+    }\n+    result\n+  }\n+\n+  /**\n+   * Updates the keys in `kvs` to their corresponding values, running `merge` on old and new values\n+   * if necessary. Returns a new IndexedRDDPartition that reflects the modification.\n+   */\n+  def multiput(kvs: Seq[(Id, V)], merge: (Id, V, V) => V): Self[V] = {\n+    if (kvs.forall(kv => self.isDefined(kv._1))) {\n+      // Pure updates can be implemented by modifying only the values\n+      join(kvs.iterator)(merge)\n+    } else {\n+      var newIndex = self.index\n+      var newValues = self.values\n+      var newMask = self.mask\n+\n+      var preMoveValues: ImmutableVector[V] = null\n+      var preMoveMask: ImmutableBitSet = null\n+      def grow(newSize: Int) {\n+        preMoveValues = newValues\n+        preMoveMask = newMask\n+\n+        newValues = ImmutableVector.fill(newSize)(null.asInstanceOf[V])\n+        newMask = new ImmutableBitSet(newSize)\n+      }\n+      def move(oldPos: Int, newPos: Int) {\n+        newValues = newValues.updated(newPos, preMoveValues(oldPos))\n+        if (preMoveMask.get(oldPos)) newMask = newMask.set(newPos)\n+      }\n+\n+      for (kv <- kvs) {\n+        val id = kv._1\n+        val otherValue = kv._2\n+        newIndex = newIndex.addWithoutResize(id)\n+        if ((newIndex.focus & OpenHashSet.NONEXISTENCE_MASK) != 0) {\n+          // This is a new key - need to update index\n+          val pos = newIndex.focus & OpenHashSet.POSITION_MASK\n+          newValues = newValues.updated(pos, otherValue)"
  }],
  "prId": 1297
}]