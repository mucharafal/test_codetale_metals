[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Technically, this method may work even though the hash code is not well-behaved, if the partitioner is not a HashPartitioner, right?\n",
    "commit": "1cd87e051c72ff7c17ee7c3aa8b9fd507167cdad",
    "createdAt": "2015-01-06T20:06:11Z",
    "diffHunk": "@@ -72,6 +72,8 @@ class OrderedRDDFunctions[K : Ordering : ClassTag,\n    * because it can push the sorting down into the shuffle machinery.\n    */\n   def repartitionAndSortWithinPartitions(partitioner: Partitioner): RDD[(K, V)] = {\n+    val keyClass = implicitly[ClassTag[K]].runtimeClass\n+    Partitioner.assertHashCodeIsWellBehaved(keyClass)",
    "line": 5
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "I think the concern here is that there's other code which might call `hashCode` on the items, so even if we use a custom partitioner we will still get incorrect results for Java arrays.  I think that this is safe as long as we can guarantee that the sorting phase doesn't call `hashCode`.\n",
    "commit": "1cd87e051c72ff7c17ee7c3aa8b9fd507167cdad",
    "createdAt": "2015-01-06T21:14:55Z",
    "diffHunk": "@@ -72,6 +72,8 @@ class OrderedRDDFunctions[K : Ordering : ClassTag,\n    * because it can push the sorting down into the shuffle machinery.\n    */\n   def repartitionAndSortWithinPartitions(partitioner: Partitioner): RDD[(K, V)] = {\n+    val keyClass = implicitly[ClassTag[K]].runtimeClass\n+    Partitioner.assertHashCodeIsWellBehaved(keyClass)",
    "line": 5
  }],
  "prId": 3795
}]