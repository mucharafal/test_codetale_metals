[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: ... saving the RDD data to a reliable/fault-tolerant storage.\nThe term \"checkpoint data\" is confusing. The way I reason it in my head is \n1. \"RDD data\" is saved to perform checkpointing\n2. Once the data is saved or checkpointed, it becomes \"checkpointed data\". \n\nBut this is really potayto / potawto. So its fine either ways.\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-07-24T03:25:36Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of replicating the checkpointed data in a reliable storage. Instead, checkpoint data"
  }],
  "prId": 7279
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "@andrewor14 I am a little confused about this. You are calling cachemanager in the _driver_, for each partition that is not present in the block manager. How does that work in the distributed manner? Dont you have to run a job (through the DAGScheduler and all) to actually run tasks? What am I missing?\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-08-02T01:20:15Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of saving the RDD data to a reliable and fault-tolerant storage. Instead, the data\n+ * is written to the local, ephemeral block storage that lives in each executor. This is useful\n+ * for use cases where RDDs build up long lineages that need to be truncated often (e.g. GraphX).\n+ */\n+private[spark] class LocalRDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])\n+  extends RDDCheckpointData[T](rdd) with Logging {\n+\n+  /**\n+   * Ensure the RDD is fully cached so the partitions can be recovered later.\n+   */\n+  protected override def doCheckpoint(): CheckpointRDD[T] = {\n+    val cm = SparkEnv.get.cacheManager\n+    val bmm = SparkEnv.get.blockManager.master\n+    val level = rdd.getStorageLevel\n+\n+    // Assume storage level uses disk; otherwise memory eviction may cause data loss\n+    assume(level.useDisk, s\"Storage level $level is not appropriate for local checkpointing\")\n+\n+    // Not all RDD actions compute all partitions of the RDD (e.g. take)\n+    // We must compute and cache any missing partitions for correctness reasons\n+    rdd.partitions.foreach { p =>"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Also, is this code tested in a unit test with a action that computes partially?\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-08-02T04:31:39Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of saving the RDD data to a reliable and fault-tolerant storage. Instead, the data\n+ * is written to the local, ephemeral block storage that lives in each executor. This is useful\n+ * for use cases where RDDs build up long lineages that need to be truncated often (e.g. GraphX).\n+ */\n+private[spark] class LocalRDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])\n+  extends RDDCheckpointData[T](rdd) with Logging {\n+\n+  /**\n+   * Ensure the RDD is fully cached so the partitions can be recovered later.\n+   */\n+  protected override def doCheckpoint(): CheckpointRDD[T] = {\n+    val cm = SparkEnv.get.cacheManager\n+    val bmm = SparkEnv.get.blockManager.master\n+    val level = rdd.getStorageLevel\n+\n+    // Assume storage level uses disk; otherwise memory eviction may cause data loss\n+    assume(level.useDisk, s\"Storage level $level is not appropriate for local checkpointing\")\n+\n+    // Not all RDD actions compute all partitions of the RDD (e.g. take)\n+    // We must compute and cache any missing partitions for correctness reasons\n+    rdd.partitions.foreach { p =>"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "I think you're right. We can probably replace this whole block with just an `rdd.count()` actually, since we assume that it's already marked for caching.\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-08-02T05:06:47Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of saving the RDD data to a reliable and fault-tolerant storage. Instead, the data\n+ * is written to the local, ephemeral block storage that lives in each executor. This is useful\n+ * for use cases where RDDs build up long lineages that need to be truncated often (e.g. GraphX).\n+ */\n+private[spark] class LocalRDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])\n+  extends RDDCheckpointData[T](rdd) with Logging {\n+\n+  /**\n+   * Ensure the RDD is fully cached so the partitions can be recovered later.\n+   */\n+  protected override def doCheckpoint(): CheckpointRDD[T] = {\n+    val cm = SparkEnv.get.cacheManager\n+    val bmm = SparkEnv.get.blockManager.master\n+    val level = rdd.getStorageLevel\n+\n+    // Assume storage level uses disk; otherwise memory eviction may cause data loss\n+    assume(level.useDisk, s\"Storage level $level is not appropriate for local checkpointing\")\n+\n+    // Not all RDD actions compute all partitions of the RDD (e.g. take)\n+    // We must compute and cache any missing partitions for correctness reasons\n+    rdd.partitions.foreach { p =>"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "This isnt great either. Even when its cached, it may be cached on disk, or serialized in memory. In which case running a count may be costly and time consuming, and pretty much defeats the purpose of making this a cheap checkpointing. Also, in the majority of the cases, this will be fully cached, in which case running this job is superfluous. The right thing (which aint too hard is to find out which partitions are missing and only run those partitions. \n\n```\nval missingPartitionIds = rdd.partition.filter { p => \n   !blockManagerMaster.contains(RDDBlockId(rdd.id, p.index)) \n}.map { _.index }\n\nrdd.sparkContext.runJob(\n  rdd, \n  (tc: TaskContext, iterator: Iterator[T]) => Utils.getIteratorSize(iterator)  // same as count()\n  missintPartitionIds\n)\n```\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-08-02T08:54:33Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of saving the RDD data to a reliable and fault-tolerant storage. Instead, the data\n+ * is written to the local, ephemeral block storage that lives in each executor. This is useful\n+ * for use cases where RDDs build up long lineages that need to be truncated often (e.g. GraphX).\n+ */\n+private[spark] class LocalRDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])\n+  extends RDDCheckpointData[T](rdd) with Logging {\n+\n+  /**\n+   * Ensure the RDD is fully cached so the partitions can be recovered later.\n+   */\n+  protected override def doCheckpoint(): CheckpointRDD[T] = {\n+    val cm = SparkEnv.get.cacheManager\n+    val bmm = SparkEnv.get.blockManager.master\n+    val level = rdd.getStorageLevel\n+\n+    // Assume storage level uses disk; otherwise memory eviction may cause data loss\n+    assume(level.useDisk, s\"Storage level $level is not appropriate for local checkpointing\")\n+\n+    // Not all RDD actions compute all partitions of the RDD (e.g. take)\n+    // We must compute and cache any missing partitions for correctness reasons\n+    rdd.partitions.foreach { p =>"
  }],
  "prId": 7279
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "I mentioned in the earlier comment thread, you may have missed it. Recommenting it here.\n\nThis `rdd.count` isnt great either. Even when its cached, it may be cached on disk, or serialized in memory. In which case running a count may be costly and time consuming, and pretty much defeats the purpose of making this a cheap checkpointing. Also, in the majority of the cases, this will be fully cached, in which case running this job is superfluous. The right thing to do (which aint too hard) is to find out which partitions are missing and only run those partitions.\n\n```\nval missingPartitionIds = rdd.partition.filter { p => \n   !blockManagerMaster.contains(RDDBlockId(rdd.id, p.index)) \n}.map { _.index }\n\nrdd.sparkContext.runJob(\n  rdd, \n  (tc: TaskContext, iterator: Iterator[T]) => Utils.getIteratorSize(iterator)  // same as count()\n  missintPartitionIds\n)\n```\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-08-02T21:40:08Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of saving the RDD data to a reliable and fault-tolerant storage. Instead, the data\n+ * is written to the local, ephemeral block storage that lives in each executor. This is useful\n+ * for use cases where RDDs build up long lineages that need to be truncated often (e.g. GraphX).\n+ */\n+private[spark] class LocalRDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])\n+  extends RDDCheckpointData[T](rdd) with Logging {\n+\n+  /**\n+   * Ensure the RDD is fully cached so the partitions can be recovered later.\n+   */\n+  protected override def doCheckpoint(): CheckpointRDD[T] = {\n+    val level = rdd.getStorageLevel\n+\n+    // Assume storage level uses disk; otherwise memory eviction may cause data loss\n+    assume(level.useDisk, s\"Storage level $level is not appropriate for local checkpointing\")\n+\n+    // Not all RDD actions compute all partitions of the RDD (e.g. take)\n+    // We must compute and cache any missing partitions for correctness reasons\n+    // TODO: avoid running another job here (SPARK-8582)\n+    rdd.count()"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "alright. Ideally the fix in SPARK-8582 will make the need to do this go away completely, but in the mean time we'll go with your suggestion.\n",
    "commit": "729600f83072422824689fb22e5148ccccd211cf",
    "createdAt": "2015-08-02T23:13:17Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rdd\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.{Logging, SparkEnv, SparkException, TaskContext}\n+import org.apache.spark.storage.{RDDBlockId, StorageLevel}\n+\n+/**\n+ * An implementation of checkpointing implemented on top of Spark's caching layer.\n+ *\n+ * Local checkpointing trades off fault tolerance for performance by skipping the expensive\n+ * step of saving the RDD data to a reliable and fault-tolerant storage. Instead, the data\n+ * is written to the local, ephemeral block storage that lives in each executor. This is useful\n+ * for use cases where RDDs build up long lineages that need to be truncated often (e.g. GraphX).\n+ */\n+private[spark] class LocalRDDCheckpointData[T: ClassTag](@transient rdd: RDD[T])\n+  extends RDDCheckpointData[T](rdd) with Logging {\n+\n+  /**\n+   * Ensure the RDD is fully cached so the partitions can be recovered later.\n+   */\n+  protected override def doCheckpoint(): CheckpointRDD[T] = {\n+    val level = rdd.getStorageLevel\n+\n+    // Assume storage level uses disk; otherwise memory eviction may cause data loss\n+    assume(level.useDisk, s\"Storage level $level is not appropriate for local checkpointing\")\n+\n+    // Not all RDD actions compute all partitions of the RDD (e.g. take)\n+    // We must compute and cache any missing partitions for correctness reasons\n+    // TODO: avoid running another job here (SPARK-8582)\n+    rdd.count()"
  }],
  "prId": 7279
}]