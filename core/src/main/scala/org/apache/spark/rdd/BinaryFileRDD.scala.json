[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we use `CPU_CORES_PER_EXECUTOR`?",
    "commit": "2fc2d9a3b66407666c57484cd20d74a49f62df27",
    "createdAt": "2017-07-03T05:33:59Z",
    "diffHunk": "@@ -35,8 +36,12 @@ private[spark] class BinaryFileRDD[T](\n   extends NewHadoopRDD[String, T](sc, inputFormatClass, keyClass, valueClass, conf) {\n \n   override def getPartitions: Array[Partition] = {\n-    val inputFormat = inputFormatClass.newInstance\n     val conf = getConf\n+    // setMinPartitions below will call FileInputFormat.listStatus(), which can be quite slow when\n+    // traversing a large number of directories and files. Parallelize it.\n+    conf.setIfUnset(FileInputFormat.LIST_STATUS_NUM_THREADS,\n+      Runtime.getRuntime.availableProcessors().toString)",
    "line": 17
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "+1. \r\nThis code aggressively tries to use all of the cores on all of the Spark instances on a node. ",
    "commit": "2fc2d9a3b66407666c57484cd20d74a49f62df27",
    "createdAt": "2017-07-03T09:38:03Z",
    "diffHunk": "@@ -35,8 +36,12 @@ private[spark] class BinaryFileRDD[T](\n   extends NewHadoopRDD[String, T](sc, inputFormatClass, keyClass, valueClass, conf) {\n \n   override def getPartitions: Array[Partition] = {\n-    val inputFormat = inputFormatClass.newInstance\n     val conf = getConf\n+    // setMinPartitions below will call FileInputFormat.listStatus(), which can be quite slow when\n+    // traversing a large number of directories and files. Parallelize it.\n+    conf.setIfUnset(FileInputFormat.LIST_STATUS_NUM_THREADS,\n+      Runtime.getRuntime.availableProcessors().toString)",
    "line": 17
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "@cloud-fan @kiszk this will happen on the driver, where it goes to assess the size of the data in order to compute the desired number of partitions. I don't know what the right value is here, to be honest. It won't actually use a ton of CPU because these threads will mostly be waiting for the external FS processes.\r\n\r\nI didn't think it's worth yet another config, and didn't know what else to base it on. The number of driver cores maybe?\r\n\r\nWhat is `CPU_CORES_PER_EXECUTOR` by the way, I don't see that in the code? I can check for `spark.driver.cores` in the Spark config here.",
    "commit": "2fc2d9a3b66407666c57484cd20d74a49f62df27",
    "createdAt": "2017-07-03T11:41:09Z",
    "diffHunk": "@@ -35,8 +36,12 @@ private[spark] class BinaryFileRDD[T](\n   extends NewHadoopRDD[String, T](sc, inputFormatClass, keyClass, valueClass, conf) {\n \n   override def getPartitions: Array[Partition] = {\n-    val inputFormat = inputFormatClass.newInstance\n     val conf = getConf\n+    // setMinPartitions below will call FileInputFormat.listStatus(), which can be quite slow when\n+    // traversing a large number of directories and files. Parallelize it.\n+    conf.setIfUnset(FileInputFormat.LIST_STATUS_NUM_THREADS,\n+      Runtime.getRuntime.availableProcessors().toString)",
    "line": 17
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ah, if it's running on driver side, I think it's ok.",
    "commit": "2fc2d9a3b66407666c57484cd20d74a49f62df27",
    "createdAt": "2017-07-03T11:50:32Z",
    "diffHunk": "@@ -35,8 +36,12 @@ private[spark] class BinaryFileRDD[T](\n   extends NewHadoopRDD[String, T](sc, inputFormatClass, keyClass, valueClass, conf) {\n \n   override def getPartitions: Array[Partition] = {\n-    val inputFormat = inputFormatClass.newInstance\n     val conf = getConf\n+    // setMinPartitions below will call FileInputFormat.listStatus(), which can be quite slow when\n+    // traversing a large number of directories and files. Parallelize it.\n+    conf.setIfUnset(FileInputFormat.LIST_STATUS_NUM_THREADS,\n+      Runtime.getRuntime.availableProcessors().toString)",
    "line": 17
  }],
  "prId": 18441
}]