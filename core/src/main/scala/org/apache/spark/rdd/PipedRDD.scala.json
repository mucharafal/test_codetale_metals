[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": ".stop() has been deprecated and 'dangerous' for a long time. You can interrupt the threads though",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-24T13:29:17Z",
    "diffHunk": "@@ -156,7 +157,34 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    def cleanUpIOThreads(): Unit = {\n+      if (proc.isAlive) {\n+        proc.destroy()\n+      }\n+      if (stdinWriterThread.isAlive) {\n+        stdinWriterThread.stop()"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "Yes, I'm aware `Thread.stop` is deprecated and 'dangerous' . I didn't think it's sufficient to just interrupt threads and should be safe enough to stop these IO threads. \r\n\r\nAfter a second thought, interrupt should be enough. Will update the code",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-24T15:43:05Z",
    "diffHunk": "@@ -156,7 +157,34 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    def cleanUpIOThreads(): Unit = {\n+      if (proc.isAlive) {\n+        proc.destroy()\n+      }\n+      if (stdinWriterThread.isAlive) {\n+        stdinWriterThread.stop()"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think you can inline this method call. At least, no need to wrap it in another function to invoke it.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-24T13:29:59Z",
    "diffHunk": "@@ -156,7 +157,34 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    def cleanUpIOThreads(): Unit = {\n+      if (proc.isAlive) {\n+        proc.destroy()\n+      }\n+      if (stdinWriterThread.isAlive) {\n+        stdinWriterThread.stop()\n+      }\n+\n+      if (stderrReaderThread.isAlive) {\n+        stderrReaderThread.stop()\n+      }\n+    }\n+\n+    // stops stdin writer and stderr read threads when the corresponding task is finished as a safe\n+    // belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time\n+    // consuming to generate(ShuffledRDD's shuffle operation for example), the outlived stdin writer\n+    // thread will consume significant memory and cpu time. Also, there's race condition for\n+    // ShuffledRDD + PipedRDD if the subprocess command is failed. The task will be marked as failed\n+    // , ShuffleBlockFetcherIterator will be cleaned up at task completion, which may hangs\n+    // ShuffleBlockFetcherIterator.next() call. The failed tasks' stdin writer never exits and leaks\n+    // significant memory held in ShufflerReader.\n+    context.addTaskCompletionListener[Unit](_ => cleanUpIOThreads())"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "Yes, will fix that.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-24T15:43:44Z",
    "diffHunk": "@@ -156,7 +157,34 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    def cleanUpIOThreads(): Unit = {\n+      if (proc.isAlive) {\n+        proc.destroy()\n+      }\n+      if (stdinWriterThread.isAlive) {\n+        stdinWriterThread.stop()\n+      }\n+\n+      if (stderrReaderThread.isAlive) {\n+        stderrReaderThread.stop()\n+      }\n+    }\n+\n+    // stops stdin writer and stderr read threads when the corresponding task is finished as a safe\n+    // belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time\n+    // consuming to generate(ShuffledRDD's shuffle operation for example), the outlived stdin writer\n+    // thread will consume significant memory and cpu time. Also, there's race condition for\n+    // ShuffledRDD + PipedRDD if the subprocess command is failed. The task will be marked as failed\n+    // , ShuffleBlockFetcherIterator will be cleaned up at task completion, which may hangs\n+    // ShuffleBlockFetcherIterator.next() call. The failed tasks' stdin writer never exits and leaks\n+    // significant memory held in ShufflerReader.\n+    context.addTaskCompletionListener[Unit](_ => cleanUpIOThreads())"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Is this needed if the task completion listener also interrupts it?",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T00:58:30Z",
    "diffHunk": "@@ -185,6 +211,10 @@ private[spark] class PipedRDD[T: ClassTag](\n       }\n \n       private def cleanup(): Unit = {\n+        // interrupt the stdin writer thread, so the stdin writer thread for ShuffledRDD could be"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "Not necessary. This will happen first if command is failed/exited, then interrupt in task completion listener is redundant.\r\n\r\nThis is my initial fix. Will remove it.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T03:09:34Z",
    "diffHunk": "@@ -185,6 +211,10 @@ private[spark] class PipedRDD[T: ClassTag](\n       }\n \n       private def cleanup(): Unit = {\n+        // interrupt the stdin writer thread, so the stdin writer thread for ShuffledRDD could be"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Does the second part of the comment, beginning at \"Also,\", belong below in the change to `ShuffleBlockFetcherIterator`?",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T01:03:06Z",
    "diffHunk": "@@ -156,7 +157,32 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr read threads when the corresponding task is finished as a\n+    // safe belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time\n+    // consuming to generate(ShuffledRDD's shuffle operation for example), the outlived stdin writer\n+    // thread will consume significant memory and cpu time. Also, there's race condition for"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "This is a tricky one. After the fix in this pr to `ShuffleBlockFetcherIterator`, the race condition should be really rare as only one potential next call may hang.  However I am unable to find a good place to put the above comment in `ShuffleBlockFetcherIterator`. So it's inside this `task completion listener`.\r\n\r\nDo you have any suggestion?",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T03:21:11Z",
    "diffHunk": "@@ -156,7 +157,32 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr read threads when the corresponding task is finished as a\n+    // safe belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time\n+    // consuming to generate(ShuffledRDD's shuffle operation for example), the outlived stdin writer\n+    // thread will consume significant memory and cpu time. Also, there's race condition for"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Why not put the comment next to the change in ShuffleBlockFetcherIterator?",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T15:43:51Z",
    "diffHunk": "@@ -156,7 +157,32 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr read threads when the corresponding task is finished as a\n+    // safe belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time\n+    // consuming to generate(ShuffledRDD's shuffle operation for example), the outlived stdin writer\n+    // thread will consume significant memory and cpu time. Also, there's race condition for"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "typo? stderr read -> stderr reader",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T04:15:57Z",
    "diffHunk": "@@ -156,7 +157,32 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr read threads when the corresponding task is finished as a"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "Will fix.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T08:52:43Z",
    "diffHunk": "@@ -156,7 +157,32 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr read threads when the corresponding task is finished as a"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: this comma seems misplaced",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-25T15:44:12Z",
    "diffHunk": "@@ -156,7 +157,32 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr reader threads when the corresponding task is finished as\n+    // a safe belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time\n+    // consuming to generate(ShuffledRDD's shuffle operation for example), the outlived stdin writer\n+    // thread will consume significant memory and cpu time. Also, there's race condition for\n+    // ShuffledRDD + PipedRDD if the subprocess command is failed. The task will be marked as failed\n+    // , ShuffleBlockFetcherIterator will be cleaned up at task completion, which may hang"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "safe belt -> remove this? not sure what it's getting at.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-26T15:21:39Z",
    "diffHunk": "@@ -156,7 +157,28 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr reader threads when the corresponding task is finished as\n+    // a safe belt. Otherwise, these threads could outlive the task's lifetime. For example:"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "Will fix.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-26T15:43:44Z",
    "diffHunk": "@@ -156,7 +157,28 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr reader threads when the corresponding task is finished as\n+    // a safe belt. Otherwise, these threads could outlive the task's lifetime. For example:"
  }],
  "prId": 23638
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "is time consuming -> takes a long time? \r\noutlived stdin writer -> stdin writer?\r\ncpu -> CPU",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-26T15:22:19Z",
    "diffHunk": "@@ -156,7 +157,28 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr reader threads when the corresponding task is finished as\n+    // a safe belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time"
  }, {
    "author": {
      "login": "advancedxy"
    },
    "body": "Thanks. Will fix.",
    "commit": "be18ba7fe303e1d6a0101a2df1e2c84a48fc9d39",
    "createdAt": "2019-01-26T15:43:55Z",
    "diffHunk": "@@ -156,7 +157,28 @@ private[spark] class PipedRDD[T: ClassTag](\n           out.close()\n         }\n       }\n-    }.start()\n+    }\n+    stdinWriterThread.start()\n+\n+    // interrupts stdin writer and stderr reader threads when the corresponding task is finished as\n+    // a safe belt. Otherwise, these threads could outlive the task's lifetime. For example:\n+    //   val pipeRDD = sc.range(1, 100).pipe(Seq(\"cat\"))\n+    //   val abnormalRDD = pipeRDD.mapPartitions(_ => Iterator.empty)\n+    // the iterator generated by PipedRDD is never involved. If the parent RDD's iterator is time"
  }],
  "prId": 23638
}]