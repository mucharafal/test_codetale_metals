[{
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Instead of returning this Hadoop data type, can we return a java.io.DataInputStream? It's easier to maintain in the future.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:21:29Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Formatting here is kind of wrong, the arguments should be indented only 4 spaces\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:21:53Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "I think you can just write = null\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:22:34Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "IMO we should call this BinaryData or DataStream instead of PortableDataStream, because the user doesn't really care that it's portable. I prefer BinaryData slightly more but I'd also be okay with DataStream.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:23:57Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Put spaces around binary operators like `*` and `/`\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:28:29Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Put spaces after all commas\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:29:02Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)\n+  extends RecordReader[String, T] {\n+\n+\n+\n+  // True means the current file has been processed, then skip it.\n+  private var processed = false\n+\n+  private var key = \"\"\n+  private var value: T = null.asInstanceOf[T]\n+\n+\n+  override def initialize(split: InputSplit, context: TaskAttemptContext) = {}\n+  override def close() = {}\n+\n+  override def getProgress = if (processed) 1.0f else 0.0f\n+\n+  override def getCurrentKey = key\n+\n+  override def getCurrentValue = value\n+\n+\n+\n+  override def nextKeyValue = {\n+    if (!processed) {\n+      val fileIn = new PortableDataStream(split,context,index)\n+      value = parseStream(fileIn)\n+      fileIn.close() // if it has not been open yet, close does nothing\n+      key = fileIn.getPath\n+      processed = true\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Parse the stream (and close it afterwards) and return the value as in type T\n+   * @param inStream the stream to be read in\n+   * @return the data formatted as\n+   */\n+  def parseStream(inStream: PortableDataStream): T\n+}\n+\n+/**\n+ * Reads the record in directly as a stream for other objects to manipulate and handle\n+ */\n+private[spark] class StreamRecordReader(\n+                                         split: CombineFileSplit,\n+                                         context: TaskAttemptContext,\n+                                         index: Integer)\n+  extends StreamBasedRecordReader[PortableDataStream](split,context,index) {\n+\n+  def parseStream(inStream: PortableDataStream): PortableDataStream = inStream\n+}\n+\n+/**\n+ * A class for extracting the information from the file using the\n+ * BinaryRecordReader (as Byte array)\n+ */\n+private[spark] class StreamInputFormat extends StreamFileInputFormat[PortableDataStream] {\n+  override def createRecordReader(split: InputSplit, taContext: TaskAttemptContext)=\n+  {\n+    new CombineFileRecordReader[String,PortableDataStream](\n+      split.asInstanceOf[CombineFileSplit],taContext,classOf[StreamRecordReader]"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "This should probably be `private[spark]`\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-09-18T03:29:37Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)\n+  extends RecordReader[String, T] {\n+\n+\n+\n+  // True means the current file has been processed, then skip it.\n+  private var processed = false\n+\n+  private var key = \"\"\n+  private var value: T = null.asInstanceOf[T]\n+\n+\n+  override def initialize(split: InputSplit, context: TaskAttemptContext) = {}\n+  override def close() = {}\n+\n+  override def getProgress = if (processed) 1.0f else 0.0f\n+\n+  override def getCurrentKey = key\n+\n+  override def getCurrentValue = value\n+\n+\n+\n+  override def nextKeyValue = {\n+    if (!processed) {\n+      val fileIn = new PortableDataStream(split,context,index)\n+      value = parseStream(fileIn)\n+      fileIn.close() // if it has not been open yet, close does nothing\n+      key = fileIn.getPath\n+      processed = true\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Parse the stream (and close it afterwards) and return the value as in type T\n+   * @param inStream the stream to be read in\n+   * @return the data formatted as\n+   */\n+  def parseStream(inStream: PortableDataStream): T\n+}\n+\n+/**\n+ * Reads the record in directly as a stream for other objects to manipulate and handle\n+ */\n+private[spark] class StreamRecordReader(\n+                                         split: CombineFileSplit,\n+                                         context: TaskAttemptContext,\n+                                         index: Integer)\n+  extends StreamBasedRecordReader[PortableDataStream](split,context,index) {\n+\n+  def parseStream(inStream: PortableDataStream): PortableDataStream = inStream\n+}\n+\n+/**\n+ * A class for extracting the information from the file using the\n+ * BinaryRecordReader (as Byte array)\n+ */\n+private[spark] class StreamInputFormat extends StreamFileInputFormat[PortableDataStream] {\n+  override def createRecordReader(split: InputSplit, taContext: TaskAttemptContext)=\n+  {\n+    new CombineFileRecordReader[String,PortableDataStream](\n+      split.asInstanceOf[CombineFileSplit],taContext,classOf[StreamRecordReader]\n+    )\n+  }\n+}\n+\n+/**\n+ * A [[org.apache.hadoop.mapreduce.RecordReader RecordReader]] for reading a single binary file\n+ * out in a key-value pair, where the key is the file path and the value is the entire content of\n+ * the file as a byte array\n+ */\n+abstract class BinaryRecordReader[T]("
  }, {
    "author": {
      "login": "kmader"
    },
    "body": "I would prefer this as public so my other tools can extend it without being in org.apache.spark, as I imagine there will be a number of more specific types like TIFFReader, MP3Reader, AVIReader, etc \n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-01T08:54:07Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)\n+  extends RecordReader[String, T] {\n+\n+\n+\n+  // True means the current file has been processed, then skip it.\n+  private var processed = false\n+\n+  private var key = \"\"\n+  private var value: T = null.asInstanceOf[T]\n+\n+\n+  override def initialize(split: InputSplit, context: TaskAttemptContext) = {}\n+  override def close() = {}\n+\n+  override def getProgress = if (processed) 1.0f else 0.0f\n+\n+  override def getCurrentKey = key\n+\n+  override def getCurrentValue = value\n+\n+\n+\n+  override def nextKeyValue = {\n+    if (!processed) {\n+      val fileIn = new PortableDataStream(split,context,index)\n+      value = parseStream(fileIn)\n+      fileIn.close() // if it has not been open yet, close does nothing\n+      key = fileIn.getPath\n+      processed = true\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Parse the stream (and close it afterwards) and return the value as in type T\n+   * @param inStream the stream to be read in\n+   * @return the data formatted as\n+   */\n+  def parseStream(inStream: PortableDataStream): T\n+}\n+\n+/**\n+ * Reads the record in directly as a stream for other objects to manipulate and handle\n+ */\n+private[spark] class StreamRecordReader(\n+                                         split: CombineFileSplit,\n+                                         context: TaskAttemptContext,\n+                                         index: Integer)\n+  extends StreamBasedRecordReader[PortableDataStream](split,context,index) {\n+\n+  def parseStream(inStream: PortableDataStream): PortableDataStream = inStream\n+}\n+\n+/**\n+ * A class for extracting the information from the file using the\n+ * BinaryRecordReader (as Byte array)\n+ */\n+private[spark] class StreamInputFormat extends StreamFileInputFormat[PortableDataStream] {\n+  override def createRecordReader(split: InputSplit, taContext: TaskAttemptContext)=\n+  {\n+    new CombineFileRecordReader[String,PortableDataStream](\n+      split.asInstanceOf[CombineFileSplit],taContext,classOf[StreamRecordReader]\n+    )\n+  }\n+}\n+\n+/**\n+ * A [[org.apache.hadoop.mapreduce.RecordReader RecordReader]] for reading a single binary file\n+ * out in a key-value pair, where the key is the file path and the value is the entire content of\n+ * the file as a byte array\n+ */\n+abstract class BinaryRecordReader[T]("
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "In that case, add `@DeveloperApi` to it to make clear that this is an internal API. In general Spark provides very strong API compatibility guarantees (https://cwiki.apache.org/confluence/display/SPARK/Spark+Versioning+Policy) so we don't try to expose stuff unless we have to. Specifically, unless you make this DeveloperApi, you wouldn't be able to break the API or the semantics of this class in future Spark releases. For DeveloperApi we allow that, though we still discourage it, because we warn users that it might change.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-01T18:58:54Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)\n+  extends RecordReader[String, T] {\n+\n+\n+\n+  // True means the current file has been processed, then skip it.\n+  private var processed = false\n+\n+  private var key = \"\"\n+  private var value: T = null.asInstanceOf[T]\n+\n+\n+  override def initialize(split: InputSplit, context: TaskAttemptContext) = {}\n+  override def close() = {}\n+\n+  override def getProgress = if (processed) 1.0f else 0.0f\n+\n+  override def getCurrentKey = key\n+\n+  override def getCurrentValue = value\n+\n+\n+\n+  override def nextKeyValue = {\n+    if (!processed) {\n+      val fileIn = new PortableDataStream(split,context,index)\n+      value = parseStream(fileIn)\n+      fileIn.close() // if it has not been open yet, close does nothing\n+      key = fileIn.getPath\n+      processed = true\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Parse the stream (and close it afterwards) and return the value as in type T\n+   * @param inStream the stream to be read in\n+   * @return the data formatted as\n+   */\n+  def parseStream(inStream: PortableDataStream): T\n+}\n+\n+/**\n+ * Reads the record in directly as a stream for other objects to manipulate and handle\n+ */\n+private[spark] class StreamRecordReader(\n+                                         split: CombineFileSplit,\n+                                         context: TaskAttemptContext,\n+                                         index: Integer)\n+  extends StreamBasedRecordReader[PortableDataStream](split,context,index) {\n+\n+  def parseStream(inStream: PortableDataStream): PortableDataStream = inStream\n+}\n+\n+/**\n+ * A class for extracting the information from the file using the\n+ * BinaryRecordReader (as Byte array)\n+ */\n+private[spark] class StreamInputFormat extends StreamFileInputFormat[PortableDataStream] {\n+  override def createRecordReader(split: InputSplit, taContext: TaskAttemptContext)=\n+  {\n+    new CombineFileRecordReader[String,PortableDataStream](\n+      split.asInstanceOf[CombineFileSplit],taContext,classOf[StreamRecordReader]\n+    )\n+  }\n+}\n+\n+/**\n+ * A [[org.apache.hadoop.mapreduce.RecordReader RecordReader]] for reading a single binary file\n+ * out in a key-value pair, where the key is the file path and the value is the entire content of\n+ * the file as a byte array\n+ */\n+abstract class BinaryRecordReader[T]("
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "I'm not sure I see re-use in other tools as a sufficiently strong reason for making this bytecode public. This is a fairly small class, can you just copy this class into your project? Making this public will tie our hands in terms of changing this in the future.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-01T23:48:32Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)\n+  extends RecordReader[String, T] {\n+\n+\n+\n+  // True means the current file has been processed, then skip it.\n+  private var processed = false\n+\n+  private var key = \"\"\n+  private var value: T = null.asInstanceOf[T]\n+\n+\n+  override def initialize(split: InputSplit, context: TaskAttemptContext) = {}\n+  override def close() = {}\n+\n+  override def getProgress = if (processed) 1.0f else 0.0f\n+\n+  override def getCurrentKey = key\n+\n+  override def getCurrentValue = value\n+\n+\n+\n+  override def nextKeyValue = {\n+    if (!processed) {\n+      val fileIn = new PortableDataStream(split,context,index)\n+      value = parseStream(fileIn)\n+      fileIn.close() // if it has not been open yet, close does nothing\n+      key = fileIn.getPath\n+      processed = true\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Parse the stream (and close it afterwards) and return the value as in type T\n+   * @param inStream the stream to be read in\n+   * @return the data formatted as\n+   */\n+  def parseStream(inStream: PortableDataStream): T\n+}\n+\n+/**\n+ * Reads the record in directly as a stream for other objects to manipulate and handle\n+ */\n+private[spark] class StreamRecordReader(\n+                                         split: CombineFileSplit,\n+                                         context: TaskAttemptContext,\n+                                         index: Integer)\n+  extends StreamBasedRecordReader[PortableDataStream](split,context,index) {\n+\n+  def parseStream(inStream: PortableDataStream): PortableDataStream = inStream\n+}\n+\n+/**\n+ * A class for extracting the information from the file using the\n+ * BinaryRecordReader (as Byte array)\n+ */\n+private[spark] class StreamInputFormat extends StreamFileInputFormat[PortableDataStream] {\n+  override def createRecordReader(split: InputSplit, taContext: TaskAttemptContext)=\n+  {\n+    new CombineFileRecordReader[String,PortableDataStream](\n+      split.asInstanceOf[CombineFileSplit],taContext,classOf[StreamRecordReader]\n+    )\n+  }\n+}\n+\n+/**\n+ * A [[org.apache.hadoop.mapreduce.RecordReader RecordReader]] for reading a single binary file\n+ * out in a key-value pair, where the key is the file path and the value is the entire content of\n+ * the file as a byte array\n+ */\n+abstract class BinaryRecordReader[T]("
  }, {
    "author": {
      "login": "kmader"
    },
    "body": "I have thought about the issue some more and due to the restructuring of the PR to use these PortableDataStreams. I now think that rather than implementing this abstract class, a better solution would be to take advantage of implicit class conversion and create for example implicit class PortableTiffReader(pds: PortableDataStream) with the method readAsTiff.\n-  keeps the implementations of readers independent from the underlying filesystem and serialization issues.\n- easier to add new file formats which can be imported with a simple import and used from binaryFiles directly.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-02T12:38:05Z",
    "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ByteStreams, Closeables}\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{FSDataInputStream, Path}\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.DataInputStream\n+\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String,T]  {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen*1.0/files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext):\n+  RecordReader[String,T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ */\n+class PortableDataStream(split: CombineFileSplit, context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+\n+  private var fileIn: FSDataInputStream = null.asInstanceOf[FSDataInputStream]\n+  private var isOpen = false\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): FSDataInputStream = {\n+    val pathp = split.getPath(index)\n+    val fs = pathp.getFileSystem(context.getConfiguration)\n+    fileIn = fs.open(pathp)\n+    isOpen=true\n+    fileIn\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen=false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing\n+      }\n+    }\n+  }\n+  def getPath(): String = path\n+}\n+\n+/**\n+ * An abstract class of [[org.apache.hadoop.mapreduce.RecordReader RecordReader]]\n+ * to reading files out as streams\n+ */\n+abstract class StreamBasedRecordReader[T](\n+                                           split: CombineFileSplit,\n+                                           context: TaskAttemptContext,\n+                                           index: Integer)\n+  extends RecordReader[String, T] {\n+\n+\n+\n+  // True means the current file has been processed, then skip it.\n+  private var processed = false\n+\n+  private var key = \"\"\n+  private var value: T = null.asInstanceOf[T]\n+\n+\n+  override def initialize(split: InputSplit, context: TaskAttemptContext) = {}\n+  override def close() = {}\n+\n+  override def getProgress = if (processed) 1.0f else 0.0f\n+\n+  override def getCurrentKey = key\n+\n+  override def getCurrentValue = value\n+\n+\n+\n+  override def nextKeyValue = {\n+    if (!processed) {\n+      val fileIn = new PortableDataStream(split,context,index)\n+      value = parseStream(fileIn)\n+      fileIn.close() // if it has not been open yet, close does nothing\n+      key = fileIn.getPath\n+      processed = true\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Parse the stream (and close it afterwards) and return the value as in type T\n+   * @param inStream the stream to be read in\n+   * @return the data formatted as\n+   */\n+  def parseStream(inStream: PortableDataStream): T\n+}\n+\n+/**\n+ * Reads the record in directly as a stream for other objects to manipulate and handle\n+ */\n+private[spark] class StreamRecordReader(\n+                                         split: CombineFileSplit,\n+                                         context: TaskAttemptContext,\n+                                         index: Integer)\n+  extends StreamBasedRecordReader[PortableDataStream](split,context,index) {\n+\n+  def parseStream(inStream: PortableDataStream): PortableDataStream = inStream\n+}\n+\n+/**\n+ * A class for extracting the information from the file using the\n+ * BinaryRecordReader (as Byte array)\n+ */\n+private[spark] class StreamInputFormat extends StreamFileInputFormat[PortableDataStream] {\n+  override def createRecordReader(split: InputSplit, taContext: TaskAttemptContext)=\n+  {\n+    new CombineFileRecordReader[String,PortableDataStream](\n+      split.asInstanceOf[CombineFileSplit],taContext,classOf[StreamRecordReader]\n+    )\n+  }\n+}\n+\n+/**\n+ * A [[org.apache.hadoop.mapreduce.RecordReader RecordReader]] for reading a single binary file\n+ * out in a key-value pair, where the key is the file path and the value is the entire content of\n+ * the file as a byte array\n+ */\n+abstract class BinaryRecordReader[T]("
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "No need for `@DeveloperApi` on this, we want to support it. It was only needed on the various input formats.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-08T20:45:08Z",
    "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ ByteStreams, Closeables }\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{ FSDataInputStream, Path }\n+import org.apache.spark.annotation.DeveloperApi\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.{ ByteArrayInputStream, ByteArrayOutputStream, DataOutputStream, DataInputStream }\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+private[spark] abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String, T] {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen * 1.0 / files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext): RecordReader[String, T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ * @note TaskAttemptContext is not serializable resulting in the confBytes construct\n+ * @note CombineFileSplit is not serializable resulting in the splitBytes construct\n+ */\n+@DeveloperApi"
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "Actually, one thing that would help is to make this a `trait` (i.e. interface in Java), so users can't instantiate it, and then have a `private[spark] class PortableDataStreamImpl` for the implementation. We don't want to expose the constructor if we can.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-08T20:46:32Z",
    "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ ByteStreams, Closeables }\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{ FSDataInputStream, Path }\n+import org.apache.spark.annotation.DeveloperApi\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.{ ByteArrayInputStream, ByteArrayOutputStream, DataOutputStream, DataInputStream }\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+private[spark] abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String, T] {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen * 1.0 / files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext): RecordReader[String, T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ * @note TaskAttemptContext is not serializable resulting in the confBytes construct\n+ * @note CombineFileSplit is not serializable resulting in the splitBytes construct\n+ */\n+@DeveloperApi"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "set isOpen = false here too, if closing failed. I think you can just set it to false above the try.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-08T20:47:12Z",
    "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.input\n+\n+import scala.collection.JavaConversions._\n+import com.google.common.io.{ ByteStreams, Closeables }\n+import org.apache.hadoop.mapreduce.InputSplit\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileSplit\n+import org.apache.hadoop.mapreduce.RecordReader\n+import org.apache.hadoop.mapreduce.TaskAttemptContext\n+import org.apache.hadoop.fs.{ FSDataInputStream, Path }\n+import org.apache.spark.annotation.DeveloperApi\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileInputFormat\n+import org.apache.hadoop.mapreduce.JobContext\n+import org.apache.hadoop.mapreduce.lib.input.CombineFileRecordReader\n+import java.io.{ ByteArrayInputStream, ByteArrayOutputStream, DataOutputStream, DataInputStream }\n+\n+/**\n+ *  A general format for reading whole files in as streams, byte arrays,\n+ *  or other functions to be added\n+ */\n+private[spark] abstract class StreamFileInputFormat[T]\n+  extends CombineFileInputFormat[String, T] {\n+  override protected def isSplitable(context: JobContext, file: Path): Boolean = false\n+  /**\n+   * Allow minPartitions set by end-user in order to keep compatibility with old Hadoop API.\n+   */\n+  def setMaxSplitSize(context: JobContext, minPartitions: Int) {\n+    val files = listStatus(context)\n+    val totalLen = files.map { file =>\n+      if (file.isDir) 0L else file.getLen\n+    }.sum\n+\n+    val maxSplitSize = Math.ceil(totalLen * 1.0 / files.length).toLong\n+    super.setMaxSplitSize(maxSplitSize)\n+  }\n+\n+  def createRecordReader(split: InputSplit, taContext: TaskAttemptContext): RecordReader[String, T]\n+\n+}\n+\n+/**\n+ * A class that allows DataStreams to be serialized and moved around by not creating them\n+ * until they need to be read\n+ * @note TaskAttemptContext is not serializable resulting in the confBytes construct\n+ * @note CombineFileSplit is not serializable resulting in the splitBytes construct\n+ */\n+@DeveloperApi\n+class PortableDataStream(@transient isplit: CombineFileSplit,\n+  @transient context: TaskAttemptContext, index: Integer)\n+  extends Serializable {\n+  // transient forces file to be reopened after being serialization\n+  // it is also used for non-serializable classes\n+\n+  @transient\n+  private var fileIn: DataInputStream = null.asInstanceOf[DataInputStream]\n+  @transient\n+  private var isOpen = false\n+\n+  private val confBytes = {\n+    val baos = new ByteArrayOutputStream()\n+    context.getConfiguration.write(new DataOutputStream(baos))\n+    baos.toByteArray\n+  }\n+\n+  private val splitBytes = {\n+    val baos = new ByteArrayOutputStream()\n+    isplit.write(new DataOutputStream(baos))\n+    baos.toByteArray\n+  }\n+\n+  @transient\n+  private lazy val split = {\n+    val bais = new ByteArrayInputStream(splitBytes)\n+    val nsplit = new CombineFileSplit()\n+    nsplit.readFields(new DataInputStream(bais))\n+    nsplit\n+  }\n+\n+  @transient\n+  private lazy val conf = {\n+    val bais = new ByteArrayInputStream(confBytes)\n+    val nconf = new Configuration()\n+    nconf.readFields(new DataInputStream(bais))\n+    nconf\n+  }\n+  /**\n+   * Calculate the path name independently of opening the file\n+   */\n+  @transient\n+  private lazy val path = {\n+    val pathp = split.getPath(index)\n+    pathp.toString\n+  }\n+\n+  /**\n+   * create a new DataInputStream from the split and context\n+   */\n+  def open(): DataInputStream = {\n+    if (!isOpen) {\n+      val pathp = split.getPath(index)\n+      val fs = pathp.getFileSystem(conf)\n+      fileIn = fs.open(pathp)\n+      isOpen = true\n+    }\n+    fileIn\n+  }\n+\n+  /**\n+   * Read the file as a byte array\n+   */\n+  def toArray(): Array[Byte] = {\n+    open()\n+    val innerBuffer = ByteStreams.toByteArray(fileIn)\n+    close()\n+    innerBuffer\n+  }\n+\n+  /**\n+   * close the file (if it is already open)\n+   */\n+  def close() = {\n+    if (isOpen) {\n+      try {\n+        fileIn.close()\n+        isOpen = false\n+      } catch {\n+        case ioe: java.io.IOException => // do nothing"
  }],
  "prId": 1658
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "This file contains several different classes none of which is named RawFileInput -- it would be better to move them to separate files, each named after the class. That makes them easier to find later.\n",
    "commit": "3c49a305033d76e07bca60a72600c0db544407dd",
    "createdAt": "2014-10-08T20:48:34Z",
    "diffHunk": "@@ -0,0 +1,219 @@\n+/*"
  }],
  "prId": 1658
}]