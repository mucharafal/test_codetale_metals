[{
  "comments": [{
    "author": {
      "login": "shivaram"
    },
    "body": "Is there a reason we should use Strings instead of Long - Just wondering as this will also add to memory overhead",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-06T06:24:24Z",
    "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I had the same question. But this is orthogonal to the changes in this PR. We can discussed it as a follow-up task.",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-06T19:19:31Z",
    "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String)"
  }],
  "prId": 16154
}, {
  "comments": [{
    "author": {
      "login": "falaki"
    },
    "body": "Would be good to catch the exception here and throw another one with more R-friendly message.",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-06T21:08:50Z",
    "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String)\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key.\n+   * Returns null if the key does not exist or has been removed.\n+   */\n+  @throws[NullPointerException](\"if key is null\")\n+  final def get(id: JVMObjectId): Object = objMap.get(id)"
  }, {
    "author": {
      "login": "felixcheung"
    },
    "body": "I'd agree completely, but generally the R-friendly handling would need to be done on the R side.\r\nRelated JIRA:\r\nhttps://issues.apache.org/jira/browse/SPARK-17838\r\nhttps://issues.apache.org/jira/browse/SPARK-18040\r\n",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-06T23:54:46Z",
    "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String)\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key.\n+   * Returns null if the key does not exist or has been removed.\n+   */\n+  @throws[NullPointerException](\"if key is null\")\n+  final def get(id: JVMObjectId): Object = objMap.get(id)"
  }],
  "prId": 16154
}, {
  "comments": [{
    "author": {
      "login": "shivaram"
    },
    "body": "I just noticed you made the `get` synchronized. Can we also make this synchronized ? In that case we will also have solved the thread safety issue ",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-08T21:45:18Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String) {\n+  require(id != null, \"Object ID cannot be null.\")\n+}\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key or None if not found.\n+   */\n+  final def get(id: JVMObjectId): Option[Object] = this.synchronized {\n+    if (objMap.containsKey(id)) {\n+      Some(objMap.get(id))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  /**\n+   * Returns the JVM object associated with the input key or throws an exception if not found.\n+   */\n+  @throws[NoSuchElementException](\"if key does not exist.\")\n+  final def apply(id: JVMObjectId): Object = {\n+    get(id).getOrElse(\n+      throw new NoSuchElementException(s\"$id does not exist.\")\n+    )\n+  }\n+\n+  /**\n+   * Adds a JVM object to track and returns assigned ID, which is unique within this tracker.\n+   */\n+  final def addAndGetId(obj: Object): JVMObjectId = {\n+    val id = JVMObjectId(objCounter.getAndIncrement().toString)",
    "line": 62
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Is it necessary? `objCounter` is an `AtomicLong`.",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-08T22:51:00Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String) {\n+  require(id != null, \"Object ID cannot be null.\")\n+}\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key or None if not found.\n+   */\n+  final def get(id: JVMObjectId): Option[Object] = this.synchronized {\n+    if (objMap.containsKey(id)) {\n+      Some(objMap.get(id))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  /**\n+   * Returns the JVM object associated with the input key or throws an exception if not found.\n+   */\n+  @throws[NoSuchElementException](\"if key does not exist.\")\n+  final def apply(id: JVMObjectId): Object = {\n+    get(id).getOrElse(\n+      throw new NoSuchElementException(s\"$id does not exist.\")\n+    )\n+  }\n+\n+  /**\n+   * Adds a JVM object to track and returns assigned ID, which is unique within this tracker.\n+   */\n+  final def addAndGetId(obj: Object): JVMObjectId = {\n+    val id = JVMObjectId(objCounter.getAndIncrement().toString)",
    "line": 62
  }, {
    "author": {
      "login": "shivaram"
    },
    "body": "The counter is atomic - but the map insert is not ? ",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-08T22:52:39Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String) {\n+  require(id != null, \"Object ID cannot be null.\")\n+}\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key or None if not found.\n+   */\n+  final def get(id: JVMObjectId): Option[Object] = this.synchronized {\n+    if (objMap.containsKey(id)) {\n+      Some(objMap.get(id))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  /**\n+   * Returns the JVM object associated with the input key or throws an exception if not found.\n+   */\n+  @throws[NoSuchElementException](\"if key does not exist.\")\n+  final def apply(id: JVMObjectId): Object = {\n+    get(id).getOrElse(\n+      throw new NoSuchElementException(s\"$id does not exist.\")\n+    )\n+  }\n+\n+  /**\n+   * Adds a JVM object to track and returns assigned ID, which is unique within this tracker.\n+   */\n+  final def addAndGetId(obj: Object): JVMObjectId = {\n+    val id = JVMObjectId(objCounter.getAndIncrement().toString)",
    "line": 62
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "But I don't see any safety issue. Two concurrent calls to `addAndGetId` will never share the same `id` because `getAndIncrement` is atomic and hence `objMap.put` won't overwrite each other. Let me know if I missed something.",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-08T23:09:49Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String) {\n+  require(id != null, \"Object ID cannot be null.\")\n+}\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key or None if not found.\n+   */\n+  final def get(id: JVMObjectId): Option[Object] = this.synchronized {\n+    if (objMap.containsKey(id)) {\n+      Some(objMap.get(id))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  /**\n+   * Returns the JVM object associated with the input key or throws an exception if not found.\n+   */\n+  @throws[NoSuchElementException](\"if key does not exist.\")\n+  final def apply(id: JVMObjectId): Object = {\n+    get(id).getOrElse(\n+      throw new NoSuchElementException(s\"$id does not exist.\")\n+    )\n+  }\n+\n+  /**\n+   * Adds a JVM object to track and returns assigned ID, which is unique within this tracker.\n+   */\n+  final def addAndGetId(obj: Object): JVMObjectId = {\n+    val id = JVMObjectId(objCounter.getAndIncrement().toString)",
    "line": 62
  }, {
    "author": {
      "login": "shivaram"
    },
    "body": "I was going to say that the keys wont clash, but that it might be unsafe to have two insert functions running at the same time. But I then realized you are using a ConcurrentHashMap, so that should be safe as well. I think the code is fine !",
    "commit": "efe332d6195ca43443d999eaba32e2ddff956e04",
    "createdAt": "2016-12-08T23:13:36Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.api.r\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/** JVM object ID wrapper */\n+private[r] case class JVMObjectId(id: String) {\n+  require(id != null, \"Object ID cannot be null.\")\n+}\n+\n+/**\n+ * Counter that tracks JVM objects returned to R.\n+ * This is useful for referencing these objects in RPC calls.\n+ */\n+private[r] class JVMObjectTracker {\n+\n+  private[this] val objMap = new ConcurrentHashMap[JVMObjectId, Object]()\n+  private[this] val objCounter = new AtomicInteger()\n+\n+  /**\n+   * Returns the JVM object associated with the input key or None if not found.\n+   */\n+  final def get(id: JVMObjectId): Option[Object] = this.synchronized {\n+    if (objMap.containsKey(id)) {\n+      Some(objMap.get(id))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  /**\n+   * Returns the JVM object associated with the input key or throws an exception if not found.\n+   */\n+  @throws[NoSuchElementException](\"if key does not exist.\")\n+  final def apply(id: JVMObjectId): Object = {\n+    get(id).getOrElse(\n+      throw new NoSuchElementException(s\"$id does not exist.\")\n+    )\n+  }\n+\n+  /**\n+   * Adds a JVM object to track and returns assigned ID, which is unique within this tracker.\n+   */\n+  final def addAndGetId(obj: Object): JVMObjectId = {\n+    val id = JVMObjectId(objCounter.getAndIncrement().toString)",
    "line": 62
  }],
  "prId": 16154
}]