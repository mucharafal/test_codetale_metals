[{
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "nit: buf.hasRemaining for this pattern of use",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-15T00:46:52Z",
    "diffHunk": "@@ -48,12 +50,30 @@ private[spark] object CryptoStreamUtils extends Logging {\n       os: OutputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): OutputStream = {\n-    val properties = toCryptoConf(sparkConf)\n-    val iv = createInitializationVector(properties)\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n     os.write(iv)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoOutputStream(transformationStr, properties, os,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    new CryptoOutputStream(params.transformation, params.conf, os, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `WritableByteChannel` for encryption.\n+   */\n+  def createWritableChannel(\n+      channel: WritableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): WritableByteChannel = {\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n+    val buf = ByteBuffer.wrap(iv)\n+    while (buf.remaining() > 0) {"
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "ByteStreams.readFully instead of the loop",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-15T19:42:31Z",
    "diffHunk": "@@ -63,12 +83,40 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    var read = 0\n+    while (read < iv.length) {\n+      val _read = is.read(iv, 0, iv.length)\n+      if (_read < 0) {\n+        throw new EOFException(\"Failed to read IV from stream.\")\n+      }\n+      read += _read\n+    }"
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "nit: The clear is not required.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-15T20:01:26Z",
    "diffHunk": "@@ -63,12 +83,40 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    var read = 0\n+    while (read < iv.length) {\n+      val _read = is.read(iv, 0, iv.length)\n+      if (_read < 0) {\n+        throw new EOFException(\"Failed to read IV from stream.\")\n+      }\n+      read += _read\n+    }\n+\n+    val params = new CryptoParams(key, sparkConf)\n+    new CryptoInputStream(params.transformation, params.conf, is, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `ReadableByteChannel` for decryption.\n+   */\n+  def createReadableChannel(\n+      channel: ReadableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): ReadableByteChannel = {\n+    val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n+    val buf = ByteBuffer.wrap(iv)\n+    buf.clear()"
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "This is a lousy bug ! Good thing that we dont seem to be hit by it (yet).",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-15T20:03:10Z",
    "diffHunk": "@@ -102,4 +150,34 @@ private[spark] object CryptoStreamUtils extends Logging {\n     }\n     iv\n   }\n+\n+  /**\n+   * This class is a workaround for CRYPTO-125, that forces all bytes to be written to the",
    "line": 98
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "There's a pretty nasty workaround for it in the network library... (the non-blocking workaround is a lot worse than this.)",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-20T17:18:50Z",
    "diffHunk": "@@ -102,4 +150,34 @@ private[spark] object CryptoStreamUtils extends Logging {\n     }\n     iv\n   }\n+\n+  /**\n+   * This class is a workaround for CRYPTO-125, that forces all bytes to be written to the",
    "line": 98
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "what does this while loop do?",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-17T05:42:56Z",
    "diffHunk": "@@ -63,12 +83,40 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    var read = 0\n+    while (read < iv.length) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "It avoids issues with short reads. It's unlikely to happen but I always write read code like this to be safe.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-17T16:31:56Z",
    "diffHunk": "@@ -63,12 +83,40 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    var read = 0\n+    while (read < iv.length) {"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Yeah, you can just use `ByteStreams.readFully(is, iv)`.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-17T21:30:45Z",
    "diffHunk": "@@ -63,12 +83,40 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    var read = 0\n+    while (read < iv.length) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Ah, missed that one. +1 for shorter code.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-17T21:41:23Z",
    "diffHunk": "@@ -63,12 +83,40 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    var read = 0\n+    while (read < iv.length) {"
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is it a separated bug fix?",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-17T05:44:21Z",
    "diffHunk": "@@ -102,4 +150,34 @@ private[spark] object CryptoStreamUtils extends Logging {\n     }\n     iv\n   }\n+\n+  /**\n+   * This class is a workaround for CRYPTO-125, that forces all bytes to be written to the\n+   * underlying channel. Since the callers of this API are using blocking I/O, there are no\n+   * concerns with regards to CPU usage here.",
    "line": 100
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "No. As the comment states, it's a workaround for a bug in the commons-crypto library, which would affect the code being added.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-17T16:32:50Z",
    "diffHunk": "@@ -102,4 +150,34 @@ private[spark] object CryptoStreamUtils extends Logging {\n     }\n     iv\n   }\n+\n+  /**\n+   * This class is a workaround for CRYPTO-125, that forces all bytes to be written to the\n+   * underlying channel. Since the callers of this API are using blocking I/O, there are no\n+   * concerns with regards to CPU usage here.",
    "line": 100
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is there any possibility this may be an infinite loop?",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-22T02:48:46Z",
    "diffHunk": "@@ -48,12 +51,30 @@ private[spark] object CryptoStreamUtils extends Logging {\n       os: OutputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): OutputStream = {\n-    val properties = toCryptoConf(sparkConf)\n-    val iv = createInitializationVector(properties)\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n     os.write(iv)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoOutputStream(transformationStr, properties, os,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    new CryptoOutputStream(params.transformation, params.conf, os, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `WritableByteChannel` for encryption.\n+   */\n+  def createWritableChannel(\n+      channel: WritableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): WritableByteChannel = {\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n+    val buf = ByteBuffer.wrap(iv)\n+    while (buf.hasRemaining()) {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "actually this logic is same with `CryptoHelperChannel.write`. Shall we create `CryptoHelperChannel` first and simply call `helper.write(buf)` here?",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-22T02:54:21Z",
    "diffHunk": "@@ -48,12 +51,30 @@ private[spark] object CryptoStreamUtils extends Logging {\n       os: OutputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): OutputStream = {\n-    val properties = toCryptoConf(sparkConf)\n-    val iv = createInitializationVector(properties)\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n     os.write(iv)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoOutputStream(transformationStr, properties, os,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    new CryptoOutputStream(params.transformation, params.conf, os, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `WritableByteChannel` for encryption.\n+   */\n+  def createWritableChannel(\n+      channel: WritableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): WritableByteChannel = {\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n+    val buf = ByteBuffer.wrap(iv)\n+    while (buf.hasRemaining()) {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "No, there's no infinite loop here, because a failure would cause an exception. Yeah, using the helper should work too.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-23T21:14:24Z",
    "diffHunk": "@@ -48,12 +51,30 @@ private[spark] object CryptoStreamUtils extends Logging {\n       os: OutputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): OutputStream = {\n-    val properties = toCryptoConf(sparkConf)\n-    val iv = createInitializationVector(properties)\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n     os.write(iv)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoOutputStream(transformationStr, properties, os,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    new CryptoOutputStream(params.transformation, params.conf, os, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `WritableByteChannel` for encryption.\n+   */\n+  def createWritableChannel(\n+      channel: WritableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): WritableByteChannel = {\n+    val params = new CryptoParams(key, sparkConf)\n+    val iv = createInitializationVector(params.conf)\n+    val buf = ByteBuffer.wrap(iv)\n+    while (buf.hasRemaining()) {"
  }],
  "prId": 17295
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why not use `ByteStreams.readFully`? the `buf` is not used else where",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-22T02:50:40Z",
    "diffHunk": "@@ -63,12 +84,27 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    ByteStreams.readFully(is, iv)\n+    val params = new CryptoParams(key, sparkConf)\n+    new CryptoInputStream(params.transformation, params.conf, is, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `ReadableByteChannel` for decryption.\n+   */\n+  def createReadableChannel(\n+      channel: ReadableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): ReadableByteChannel = {\n+    val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n+    val buf = ByteBuffer.wrap(iv)\n+    JavaUtils.readFully(channel, buf)",
    "line": 84
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "There's no `ByteStreams.readFully` for `ReadableByteChannel` that I'm aware of.",
    "commit": "4a39cb23dae86d4289bf529c27dae21680620cab",
    "createdAt": "2017-03-23T21:15:52Z",
    "diffHunk": "@@ -63,12 +84,27 @@ private[spark] object CryptoStreamUtils extends Logging {\n       is: InputStream,\n       sparkConf: SparkConf,\n       key: Array[Byte]): InputStream = {\n-    val properties = toCryptoConf(sparkConf)\n     val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n-    is.read(iv, 0, iv.length)\n-    val transformationStr = sparkConf.get(IO_CRYPTO_CIPHER_TRANSFORMATION)\n-    new CryptoInputStream(transformationStr, properties, is,\n-      new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv))\n+    ByteStreams.readFully(is, iv)\n+    val params = new CryptoParams(key, sparkConf)\n+    new CryptoInputStream(params.transformation, params.conf, is, params.keySpec,\n+      new IvParameterSpec(iv))\n+  }\n+\n+  /**\n+   * Wrap a `ReadableByteChannel` for decryption.\n+   */\n+  def createReadableChannel(\n+      channel: ReadableByteChannel,\n+      sparkConf: SparkConf,\n+      key: Array[Byte]): ReadableByteChannel = {\n+    val iv = new Array[Byte](IV_LENGTH_IN_BYTES)\n+    val buf = ByteBuffer.wrap(iv)\n+    JavaUtils.readFully(channel, buf)",
    "line": 84
  }],
  "prId": 17295
}]