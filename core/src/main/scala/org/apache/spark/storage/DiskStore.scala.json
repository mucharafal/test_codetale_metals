[{
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "If you actually want to handle this case; you should delete the file in case write failed.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-05-03T17:08:49Z",
    "diffHunk": "@@ -77,7 +77,12 @@ private class DiskStore(blockManager: BlockManager, diskManager: DiskBlockManage\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      blockManager.dataSerializeStream(blockId, outputStream, values)\n+    }\n+    finally {\n+      outputStream.close\n+    }"
  }],
  "prId": 577
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "Why not do the full `try catch finally` here, and put `outputStream.close()` in finally?\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-11T23:25:41Z",
    "diffHunk": "@@ -73,7 +73,17 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      blockManager.dataSerializeStream(blockId, outputStream, values)\n+      outputStream.close()\n+    } catch {\n+      case e: Throwable => {\n+        outputStream.close()\n+        if(file.exists()) file.delete()\n+        throw e\n+      }\n+    }\n+"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "I want to close the stream before deleting the file.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-12T14:47:52Z",
    "diffHunk": "@@ -73,7 +73,17 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      blockManager.dataSerializeStream(blockId, outputStream, values)\n+      outputStream.close()\n+    } catch {\n+      case e: Throwable => {\n+        outputStream.close()\n+        if(file.exists()) file.delete()\n+        throw e\n+      }\n+    }\n+"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "On Unix at least that's not necessary. It's possible to delete a file with open fds. The inodes will be released when you close the fd.\n\nDon't know if Windows follows the same semantics, though.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-12T18:17:40Z",
    "diffHunk": "@@ -73,7 +73,17 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      blockManager.dataSerializeStream(blockId, outputStream, values)\n+      outputStream.close()\n+    } catch {\n+      case e: Throwable => {\n+        outputStream.close()\n+        if(file.exists()) file.delete()\n+        throw e\n+      }\n+    }\n+"
  }],
  "prId": 577
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "prefer this style: `if (file.exists()) { file.delete() }`\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-11T23:26:02Z",
    "diffHunk": "@@ -73,7 +73,17 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      blockManager.dataSerializeStream(blockId, outputStream, values)\n+      outputStream.close()\n+    } catch {\n+      case e: Throwable => {\n+        outputStream.close()\n+        if(file.exists()) file.delete()"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Thanks. Already updated it.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-12T14:48:09Z",
    "diffHunk": "@@ -73,7 +73,17 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      blockManager.dataSerializeStream(blockId, outputStream, values)\n+      outputStream.close()\n+    } catch {\n+      case e: Throwable => {\n+        outputStream.close()\n+        if(file.exists()) file.delete()"
  }],
  "prId": 577
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "I think what you had before was actually clearer. Nested `try`s is a little more complicated. If you were worried about the 1 line duplicate code then maybe you can just add a comment to explain that \"outputStream should closed before file is delete\" or something.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-16T17:49:23Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {\n+          file.delete()\n+        }\n+        throw e\n+      }\n+    }",
    "line": 19
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "I noticed that `outputStream.close` also may throw IOException. Therefore I changed to this approach to make sure if any exception is thrown, we can always try to delete the file.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-17T02:13:28Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {\n+          file.delete()\n+        }\n+        throw e\n+      }\n+    }",
    "line": 19
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "Hm I'm still not so sure about having the nested `try`s. Doesn't this argument also apply to other changes made in this PR? I think it might be OK to just keep the close in both `try` and `catch` and have only 1 level of `try-catch`. It's already strictly better than before (maybe others disagree).\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-17T23:50:20Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {\n+          file.delete()\n+        }\n+        throw e\n+      }\n+    }",
    "line": 19
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "The previous codes are:\n\n``` scala\n1    try {\n2     blockManager.dataSerializeStream(blockId, outputStream, values)\n3      outputStream.close()\n4    } catch {\n5      case e: Throwable => {\n6        outputStream.close()\n7        if(file.exists()) {\n8          file.delete()\n9        }\n10        throw e\n11      }\n12   }\n```\n\nMy concern is if L6 outputStream.close() throws an exception, `if(file.exists()) { file.delete() }` won't be executed. So I changed to the nested `try`s.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-18T01:42:48Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {\n+          file.delete()\n+        }\n+        throw e\n+      }\n+    }",
    "line": 19
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "@andrewor14 do you agree my concern?\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-10-05T08:31:04Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {\n+          file.delete()\n+        }\n+        throw e\n+      }\n+    }",
    "line": 19
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "Ok, that seems fine.\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-10-05T16:54:31Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {\n+          file.delete()\n+        }\n+        throw e\n+      }\n+    }",
    "line": 19
  }],
  "prId": 577
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "need space after `if`\n",
    "commit": "c431095b05a84ca26e532e63c4b54f08f29abc78",
    "createdAt": "2014-09-16T17:49:42Z",
    "diffHunk": "@@ -73,7 +73,21 @@ private[spark] class DiskStore(blockManager: BlockManager, diskManager: DiskBloc\n     val startTime = System.currentTimeMillis\n     val file = diskManager.getFile(blockId)\n     val outputStream = new FileOutputStream(file)\n-    blockManager.dataSerializeStream(blockId, outputStream, values)\n+    try {\n+      try {\n+        blockManager.dataSerializeStream(blockId, outputStream, values)\n+      } finally {\n+        outputStream.close()\n+      }\n+    } catch {\n+      case e: Throwable => {\n+        if(file.exists()) {"
  }],
  "prId": 577
}]