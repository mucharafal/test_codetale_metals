[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "if its been cached by multiple executors on the same host, this will only return one of them.  I guess that is OK?  there isn't really an important scenario where it would become unavailable from one executor but still available on another.",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-10T02:08:35Z",
    "diffHunk": "@@ -438,12 +439,27 @@ class BlockManagerMasterEndpoint(\n     if (blockLocations.containsKey(blockId)) blockLocations.get(blockId).toSeq else Seq.empty\n   }\n \n-  private def getLocationsAndStatus(blockId: BlockId): Option[BlockLocationsAndStatus] = {\n+  private def getLocationsAndStatus(\n+      blockId: BlockId, requesterHost: String): Option[BlockLocationsAndStatus] = {\n     val locations = Option(blockLocations.get(blockId)).map(_.toSeq).getOrElse(Seq.empty)\n     val status = locations.headOption.flatMap { bmId => blockManagerInfo(bmId).getStatus(blockId) }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val bmIdToLocalDirs = if (status.get.storageLevel.useDisk) {\n+        locations\n+          .find(_.host == requesterHost)"
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "Yes that was my idea. First it is mostly only cached at one executor and even more rare to be cached/replicated on multiple executors but on the same host. So to give back only one of `localDirs` should be fine here.",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-10T10:03:14Z",
    "diffHunk": "@@ -438,12 +439,27 @@ class BlockManagerMasterEndpoint(\n     if (blockLocations.containsKey(blockId)) blockLocations.get(blockId).toSeq else Seq.empty\n   }\n \n-  private def getLocationsAndStatus(blockId: BlockId): Option[BlockLocationsAndStatus] = {\n+  private def getLocationsAndStatus(\n+      blockId: BlockId, requesterHost: String): Option[BlockLocationsAndStatus] = {\n     val locations = Option(blockLocations.get(blockId)).map(_.toSeq).getOrElse(Seq.empty)\n     val status = locations.headOption.flatMap { bmId => blockManagerInfo(bmId).getStatus(blockId) }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val bmIdToLocalDirs = if (status.get.storageLevel.useDisk) {\n+        locations\n+          .find(_.host == requesterHost)"
  }],
  "prId": 24554
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "minor: instead of `getOrElse`, you can use `orElse`, to avoid some of the extra `Some()` wrapping:\r\n\r\n```scala\r\nscala> def foo(x: Option[Int]): Option[String] = {\r\n     |   x.map { i => i.toString}.orElse(Some(\"nope\"))\r\n     | }\r\nfoo: (x: Option[Int])Option[String]\r\n\r\nscala> \r\n\r\nscala> foo(None)\r\nres1: Option[String] = Some(nope)\r\n\r\nscala> foo(Some(1))\r\nres2: Option[String] = Some(1)\r\n```",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-10T02:12:15Z",
    "diffHunk": "@@ -438,12 +439,27 @@ class BlockManagerMasterEndpoint(\n     if (blockLocations.containsKey(blockId)) blockLocations.get(blockId).toSeq else Seq.empty\n   }\n \n-  private def getLocationsAndStatus(blockId: BlockId): Option[BlockLocationsAndStatus] = {\n+  private def getLocationsAndStatus(\n+      blockId: BlockId, requesterHost: String): Option[BlockLocationsAndStatus] = {\n     val locations = Option(blockLocations.get(blockId)).map(_.toSeq).getOrElse(Seq.empty)\n     val status = locations.headOption.flatMap { bmId => blockManagerInfo(bmId).getStatus(blockId) }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val bmIdToLocalDirs = if (status.get.storageLevel.useDisk) {\n+        locations\n+          .find(_.host == requesterHost)\n+          .map { sameHostBlockId =>\n+            val bmInfo = blockManagerInfo(sameHostBlockId)\n+            bmInfo.blockManagerId -> bmInfo.localDirs\n+          }\n+      } else {\n+        None\n+      }\n+      bmIdToLocalDirs.map { case (bmId, localDirs) =>\n+        Some(BlockLocationsAndStatus(locations.filter(_ != bmId), status.get, Some(localDirs)))\n+      }.getOrElse(\n+        Some(BlockLocationsAndStatus(locations, status.get, None))"
  }],
  "prId": 24554
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: multi-line args",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-10T18:42:27Z",
    "diffHunk": "@@ -438,12 +439,27 @@ class BlockManagerMasterEndpoint(\n     if (blockLocations.containsKey(blockId)) blockLocations.get(blockId).toSeq else Seq.empty\n   }\n \n-  private def getLocationsAndStatus(blockId: BlockId): Option[BlockLocationsAndStatus] = {\n+  private def getLocationsAndStatus(\n+      blockId: BlockId, requesterHost: String): Option[BlockLocationsAndStatus] = {"
  }],
  "prId": 24554
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Hmm, this looks a little counter-intuitive, so a comment could help...\r\n\r\nI guess what you're doing here is sending back a list of block manager IDs where the block is stored, except for the one that owns the `localDirs` you're sending back?\r\n\r\nWill it break anything if you just send back the list of locations untouched?",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-10T18:47:43Z",
    "diffHunk": "@@ -438,12 +439,27 @@ class BlockManagerMasterEndpoint(\n     if (blockLocations.containsKey(blockId)) blockLocations.get(blockId).toSeq else Seq.empty\n   }\n \n-  private def getLocationsAndStatus(blockId: BlockId): Option[BlockLocationsAndStatus] = {\n+  private def getLocationsAndStatus(\n+      blockId: BlockId, requesterHost: String): Option[BlockLocationsAndStatus] = {\n     val locations = Option(blockLocations.get(blockId)).map(_.toSeq).getOrElse(Seq.empty)\n     val status = locations.headOption.flatMap { bmId => blockManagerInfo(bmId).getStatus(blockId) }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val bmIdToLocalDirs = if (status.get.storageLevel.useDisk) {\n+        locations\n+          .find(_.host == requesterHost)\n+          .map { sameHostBlockId =>\n+            val bmInfo = blockManagerInfo(sameHostBlockId)\n+            bmInfo.blockManagerId -> bmInfo.localDirs\n+          }\n+      } else {\n+        None\n+      }\n+      bmIdToLocalDirs.map { case (bmId, localDirs) =>\n+        BlockLocationsAndStatus(locations.filter(_ != bmId), status.get, Some(localDirs))"
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "I was thinking about this case and you are right better not use filterer out this one item from the locations: although this method is only used by one RPC call `GetLocationsAndStatus` which only used by the `BlockManager#getRemoteManagedBuffer` where the `localDirs` are used for accessing the block content and if that fails still there is some chance that this could be loaded from Memory (if the block was in Memory then spilled to Disk then promoted to Memory latter on, like Imran mentioned in #24499 ).\r\n",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-23T13:20:47Z",
    "diffHunk": "@@ -438,12 +439,27 @@ class BlockManagerMasterEndpoint(\n     if (blockLocations.containsKey(blockId)) blockLocations.get(blockId).toSeq else Seq.empty\n   }\n \n-  private def getLocationsAndStatus(blockId: BlockId): Option[BlockLocationsAndStatus] = {\n+  private def getLocationsAndStatus(\n+      blockId: BlockId, requesterHost: String): Option[BlockLocationsAndStatus] = {\n     val locations = Option(blockLocations.get(blockId)).map(_.toSeq).getOrElse(Seq.empty)\n     val status = locations.headOption.flatMap { bmId => blockManagerInfo(bmId).getStatus(blockId) }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val bmIdToLocalDirs = if (status.get.storageLevel.useDisk) {\n+        locations\n+          .find(_.host == requesterHost)\n+          .map { sameHostBlockId =>\n+            val bmInfo = blockManagerInfo(sameHostBlockId)\n+            bmInfo.blockManagerId -> bmInfo.localDirs\n+          }\n+      } else {\n+        None\n+      }\n+      bmIdToLocalDirs.map { case (bmId, localDirs) =>\n+        BlockLocationsAndStatus(locations.filter(_ != bmId), status.get, Some(localDirs))"
  }],
  "prId": 24554
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Can it be that the RDD is only on disk in a different host (e.g. for RDDs that have replication > 1)? Can that be detected here instead of triggering the failure handling on the reader and falling back to the network path?",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-28T23:53:12Z",
    "diffHunk": "@@ -522,7 +525,12 @@ class BlockManagerMasterEndpoint(\n     }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val localDirs = if (status.get.storageLevel.useDisk) {\n+        locations.find(_.host == requesterHost).map(blockManagerInfo(_).localDirs)"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "I was confused by your comment at first, but I guess you are saying the block is cached in memory on the requestorHost, and on disk on another host?  That's a good point, I guess you'd look at more than just `headOption` in the creation of `val status` above, but to look at the status in locations w/ the matching host.",
    "commit": "261fc767a23061844e32b1a7ec0e8fd58c42e12c",
    "createdAt": "2019-05-30T20:13:14Z",
    "diffHunk": "@@ -522,7 +525,12 @@ class BlockManagerMasterEndpoint(\n     }\n \n     if (locations.nonEmpty && status.isDefined) {\n-      Some(BlockLocationsAndStatus(locations, status.get))\n+      val localDirs = if (status.get.storageLevel.useDisk) {\n+        locations.find(_.host == requesterHost).map(blockManagerInfo(_).localDirs)"
  }],
  "prId": 24554
}]