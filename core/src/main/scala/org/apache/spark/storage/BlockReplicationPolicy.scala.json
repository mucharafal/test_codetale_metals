[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we use `LinkedHashSet` so that we don't need this extra shuffle?",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-22T00:46:09Z",
    "diffHunk": "@@ -53,6 +53,48 @@ trait BlockReplicationPolicy {\n       numReplicas: Int): List[BlockManagerId]\n }\n \n+object BlockReplicationUtils {\n+  // scalastyle:off line.size.limit\n+  /**\n+   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n+   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n+   * here</a>.\n+   *\n+   * @param n total number of indices\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @return list of m random unique indices\n+   */\n+  // scalastyle:on line.size.limit\n+  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n+    val indices = (n - m + 1 to n).foldLeft(Set.empty[Int]) {case (set, i) =>\n+      val t = r.nextInt(i) + 1\n+      if (set.contains(t)) set + i else set + t\n+    }\n+    // we shuffle the result to ensure a random arrangement within the sample\n+    // to avoid any bias from set implementations\n+    r.shuffle(indices.map(_ - 1).toList)"
  }],
  "prId": 13932
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can we explain the replicating logic for any replication factor?",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-22T00:50:10Z",
    "diffHunk": "@@ -88,26 +131,94 @@ class RandomBlockReplicationPolicy\n     logDebug(s\"Prioritized peers : ${prioritizedPeers.mkString(\", \")}\")\n     prioritizedPeers\n   }\n+}\n+\n+@DeveloperApi\n+class BasicBlockReplicationPolicy\n+  extends BlockReplicationPolicy\n+    with Logging {\n \n-  // scalastyle:off line.size.limit\n   /**\n-   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n-   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n-   * here</a>.\n+   * Method to prioritize a bunch of candidate peers of a block manager. This implementation\n+   * replicates the behavior of block replication in HDFS, a peer is chosen within the rack,"
  }],
  "prId": 13932
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we add a `.filter(_.host != blockManagerId.host)`?",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-24T04:29:40Z",
    "diffHunk": "@@ -88,26 +129,96 @@ class RandomBlockReplicationPolicy\n     logDebug(s\"Prioritized peers : ${prioritizedPeers.mkString(\", \")}\")\n     prioritizedPeers\n   }\n+}\n+\n+@DeveloperApi\n+class BasicBlockReplicationPolicy\n+  extends BlockReplicationPolicy\n+    with Logging {\n \n-  // scalastyle:off line.size.limit\n   /**\n-   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n-   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n-   * here</a>.\n+   * Method to prioritize a bunch of candidate peers of a block manager. This implementation\n+   * replicates the behavior of block replication in HDFS. For a given number of replicas needed,\n+   * we choose a peer within the rack, one outside and remaining blockmanagers are chosen at\n+   * random, in that order till we meet the number of replicas needed.\n+   * This works best with a total replication factor of 3, like HDFS.\n    *\n-   * @param n total number of indices\n-   * @param m number of samples needed\n-   * @param r random number generator\n-   * @return list of m random unique indices\n+   * @param blockManagerId    Id of the current BlockManager for self identification\n+   * @param peers             A list of peers of a BlockManager\n+   * @param peersReplicatedTo Set of peers already replicated to\n+   * @param blockId           BlockId of the block being replicated. This can be used as a source of\n+   *                          randomness if needed.\n+   * @param numReplicas Number of peers we need to replicate to\n+   * @return A prioritized list of peers. Lower the index of a peer, higher its priority\n    */\n-  // scalastyle:on line.size.limit\n-  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n-    val indices = (n - m + 1 to n).foldLeft(Set.empty[Int]) {case (set, i) =>\n-      val t = r.nextInt(i) + 1\n-      if (set.contains(t)) set + i else set + t\n+  override def prioritize(\n+      blockManagerId: BlockManagerId,\n+      peers: Seq[BlockManagerId],\n+      peersReplicatedTo: mutable.HashSet[BlockManagerId],\n+      blockId: BlockId,\n+      numReplicas: Int): List[BlockManagerId] = {\n+\n+    logDebug(s\"Input peers : $peers\")\n+    logDebug(s\"BlockManagerId : $blockManagerId\")\n+\n+    val random = new Random(blockId.hashCode)\n+\n+    // if block doesn't have topology info, we can't do much, so we randomly shuffle\n+    // if there is, we see what's needed from peersReplicatedTo and based on numReplicas,\n+    // we choose whats needed\n+    if (blockManagerId.topologyInfo.isEmpty || numReplicas == 0) {\n+      // no topology info for the block. The best we can do is randomly choose peers\n+      BlockReplicationUtils.getRandomSample(peers, numReplicas, random)\n+    } else {\n+      // we have topology information, we see what is left to be done from peersReplicatedTo\n+      val doneWithinRack = peersReplicatedTo.exists(_.topologyInfo == blockManagerId.topologyInfo)",
    "line": 123
  }, {
    "author": {
      "login": "shubhamchopra"
    },
    "body": "Master ensures the list of peers sent to a block manager doesn't include the requesting block manager. Was that the intention here?",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-27T15:36:29Z",
    "diffHunk": "@@ -88,26 +129,96 @@ class RandomBlockReplicationPolicy\n     logDebug(s\"Prioritized peers : ${prioritizedPeers.mkString(\", \")}\")\n     prioritizedPeers\n   }\n+}\n+\n+@DeveloperApi\n+class BasicBlockReplicationPolicy\n+  extends BlockReplicationPolicy\n+    with Logging {\n \n-  // scalastyle:off line.size.limit\n   /**\n-   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n-   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n-   * here</a>.\n+   * Method to prioritize a bunch of candidate peers of a block manager. This implementation\n+   * replicates the behavior of block replication in HDFS. For a given number of replicas needed,\n+   * we choose a peer within the rack, one outside and remaining blockmanagers are chosen at\n+   * random, in that order till we meet the number of replicas needed.\n+   * This works best with a total replication factor of 3, like HDFS.\n    *\n-   * @param n total number of indices\n-   * @param m number of samples needed\n-   * @param r random number generator\n-   * @return list of m random unique indices\n+   * @param blockManagerId    Id of the current BlockManager for self identification\n+   * @param peers             A list of peers of a BlockManager\n+   * @param peersReplicatedTo Set of peers already replicated to\n+   * @param blockId           BlockId of the block being replicated. This can be used as a source of\n+   *                          randomness if needed.\n+   * @param numReplicas Number of peers we need to replicate to\n+   * @return A prioritized list of peers. Lower the index of a peer, higher its priority\n    */\n-  // scalastyle:on line.size.limit\n-  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n-    val indices = (n - m + 1 to n).foldLeft(Set.empty[Int]) {case (set, i) =>\n-      val t = r.nextInt(i) + 1\n-      if (set.contains(t)) set + i else set + t\n+  override def prioritize(\n+      blockManagerId: BlockManagerId,\n+      peers: Seq[BlockManagerId],\n+      peersReplicatedTo: mutable.HashSet[BlockManagerId],\n+      blockId: BlockId,\n+      numReplicas: Int): List[BlockManagerId] = {\n+\n+    logDebug(s\"Input peers : $peers\")\n+    logDebug(s\"BlockManagerId : $blockManagerId\")\n+\n+    val random = new Random(blockId.hashCode)\n+\n+    // if block doesn't have topology info, we can't do much, so we randomly shuffle\n+    // if there is, we see what's needed from peersReplicatedTo and based on numReplicas,\n+    // we choose whats needed\n+    if (blockManagerId.topologyInfo.isEmpty || numReplicas == 0) {\n+      // no topology info for the block. The best we can do is randomly choose peers\n+      BlockReplicationUtils.getRandomSample(peers, numReplicas, random)\n+    } else {\n+      // we have topology information, we see what is left to be done from peersReplicatedTo\n+      val doneWithinRack = peersReplicatedTo.exists(_.topologyInfo == blockManagerId.topologyInfo)",
    "line": 123
  }],
  "prId": 13932
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "~~Given that you're already shuffling the sample here anyways, just out of curiosity is there any advantage of using Robert Floyd's algorithm over (say) Fisher-Yates~~? Also, more generally, is space complexity really a concern here? Can't we just use `r.shuffle(totalSize).take(sampleSize)` for easy readability?\r\n\r\nEDIT: Please ignore my first concern. I misread the code.",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-24T18:27:41Z",
    "diffHunk": "@@ -53,6 +53,46 @@ trait BlockReplicationPolicy {\n       numReplicas: Int): List[BlockManagerId]\n }\n \n+object BlockReplicationUtils {\n+  // scalastyle:off line.size.limit\n+  /**\n+   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n+   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n+   * here</a>.\n+   *\n+   * @param n total number of indices\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @return list of m random unique indices\n+   */\n+  // scalastyle:on line.size.limit\n+  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n+    val indices = (n - m + 1 to n).foldLeft(mutable.LinkedHashSet.empty[Int]) {case (set, i) =>\n+      val t = r.nextInt(i) + 1\n+      if (set.contains(t)) set + i else set + t\n+    }\n+    indices.map(_ - 1).toList\n+  }\n+\n+  /**\n+   * Get a random sample of size m from the elems\n+   *\n+   * @param elems\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @tparam T\n+   * @return a random list of size m. If there are fewer than m elements in elems, we just\n+   *         randomly shuffle elems\n+   */\n+  def getRandomSample[T](elems: Seq[T], m: Int, r: Random): List[T] = {\n+    if (elems.size > m) {\n+      getSampleIds(elems.size, m, r).map(elems(_))\n+    } else {\n+      r.shuffle(elems).toList",
    "line": 39
  }, {
    "author": {
      "login": "shubhamchopra"
    },
    "body": "I completely agree with you here. Except I was told earlier that iterating through a list the size of the executors was a concern. So this was to address time complexity.",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-27T15:42:34Z",
    "diffHunk": "@@ -53,6 +53,46 @@ trait BlockReplicationPolicy {\n       numReplicas: Int): List[BlockManagerId]\n }\n \n+object BlockReplicationUtils {\n+  // scalastyle:off line.size.limit\n+  /**\n+   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n+   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n+   * here</a>.\n+   *\n+   * @param n total number of indices\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @return list of m random unique indices\n+   */\n+  // scalastyle:on line.size.limit\n+  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n+    val indices = (n - m + 1 to n).foldLeft(mutable.LinkedHashSet.empty[Int]) {case (set, i) =>\n+      val t = r.nextInt(i) + 1\n+      if (set.contains(t)) set + i else set + t\n+    }\n+    indices.map(_ - 1).toList\n+  }\n+\n+  /**\n+   * Get a random sample of size m from the elems\n+   *\n+   * @param elems\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @tparam T\n+   * @return a random list of size m. If there are fewer than m elements in elems, we just\n+   *         randomly shuffle elems\n+   */\n+  def getRandomSample[T](elems: Seq[T], m: Int, r: Random): List[T] = {\n+    if (elems.size > m) {\n+      getSampleIds(elems.size, m, r).map(elems(_))\n+    } else {\n+      r.shuffle(elems).toList",
    "line": 39
  }, {
    "author": {
      "login": "sameeragarwal"
    },
    "body": "But isn't the time complexity same for both cases? It seems like they both only differ in terms of space complexity.",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-28T18:09:27Z",
    "diffHunk": "@@ -53,6 +53,46 @@ trait BlockReplicationPolicy {\n       numReplicas: Int): List[BlockManagerId]\n }\n \n+object BlockReplicationUtils {\n+  // scalastyle:off line.size.limit\n+  /**\n+   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n+   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n+   * here</a>.\n+   *\n+   * @param n total number of indices\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @return list of m random unique indices\n+   */\n+  // scalastyle:on line.size.limit\n+  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n+    val indices = (n - m + 1 to n).foldLeft(mutable.LinkedHashSet.empty[Int]) {case (set, i) =>\n+      val t = r.nextInt(i) + 1\n+      if (set.contains(t)) set + i else set + t\n+    }\n+    indices.map(_ - 1).toList\n+  }\n+\n+  /**\n+   * Get a random sample of size m from the elems\n+   *\n+   * @param elems\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @tparam T\n+   * @return a random list of size m. If there are fewer than m elements in elems, we just\n+   *         randomly shuffle elems\n+   */\n+  def getRandomSample[T](elems: Seq[T], m: Int, r: Random): List[T] = {\n+    if (elems.size > m) {\n+      getSampleIds(elems.size, m, r).map(elems(_))\n+    } else {\n+      r.shuffle(elems).toList",
    "line": 39
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Note that, this logic is same as before, see https://github.com/apache/spark/pull/13932/files#diff-85cf7285f83b73c253480dc010b0013bL105",
    "commit": "c465aaf044c73228bbd60aa4b717def734f338c8",
    "createdAt": "2017-03-29T12:34:11Z",
    "diffHunk": "@@ -53,6 +53,46 @@ trait BlockReplicationPolicy {\n       numReplicas: Int): List[BlockManagerId]\n }\n \n+object BlockReplicationUtils {\n+  // scalastyle:off line.size.limit\n+  /**\n+   * Uses sampling algorithm by Robert Floyd. Finds a random sample in O(n) while\n+   * minimizing space usage. Please see <a href=\"http://math.stackexchange.com/questions/178690/whats-the-proof-of-correctness-for-robert-floyds-algorithm-for-selecting-a-sin\">\n+   * here</a>.\n+   *\n+   * @param n total number of indices\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @return list of m random unique indices\n+   */\n+  // scalastyle:on line.size.limit\n+  private def getSampleIds(n: Int, m: Int, r: Random): List[Int] = {\n+    val indices = (n - m + 1 to n).foldLeft(mutable.LinkedHashSet.empty[Int]) {case (set, i) =>\n+      val t = r.nextInt(i) + 1\n+      if (set.contains(t)) set + i else set + t\n+    }\n+    indices.map(_ - 1).toList\n+  }\n+\n+  /**\n+   * Get a random sample of size m from the elems\n+   *\n+   * @param elems\n+   * @param m number of samples needed\n+   * @param r random number generator\n+   * @tparam T\n+   * @return a random list of size m. If there are fewer than m elements in elems, we just\n+   *         randomly shuffle elems\n+   */\n+  def getRandomSample[T](elems: Seq[T], m: Int, r: Random): List[T] = {\n+    if (elems.size > m) {\n+      getSampleIds(elems.size, m, r).map(elems(_))\n+    } else {\n+      r.shuffle(elems).toList",
    "line": 39
  }],
  "prId": 13932
}]