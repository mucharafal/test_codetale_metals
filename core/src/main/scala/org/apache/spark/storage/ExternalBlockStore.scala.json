[{
  "comments": [{
    "author": {
      "login": "zhzhan"
    },
    "body": "Need to take care the case that plugin does not implement putValue\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-06T04:15:44Z",
    "diffHunk": "@@ -62,42 +62,50 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, Left(values), returnValues)"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "zhzhan"
    },
    "body": "Need to handle the case that plugin does not handle putBytes\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-06T04:16:18Z",
    "diffHunk": "@@ -46,7 +46,7 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n   }\n \n   override def putBytes(blockId: BlockId, bytes: ByteBuffer, level: StorageLevel): PutResult = {\n-    putIntoExternalBlockStore(blockId, bytes, returnValues = true)\n+    putIntoExternalBlockStore(blockId, Right(bytes), returnValues = true)"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "zhzhan"
    },
    "body": "Need to handle the case plugin does not have getValues (getBytes only) \n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-06T04:17:10Z",
    "diffHunk": "@@ -113,7 +121,13 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n   }\n \n   override def getValues(blockId: BlockId): Option[Iterator[Any]] = {\n-    getBytes(blockId).map(buffer => blockManager.dataDeserialize(blockId, buffer))\n+    try {\n+      externalBlockManager.flatMap(_.getValues(blockId))",
    "line": 133
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "Please don't use Either. I think it's easier to just break this into two functions.\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-06T04:20:02Z",
    "diffHunk": "@@ -62,42 +62,50 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, Left(values), returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      data: Either[Iterator[_], ByteBuffer],"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This is really opinion too, but if it's not fatal, I think it could be a warning instead of error.\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-11T11:47:25Z",
    "diffHunk": "@@ -113,7 +143,13 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n   }\n \n   override def getValues(blockId: BlockId): Option[Iterator[Any]] = {\n-    getBytes(blockId).map(buffer => blockManager.dataDeserialize(blockId, buffer))\n+    try {\n+      externalBlockManager.flatMap(_.getValues(blockId))\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"error in getValues from $blockId\", t)"
  }, {
    "author": {
      "login": "shimingfei"
    },
    "body": "use logError to keep consistent with other part of the code in this file \n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-12T02:11:54Z",
    "diffHunk": "@@ -113,7 +143,13 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n   }\n \n   override def getValues(blockId: BlockId): Option[Iterator[Any]] = {\n-    getBytes(blockId).map(buffer => blockManager.dataDeserialize(blockId, buffer))\n+    try {\n+      externalBlockManager.flatMap(_.getValues(blockId))\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"error in getValues from $blockId\", t)"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "what's the error?\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-16T08:54:58Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n     logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"error in putBytes $blockId\")"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "trace level\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-16T08:55:11Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n     logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"error in putBytes $blockId\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"error in putBytes $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "ExtBlk -> external block\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-16T08:55:17Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n     logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"error in putBytes $blockId\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"error in putBytes $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "again - what's the error here?\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-16T08:55:37Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n     logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"error in putBytes $blockId\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"error in putBytes $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n+    // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n+    try {\n+      val startTime = System.currentTimeMillis\n+      if (externalBlockManager.isDefined) {\n+        // So that we do not modify the input offsets !\n+        // duplicate does not copy buffer, so inexpensive\n+        val byteBuffer = bytes.duplicate()\n+        byteBuffer.rewind()\n+        externalBlockManager.get.putBytes(blockId, byteBuffer)\n+        val size = bytes.limit()\n+        val data = if (returnValues) {\n+          Right(bytes)\n         } else {\n-          PutResult(bytes.limit(), null)\n+          null\n         }\n+        val finishTime = System.currentTimeMillis\n+        logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n       } else {\n         logError(s\"error in putBytes $blockId\")"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "```\ns\"Error in putBytes($blockId): no ExternalBlockManager has been configured.\"\n```\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T07:57:28Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n-    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"Error in putValues $blockId : no ExternalBlockManager exists!\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"Error in putValues $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n+    // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n+    try {\n+      val startTime = System.currentTimeMillis\n+      if (externalBlockManager.isDefined) {\n+        // So that we do not modify the input offsets !\n+        // duplicate does not copy buffer, so inexpensive\n+        val byteBuffer = bytes.duplicate()\n+        byteBuffer.rewind()\n+        externalBlockManager.get.putBytes(blockId, byteBuffer)\n+        val size = bytes.limit()\n+        val data = if (returnValues) {\n+          Right(bytes)\n         } else {\n-          PutResult(bytes.limit(), null)\n+          null\n         }\n+        val finishTime = System.currentTimeMillis\n+        logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n       } else {\n-        logError(s\"error in putBytes $blockId\")\n-        PutResult(bytes.limit(), null, Seq((blockId, BlockStatus.empty)))\n+        logError(s\"Error in putBytes $blockId : no ExternalBlockManager exists!\")"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "```\nError in putValues($blockId): no ExternalBlockManager has been configured.\n```\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T07:57:50Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n-    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"Error in putValues $blockId : no ExternalBlockManager exists!\")"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "Can you change this to\n\n```\nError calling getSize($blockId)\n```\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T07:58:25Z",
    "diffHunk": "@@ -40,7 +40,7 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       externalBlockManager.map(_.getSize(blockId)).getOrElse(0)\n     } catch {\n       case NonFatal(t) =>\n-        logError(s\"error in getSize from $blockId\", t)\n+        logError(s\"Error in getSize from $blockId\", t)"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "and do this for the other messages too, since it is not clear \"getSize\", \"getValues\", ... are function calls. Let's just make them more explicitly.\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T07:58:59Z",
    "diffHunk": "@@ -40,7 +40,7 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       externalBlockManager.map(_.getSize(blockId)).getOrElse(0)\n     } catch {\n       case NonFatal(t) =>\n-        logError(s\"error in getSize from $blockId\", t)\n+        logError(s\"Error in getSize from $blockId\", t)"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think you can remove this 2 lines of comments. it is obvious what's happening\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T08:00:51Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n-    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"Error in putValues $blockId : no ExternalBlockManager exists!\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"Error in putValues $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n+    // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n+    try {\n+      val startTime = System.currentTimeMillis\n+      if (externalBlockManager.isDefined) {\n+        // So that we do not modify the input offsets !"
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "```\nval data = if (returnValues) Right(bytes) else null\n```\n\nis block manager currently designed to return null, or is this new behavior? \n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T08:01:52Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n-    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"Error in putValues $blockId : no ExternalBlockManager exists!\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"Error in putValues $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n+    // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n+    try {\n+      val startTime = System.currentTimeMillis\n+      if (externalBlockManager.isDefined) {\n+        // So that we do not modify the input offsets !\n+        // duplicate does not copy buffer, so inexpensive\n+        val byteBuffer = bytes.duplicate()\n+        byteBuffer.rewind()\n+        externalBlockManager.get.putBytes(blockId, byteBuffer)\n+        val size = bytes.limit()\n+        val data = if (returnValues) {",
    "line": 95
  }, {
    "author": {
      "login": "shimingfei"
    },
    "body": "block manager currently designed to return null.\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T09:41:18Z",
    "diffHunk": "@@ -62,42 +62,72 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       values: Iterator[Any],\n       level: StorageLevel,\n       returnValues: Boolean): PutResult = {\n-    logDebug(s\"Attempting to write values for block $blockId\")\n-    val bytes = blockManager.dataSerialize(blockId, values)\n-    putIntoExternalBlockStore(blockId, bytes, returnValues)\n+    putIntoExternalBlockStore(blockId, values, returnValues)\n   }\n \n   private def putIntoExternalBlockStore(\n       blockId: BlockId,\n-      bytes: ByteBuffer,\n+      values: Iterator[_],\n       returnValues: Boolean): PutResult = {\n-    // So that we do not modify the input offsets !\n-    // duplicate does not copy buffer, so inexpensive\n-    val byteBuffer = bytes.duplicate()\n-    byteBuffer.rewind()\n-    logDebug(s\"Attempting to put block $blockId into ExtBlk store\")\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n     // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n     try {\n       val startTime = System.currentTimeMillis\n       if (externalBlockManager.isDefined) {\n-        externalBlockManager.get.putBytes(blockId, bytes)\n+        externalBlockManager.get.putValues(blockId, values)\n+        val size = getSize(blockId)\n+        val data = if (returnValues) {\n+          Left(getValues(blockId).get)\n+        } else {\n+          null\n+        }\n         val finishTime = System.currentTimeMillis\n         logDebug(\"Block %s stored as %s file in ExternalBlockStore in %d ms\".format(\n-          blockId, Utils.bytesToString(byteBuffer.limit), finishTime - startTime))\n+          blockId, Utils.bytesToString(size), finishTime - startTime))\n+        PutResult(size, data)\n+      } else {\n+        logError(s\"Error in putValues $blockId : no ExternalBlockManager exists!\")\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+      }\n+    } catch {\n+      case NonFatal(t) =>\n+        logError(s\"Error in putValues $blockId\", t)\n+        PutResult(-1, null, Seq((blockId, BlockStatus.empty)))\n+    }\n+  }\n \n-        if (returnValues) {\n-          PutResult(bytes.limit(), Right(bytes.duplicate()))\n+  private def putIntoExternalBlockStore(\n+      blockId: BlockId,\n+      bytes: ByteBuffer,\n+      returnValues: Boolean): PutResult = {\n+    logTrace(s\"Attempting to put block $blockId into ExternalBlockStore\")\n+    // we should never hit here if externalBlockManager is None. Handle it anyway for safety.\n+    try {\n+      val startTime = System.currentTimeMillis\n+      if (externalBlockManager.isDefined) {\n+        // So that we do not modify the input offsets !\n+        // duplicate does not copy buffer, so inexpensive\n+        val byteBuffer = bytes.duplicate()\n+        byteBuffer.rewind()\n+        externalBlockManager.get.putBytes(blockId, byteBuffer)\n+        val size = bytes.limit()\n+        val data = if (returnValues) {",
    "line": 95
  }],
  "prId": 5908
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "`Error in remove($blockId)`\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T08:02:31Z",
    "diffHunk": "@@ -107,13 +137,19 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       externalBlockManager.map(_.removeBlock(blockId)).getOrElse(true)\n     } catch {\n       case NonFatal(t) =>\n-        logError(s\"error in removing $blockId\", t)\n+        logError(s\"Error in removing $blockId\", t)"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "anyway please just change the logging messages to make them very explicit that they are function calls. We should either do this, or make them English sentences.\n",
    "commit": "033bc57e83928d50e2d942027a51668ac39a580d",
    "createdAt": "2015-05-19T08:03:08Z",
    "diffHunk": "@@ -107,13 +137,19 @@ private[spark] class ExternalBlockStore(blockManager: BlockManager, executorId:\n       externalBlockManager.map(_.removeBlock(blockId)).getOrElse(true)\n     } catch {\n       case NonFatal(t) =>\n-        logError(s\"error in removing $blockId\", t)\n+        logError(s\"Error in removing $blockId\", t)"
  }],
  "prId": 5908
}]