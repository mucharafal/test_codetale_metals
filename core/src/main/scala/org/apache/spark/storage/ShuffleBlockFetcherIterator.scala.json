[{
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "I don't think this is safe to do. The user can specify the full path to hash shuffle writer.\n",
    "commit": "6c5c1d4d143e4806edd6cf747b84c56f992f14a9",
    "createdAt": "2015-03-25T20:18:31Z",
    "diffHunk": "@@ -181,68 +181,100 @@ final class ShuffleBlockFetcherIterator(\n     // at most maxBytesInFlight in order to limit the amount of data in flight.\n     val remoteRequests = new ArrayBuffer[FetchRequest]\n \n+    val shuffleMgrName = SparkEnv.get.conf.get(\"spark.shuffle.manager\", \"sort\")\n+\n     // Tracks total number of blocks (including zero sized blocks)\n     var totalBlocks = 0\n-    for ((address, blockInfos) <- blocksByAddress) {\n-      totalBlocks += blockInfos.size\n-      if (address.executorId == blockManager.blockManagerId.executorId) {\n-        // Filter out zero-sized blocks\n-        localBlocks ++= blockInfos.filter(_._2 != 0).map(_._1)\n-        numBlocksToFetch += localBlocks.size\n-      } else {\n-        val iterator = blockInfos.iterator\n-        var curRequestSize = 0L\n-        var curBlocks = new ArrayBuffer[(BlockId, Long)]\n-        while (iterator.hasNext) {\n-          val (blockId, size) = iterator.next()\n-          // Skip empty blocks\n-          if (size > 0) {\n-            curBlocks += ((blockId, size))\n-            remoteBlocks += blockId\n-            numBlocksToFetch += 1\n-            curRequestSize += size\n-          } else if (size < 0) {\n-            throw new BlockException(blockId, \"Negative block size \" + size)\n-          }\n-          if (curRequestSize >= targetRequestSize) {\n-            // Add this FetchRequest\n-            remoteRequests += new FetchRequest(address, curBlocks)\n-            curBlocks = new ArrayBuffer[(BlockId, Long)]\n-            logDebug(s\"Creating fetch request of $curRequestSize at $address\")\n-            curRequestSize = 0\n-          }\n+    if(shuffleMgrName == \"hash\") {"
  }, {
    "author": {
      "login": "viper-kun"
    },
    "body": "what are you means？how to specify the full path？\n",
    "commit": "6c5c1d4d143e4806edd6cf747b84c56f992f14a9",
    "createdAt": "2015-03-26T08:01:42Z",
    "diffHunk": "@@ -181,68 +181,100 @@ final class ShuffleBlockFetcherIterator(\n     // at most maxBytesInFlight in order to limit the amount of data in flight.\n     val remoteRequests = new ArrayBuffer[FetchRequest]\n \n+    val shuffleMgrName = SparkEnv.get.conf.get(\"spark.shuffle.manager\", \"sort\")\n+\n     // Tracks total number of blocks (including zero sized blocks)\n     var totalBlocks = 0\n-    for ((address, blockInfos) <- blocksByAddress) {\n-      totalBlocks += blockInfos.size\n-      if (address.executorId == blockManager.blockManagerId.executorId) {\n-        // Filter out zero-sized blocks\n-        localBlocks ++= blockInfos.filter(_._2 != 0).map(_._1)\n-        numBlocksToFetch += localBlocks.size\n-      } else {\n-        val iterator = blockInfos.iterator\n-        var curRequestSize = 0L\n-        var curBlocks = new ArrayBuffer[(BlockId, Long)]\n-        while (iterator.hasNext) {\n-          val (blockId, size) = iterator.next()\n-          // Skip empty blocks\n-          if (size > 0) {\n-            curBlocks += ((blockId, size))\n-            remoteBlocks += blockId\n-            numBlocksToFetch += 1\n-            curRequestSize += size\n-          } else if (size < 0) {\n-            throw new BlockException(blockId, \"Negative block size \" + size)\n-          }\n-          if (curRequestSize >= targetRequestSize) {\n-            // Add this FetchRequest\n-            remoteRequests += new FetchRequest(address, curBlocks)\n-            curBlocks = new ArrayBuffer[(BlockId, Long)]\n-            logDebug(s\"Creating fetch request of $curRequestSize at $address\")\n-            curRequestSize = 0\n-          }\n+    if(shuffleMgrName == \"hash\") {"
  }],
  "prId": 5178
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "We should check if SortShuffleManager is used because this patch only supports it. This logic fails when new shuffle managers will be implemented.\n",
    "commit": "6c5c1d4d143e4806edd6cf747b84c56f992f14a9",
    "createdAt": "2015-04-06T00:38:55Z",
    "diffHunk": "@@ -181,68 +181,102 @@ final class ShuffleBlockFetcherIterator(\n     // at most maxBytesInFlight in order to limit the amount of data in flight.\n     val remoteRequests = new ArrayBuffer[FetchRequest]\n \n+    val shuffleMgrName = blockManager.conf.get(\"spark.shuffle.manager\", \"sort\")\n+    val externalShuffleServiceEnabled =\n+      blockManager.conf.getBoolean(\"spark.shuffle.service.enabled\", false)\n+\n     // Tracks total number of blocks (including zero sized blocks)\n     var totalBlocks = 0\n-    for ((address, blockInfos) <- blocksByAddress) {\n-      totalBlocks += blockInfos.size\n-      if (address.executorId == blockManager.blockManagerId.executorId) {\n-        // Filter out zero-sized blocks\n-        localBlocks ++= blockInfos.filter(_._2 != 0).map(_._1)\n-        numBlocksToFetch += localBlocks.size\n-      } else {\n-        val iterator = blockInfos.iterator\n-        var curRequestSize = 0L\n-        var curBlocks = new ArrayBuffer[(BlockId, Long)]\n-        while (iterator.hasNext) {\n-          val (blockId, size) = iterator.next()\n-          // Skip empty blocks\n-          if (size > 0) {\n-            curBlocks += ((blockId, size))\n-            remoteBlocks += blockId\n-            numBlocksToFetch += 1\n-            curRequestSize += size\n-          } else if (size < 0) {\n-            throw new BlockException(blockId, \"Negative block size \" + size)\n-          }\n-          if (curRequestSize >= targetRequestSize) {\n-            // Add this FetchRequest\n-            remoteRequests += new FetchRequest(address, curBlocks)\n-            curBlocks = new ArrayBuffer[(BlockId, Long)]\n-            logDebug(s\"Creating fetch request of $curRequestSize at $address\")\n-            curRequestSize = 0\n-          }\n+    if (shuffleMgrName.toLowerCase == \"hash\" || externalShuffleServiceEnabled) {\n+      for ((address, blockInfos) <- blocksByAddress) {",
    "line": 57
  }],
  "prId": 5178
}]