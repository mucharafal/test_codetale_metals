[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "In both TimeStampedHashMap and scala.collection.concurrent.Map, `putIfAbsent`'s value is call-by-value, not call-by-name:\n\n```\ndef putIfAbsent(key: A, value: B): Option[B]\n```\n\nAs a result, this code will end up calling `new ShuffleState(numBuckets)` on every completed map task.  ShuffleState looks moderately expensive to construct since it contains a bunch of queues, etc.\n\nIt would be more efficient to extend TimeStampedHashMap with a `getOrElseUpdate` method whose `default` argument is call-by-name so that we don't end up constructing and discarding so many ShuffleStates.\n",
    "commit": "bd841f9e3252404e29d593d7f7da5005e7f0b624",
    "createdAt": "2014-07-28T22:21:48Z",
    "diffHunk": "@@ -91,6 +97,20 @@ class ShuffleBlockManager(blockManager: BlockManager) extends Logging {\n   private val metadataCleaner =\n     new MetadataCleaner(MetadataCleanerType.SHUFFLE_BLOCK_MANAGER, this.cleanup, conf)\n \n+  /**\n+   * Register a completed map without getting a ShuffleWriterGroup. Used by sort-based shuffle\n+   * because it just writes a single file by itself.\n+   */\n+  def addCompletedMap(shuffleId: Int, mapId: Int, numBuckets: Int): Unit = {\n+    shuffleStates.putIfAbsent(shuffleId, new ShuffleState(numBuckets))",
    "line": 36
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "Looks like we currently already do that in `forMapTask`. It hasn't bitten us yet, but it seems like a good idea to change it here and down there.\n",
    "commit": "bd841f9e3252404e29d593d7f7da5005e7f0b624",
    "createdAt": "2014-07-29T22:51:13Z",
    "diffHunk": "@@ -91,6 +97,20 @@ class ShuffleBlockManager(blockManager: BlockManager) extends Logging {\n   private val metadataCleaner =\n     new MetadataCleaner(MetadataCleanerType.SHUFFLE_BLOCK_MANAGER, this.cleanup, conf)\n \n+  /**\n+   * Register a completed map without getting a ShuffleWriterGroup. Used by sort-based shuffle\n+   * because it just writes a single file by itself.\n+   */\n+  def addCompletedMap(shuffleId: Int, mapId: Int, numBuckets: Int): Unit = {\n+    shuffleStates.putIfAbsent(shuffleId, new ShuffleState(numBuckets))",
    "line": 36
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "Yeah IMO we should open a JIRA to fix this later. It's only called once per map task but it is kind of wasteful.\n",
    "commit": "bd841f9e3252404e29d593d7f7da5005e7f0b624",
    "createdAt": "2014-07-30T18:47:10Z",
    "diffHunk": "@@ -91,6 +97,20 @@ class ShuffleBlockManager(blockManager: BlockManager) extends Logging {\n   private val metadataCleaner =\n     new MetadataCleaner(MetadataCleanerType.SHUFFLE_BLOCK_MANAGER, this.cleanup, conf)\n \n+  /**\n+   * Register a completed map without getting a ShuffleWriterGroup. Used by sort-based shuffle\n+   * because it just writes a single file by itself.\n+   */\n+  def addCompletedMap(shuffleId: Int, mapId: Int, numBuckets: Int): Unit = {\n+    shuffleStates.putIfAbsent(shuffleId, new ShuffleState(numBuckets))",
    "line": 36
  }],
  "prId": 1499
}]