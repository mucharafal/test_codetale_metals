[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`reservoirSampleAndCount`?\n",
    "commit": "17bcbf3982fabc027900c9ce791ae3233ba66700",
    "createdAt": "2014-07-18T05:05:30Z",
    "diffHunk": "@@ -17,9 +17,49 @@\n \n package org.apache.spark.util.random\n \n+import scala.reflect.ClassTag\n+\n private[spark] object SamplingUtils {\n \n   /**\n+   * Reservoir Sampling implementation.\n+   *\n+   * @param input input size\n+   * @param k reservoir size\n+   * @return (samples, input size)\n+   */\n+  def reservoirSample[T: ClassTag](input: Iterator[T], k: Int): (Array[T], Int) = {"
  }],
  "prId": 1478
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Please use a deterministic seed passed as an argument.\n",
    "commit": "17bcbf3982fabc027900c9ce791ae3233ba66700",
    "createdAt": "2014-07-18T07:35:12Z",
    "diffHunk": "@@ -17,9 +17,49 @@\n \n package org.apache.spark.util.random\n \n+import scala.reflect.ClassTag\n+\n private[spark] object SamplingUtils {\n \n   /**\n+   * Reservoir sampling implementation that also returns the input size.\n+   *\n+   * @param input input size\n+   * @param k reservoir size\n+   * @return (samples, input size)\n+   */\n+  def reservoirSampleAndCount[T: ClassTag](input: Iterator[T], k: Int): (Array[T], Int) = {\n+    val reservoir = new Array[T](k)\n+    // Put the first k elements in the reservoir.\n+    var i = 0\n+    while (i < k && input.hasNext) {\n+      val item = input.next()\n+      reservoir(i) = item\n+      i += 1\n+    }\n+\n+    // If we have consumed all the elements, return them. Otherwise do the replacement.\n+    if (i < k) {\n+      // If input size < k, trim the array to return only an array of input size.\n+      val trimReservoir = new Array[T](i)\n+      System.arraycopy(reservoir, 0, trimReservoir, 0, i)\n+      (trimReservoir, i)\n+    } else {\n+      // If input size > k, continue the sampling process.\n+      val rand = new XORShiftRandom"
  }],
  "prId": 1478
}]