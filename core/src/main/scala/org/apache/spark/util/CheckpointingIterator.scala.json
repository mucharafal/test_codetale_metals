[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "It is possible that more than one iterators for the same split are created and used, e.g., `CartesianRDD`. We only need one of them to write checkpoint data to disk.\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-06-26T09:57:31Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]](\n+  sub: I,\n+  path: String,\n+  broadcastedConf: Broadcast[SerializableConfiguration],\n+  partitionId: Int,\n+  context: TaskContext,\n+  blockSize: Int = -1) extends Iterator[A] with Logging {\n+\n+  val env = SparkEnv.get\n+  var fs: FileSystem = null\n+  val bufferSize = env.conf.getInt(\"spark.buffer.size\", 65536)\n+  var serializeStream: SerializationStream = null\n+\n+  var finalOutputPath: Path = null\n+  var tempOutputPath: Path = null\n+\n+  def init(): this.type = {\n+    val outputDir = new Path(path)\n+    fs = outputDir.getFileSystem(broadcastedConf.value.value)\n+\n+    val finalOutputName = CheckpointRDD.splitIdToFile(partitionId)\n+    finalOutputPath = new Path(outputDir, finalOutputName)\n+    tempOutputPath =\n+      new Path(outputDir, \".\" + finalOutputName + \"-attempt-\" + context.attemptNumber)\n+\n+    if (fs.exists(tempOutputPath)) {",
    "line": 65
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Sometimes the rdd.iterator will not be consumed to call `hasNext` until it returns false, e.g., we already know the number of elements and call next() at exact times of that number. If so, we need to write the checkpoint data to final output path early when we return the latest element.\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-06-26T10:02:31Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]](\n+  sub: I,\n+  path: String,\n+  broadcastedConf: Broadcast[SerializableConfiguration],\n+  partitionId: Int,\n+  context: TaskContext,\n+  blockSize: Int = -1) extends Iterator[A] with Logging {\n+\n+  val env = SparkEnv.get\n+  var fs: FileSystem = null\n+  val bufferSize = env.conf.getInt(\"spark.buffer.size\", 65536)\n+  var serializeStream: SerializationStream = null\n+\n+  var finalOutputPath: Path = null\n+  var tempOutputPath: Path = null\n+\n+  def init(): this.type = {\n+    val outputDir = new Path(path)\n+    fs = outputDir.getFileSystem(broadcastedConf.value.value)\n+\n+    val finalOutputName = CheckpointRDD.splitIdToFile(partitionId)\n+    finalOutputPath = new Path(outputDir, finalOutputName)\n+    tempOutputPath =\n+      new Path(outputDir, \".\" + finalOutputName + \"-attempt-\" + context.attemptNumber)\n+\n+    if (fs.exists(tempOutputPath)) {\n+      // There are more than one iterator of the RDD is consumed.\n+      // Don't checkpoint data in this iterator.\n+      doCheckpoint = false\n+      return this\n+    }\n+\n+    val fileOutputStream = if (blockSize < 0) {\n+      fs.create(tempOutputPath, false, bufferSize)\n+    } else {\n+      // This is mainly for testing purpose\n+      fs.create(tempOutputPath, false, bufferSize, fs.getDefaultReplication, blockSize)\n+    }\n+    val serializer = env.serializer.newInstance()\n+    serializeStream = serializer.serializeStream(fileOutputStream)\n+    this\n+  }\n+\n+  def completion(): Unit = {\n+    if (!doCheckpoint) {\n+      return\n+    }\n+\n+    serializeStream.close()\n+\n+    if (!fs.rename(tempOutputPath, finalOutputPath)) {\n+      if (!fs.exists(finalOutputPath)) {\n+        logInfo(\"Deleting tempOutputPath \" + tempOutputPath)\n+        fs.delete(tempOutputPath, false)\n+        throw new IOException(\"Checkpoint failed: failed to save output of task: \"\n+          + context.attemptNumber + \" and final output path does not exist\")\n+      } else {\n+        // Some other copy of this task must've finished before us and renamed it\n+        logInfo(\"Final output path \" + finalOutputPath + \" already exists; not overwriting it\")\n+        fs.delete(tempOutputPath, false)\n+      }\n+    }\n+  }\n+\n+  def checkpointing(item: A): Unit = {\n+    serializeStream.writeObject(item)\n+  }\n+\n+  override def next(): A = {\n+    val item = sub.next()\n+    if (doCheckpoint) {\n+      checkpointing(item)\n+    }\n+    // If this the latest item, call hasNext will write to final output early.\n+    hasNext",
    "line": 118
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "these should all be indented two spaces\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-02T00:41:21Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]](\n+  sub: I,\n+  path: String,\n+  broadcastedConf: Broadcast[SerializableConfiguration],\n+  partitionId: Int,\n+  context: TaskContext,\n+  blockSize: Int = -1) extends Iterator[A] with Logging {"
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "this type signature is rather complex. Could you rewrite this with only `A`? Then `sub` can just be of type `Iterator[A]`.\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-02T00:44:09Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]]("
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "also I would rename `sub` to `values` or something\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-02T00:44:25Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]]("
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "many of these variables can be private. It would be great to tighten the visibility as much as possible.\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-02T00:44:47Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]](\n+  sub: I,\n+  path: String,\n+  broadcastedConf: Broadcast[SerializableConfiguration],\n+  partitionId: Int,\n+  context: TaskContext,\n+  blockSize: Int = -1) extends Iterator[A] with Logging {\n+\n+  val env = SparkEnv.get\n+  var fs: FileSystem = null\n+  val bufferSize = env.conf.getInt(\"spark.buffer.size\", 65536)\n+  var serializeStream: SerializationStream = null\n+\n+  var finalOutputPath: Path = null\n+  var tempOutputPath: Path = null"
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "what does `completion` mean? Can you add some java docs here and everywhere?\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-02T00:45:26Z",
    "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag, +I <: Iterator[A]](\n+  sub: I,\n+  path: String,\n+  broadcastedConf: Broadcast[SerializableConfiguration],\n+  partitionId: Int,\n+  context: TaskContext,\n+  blockSize: Int = -1) extends Iterator[A] with Logging {\n+\n+  val env = SparkEnv.get\n+  var fs: FileSystem = null\n+  val bufferSize = env.conf.getInt(\"spark.buffer.size\", 65536)\n+  var serializeStream: SerializationStream = null\n+\n+  var finalOutputPath: Path = null\n+  var tempOutputPath: Path = null\n+\n+  def init(): this.type = {\n+    val outputDir = new Path(path)\n+    fs = outputDir.getFileSystem(broadcastedConf.value.value)\n+\n+    val finalOutputName = CheckpointRDD.splitIdToFile(partitionId)\n+    finalOutputPath = new Path(outputDir, finalOutputName)\n+    tempOutputPath =\n+      new Path(outputDir, \".\" + finalOutputName + \"-attempt-\" + context.attemptNumber)\n+\n+    if (fs.exists(tempOutputPath)) {\n+      // There are more than one iterator of the RDD is consumed.\n+      // Don't checkpoint data in this iterator.\n+      doCheckpoint = false\n+      return this\n+    }\n+\n+    val fileOutputStream = if (blockSize < 0) {\n+      fs.create(tempOutputPath, false, bufferSize)\n+    } else {\n+      // This is mainly for testing purpose\n+      fs.create(tempOutputPath, false, bufferSize, fs.getDefaultReplication, blockSize)\n+    }\n+    val serializer = env.serializer.newInstance()\n+    serializeStream = serializer.serializeStream(fileOutputStream)\n+    this\n+  }\n+\n+  def completion(): Unit = {"
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "In the java doc, could you document what each of these variables represent?\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-06T19:18:27Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag](\n+    values: Iterator[A],\n+    path: String,\n+    broadcastedConf: Broadcast[SerializableConfiguration],\n+    partitionId: Int,\n+    context: TaskContext,\n+    blockSize: Int = -1) extends Iterator[A] with Logging {",
    "line": 42
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "can we remove this `init` method? It doesn't seem necessary since we can just do all of this in the constructor. The advantage of removing it is that we won't have a bunch of `var`s initialized to `null`.\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-06T19:21:20Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag](\n+    values: Iterator[A],\n+    path: String,\n+    broadcastedConf: Broadcast[SerializableConfiguration],\n+    partitionId: Int,\n+    context: TaskContext,\n+    blockSize: Int = -1) extends Iterator[A] with Logging {\n+\n+  private val env = SparkEnv.get\n+  private var fs: FileSystem = null\n+  private val bufferSize = env.conf.getInt(\"spark.buffer.size\", 65536)\n+  private var serializeStream: SerializationStream = null\n+\n+  private var finalOutputPath: Path = null\n+  private var tempOutputPath: Path = null\n+\n+  /**\n+   * Initialize this iterator by creating temporary output path and serializer instance.\n+   *\n+   */\n+  def init(): this.type = {",
    "line": 56
  }],
  "prId": 7021
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "please declare all variables at the top\n",
    "commit": "2f43ff3c6d1a4a428e5cbe8f4a4e4347274fc95c",
    "createdAt": "2015-07-06T19:22:01Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.io.IOException\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.fs.FileSystem\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark._\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.CheckpointRDD\n+import org.apache.spark.serializer.SerializationStream\n+\n+/**\n+ * Wrapper around an iterator which writes checkpoint data to HDFS while running action on\n+ * a RDD to support checkpointing RDD.\n+ */\n+private[spark] class CheckpointingIterator[A: ClassTag](\n+    values: Iterator[A],\n+    path: String,\n+    broadcastedConf: Broadcast[SerializableConfiguration],\n+    partitionId: Int,\n+    context: TaskContext,\n+    blockSize: Int = -1) extends Iterator[A] with Logging {\n+\n+  private val env = SparkEnv.get\n+  private var fs: FileSystem = null\n+  private val bufferSize = env.conf.getInt(\"spark.buffer.size\", 65536)\n+  private var serializeStream: SerializationStream = null\n+\n+  private var finalOutputPath: Path = null\n+  private var tempOutputPath: Path = null\n+\n+  /**\n+   * Initialize this iterator by creating temporary output path and serializer instance.\n+   *\n+   */\n+  def init(): this.type = {\n+    val outputDir = new Path(path)\n+    fs = outputDir.getFileSystem(broadcastedConf.value.value)\n+\n+    val finalOutputName = CheckpointRDD.splitIdToFile(partitionId)\n+    finalOutputPath = new Path(outputDir, finalOutputName)\n+    tempOutputPath =\n+      new Path(outputDir, \".\" + finalOutputName + \"-attempt-\" + context.attemptNumber)\n+\n+    if (fs.exists(tempOutputPath)) {\n+      // There are more than one iterator of the RDD is consumed.\n+      // Don't checkpoint data in this iterator.\n+      doCheckpoint = false\n+      return this\n+    }\n+\n+    val fileOutputStream = if (blockSize < 0) {\n+      fs.create(tempOutputPath, false, bufferSize)\n+    } else {\n+      // This is mainly for testing purpose\n+      fs.create(tempOutputPath, false, bufferSize, fs.getDefaultReplication, blockSize)\n+    }\n+    val serializer = env.serializer.newInstance()\n+    serializeStream = serializer.serializeStream(fileOutputStream)\n+    this\n+  }\n+\n+  /**\n+   * Called when this iterator is on the latest element by `hasNext`.\n+   * This method will rename temporary output path to final output path of checkpoint data.\n+   */\n+  def completion(): Unit = {\n+    if (!doCheckpoint) {\n+      return\n+    }\n+\n+    serializeStream.close()\n+\n+    if (!fs.rename(tempOutputPath, finalOutputPath)) {\n+      if (!fs.exists(finalOutputPath)) {\n+        logInfo(\"Deleting tempOutputPath \" + tempOutputPath)\n+        fs.delete(tempOutputPath, false)\n+        throw new IOException(\"Checkpoint failed: failed to save output of task: \"\n+          + context.attemptNumber + \" and final output path does not exist\")\n+      } else {\n+        // Some other copy of this task must've finished before us and renamed it\n+        logInfo(\"Final output path \" + finalOutputPath + \" already exists; not overwriting it\")\n+        fs.delete(tempOutputPath, false)\n+      }\n+    }\n+  }\n+\n+  def checkpointing(item: A): Unit = {\n+    serializeStream.writeObject(item)\n+  }\n+\n+  override def next(): A = {\n+    val item = values.next()\n+    if (doCheckpoint) {\n+      checkpointing(item)\n+    }\n+    // If this the latest item, call hasNext will write to final output early.\n+    hasNext\n+    item\n+  }\n+\n+  private[this] var doCheckpoint = true\n+  private[this] var completed = false",
    "line": 123
  }],
  "prId": 7021
}]