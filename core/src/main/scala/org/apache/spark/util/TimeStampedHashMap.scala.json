[{
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "these should probably all be private[util] (here and WrappedJavaHashMap and TimeStampedWeakValueMap)\n",
    "commit": "61b8d6e2b37d7b0e200e9a506c24d18c961f8d73",
    "createdAt": "2014-03-25T03:17:09Z",
    "diffHunk": "@@ -19,108 +19,66 @@ package org.apache.spark.util\n \n import java.util.concurrent.ConcurrentHashMap\n \n-import scala.collection.JavaConversions\n-import scala.collection.immutable\n-import scala.collection.mutable.Map\n-\n import org.apache.spark.Logging\n \n+private[util] case class TimeStampedValue[T](timestamp: Long, value: T)\n+\n /**\n- * This is a custom implementation of scala.collection.mutable.Map which stores the insertion\n- * timestamp along with each key-value pair. If specified, the timestamp of each pair can be\n- * updated every time it is accessed. Key-value pairs whose timestamp are older than a particular\n- * threshold time can then be removed using the clearOldValues method. This is intended to\n- * be a drop-in replacement of scala.collection.mutable.HashMap.\n+ * A map that stores the timestamp of when a key was inserted along with the value. If specified,\n+ * the timestamp of each pair can be updated every time it is accessed.\n+ * Key-value pairs whose timestamps are older than a particular\n+ * threshold time can then be removed using the clearOldValues method. It exposes a\n+ * scala.collection.mutable.Map interface to allow it to be a drop-in replacement for Scala\n+ * HashMaps.\n+ *\n+ * Internally, it uses a Java ConcurrentHashMap, so all operations on this HashMap are thread-safe.\n+ *\n  * @param updateTimeStampOnGet When enabled, the timestamp of a pair will be\n  *                             updated when it is accessed\n  */\n-class TimeStampedHashMap[A, B](updateTimeStampOnGet: Boolean = false)\n-  extends Map[A, B]() with Logging {\n-  val internalMap = new ConcurrentHashMap[A, (B, Long)]()\n-\n-  def get(key: A): Option[B] = {\n-    val value = internalMap.get(key)\n-    if (value != null && updateTimeStampOnGet) {\n-      internalMap.replace(key, value, (value._1, currentTime))\n-    }\n-    Option(value).map(_._1)\n-  }\n-\n-  def iterator: Iterator[(A, B)] = {\n-    val jIterator = internalMap.entrySet().iterator()\n-    JavaConversions.asScalaIterator(jIterator).map(kv => (kv.getKey, kv.getValue._1))\n-  }\n-\n-  override def + [B1 >: B](kv: (A, B1)): Map[A, B1] = {\n-    val newMap = new TimeStampedHashMap[A, B1]\n-    newMap.internalMap.putAll(this.internalMap)\n-    newMap.internalMap.put(kv._1, (kv._2, currentTime))\n-    newMap\n-  }\n-\n-  override def - (key: A): Map[A, B] = {\n-    val newMap = new TimeStampedHashMap[A, B]\n-    newMap.internalMap.putAll(this.internalMap)\n-    newMap.internalMap.remove(key)\n-    newMap\n-  }\n+private[spark] class TimeStampedHashMap[A, B](updateTimeStampOnGet: Boolean = false)\n+  extends WrappedJavaHashMap[A, B, A, TimeStampedValue[B]] with Logging {\n \n-  override def += (kv: (A, B)): this.type = {\n-    internalMap.put(kv._1, (kv._2, currentTime))\n-    this\n-  }\n+  protected[util] val internalJavaMap = new ConcurrentHashMap[A, TimeStampedValue[B]]()"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Changed. Less confusing, that protected[util]\n",
    "commit": "61b8d6e2b37d7b0e200e9a506c24d18c961f8d73",
    "createdAt": "2014-03-25T19:29:52Z",
    "diffHunk": "@@ -19,108 +19,66 @@ package org.apache.spark.util\n \n import java.util.concurrent.ConcurrentHashMap\n \n-import scala.collection.JavaConversions\n-import scala.collection.immutable\n-import scala.collection.mutable.Map\n-\n import org.apache.spark.Logging\n \n+private[util] case class TimeStampedValue[T](timestamp: Long, value: T)\n+\n /**\n- * This is a custom implementation of scala.collection.mutable.Map which stores the insertion\n- * timestamp along with each key-value pair. If specified, the timestamp of each pair can be\n- * updated every time it is accessed. Key-value pairs whose timestamp are older than a particular\n- * threshold time can then be removed using the clearOldValues method. This is intended to\n- * be a drop-in replacement of scala.collection.mutable.HashMap.\n+ * A map that stores the timestamp of when a key was inserted along with the value. If specified,\n+ * the timestamp of each pair can be updated every time it is accessed.\n+ * Key-value pairs whose timestamps are older than a particular\n+ * threshold time can then be removed using the clearOldValues method. It exposes a\n+ * scala.collection.mutable.Map interface to allow it to be a drop-in replacement for Scala\n+ * HashMaps.\n+ *\n+ * Internally, it uses a Java ConcurrentHashMap, so all operations on this HashMap are thread-safe.\n+ *\n  * @param updateTimeStampOnGet When enabled, the timestamp of a pair will be\n  *                             updated when it is accessed\n  */\n-class TimeStampedHashMap[A, B](updateTimeStampOnGet: Boolean = false)\n-  extends Map[A, B]() with Logging {\n-  val internalMap = new ConcurrentHashMap[A, (B, Long)]()\n-\n-  def get(key: A): Option[B] = {\n-    val value = internalMap.get(key)\n-    if (value != null && updateTimeStampOnGet) {\n-      internalMap.replace(key, value, (value._1, currentTime))\n-    }\n-    Option(value).map(_._1)\n-  }\n-\n-  def iterator: Iterator[(A, B)] = {\n-    val jIterator = internalMap.entrySet().iterator()\n-    JavaConversions.asScalaIterator(jIterator).map(kv => (kv.getKey, kv.getValue._1))\n-  }\n-\n-  override def + [B1 >: B](kv: (A, B1)): Map[A, B1] = {\n-    val newMap = new TimeStampedHashMap[A, B1]\n-    newMap.internalMap.putAll(this.internalMap)\n-    newMap.internalMap.put(kv._1, (kv._2, currentTime))\n-    newMap\n-  }\n-\n-  override def - (key: A): Map[A, B] = {\n-    val newMap = new TimeStampedHashMap[A, B]\n-    newMap.internalMap.putAll(this.internalMap)\n-    newMap.internalMap.remove(key)\n-    newMap\n-  }\n+private[spark] class TimeStampedHashMap[A, B](updateTimeStampOnGet: Boolean = false)\n+  extends WrappedJavaHashMap[A, B, A, TimeStampedValue[B]] with Logging {\n \n-  override def += (kv: (A, B)): this.type = {\n-    internalMap.put(kv._1, (kv._2, currentTime))\n-    this\n-  }\n+  protected[util] val internalJavaMap = new ConcurrentHashMap[A, TimeStampedValue[B]]()"
  }],
  "prId": 126
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Is this a question still? Seems like you chose `Option`\n",
    "commit": "61b8d6e2b37d7b0e200e9a506c24d18c961f8d73",
    "createdAt": "2014-04-08T03:30:16Z",
    "diffHunk": "@@ -87,53 +86,67 @@ class TimeStampedHashMap[A, B](updateTimeStampOnGet: Boolean = false)\n   }\n \n   override def apply(key: A): B = {\n-    val value = internalMap.get(key)\n-    if (value == null) throw new NoSuchElementException()\n-    value._1\n+    get(key).getOrElse { throw new NoSuchElementException() }\n   }\n \n-  override def filter(p: ((A, B)) => Boolean): Map[A, B] = {\n-    JavaConversions.mapAsScalaConcurrentMap(internalMap).map(kv => (kv._1, kv._2._1)).filter(p)\n+  override def filter(p: ((A, B)) => Boolean): mutable.Map[A, B] = {\n+    JavaConversions.mapAsScalaConcurrentMap(internalMap)\n+      .map { case (k, TimeStampedValue(v, t)) => (k, v) }\n+      .filter(p)\n   }\n \n-  override def empty: Map[A, B] = new TimeStampedHashMap[A, B]()\n+  override def empty: mutable.Map[A, B] = new TimeStampedHashMap[A, B]()\n \n   override def size: Int = internalMap.size\n \n   override def foreach[U](f: ((A, B)) => U) {\n-    val iterator = internalMap.entrySet().iterator()\n-    while(iterator.hasNext) {\n-      val entry = iterator.next()\n-      val kv = (entry.getKey, entry.getValue._1)\n+    val it = getEntrySet.iterator\n+    while(it.hasNext) {\n+      val entry = it.next()\n+      val kv = (entry.getKey, entry.getValue.value)\n       f(kv)\n     }\n   }\n \n-  def toMap: immutable.Map[A, B] = iterator.toMap\n+  // Should we return previous value directly or as Option?"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Removed.\n",
    "commit": "61b8d6e2b37d7b0e200e9a506c24d18c961f8d73",
    "createdAt": "2014-04-08T04:02:02Z",
    "diffHunk": "@@ -87,53 +86,67 @@ class TimeStampedHashMap[A, B](updateTimeStampOnGet: Boolean = false)\n   }\n \n   override def apply(key: A): B = {\n-    val value = internalMap.get(key)\n-    if (value == null) throw new NoSuchElementException()\n-    value._1\n+    get(key).getOrElse { throw new NoSuchElementException() }\n   }\n \n-  override def filter(p: ((A, B)) => Boolean): Map[A, B] = {\n-    JavaConversions.mapAsScalaConcurrentMap(internalMap).map(kv => (kv._1, kv._2._1)).filter(p)\n+  override def filter(p: ((A, B)) => Boolean): mutable.Map[A, B] = {\n+    JavaConversions.mapAsScalaConcurrentMap(internalMap)\n+      .map { case (k, TimeStampedValue(v, t)) => (k, v) }\n+      .filter(p)\n   }\n \n-  override def empty: Map[A, B] = new TimeStampedHashMap[A, B]()\n+  override def empty: mutable.Map[A, B] = new TimeStampedHashMap[A, B]()\n \n   override def size: Int = internalMap.size\n \n   override def foreach[U](f: ((A, B)) => U) {\n-    val iterator = internalMap.entrySet().iterator()\n-    while(iterator.hasNext) {\n-      val entry = iterator.next()\n-      val kv = (entry.getKey, entry.getValue._1)\n+    val it = getEntrySet.iterator\n+    while(it.hasNext) {\n+      val entry = it.next()\n+      val kv = (entry.getKey, entry.getValue.value)\n       f(kv)\n     }\n   }\n \n-  def toMap: immutable.Map[A, B] = iterator.toMap\n+  // Should we return previous value directly or as Option?"
  }],
  "prId": 126
}]