[{
  "comments": [{
    "author": {
      "login": "jodersky"
    },
    "body": "I should have mentioned this in the PR description. When a signal is caught, the first thing the handler does is de-register itself. That way it only ever accepts the first signal and subsequent signals are escalated.\n",
    "commit": "4f9bf695344a5c4c54372eaa6bf54af0d2da1f74",
    "createdAt": "2016-04-21T23:02:48Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.{Collections, LinkedList}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.HashMap\n+\n+import org.apache.commons.lang3.SystemUtils\n+import sun.misc.{Signal, SignalHandler}\n+\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Contains utilities for working with posix signals.\n+ */\n+private[spark] object Signaling extends Logging {\n+\n+  /**\n+   * A handler for the given signal that runs a collection of actions.\n+   */\n+  private class ActionHandler(signal: Signal) extends SignalHandler {\n+\n+    private val actions = Collections.synchronizedList(new LinkedList[() => Boolean])\n+\n+    // original signal handler, before this handler was attached\n+    private val prevHandler: SignalHandler = Signal.handle(signal, this)\n+\n+    /**\n+     * Called when this handler's signal is received. Note that if the same signal is received\n+     * before this method returns, it is escalated to the previous handler.\n+     */\n+    override def handle(sig: Signal): Unit = {\n+      // register old handler, will receive incoming signals while this handler is running\n+      Signal.handle(signal, prevHandler)",
    "line": 52
  }],
  "prId": 12557
}, {
  "comments": [{
    "author": {
      "login": "jodersky"
    },
    "body": "Only after successully running all actions, does it reregister itself to catch signals again.\n",
    "commit": "4f9bf695344a5c4c54372eaa6bf54af0d2da1f74",
    "createdAt": "2016-04-21T23:03:07Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.{Collections, LinkedList}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.HashMap\n+\n+import org.apache.commons.lang3.SystemUtils\n+import sun.misc.{Signal, SignalHandler}\n+\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Contains utilities for working with posix signals.\n+ */\n+private[spark] object Signaling extends Logging {\n+\n+  /**\n+   * A handler for the given signal that runs a collection of actions.\n+   */\n+  private class ActionHandler(signal: Signal) extends SignalHandler {\n+\n+    private val actions = Collections.synchronizedList(new LinkedList[() => Boolean])\n+\n+    // original signal handler, before this handler was attached\n+    private val prevHandler: SignalHandler = Signal.handle(signal, this)\n+\n+    /**\n+     * Called when this handler's signal is received. Note that if the same signal is received\n+     * before this method returns, it is escalated to the previous handler.\n+     */\n+    override def handle(sig: Signal): Unit = {\n+      // register old handler, will receive incoming signals while this handler is running\n+      Signal.handle(signal, prevHandler)\n+\n+      val escalate = actions.asScala forall { action =>\n+        !action()\n+      }\n+\n+      if(escalate) {\n+        prevHandler.handle(sig)\n+      }\n+\n+      // re-register this handler\n+      Signal.handle(signal, this)",
    "line": 63
  }],
  "prId": 12557
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "this is a really weird style for spark\n",
    "commit": "4f9bf695344a5c4c54372eaa6bf54af0d2da1f74",
    "createdAt": "2016-04-22T07:16:37Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.{Collections, LinkedList}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.HashMap\n+\n+import org.apache.commons.lang3.SystemUtils\n+import sun.misc.{Signal, SignalHandler}\n+\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Contains utilities for working with posix signals.\n+ */\n+private[spark] object Signaling extends Logging {\n+\n+  /**\n+   * A handler for the given signal that runs a collection of actions.\n+   */\n+  private class ActionHandler(signal: Signal) extends SignalHandler {\n+\n+    private val actions = Collections.synchronizedList(new LinkedList[() => Boolean])\n+\n+    // original signal handler, before this handler was attached\n+    private val prevHandler: SignalHandler = Signal.handle(signal, this)\n+\n+    /**\n+     * Called when this handler's signal is received. Note that if the same signal is received\n+     * before this method returns, it is escalated to the previous handler.\n+     */\n+    override def handle(sig: Signal): Unit = {\n+      // register old handler, will receive incoming signals while this handler is running\n+      Signal.handle(signal, prevHandler)\n+\n+      val escalate = actions.asScala forall { action =>\n+        !action()\n+      }\n+\n+      if(escalate) {\n+        prevHandler.handle(sig)\n+      }\n+\n+      // re-register this handler\n+      Signal.handle(signal, this)\n+    }\n+\n+    /**\n+     * Add an action to be run by this handler.\n+     * @param action An action to be run when a signal is received. Return true if the signal\n+     * should be stopped with this handler, false if it should be escalated.\n+     */\n+    def register(action: => Boolean): Unit = actions.add(() => action)\n+\n+  }\n+\n+  // contains association of signals to their respective handlers\n+  private val handlers = new HashMap[String, ActionHandler]\n+\n+  /**\n+   * Adds an action to be run when a given signal is received by this process.\n+   *\n+   * Note that signals are only supported on unix-like operating systems and work on a best-effort\n+   * basis: if a signal is not available or cannot be intercepted, only a warning is emitted.\n+   *\n+   * All actions for a given signal are run in a separate thread.\n+   */\n+  def register(signal: String)(action: => Boolean): Unit = synchronized {\n+    if (SystemUtils.IS_OS_UNIX) try {",
    "line": 87
  }, {
    "author": {
      "login": "jodersky"
    },
    "body": "not sure what you mean, maybe a\n\n```\nif(...) {\n  try {\n```\n\n?\n",
    "commit": "4f9bf695344a5c4c54372eaa6bf54af0d2da1f74",
    "createdAt": "2016-04-22T07:26:01Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.{Collections, LinkedList}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.HashMap\n+\n+import org.apache.commons.lang3.SystemUtils\n+import sun.misc.{Signal, SignalHandler}\n+\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Contains utilities for working with posix signals.\n+ */\n+private[spark] object Signaling extends Logging {\n+\n+  /**\n+   * A handler for the given signal that runs a collection of actions.\n+   */\n+  private class ActionHandler(signal: Signal) extends SignalHandler {\n+\n+    private val actions = Collections.synchronizedList(new LinkedList[() => Boolean])\n+\n+    // original signal handler, before this handler was attached\n+    private val prevHandler: SignalHandler = Signal.handle(signal, this)\n+\n+    /**\n+     * Called when this handler's signal is received. Note that if the same signal is received\n+     * before this method returns, it is escalated to the previous handler.\n+     */\n+    override def handle(sig: Signal): Unit = {\n+      // register old handler, will receive incoming signals while this handler is running\n+      Signal.handle(signal, prevHandler)\n+\n+      val escalate = actions.asScala forall { action =>\n+        !action()\n+      }\n+\n+      if(escalate) {\n+        prevHandler.handle(sig)\n+      }\n+\n+      // re-register this handler\n+      Signal.handle(signal, this)\n+    }\n+\n+    /**\n+     * Add an action to be run by this handler.\n+     * @param action An action to be run when a signal is received. Return true if the signal\n+     * should be stopped with this handler, false if it should be escalated.\n+     */\n+    def register(action: => Boolean): Unit = actions.add(() => action)\n+\n+  }\n+\n+  // contains association of signals to their respective handlers\n+  private val handlers = new HashMap[String, ActionHandler]\n+\n+  /**\n+   * Adds an action to be run when a given signal is received by this process.\n+   *\n+   * Note that signals are only supported on unix-like operating systems and work on a best-effort\n+   * basis: if a signal is not available or cannot be intercepted, only a warning is emitted.\n+   *\n+   * All actions for a given signal are run in a separate thread.\n+   */\n+  def register(signal: String)(action: => Boolean): Unit = synchronized {\n+    if (SystemUtils.IS_OS_UNIX) try {",
    "line": 87
  }],
  "prId": 12557
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nit space. also i think this deserves more comment explaining what's going on.\n",
    "commit": "4f9bf695344a5c4c54372eaa6bf54af0d2da1f74",
    "createdAt": "2016-04-22T07:18:37Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.{Collections, LinkedList}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.HashMap\n+\n+import org.apache.commons.lang3.SystemUtils\n+import sun.misc.{Signal, SignalHandler}\n+\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Contains utilities for working with posix signals.\n+ */\n+private[spark] object Signaling extends Logging {\n+\n+  /**\n+   * A handler for the given signal that runs a collection of actions.\n+   */\n+  private class ActionHandler(signal: Signal) extends SignalHandler {\n+\n+    private val actions = Collections.synchronizedList(new LinkedList[() => Boolean])\n+\n+    // original signal handler, before this handler was attached\n+    private val prevHandler: SignalHandler = Signal.handle(signal, this)\n+\n+    /**\n+     * Called when this handler's signal is received. Note that if the same signal is received\n+     * before this method returns, it is escalated to the previous handler.\n+     */\n+    override def handle(sig: Signal): Unit = {\n+      // register old handler, will receive incoming signals while this handler is running\n+      Signal.handle(signal, prevHandler)\n+\n+      val escalate = actions.asScala forall { action =>\n+        !action()\n+      }\n+\n+      if(escalate) {",
    "line": 58
  }, {
    "author": {
      "login": "jodersky"
    },
    "body": "oops that slipped past my my review\n",
    "commit": "4f9bf695344a5c4c54372eaa6bf54af0d2da1f74",
    "createdAt": "2016-04-22T07:27:55Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.{Collections, LinkedList}\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.HashMap\n+\n+import org.apache.commons.lang3.SystemUtils\n+import sun.misc.{Signal, SignalHandler}\n+\n+import org.apache.spark.internal.Logging\n+\n+\n+/**\n+ * Contains utilities for working with posix signals.\n+ */\n+private[spark] object Signaling extends Logging {\n+\n+  /**\n+   * A handler for the given signal that runs a collection of actions.\n+   */\n+  private class ActionHandler(signal: Signal) extends SignalHandler {\n+\n+    private val actions = Collections.synchronizedList(new LinkedList[() => Boolean])\n+\n+    // original signal handler, before this handler was attached\n+    private val prevHandler: SignalHandler = Signal.handle(signal, this)\n+\n+    /**\n+     * Called when this handler's signal is received. Note that if the same signal is received\n+     * before this method returns, it is escalated to the previous handler.\n+     */\n+    override def handle(sig: Signal): Unit = {\n+      // register old handler, will receive incoming signals while this handler is running\n+      Signal.handle(signal, prevHandler)\n+\n+      val escalate = actions.asScala forall { action =>\n+        !action()\n+      }\n+\n+      if(escalate) {",
    "line": 58
  }],
  "prId": 12557
}]