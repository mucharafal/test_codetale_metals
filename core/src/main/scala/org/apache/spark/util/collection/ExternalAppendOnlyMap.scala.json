[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I choose to simply return false now. Another option is to actually spill the in-memory map.",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2016-12-23T05:54:24Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "This fixes the problem reported in the bug, but is there a reason not to just instantiate `readingIterator` if it hasn't been set yet? Feels like it would be the right thing to do.",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-10T21:12:53Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "As I commented before:\r\n\r\n> I choose to simply return false now. Another option is to actually spill the in-memory map.\r\n\r\nIf `readingIterator` is not set, once `forceSpill` is called we can spill the content of `currentMap` into disk like `spill` does now.\r\n\r\nWe can't just instantiate `readingIterator` and spill it. Because `readingIterator` is only created for iterating over the entries of the in-memory map, when we want to read the content of this `ExternalAppendOnlyMap`. If `forceSpill` is called before we want to read the content, and we instantiate `readingIterator` and spill it, the in-memory map will be released and we can't insert data further.",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-11T02:18:21Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Sorry, you're right, so let me rephrase: is there any reason not to try to spill the current map if the iterator hasn't been instantiated?",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-11T03:12:48Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "The reason I chose to simple return false is, if the in-memory map is not yet spilled to disk during inserting data, it may not need to be spilled in fact as it should be a small spill.\r\n\r\nBut I think it is arguable that when `forceSpill` is called, we should spill the collection anyway. I will do the change.\r\n",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-11T08:06:54Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "BTW, `ExternalSorter` has the same behavior as the current change: its `forceSpill` does nothing before its iterator is called. ",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-11T08:12:11Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "@vanzin As @samkum tested, spilling the map could cause GC pressure. I think that is because the map is frequently spilled.\r\n\r\nBecause the map will be checked and spilled during `insertAll`, I think it is ok not to spill it in `forceSpill` in order to avoid frequent spilling.\r\n\r\nWhat do you think?",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-18T13:35:37Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I'm not sure I understand how freeing memory would cause GC pressure, unless you're not actually freeing memory.\r\n\r\n@samkum did you try this patch without the \"spill map on every call\" behavior (basically returning \"false\" instead of spilling the in-memory map when the iterator doesn't exist)?\r\n\r\nIf that case also results in increased gc, maybe your app just needs more memory. That would be the case where the assert would trigger before.",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-18T18:12:28Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "@samkum Do you have any comment on @vanzin's question?",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-20T09:11:18Z",
    "diffHunk": "@@ -192,12 +193,16 @@ class ExternalAppendOnlyMap[K, V, C](\n    * It will be called by TaskMemoryManager when there is not enough memory for the task.\n    */\n   override protected[this] def forceSpill(): Boolean = {\n-    assert(readingIterator != null)\n-    val isSpilled = readingIterator.spill()\n-    if (isSpilled) {\n-      currentMap = null\n+    if (isReadingIterator) {\n+      assert(readingIterator != null)\n+      val isSpilled = readingIterator.spill()\n+      if (isSpilled) {\n+        currentMap = null\n+      }\n+      isSpilled\n+    } else {\n+      false"
  }],
  "prId": 16387
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I'm a little confused. Isn't this having the same effect as just removing the assert, since you're setting this to `true` right after instantiating `readingIterator`?",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-07T00:31:01Z",
    "diffHunk": "@@ -115,6 +115,7 @@ class ExternalAppendOnlyMap[K, V, C](\n   private val keyComparator = new HashComparator[K]\n   private val ser = serializer.newInstance()\n \n+  @volatile private var isReadingIterator: Boolean = false"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yeah, alternatively we can remove the assert and check if `readingIterator` is null or not. I just want to keep the original behavior.",
    "commit": "b1ef9ec749737125d833cd3a64922b4a9f8c32f1",
    "createdAt": "2017-01-07T01:48:24Z",
    "diffHunk": "@@ -115,6 +115,7 @@ class ExternalAppendOnlyMap[K, V, C](\n   private val keyComparator = new HashComparator[K]\n   private val ser = serializer.newInstance()\n \n+  @volatile private var isReadingIterator: Boolean = false"
  }],
  "prId": 16387
}]