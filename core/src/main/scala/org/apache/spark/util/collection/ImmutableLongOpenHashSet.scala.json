[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "would it be better to throw an exception here?  Just in case something goes wrong and you end up here, you get a stack trace which will pinpoint the problem.\n",
    "commit": "02a9bde62102facfd5f9146039a2d68cdc0f180b",
    "createdAt": "2014-09-19T15:31:56Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.reflect._\n+import com.google.common.hash.Hashing\n+\n+/**\n+ * A fast, immutable hash set optimized for insertions and lookups (but not deletions) of `Long`\n+ * elements. Because it exposes the position of a key in the underlying array, this is useful as a\n+ * building block for higher level data structures such as a hash map (for example,\n+ * IndexedRDDPartition).\n+ *\n+ * It uses quadratic probing with a power-of-2 hash table size, which is guaranteed to explore all\n+ * spaces for each key (see http://en.wikipedia.org/wiki/Quadratic_probing).\n+ */\n+private[spark] class ImmutableLongOpenHashSet(\n+    /** Underlying array of elements used as a hash table. */\n+    val data: ImmutableVector[Long],\n+    /** Whether or not there is an element at the corresponding position in `data`. */\n+    val bitset: ImmutableBitSet,\n+    /**\n+     * Position of a focused element. This is useful when returning a modified set along with a\n+     * pointer to the location of modification.\n+     */\n+    val focus: Int,\n+    /** Load threshold at which to grow the underlying vectors. */\n+    loadFactor: Double\n+  ) extends Serializable {\n+\n+  require(loadFactor < 1.0, \"Load factor must be less than 1.0\")\n+  require(loadFactor > 0.0, \"Load factor must be greater than 0.0\")\n+  require(capacity == nextPowerOf2(capacity), \"data capacity must be a power of 2\")\n+\n+  import OpenHashSet.{INVALID_POS, NONEXISTENCE_MASK, POSITION_MASK, Hasher, LongHasher}\n+\n+  private val hasher: Hasher[Long] = new LongHasher\n+\n+  private def mask = capacity - 1\n+  private def growThreshold = (loadFactor * capacity).toInt\n+\n+  def withFocus(focus: Int): ImmutableLongOpenHashSet =\n+    new ImmutableLongOpenHashSet(data, bitset, focus, loadFactor)\n+\n+  /** The number of elements in the set. */\n+  def size: Int = bitset.cardinality\n+\n+  /** The capacity of the set (i.e. size of the underlying vector). */\n+  def capacity: Int = data.size\n+\n+  /** Return true if this set contains the specified element. */\n+  def contains(k: Long): Boolean = getPos(k) != INVALID_POS\n+\n+  /**\n+   * Nondestructively add an element to the set, returning a new set. If the set is over capacity\n+   * after the insertion, grows the set and rehashes all elements.\n+   */\n+  def add(k: Long): ImmutableLongOpenHashSet = {\n+    addWithoutResize(k).rehashIfNeeded(ImmutableLongOpenHashSet.grow, ImmutableLongOpenHashSet.move)\n+  }\n+\n+  /**\n+   * Add an element to the set. This one differs from add in that it doesn't trigger rehashing.\n+   * The caller is responsible for calling rehashIfNeeded.\n+   *\n+   * Use (retval.focus & POSITION_MASK) to get the actual position, and\n+   * (retval.focus & NONEXISTENCE_MASK) == 0 for prior existence.\n+   */\n+  def addWithoutResize(k: Long): ImmutableLongOpenHashSet = {\n+    var pos = hashcode(hasher.hash(k)) & mask\n+    var i = 1\n+    var result: ImmutableLongOpenHashSet = null\n+    while (result == null) {\n+      if (!bitset.get(pos)) {\n+        // This is a new key.\n+        result = new ImmutableLongOpenHashSet(\n+          data.updated(pos, k), bitset.set(pos), pos | NONEXISTENCE_MASK, loadFactor)\n+      } else if (data(pos) == k) {\n+        // Found an existing key.\n+        result = this.withFocus(pos)\n+      } else {\n+        val delta = i\n+        pos = (pos + delta) & mask\n+        i += 1\n+      }\n+    }\n+    result\n+  }\n+\n+  /**\n+   * Rehash the set if it is overloaded.\n+   * @param allocateFunc Callback invoked when we are allocating a new, larger array.\n+   * @param moveFunc Callback invoked when we move the key from one position (in the old data array)\n+   *                 to a new position (in the new data array).\n+   */\n+  def rehashIfNeeded(\n+      allocateFunc: (Int) => Unit, moveFunc: (Int, Int) => Unit): ImmutableLongOpenHashSet = {\n+    if (size > growThreshold) {\n+      rehash(allocateFunc, moveFunc)\n+    } else {\n+      this\n+    }\n+  }\n+\n+  /**\n+   * Return the position of the element in the underlying array, or INVALID_POS if it is not found.\n+   */\n+  def getPos(k: Long): Int = {\n+    var pos = hashcode(hasher.hash(k)) & mask\n+    var i = 1\n+    val maxProbe = capacity\n+    while (i < maxProbe) {\n+      if (!bitset.get(pos)) {\n+        return INVALID_POS\n+      } else if (k == data(pos)) {\n+        return pos\n+      } else {\n+        val delta = i\n+        pos = (pos + delta) & mask\n+        i += 1\n+      }\n+    }\n+    // Never reached here\n+    INVALID_POS",
    "line": 139
  }],
  "prId": 1297
}]