[{
  "comments": [{
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "this should always be != null, right? Because the thread the acquired has been the one to put it there, so it should be the one who removes it?",
    "commit": "9b59ca2074f4b90a115b668a6b2c0a043e3475af",
    "createdAt": "2019-08-29T18:45:25Z",
    "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/**\n+ * A special locking mechanism to provide locking with a given key. By providing the same key\n+ * (identity is tested using the `equals` method), we ensure there is only one `func` running at\n+ * the same time.\n+ *\n+ * @tparam K the type of key to identify a lock. This type must implement `equals` and `hashCode`\n+ *           correctly as it will be the key type of an internal Map.\n+ */\n+private[spark] class KeyLock[K] {\n+\n+  private val lockMap = new ConcurrentHashMap[K, AnyRef]()\n+\n+  private def acquireLock(key: K): Unit = {\n+    while (true) {\n+      val lock = lockMap.putIfAbsent(key, new Object)\n+      if (lock == null) return\n+      lock.synchronized {\n+        while (lockMap.get(key) eq lock) {\n+          lock.wait()\n+        }\n+      }\n+    }\n+  }\n+\n+  private def releaseLock(key: K): Unit = {\n+    val lock = lockMap.remove(key)\n+    if (lock != null) {"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Correct. We can remove this check.",
    "commit": "9b59ca2074f4b90a115b668a6b2c0a043e3475af",
    "createdAt": "2019-08-29T18:56:20Z",
    "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/**\n+ * A special locking mechanism to provide locking with a given key. By providing the same key\n+ * (identity is tested using the `equals` method), we ensure there is only one `func` running at\n+ * the same time.\n+ *\n+ * @tparam K the type of key to identify a lock. This type must implement `equals` and `hashCode`\n+ *           correctly as it will be the key type of an internal Map.\n+ */\n+private[spark] class KeyLock[K] {\n+\n+  private val lockMap = new ConcurrentHashMap[K, AnyRef]()\n+\n+  private def acquireLock(key: K): Unit = {\n+    while (true) {\n+      val lock = lockMap.putIfAbsent(key, new Object)\n+      if (lock == null) return\n+      lock.synchronized {\n+        while (lockMap.get(key) eq lock) {\n+          lock.wait()\n+        }\n+      }\n+    }\n+  }\n+\n+  private def releaseLock(key: K): Unit = {\n+    val lock = lockMap.remove(key)\n+    if (lock != null) {"
  }],
  "prId": 25612
}, {
  "comments": [{
    "author": {
      "login": "Ngone51"
    },
    "body": "After releasing keylock, if a new thread for the same broadcastId enters to put a new object before another queueing thread to check `lockMap.get(key) eq lock`,  both threads could get the keylock finally ?",
    "commit": "9b59ca2074f4b90a115b668a6b2c0a043e3475af",
    "createdAt": "2019-08-30T13:59:15Z",
    "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/**\n+ * A special locking mechanism to provide locking with a given key. By providing the same key\n+ * (identity is tested using the `equals` method), we ensure there is only one `func` running at\n+ * the same time.\n+ *\n+ * @tparam K the type of key to identify a lock. This type must implement `equals` and `hashCode`\n+ *           correctly as it will be the key type of an internal Map.\n+ */\n+private[spark] class KeyLock[K] {\n+\n+  private val lockMap = new ConcurrentHashMap[K, AnyRef]()\n+\n+  private def acquireLock(key: K): Unit = {\n+    while (true) {\n+      val lock = lockMap.putIfAbsent(key, new Object)\n+      if (lock == null) return\n+      lock.synchronized {\n+        while (lockMap.get(key) eq lock) {",
    "line": 39
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "The thread inside this inner while loop will end, and will retry the outer while loop. The line `if (lock == null) return` is the only exit. When `acquireLock` returns, this thread has `putIfAbsent` a new object to `lockMap` successfully.",
    "commit": "9b59ca2074f4b90a115b668a6b2c0a043e3475af",
    "createdAt": "2019-08-30T17:21:54Z",
    "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/**\n+ * A special locking mechanism to provide locking with a given key. By providing the same key\n+ * (identity is tested using the `equals` method), we ensure there is only one `func` running at\n+ * the same time.\n+ *\n+ * @tparam K the type of key to identify a lock. This type must implement `equals` and `hashCode`\n+ *           correctly as it will be the key type of an internal Map.\n+ */\n+private[spark] class KeyLock[K] {\n+\n+  private val lockMap = new ConcurrentHashMap[K, AnyRef]()\n+\n+  private def acquireLock(key: K): Unit = {\n+    while (true) {\n+      val lock = lockMap.putIfAbsent(key, new Object)\n+      if (lock == null) return\n+      lock.synchronized {\n+        while (lockMap.get(key) eq lock) {",
    "line": 39
  }, {
    "author": {
      "login": "Ngone51"
    },
    "body": "Oh, I see.",
    "commit": "9b59ca2074f4b90a115b668a6b2c0a043e3475af",
    "createdAt": "2019-08-31T04:34:03Z",
    "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+/**\n+ * A special locking mechanism to provide locking with a given key. By providing the same key\n+ * (identity is tested using the `equals` method), we ensure there is only one `func` running at\n+ * the same time.\n+ *\n+ * @tparam K the type of key to identify a lock. This type must implement `equals` and `hashCode`\n+ *           correctly as it will be the key type of an internal Map.\n+ */\n+private[spark] class KeyLock[K] {\n+\n+  private val lockMap = new ConcurrentHashMap[K, AnyRef]()\n+\n+  private def acquireLock(key: K): Unit = {\n+    while (true) {\n+      val lock = lockMap.putIfAbsent(key, new Object)\n+      if (lock == null) return\n+      lock.synchronized {\n+        while (lockMap.get(key) eq lock) {",
    "line": 39
  }],
  "prId": 25612
}]