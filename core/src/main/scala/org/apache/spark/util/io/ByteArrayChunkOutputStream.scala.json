[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: move to previous line\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-04-07T21:42:09Z",
    "diffHunk": "@@ -91,4 +95,41 @@ class ByteArrayChunkOutputStream(chunkSize: Int) extends OutputStream {\n       ret\n     }\n   }\n+\n+  /**\n+   * get a copy of the data between the two endpoints\n+   */\n+  def slice(start: Long, until: Long): Array[Byte] = {\n+    require((until - start) < Integer.MAX_VALUE, \"max slice length = Integer.MAX_VALUE\")\n+    var chunkStart = 0L\n+    var chunkIdx = 0\n+    var foundStart = false\n+    val length = (until - start).toInt\n+    val result = new Array[Byte](length)\n+    while (!foundStart) {\n+      val nextSize = chunkStart + chunks(chunkIdx).size\n+      if (nextSize > start) {\n+        foundStart = true\n+      }\n+      else {"
  }],
  "prId": 5400
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This feels wrong. You're comparing `start` to the added size of the last two chunks, not to the cumulative size of all previous chunks.\n\nI think L119 should be a `+=` instead of plain `=`, and maybe you need a better named variable than `chunkStart`.\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-02T16:27:20Z",
    "diffHunk": "@@ -91,4 +95,45 @@ class ByteArrayChunkOutputStream(chunkSize: Int) extends OutputStream {\n       ret\n     }\n   }\n+\n+  /**\n+   * Get a copy of the data between the two endpoints, start <= idx < until.  Always returns\n+   * an array of size (until - start).  Throws an IllegalArgumentException if\n+   * 0 <= start <= until <= size\n+   */\n+  def slice(start: Long, until: Long): Array[Byte] = {\n+    require((until - start) < Integer.MAX_VALUE, \"max slice length = Integer.MAX_VALUE\")\n+    require(start >= 0 && start <= until, s\"start ($start) must be >= 0 and <= until ($until)\")\n+    require(until >= start && until <= size,\n+      s\"until ($until) must be >= start ($start) and <= size ($size)\")\n+    var chunkStart = 0L\n+    var chunkIdx = 0\n+    val length = (until - start).toInt\n+    var foundStart = false\n+    val result = new Array[Byte](length)\n+    while (!foundStart) {\n+      val nextSize = chunkStart + chunks(chunkIdx).size"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Can you add a regression test for slice while fixing this?\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-02T17:01:56Z",
    "diffHunk": "@@ -91,4 +95,45 @@ class ByteArrayChunkOutputStream(chunkSize: Int) extends OutputStream {\n       ret\n     }\n   }\n+\n+  /**\n+   * Get a copy of the data between the two endpoints, start <= idx < until.  Always returns\n+   * an array of size (until - start).  Throws an IllegalArgumentException if\n+   * 0 <= start <= until <= size\n+   */\n+  def slice(start: Long, until: Long): Array[Byte] = {\n+    require((until - start) < Integer.MAX_VALUE, \"max slice length = Integer.MAX_VALUE\")\n+    require(start >= 0 && start <= until, s\"start ($start) must be >= 0 and <= until ($until)\")\n+    require(until >= start && until <= size,\n+      s\"until ($until) must be >= start ($start) and <= size ($size)\")\n+    var chunkStart = 0L\n+    var chunkIdx = 0\n+    val length = (until - start).toInt\n+    var foundStart = false\n+    val result = new Array[Byte](length)\n+    while (!foundStart) {\n+      val nextSize = chunkStart + chunks(chunkIdx).size"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "e.g. a test that fails and demonstrates the issue that Marcelo points out here?\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-02T17:02:29Z",
    "diffHunk": "@@ -91,4 +95,45 @@ class ByteArrayChunkOutputStream(chunkSize: Int) extends OutputStream {\n       ret\n     }\n   }\n+\n+  /**\n+   * Get a copy of the data between the two endpoints, start <= idx < until.  Always returns\n+   * an array of size (until - start).  Throws an IllegalArgumentException if\n+   * 0 <= start <= until <= size\n+   */\n+  def slice(start: Long, until: Long): Array[Byte] = {\n+    require((until - start) < Integer.MAX_VALUE, \"max slice length = Integer.MAX_VALUE\")\n+    require(start >= 0 && start <= until, s\"start ($start) must be >= 0 and <= until ($until)\")\n+    require(until >= start && until <= size,\n+      s\"until ($until) must be >= start ($start) and <= size ($size)\")\n+    var chunkStart = 0L\n+    var chunkIdx = 0\n+    val length = (until - start).toInt\n+    var foundStart = false\n+    val result = new Array[Byte](length)\n+    while (!foundStart) {\n+      val nextSize = chunkStart + chunks(chunkIdx).size"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "I think its correct as is, the problem is that `nextSize` is actually a very misleading name, it should be `nextChunkStart` (it puzzled me too when I looked at it again).  I think the [tests](https://github.com/squito/spark/blob/6c2a115b970d31400cd77dc8f0236555e382a1af/core/src/test/scala/org/apache/spark/util/io/ByteArrayChunkOutputStreamSuite.scala#L111) already cover this case.  I will fix the variable name and the test to use chunk size of 5 bytes, so we get more coverage of slicing across several chunks.\n",
    "commit": "3447bb995b53c4d93154328c7c7c06e08a5ec9b9",
    "createdAt": "2015-06-02T19:56:54Z",
    "diffHunk": "@@ -91,4 +95,45 @@ class ByteArrayChunkOutputStream(chunkSize: Int) extends OutputStream {\n       ret\n     }\n   }\n+\n+  /**\n+   * Get a copy of the data between the two endpoints, start <= idx < until.  Always returns\n+   * an array of size (until - start).  Throws an IllegalArgumentException if\n+   * 0 <= start <= until <= size\n+   */\n+  def slice(start: Long, until: Long): Array[Byte] = {\n+    require((until - start) < Integer.MAX_VALUE, \"max slice length = Integer.MAX_VALUE\")\n+    require(start >= 0 && start <= until, s\"start ($start) must be >= 0 and <= until ($until)\")\n+    require(until >= start && until <= size,\n+      s\"until ($until) must be >= start ($start) and <= size ($size)\")\n+    var chunkStart = 0L\n+    var chunkIdx = 0\n+    val length = (until - start).toInt\n+    var foundStart = false\n+    val result = new Array[Byte](length)\n+    while (!foundStart) {\n+      val nextSize = chunkStart + chunks(chunkIdx).size"
  }],
  "prId": 5400
}]