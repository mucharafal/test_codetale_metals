[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: we generally use `hooks.synchronized`.\n",
    "commit": "3da8644739c18aee4dde327cc2f2530283856c41",
    "createdAt": "2015-11-30T18:01:17Z",
    "diffHunk": "@@ -232,22 +232,23 @@ private [util] class SparkShutdownHookManager {\n     }\n   }\n \n-  def runAll(): Unit = synchronized {\n+  def runAll(): Unit = {\n     shuttingDown = true\n-    while (!hooks.isEmpty()) {\n-      Try(Utils.logUncaughtExceptions(hooks.poll().run()))\n+    var nextHook: SparkShutdownHook = null\n+    while ({nextHook = hooks synchronized { hooks.poll() }; nextHook != null}) {"
  }],
  "prId": 10042
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "So, technically, this is not really thread-safe anymore. You can have this order of things:\n\nT1: in add(), passes `checkState()` check\nT2: in runAll(), sets `shuttingDown` to true\nT2: in runAll(), calls `hooks.poll()`, list is empty, stops calling hooks\nT1: in add(), adds hook to the list, hook will never be called.\n\nGranted, that's very unlikely. I think if you move the `checkState()` call inside the lock it should fix things, though. You may end up adding a new hook when `shuttingDown` is true in that case, but you make sure that `runAll` will still pick it up.\n",
    "commit": "3da8644739c18aee4dde327cc2f2530283856c41",
    "createdAt": "2015-11-30T18:09:22Z",
    "diffHunk": "@@ -232,22 +232,23 @@ private [util] class SparkShutdownHookManager {\n     }\n   }\n \n-  def runAll(): Unit = synchronized {\n+  def runAll(): Unit = {\n     shuttingDown = true\n-    while (!hooks.isEmpty()) {\n-      Try(Utils.logUncaughtExceptions(hooks.poll().run()))\n+    var nextHook: SparkShutdownHook = null\n+    while ({nextHook = hooks synchronized { hooks.poll() }; nextHook != null}) {\n+      Try(Utils.logUncaughtExceptions(nextHook.run()))\n     }\n   }\n \n-  def add(priority: Int, hook: () => Unit): AnyRef = synchronized {\n+  def add(priority: Int, hook: () => Unit): AnyRef = {\n     checkState()\n     val hookRef = new SparkShutdownHook(priority, hook)\n-    hooks.add(hookRef)\n+    hooks synchronized { hooks.add(hookRef) }"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Yeah, you got me. That really has to be tightened up. Will address these shortly.\n",
    "commit": "3da8644739c18aee4dde327cc2f2530283856c41",
    "createdAt": "2015-11-30T18:33:02Z",
    "diffHunk": "@@ -232,22 +232,23 @@ private [util] class SparkShutdownHookManager {\n     }\n   }\n \n-  def runAll(): Unit = synchronized {\n+  def runAll(): Unit = {\n     shuttingDown = true\n-    while (!hooks.isEmpty()) {\n-      Try(Utils.logUncaughtExceptions(hooks.poll().run()))\n+    var nextHook: SparkShutdownHook = null\n+    while ({nextHook = hooks synchronized { hooks.poll() }; nextHook != null}) {\n+      Try(Utils.logUncaughtExceptions(nextHook.run()))\n     }\n   }\n \n-  def add(priority: Int, hook: () => Unit): AnyRef = synchronized {\n+  def add(priority: Int, hook: () => Unit): AnyRef = {\n     checkState()\n     val hookRef = new SparkShutdownHook(priority, hook)\n-    hooks.add(hookRef)\n+    hooks synchronized { hooks.add(hookRef) }"
  }],
  "prId": 10042
}]