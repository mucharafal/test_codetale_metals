[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "minor: should you bail out early if `shouldInterruptThread` has already been set somehow?\n",
    "commit": "47187d82a4f8748a718d6ef9db5867bf22ef8c99",
    "createdAt": "2016-03-27T00:31:27Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+/**\n+ * A special Thread that provides \"runUninterruptibly\" to allow running codes without being\n+ * interrupted by `Thread.interrupt()`. If `Thread.interrupt()` is called during runUninterruptibly\n+ * is running, it won't set the interrupted status. Instead, setting the interrupted status will be\n+ * deferred until it's returning from \"runUninterruptibly\".\n+ *\n+ * Note: this method should be called only in `this` thread.\n+ */\n+private[spark] class UninterruptibleThread(name: String) extends Thread(name) {\n+\n+  /** A monitor to protect \"uninterruptible\" and \"interrupted\" */\n+  private val uninterruptibleLock = new Object\n+\n+  /**\n+   * Indicates if `this`  thread are in the uninterruptible status. If so, interrupting\n+   * \"this\" will be deferred until `this`  enters into the interruptible status.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var uninterruptible = false\n+\n+  /**\n+   * Indicates if we should interrupt `this` when we are leaving the uninterruptible zone.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var shouldInterruptThread = false\n+\n+  /**\n+   * Run `f` uninterruptibly in `this` thread. The thread won't be interrupted before returning\n+   * from `f`.\n+   *\n+   * Note: this method should be called only in `this` thread.\n+   */\n+  def runUninterruptibly[T](f: => T): T = {\n+    if (Thread.currentThread() != this) {\n+      throw new IllegalStateException(s\"Call runUninterruptibly in a wrong thread. \" +\n+        s\"Expected: $this but was ${Thread.currentThread()}\")\n+    }\n+",
    "line": 62
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "> minor: should you bail out early if shouldInterruptThread has already been set somehow?\n\nDon't get it. `shouldInterruptThread` is just a flag that indicates if we should call `super.interrupt`  in `finally`. What do you suggest to do here?\n",
    "commit": "47187d82a4f8748a718d6ef9db5867bf22ef8c99",
    "createdAt": "2016-03-28T17:29:17Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+/**\n+ * A special Thread that provides \"runUninterruptibly\" to allow running codes without being\n+ * interrupted by `Thread.interrupt()`. If `Thread.interrupt()` is called during runUninterruptibly\n+ * is running, it won't set the interrupted status. Instead, setting the interrupted status will be\n+ * deferred until it's returning from \"runUninterruptibly\".\n+ *\n+ * Note: this method should be called only in `this` thread.\n+ */\n+private[spark] class UninterruptibleThread(name: String) extends Thread(name) {\n+\n+  /** A monitor to protect \"uninterruptible\" and \"interrupted\" */\n+  private val uninterruptibleLock = new Object\n+\n+  /**\n+   * Indicates if `this`  thread are in the uninterruptible status. If so, interrupting\n+   * \"this\" will be deferred until `this`  enters into the interruptible status.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var uninterruptible = false\n+\n+  /**\n+   * Indicates if we should interrupt `this` when we are leaving the uninterruptible zone.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var shouldInterruptThread = false\n+\n+  /**\n+   * Run `f` uninterruptibly in `this` thread. The thread won't be interrupted before returning\n+   * from `f`.\n+   *\n+   * Note: this method should be called only in `this` thread.\n+   */\n+  def runUninterruptibly[T](f: => T): T = {\n+    if (Thread.currentThread() != this) {\n+      throw new IllegalStateException(s\"Call runUninterruptibly in a wrong thread. \" +\n+        s\"Expected: $this but was ${Thread.currentThread()}\")\n+    }\n+",
    "line": 62
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I mean: if the thread is already interrupted before you try to run the given function (or, in other words, if `Thread.interrupt()` was called before you get to this point), should you just return early instead of calling the function?\n\n(I guess I should have commented on L68 instead, where there's an explicit check for whether the thread is already interrupted.)\n",
    "commit": "47187d82a4f8748a718d6ef9db5867bf22ef8c99",
    "createdAt": "2016-03-28T17:34:12Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+/**\n+ * A special Thread that provides \"runUninterruptibly\" to allow running codes without being\n+ * interrupted by `Thread.interrupt()`. If `Thread.interrupt()` is called during runUninterruptibly\n+ * is running, it won't set the interrupted status. Instead, setting the interrupted status will be\n+ * deferred until it's returning from \"runUninterruptibly\".\n+ *\n+ * Note: this method should be called only in `this` thread.\n+ */\n+private[spark] class UninterruptibleThread(name: String) extends Thread(name) {\n+\n+  /** A monitor to protect \"uninterruptible\" and \"interrupted\" */\n+  private val uninterruptibleLock = new Object\n+\n+  /**\n+   * Indicates if `this`  thread are in the uninterruptible status. If so, interrupting\n+   * \"this\" will be deferred until `this`  enters into the interruptible status.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var uninterruptible = false\n+\n+  /**\n+   * Indicates if we should interrupt `this` when we are leaving the uninterruptible zone.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var shouldInterruptThread = false\n+\n+  /**\n+   * Run `f` uninterruptibly in `this` thread. The thread won't be interrupted before returning\n+   * from `f`.\n+   *\n+   * Note: this method should be called only in `this` thread.\n+   */\n+  def runUninterruptibly[T](f: => T): T = {\n+    if (Thread.currentThread() != this) {\n+      throw new IllegalStateException(s\"Call runUninterruptibly in a wrong thread. \" +\n+        s\"Expected: $this but was ${Thread.currentThread()}\")\n+    }\n+",
    "line": 62
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "In this case, it should clear the interrupt status and set it back after calling `f`. `StreamExecution` allows people to `interrupt` at any time.\n",
    "commit": "47187d82a4f8748a718d6ef9db5867bf22ef8c99",
    "createdAt": "2016-03-28T17:39:45Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+/**\n+ * A special Thread that provides \"runUninterruptibly\" to allow running codes without being\n+ * interrupted by `Thread.interrupt()`. If `Thread.interrupt()` is called during runUninterruptibly\n+ * is running, it won't set the interrupted status. Instead, setting the interrupted status will be\n+ * deferred until it's returning from \"runUninterruptibly\".\n+ *\n+ * Note: this method should be called only in `this` thread.\n+ */\n+private[spark] class UninterruptibleThread(name: String) extends Thread(name) {\n+\n+  /** A monitor to protect \"uninterruptible\" and \"interrupted\" */\n+  private val uninterruptibleLock = new Object\n+\n+  /**\n+   * Indicates if `this`  thread are in the uninterruptible status. If so, interrupting\n+   * \"this\" will be deferred until `this`  enters into the interruptible status.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var uninterruptible = false\n+\n+  /**\n+   * Indicates if we should interrupt `this` when we are leaving the uninterruptible zone.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var shouldInterruptThread = false\n+\n+  /**\n+   * Run `f` uninterruptibly in `this` thread. The thread won't be interrupted before returning\n+   * from `f`.\n+   *\n+   * Note: this method should be called only in `this` thread.\n+   */\n+  def runUninterruptibly[T](f: => T): T = {\n+    if (Thread.currentThread() != this) {\n+      throw new IllegalStateException(s\"Call runUninterruptibly in a wrong thread. \" +\n+        s\"Expected: $this but was ${Thread.currentThread()}\")\n+    }\n+",
    "line": 62
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I understand that's what the code does right now. I'm asking whether it would be better to not run `f` if the thread has already been interrupted, since you might be running a long computation after some other code has asked the thread to stop what it's doing.\n",
    "commit": "47187d82a4f8748a718d6ef9db5867bf22ef8c99",
    "createdAt": "2016-03-28T17:43:15Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+/**\n+ * A special Thread that provides \"runUninterruptibly\" to allow running codes without being\n+ * interrupted by `Thread.interrupt()`. If `Thread.interrupt()` is called during runUninterruptibly\n+ * is running, it won't set the interrupted status. Instead, setting the interrupted status will be\n+ * deferred until it's returning from \"runUninterruptibly\".\n+ *\n+ * Note: this method should be called only in `this` thread.\n+ */\n+private[spark] class UninterruptibleThread(name: String) extends Thread(name) {\n+\n+  /** A monitor to protect \"uninterruptible\" and \"interrupted\" */\n+  private val uninterruptibleLock = new Object\n+\n+  /**\n+   * Indicates if `this`  thread are in the uninterruptible status. If so, interrupting\n+   * \"this\" will be deferred until `this`  enters into the interruptible status.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var uninterruptible = false\n+\n+  /**\n+   * Indicates if we should interrupt `this` when we are leaving the uninterruptible zone.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var shouldInterruptThread = false\n+\n+  /**\n+   * Run `f` uninterruptibly in `this` thread. The thread won't be interrupted before returning\n+   * from `f`.\n+   *\n+   * Note: this method should be called only in `this` thread.\n+   */\n+  def runUninterruptibly[T](f: => T): T = {\n+    if (Thread.currentThread() != this) {\n+      throw new IllegalStateException(s\"Call runUninterruptibly in a wrong thread. \" +\n+        s\"Expected: $this but was ${Thread.currentThread()}\")\n+    }\n+",
    "line": 62
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "That's a good point. Will update my PR.\n",
    "commit": "47187d82a4f8748a718d6ef9db5867bf22ef8c99",
    "createdAt": "2016-03-28T17:46:52Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+/**\n+ * A special Thread that provides \"runUninterruptibly\" to allow running codes without being\n+ * interrupted by `Thread.interrupt()`. If `Thread.interrupt()` is called during runUninterruptibly\n+ * is running, it won't set the interrupted status. Instead, setting the interrupted status will be\n+ * deferred until it's returning from \"runUninterruptibly\".\n+ *\n+ * Note: this method should be called only in `this` thread.\n+ */\n+private[spark] class UninterruptibleThread(name: String) extends Thread(name) {\n+\n+  /** A monitor to protect \"uninterruptible\" and \"interrupted\" */\n+  private val uninterruptibleLock = new Object\n+\n+  /**\n+   * Indicates if `this`  thread are in the uninterruptible status. If so, interrupting\n+   * \"this\" will be deferred until `this`  enters into the interruptible status.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var uninterruptible = false\n+\n+  /**\n+   * Indicates if we should interrupt `this` when we are leaving the uninterruptible zone.\n+   */\n+  @GuardedBy(\"uninterruptibleLock\")\n+  private var shouldInterruptThread = false\n+\n+  /**\n+   * Run `f` uninterruptibly in `this` thread. The thread won't be interrupted before returning\n+   * from `f`.\n+   *\n+   * Note: this method should be called only in `this` thread.\n+   */\n+  def runUninterruptibly[T](f: => T): T = {\n+    if (Thread.currentThread() != this) {\n+      throw new IllegalStateException(s\"Call runUninterruptibly in a wrong thread. \" +\n+        s\"Expected: $this but was ${Thread.currentThread()}\")\n+    }\n+",
    "line": 62
  }],
  "prId": 11971
}]