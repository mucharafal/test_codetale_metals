[{
  "comments": [{
    "author": {
      "login": "mccheah"
    },
    "body": "Part of the reason why boxing is okay is because SizeEstimator doesn't actually use CastedArray.get() on primitive arrays. If it gets a primitive array, size estimation just multiplies the size of the array by the size of the primitive type. So we don't ever invoke get() in those situations.\n\nNevertheless, boxing looks ugly and I'm welcome to suggestions on better ways to do this.\n",
    "commit": "8527852ef1eba96298a5809ad192b32ed6f08217",
    "createdAt": "2015-03-12T04:11:46Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.util\n+\n+/**\n+ * Provides a wrapper around an object that is known to be an array, but the specific\n+ * type for the array is unknown.\n+ *\n+ * Normally, in situations when such an array is to be accessed reflectively, one would use\n+ * {@link java.lang.reflect.Array} using getLength() and get() methods. However, it turns\n+ * out that such methods are ill-performant.\n+ *\n+ * It turns out it is better to just use instanceOf and lots of casting over calling through\n+ * to the native C implementation. There is some discussion and a sample code snippet in\n+ * <a href=https://bugs.openjdk.java.net/browse/JDK-8051447>an open JDK ticket</a>. In this\n+ * class, that approach is implemented in an alternative way: creating a wrapper object to\n+ * wrap the array allows the cast to be done once, so the overhead of casting multiple times\n+ * is also avoided. It turns out we invoke the get() method to get the value of the array\n+ * numerous times, so doing the cast just once is worth the cost of constructing the wrapper\n+ * object for larger arrays.\n+ */\n+sealed trait CastedArray extends Any {\n+  def get(i: Int): AnyRef\n+  def getLength(): Int\n+}\n+\n+object CastedArray {\n+  def castAndWrap(arr: AnyRef): CastedArray = {\n+    if (arr.isInstanceOf[Array[Boolean]]) {\n+      return new BooleanCastedArray(arr.asInstanceOf[Array[Boolean]])\n+    } else if (arr.isInstanceOf[Array[Byte]]) {\n+      return new ByteCastedArray(arr.asInstanceOf[Array[Byte]])\n+    } else if (arr.isInstanceOf[Array[Char]]) {\n+      return new CharCastedArray(arr.asInstanceOf[Array[Char]])\n+    } else if (arr.isInstanceOf[Array[Double]]) {\n+      return new DoubleCastedArray(arr.asInstanceOf[Array[Double]])\n+    } else if (arr.isInstanceOf[Array[Float]]) {\n+      return new FloatCastedArray(arr.asInstanceOf[Array[Float]])\n+    } else if (arr.isInstanceOf[Array[Int]]) {\n+      return new IntCastedArray(arr.asInstanceOf[Array[Int]])\n+    } else if (arr.isInstanceOf[Array[Long]]) {\n+      return new LongCastedArray(arr.asInstanceOf[Array[Long]])\n+    } else if (arr.isInstanceOf[Array[Object]]) {\n+      return new ObjectCastedArray(arr.asInstanceOf[Array[Object]])\n+    } else if (arr.isInstanceOf[Array[Short]]) {\n+      return new ShortCastedArray(arr.asInstanceOf[Array[Short]])\n+    } else {\n+      throw createBadArrayException(arr)\n+    }\n+  }\n+\n+  // Boxing is not ideal, but we want to return AnyRef here. An alternative implementation\n+  // that used Java wouldn't force explicitly boxing... but returning Object there would\n+  // make the boxing happen implicitly anyways. In practice this tends to be okay\n+  // in terms of performance.\n+  private class BooleanCastedArray(val arr: Array[Boolean]) extends AnyVal with CastedArray {\n+    override def get(i: Int): AnyRef = Boolean.box(arr(i))"
  }],
  "prId": 4972
}]