[{
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "why interpolate ? simply pick one.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T04:13:40Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "jinxing64"
    },
    "body": "I think average value is the definition of 'median' when there are even numbers. Maybe it's better to keep it as `(minHeap.head + maxHeap.head) / 2.0` ?",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T05:00:06Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "I prefer actual values and not synthetic.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T06:52:15Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "kayousterhout"
    },
    "body": "@mridulm it seems like we should be using the traditional definition of the median here, as and not what you would prefer that the definition of the median was!",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T20:00:43Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "You are right, the strict definition requires us to average - it just makes\r\nit difficult to reason based on logs at times when the duration mentioned\r\ndoes not exist when there are discontinuities :-)\r\n(currently, it is simple 2/3 * threshold if we want to narrow down spec\r\nexec task triggers)",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T20:32:01Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "kayousterhout"
    },
    "body": "How about adding a debug log message in the TSM for when speculation is triggered that lists the threshold time and all completed task times to make this easier to reason about?",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T20:35:32Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "Wont that not be very verbose for large number of tasks ?\r\nI have rarely had to debug spec exec - but when I had to, it was not easy !",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T20:43:07Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "kayousterhout"
    },
    "body": "So what are you proposing here?  I'm not convinced that the ability to map the task length threshold for speculation to a particular task (especially in a job with thousands of tasks) is useful enough to merit having a `median` function that returns something that's not technically the median.  I don't doubt that the speculation code path is easy to debug -- but it seems like there are better ways to improve the logging around that than to have an incorrect median implementation.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T20:51:39Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "I was proposing to keep the behavior consistent with what we had earlier - iirc we picked an actual duration right ?",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T20:58:14Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "On second thought, since MedianHeap is being modeled as a general data structure potentially reused (and not an impl detail in tsm), might be good to average and ensure consistency with definition. That might be less of a surprise in future use of api, compared to knowing that duration applied for speculative exec debugging is not exact.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-06T21:15:50Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  val maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  val minHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {\n+    if (isEmpty) {\n+      throw new NoSuchElementException(\"MedianHeap is empty.\")\n+    }\n+    if (minHeap.size == maxHeap.size) {\n+      (minHeap.head + maxHeap.head) / 2.0"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "can't this just be `ord` instead of `implicitly[Ordering[Double]]`?  that would be simpler",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-13T19:34:21Z",
    "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  private[this] var maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "same here, `ord.reverse`.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-13T19:34:32Z",
    "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  private[this] var maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  private[this] var minHeap = mutable.PriorityQueue.empty[Double](\n+    implicitly[Ordering[Double]].reverse)"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "since we're not using `remove` anymore, can you get rid of this method? (and the test?)  The code may be fine, but its certainly somewhat confusing, would rather avoid thinking about it if I can ... :)",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-13T19:41:10Z",
    "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  private[this] var maxHeap = mutable.PriorityQueue.empty[Double](implicitly[Ordering[Double]])\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  private[this] var minHeap = mutable.PriorityQueue.empty[Double](\n+    implicitly[Ordering[Double]].reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Remove an number from MedianHeap, return if the number exists.\n+  def remove(x: Double): Boolean = {"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "nit: I think `private[spark]` will fit on the same line.\r\n\r\nAlso can you update the doc to mention that insertion is `O(log n)`",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-13T19:48:06Z",
    "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap stores numbers and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark]\n+class MedianHeap(implicit val ord: Ordering[Double]) {"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "Can you change this first line to something like:\r\n\r\nMedianHeap is designed to be used to quickly track the median of a group of numbers that may contain duplicates.  Inserting a new number has O(log n) time complexity and determining the median has O(1) time complexity.\r\n(newline)\r\n\r\nand then have the more detailed implementation description.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-15T17:46:22Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap inserts number by O(log n) and returns the median by O(1) time complexity."
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "how about calling this `smallerHalf` and calling the other one `largerHalf`? I think that would make the other code slightly easier to read (otherwise it's confusing that \"minHeap\" actually refers to the larger half of the numbers)",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-15T17:48:46Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap inserts number by O(log n) and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark] class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  private[this] var maxHeap = mutable.PriorityQueue.empty[Double](ord)"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "can you just call this median, and declare it without parents (since it doesn't modify internal state)?  I think that helps make it more obvious that this method is very inexpensive ",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-15T17:50:46Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable\n+\n+/**\n+ * MedianHeap inserts number by O(log n) and returns the median by O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a maxHeap and a minHeap. The maxHeap stores\n+ * the smaller half of all numbers while the minHeap stores the larger half.  The sizes\n+ * of two heaps need to be balanced each time when a new number is inserted so that their\n+ * sizes will not be different by more than 1. Therefore each time when findMedian() is\n+ * called we check if two heaps have the same size. If they do, we should return the\n+ * average of the two top values of heaps. Otherwise we return the top of the heap which\n+ * has one more element.\n+ */\n+\n+private[spark] class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a maxHeap,\n+  // i.e median is the maximum, at the root\n+  private[this] var maxHeap = mutable.PriorityQueue.empty[Double](ord)\n+\n+  // Stores all the numbers greater than the current median in a minHeap,\n+  // i.e median is the minimum, at the root\n+  private[this] var minHeap = mutable.PriorityQueue.empty[Double](ord.reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    maxHeap.isEmpty && minHeap.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    maxHeap.size + minHeap.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the minHeap.\n+    if (isEmpty) {\n+      minHeap.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into minHeap,\n+      // otherwise maxHeap.\n+      if (x > findMedian) {\n+        minHeap.enqueue(x)\n+      } else {\n+        maxHeap.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (minHeap.size - maxHeap.size > 1) {\n+      maxHeap.enqueue(minHeap.dequeue())\n+    }\n+    if (maxHeap.size - minHeap.size > 1) {\n+      minHeap.enqueue(maxHeap.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def findMedian(): Double = {"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "import PriorityQueue directly",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-15T17:52:15Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "very minor -- could you make this comment a doc with `/**`?  Even though its private, I find that helpful as that is useful in IDEs where they'll show this text w/ a hover on a reference",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-20T04:25:44Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable.PriorityQueue\n+\n+/**\n+ * MedianHeap is designed to be used to quickly track the median of a group of numbers\n+ * that may contain duplicates. Inserting a new number has O(log n) time complexity and\n+ * determining the median has O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a smallerHalf and a largerHalf. The smallerHalf\n+ * stores the smaller half of all numbers while the largerHalf stores the larger half.\n+ * The sizes of two heaps need to be balanced each time when a new number is inserted so\n+ * that their sizes will not be different by more than 1. Therefore each time when\n+ * findMedian() is called we check if two heaps have the same size. If they do, we should\n+ * return the average of the two top values of heaps. Otherwise we return the top of the\n+ * heap which has one more element.\n+ */\n+\n+private[spark] class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a smallerHalf,\n+  // i.e median is the maximum, at the root\n+  private[this] var smallerHalf = PriorityQueue.empty[Double](ord)"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "nit: delete this blank line",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-20T04:25:58Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable.PriorityQueue\n+\n+/**\n+ * MedianHeap is designed to be used to quickly track the median of a group of numbers\n+ * that may contain duplicates. Inserting a new number has O(log n) time complexity and\n+ * determining the median has O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a smallerHalf and a largerHalf. The smallerHalf\n+ * stores the smaller half of all numbers while the largerHalf stores the larger half.\n+ * The sizes of two heaps need to be balanced each time when a new number is inserted so\n+ * that their sizes will not be different by more than 1. Therefore each time when\n+ * findMedian() is called we check if two heaps have the same size. If they do, we should\n+ * return the average of the two top values of heaps. Otherwise we return the top of the\n+ * heap which has one more element.\n+ */\n+"
  }],
  "prId": 16867
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "minor: I find comments which basically just restate the method name to be pretty pointless.  I'd only include them if they add something else, eg. preconditions, or complexity, etc.  Mostly I'd say they're not necessary for any of the methods here.",
    "commit": "b9bdf443d8fc8124fc5b8e30f471fe8b0067264f",
    "createdAt": "2017-03-20T04:29:06Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.collection.mutable.PriorityQueue\n+\n+/**\n+ * MedianHeap is designed to be used to quickly track the median of a group of numbers\n+ * that may contain duplicates. Inserting a new number has O(log n) time complexity and\n+ * determining the median has O(1) time complexity.\n+ * The basic idea is to maintain two heaps: a smallerHalf and a largerHalf. The smallerHalf\n+ * stores the smaller half of all numbers while the largerHalf stores the larger half.\n+ * The sizes of two heaps need to be balanced each time when a new number is inserted so\n+ * that their sizes will not be different by more than 1. Therefore each time when\n+ * findMedian() is called we check if two heaps have the same size. If they do, we should\n+ * return the average of the two top values of heaps. Otherwise we return the top of the\n+ * heap which has one more element.\n+ */\n+\n+private[spark] class MedianHeap(implicit val ord: Ordering[Double]) {\n+\n+  // Stores all the numbers less than the current median in a smallerHalf,\n+  // i.e median is the maximum, at the root\n+  private[this] var smallerHalf = PriorityQueue.empty[Double](ord)\n+\n+  // Stores all the numbers greater than the current median in a largerHalf,\n+  // i.e median is the minimum, at the root\n+  private[this] var largerHalf = PriorityQueue.empty[Double](ord.reverse)\n+\n+  // Returns if there is no element in MedianHeap.\n+  def isEmpty(): Boolean = {\n+    smallerHalf.isEmpty && largerHalf.isEmpty\n+  }\n+\n+  // Size of MedianHeap.\n+  def size(): Int = {\n+    smallerHalf.size + largerHalf.size\n+  }\n+\n+  // Insert a new number into MedianHeap.\n+  def insert(x: Double): Unit = {\n+    // If both heaps are empty, we arbitrarily insert it into a heap, let's say, the largerHalf.\n+    if (isEmpty) {\n+      largerHalf.enqueue(x)\n+    } else {\n+      // If the number is larger than current median, it should be inserted into largerHalf,\n+      // otherwise smallerHalf.\n+      if (x > median) {\n+        largerHalf.enqueue(x)\n+      } else {\n+        smallerHalf.enqueue(x)\n+      }\n+    }\n+    rebalance()\n+  }\n+\n+  // Re-balance the heaps.\n+  private[this] def rebalance(): Unit = {\n+    if (largerHalf.size - smallerHalf.size > 1) {\n+      smallerHalf.enqueue(largerHalf.dequeue())\n+    }\n+    if (smallerHalf.size - largerHalf.size > 1) {\n+      largerHalf.enqueue(smallerHalf.dequeue)\n+    }\n+  }\n+\n+  // Returns the median of the numbers.\n+  def median: Double = {"
  }],
  "prId": 16867
}]