[{
  "comments": [{
    "author": {
      "login": "bOOm-X"
    },
    "body": "Why not keeping the option in the collection instead of putting null ? ",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-01T10:54:03Z",
    "diffHunk": "@@ -23,29 +23,41 @@ import scala.collection.JavaConverters._\n import scala.reflect.ClassTag\n import scala.util.control.NonFatal\n \n+import com.codahale.metrics.Timer\n+\n import org.apache.spark.internal.Logging\n \n /**\n  * An event bus which posts events to its listeners.\n  */\n private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n \n+  private[this] val listenersPlusTimers = new CopyOnWriteArrayList[(L, Timer)]\n+\n   // Marked `private[spark]` for access in tests.\n-  private[spark] val listeners = new CopyOnWriteArrayList[L]\n+  private[spark] def listeners = listenersPlusTimers.asScala.map(_._1).asJava\n+\n+  /**\n+   * Returns a CodaHale metrics Timer for measuring the listener's event processing time.\n+   * This method is intended to be overridden by subclasses.\n+   */\n+  protected def createTimer(listener: L): Option[Timer] = None\n \n   /**\n    * Add a listener to listen events. This method is thread-safe and can be called in any thread.\n    */\n   final def addListener(listener: L): Unit = {\n-    listeners.add(listener)\n+    listenersPlusTimers.add((listener, createTimer(listener).orNull))"
  }],
  "prId": 18083
}, {
  "comments": [{
    "author": {
      "login": "bOOm-X"
    },
    "body": "With an option (instead of null value) it would be much simpler",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-01T10:54:54Z",
    "diffHunk": "@@ -56,14 +68,25 @@ private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n     // JavaConverters can create a JIterableWrapper if we use asScala.\n     // However, this method will be called frequently. To avoid the wrapper cost, here we use\n     // Java Iterator directly.\n-    val iter = listeners.iterator\n+    val iter = listenersPlusTimers.iterator\n     while (iter.hasNext) {\n-      val listener = iter.next()\n+      val listenerAndMaybeTimer = iter.next()\n+      val listener = listenerAndMaybeTimer._1\n+      val maybeTimer = listenerAndMaybeTimer._2\n+      var maybeTimerContext = if (maybeTimer != null) {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Yeah, this is just premature optimization. I'll undo.",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-05T19:58:22Z",
    "diffHunk": "@@ -56,14 +68,25 @@ private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n     // JavaConverters can create a JIterableWrapper if we use asScala.\n     // However, this method will be called frequently. To avoid the wrapper cost, here we use\n     // Java Iterator directly.\n-    val iter = listeners.iterator\n+    val iter = listenersPlusTimers.iterator\n     while (iter.hasNext) {\n-      val listener = iter.next()\n+      val listenerAndMaybeTimer = iter.next()\n+      val listener = listenerAndMaybeTimer._1\n+      val maybeTimer = listenerAndMaybeTimer._2\n+      var maybeTimerContext = if (maybeTimer != null) {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Actually, there is a cost here: allocating a new Option on every `postToAll` is going to create more allocations and method calls. Thus I'm going to leave this unchanged.",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-05T20:11:12Z",
    "diffHunk": "@@ -56,14 +68,25 @@ private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n     // JavaConverters can create a JIterableWrapper if we use asScala.\n     // However, this method will be called frequently. To avoid the wrapper cost, here we use\n     // Java Iterator directly.\n-    val iter = listeners.iterator\n+    val iter = listenersPlusTimers.iterator\n     while (iter.hasNext) {\n-      val listener = iter.next()\n+      val listenerAndMaybeTimer = iter.next()\n+      val listener = listenerAndMaybeTimer._1\n+      val maybeTimer = listenerAndMaybeTimer._2\n+      var maybeTimerContext = if (maybeTimer != null) {"
  }, {
    "author": {
      "login": "bOOm-X"
    },
    "body": "Indeed ! But you can put the option in the collection listenersPlusTimers (instead of doing a orNull when you create the timer) and so you can use it without having to recreate one each time in the postToAll method ",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-07T13:10:34Z",
    "diffHunk": "@@ -56,14 +68,25 @@ private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n     // JavaConverters can create a JIterableWrapper if we use asScala.\n     // However, this method will be called frequently. To avoid the wrapper cost, here we use\n     // Java Iterator directly.\n-    val iter = listeners.iterator\n+    val iter = listenersPlusTimers.iterator\n     while (iter.hasNext) {\n-      val listener = iter.next()\n+      val listenerAndMaybeTimer = iter.next()\n+      val listener = listenerAndMaybeTimer._1\n+      val maybeTimer = listenerAndMaybeTimer._2\n+      var maybeTimerContext = if (maybeTimer != null) {"
  }],
  "prId": 18083
}, {
  "comments": [{
    "author": {
      "login": "bOOm-X"
    },
    "body": "Same. simpler with an option",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-01T10:55:15Z",
    "diffHunk": "@@ -56,14 +68,25 @@ private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n     // JavaConverters can create a JIterableWrapper if we use asScala.\n     // However, this method will be called frequently. To avoid the wrapper cost, here we use\n     // Java Iterator directly.\n-    val iter = listeners.iterator\n+    val iter = listenersPlusTimers.iterator\n     while (iter.hasNext) {\n-      val listener = iter.next()\n+      val listenerAndMaybeTimer = iter.next()\n+      val listener = listenerAndMaybeTimer._1\n+      val maybeTimer = listenerAndMaybeTimer._2\n+      var maybeTimerContext = if (maybeTimer != null) {\n+        maybeTimer.time()\n+      } else {\n+        null\n+      }\n       try {\n         doPostEvent(listener, event)\n       } catch {\n         case NonFatal(e) =>\n           logError(s\"Listener ${Utils.getFormattedClassName(listener)} threw an exception\", e)\n+      } finally {\n+        if (maybeTimerContext != null) {",
    "line": 67
  }],
  "prId": 18083
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we use `Option[Timmer]` as value type?",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-08T19:03:31Z",
    "diffHunk": "@@ -23,29 +23,41 @@ import scala.collection.JavaConverters._\n import scala.reflect.ClassTag\n import scala.util.control.NonFatal\n \n+import com.codahale.metrics.Timer\n+\n import org.apache.spark.internal.Logging\n \n /**\n  * An event bus which posts events to its listeners.\n  */\n private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n \n+  private[this] val listenersPlusTimers = new CopyOnWriteArrayList[(L, Timer)]"
  }],
  "prId": 18083
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "since this is a `CopyOnWriteArrayList`, shall we just do a filter and create a new array?",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-08T19:07:39Z",
    "diffHunk": "@@ -23,29 +23,41 @@ import scala.collection.JavaConverters._\n import scala.reflect.ClassTag\n import scala.util.control.NonFatal\n \n+import com.codahale.metrics.Timer\n+\n import org.apache.spark.internal.Logging\n \n /**\n  * An event bus which posts events to its listeners.\n  */\n private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n \n+  private[this] val listenersPlusTimers = new CopyOnWriteArrayList[(L, Timer)]\n+\n   // Marked `private[spark]` for access in tests.\n-  private[spark] val listeners = new CopyOnWriteArrayList[L]\n+  private[spark] def listeners = listenersPlusTimers.asScala.map(_._1).asJava\n+\n+  /**\n+   * Returns a CodaHale metrics Timer for measuring the listener's event processing time.\n+   * This method is intended to be overridden by subclasses.\n+   */\n+  protected def getTimer(listener: L): Option[Timer] = None\n \n   /**\n    * Add a listener to listen events. This method is thread-safe and can be called in any thread.\n    */\n   final def addListener(listener: L): Unit = {\n-    listeners.add(listener)\n+    listenersPlusTimers.add((listener, getTimer(listener).orNull))\n   }\n \n   /**\n    * Remove a listener and it won't receive any events. This method is thread-safe and can be called\n    * in any thread.\n    */\n   final def removeListener(listener: L): Unit = {\n-    listeners.remove(listener)\n+    listenersPlusTimers.asScala.find(_._1 eq listener).foreach { listenerAndTimer =>\n+      listenersPlusTimers.remove(listenerAndTimer)",
    "line": 40
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "I think the only reason that `CopyOnWriteArrayList` was used was for thread-safety and fast performance for readers interleaved with very rare mutations / writes. If we were to replace the array list then we'd need to add a `synchronized` to guard the `listenersPlusTimers` field itself.\r\n\r\nGiven the workload and access patterns here, I'm not sure that it's worth it to attempt to optimize this `removeListener()` method any further.",
    "commit": "76b669ca6eb35a0cce4291702baa5d1f60adb467",
    "createdAt": "2017-06-08T21:09:53Z",
    "diffHunk": "@@ -23,29 +23,41 @@ import scala.collection.JavaConverters._\n import scala.reflect.ClassTag\n import scala.util.control.NonFatal\n \n+import com.codahale.metrics.Timer\n+\n import org.apache.spark.internal.Logging\n \n /**\n  * An event bus which posts events to its listeners.\n  */\n private[spark] trait ListenerBus[L <: AnyRef, E] extends Logging {\n \n+  private[this] val listenersPlusTimers = new CopyOnWriteArrayList[(L, Timer)]\n+\n   // Marked `private[spark]` for access in tests.\n-  private[spark] val listeners = new CopyOnWriteArrayList[L]\n+  private[spark] def listeners = listenersPlusTimers.asScala.map(_._1).asJava\n+\n+  /**\n+   * Returns a CodaHale metrics Timer for measuring the listener's event processing time.\n+   * This method is intended to be overridden by subclasses.\n+   */\n+  protected def getTimer(listener: L): Option[Timer] = None\n \n   /**\n    * Add a listener to listen events. This method is thread-safe and can be called in any thread.\n    */\n   final def addListener(listener: L): Unit = {\n-    listeners.add(listener)\n+    listenersPlusTimers.add((listener, getTimer(listener).orNull))\n   }\n \n   /**\n    * Remove a listener and it won't receive any events. This method is thread-safe and can be called\n    * in any thread.\n    */\n   final def removeListener(listener: L): Unit = {\n-    listeners.remove(listener)\n+    listenersPlusTimers.asScala.find(_._1 eq listener).foreach { listenerAndTimer =>\n+      listenersPlusTimers.remove(listenerAndTimer)",
    "line": 40
  }],
  "prId": 18083
}]