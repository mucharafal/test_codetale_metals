[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This still entails a copy, right? I don't see that this improves the situation by itself.\n",
    "commit": "1746223744a9eb7d9808d749d0891aa3e37ead59",
    "createdAt": "2014-04-12T08:53:09Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.io\n+\n+import java.io.OutputStream\n+\n+/**\n+ * A simple, fast byte-array output stream that exposes the backing array,\n+ * inspired by fastutil's FastByteArrayOutputStream.\n+ *\n+ * [[java.io.ByteArrayOutputStream]] is nice, but to get its content you\n+ * must generate each time a new object. This doesn't happen here.\n+ *\n+ * This class will automatically enlarge the backing array, doubling its\n+ * size whenever new space is needed.\n+ */\n+private[spark] class FastByteArrayOutputStream(initialCapacity: Int = 16) extends OutputStream {\n+\n+  private[this] var _array = new Array[Byte](initialCapacity)\n+\n+  /** The current writing position. */\n+  private[this] var _position: Int = 0\n+\n+  /** The array backing the output stream. */\n+  def array: Array[Byte] = _array\n+\n+  /** The number of valid bytes in array. */\n+  def length: Int = _position\n+\n+  override def write(b: Int): Unit = {\n+    if (_position >= _array.length ) {\n+      _array = FastByteArrayOutputStream.growArray(_array, _position + 1, _position)\n+    }\n+    _array(_position) = b.toByte\n+    _position += 1\n+  }\n+\n+  override def write(b: Array[Byte], off: Int, len: Int) {\n+    if (off < 0) {\n+      throw new ArrayIndexOutOfBoundsException(s\"Offset ($off) is negative\" )\n+    }\n+    if (len < 0) {\n+      throw new IllegalArgumentException(s\"Length ($len) is negative\" )\n+    }\n+    if (off + len > b.length) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        s\"Last index (${off+len}) is greater than array length (${b.length})\")\n+    }\n+    if ( _position + len > _array.length ) {\n+      _array = FastByteArrayOutputStream.growArray(_array, _position + len, _position)\n+    }\n+    System.arraycopy(b, off, _array, _position, len)\n+    _position += len\n+  }\n+\n+  /** Ensures that the length of the backing array is equal to [[length]]. */\n+  def trim(): this.type = {\n+    if (_position < _array.length) {\n+      val newArr = new Array[Byte](_position)"
  }],
  "prId": 397
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "We probably don't need this method, as it eliminates the whole purpose of this stream. You might as well use ByteArrayOutputStream if you need trim().\n",
    "commit": "1746223744a9eb7d9808d749d0891aa3e37ead59",
    "createdAt": "2014-04-13T21:25:02Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.io\n+\n+import java.io.OutputStream\n+import java.nio.ByteBuffer\n+\n+/**\n+ * A simple, fast byte-array output stream that exposes the backing array,\n+ * inspired by fastutil's FastByteArrayOutputStream.\n+ *\n+ * [[java.io.ByteArrayOutputStream]] is nice, but to get its content you\n+ * must generate each time a new object. This doesn't happen here.\n+ *\n+ * This class will automatically enlarge the backing array, doubling its\n+ * size whenever new space is needed.\n+ */\n+private[spark] class FastByteArrayOutputStream(initialCapacity: Int = 16) extends OutputStream {\n+\n+  private[this] var _array = new Array[Byte](initialCapacity)\n+\n+  /** The current writing position. */\n+  private[this] var _position: Int = 0\n+\n+  /** The number of valid bytes in array. */\n+  def length: Int = _position\n+\n+  override def write(b: Int): Unit = {\n+    if (_position >= _array.length ) {\n+      _array = FastByteArrayOutputStream.growArray(_array, _position + 1, _position)\n+    }\n+    _array(_position) = b.toByte\n+    _position += 1\n+  }\n+\n+  override def write(b: Array[Byte], off: Int, len: Int) {\n+    if (off < 0) {\n+      throw new ArrayIndexOutOfBoundsException(s\"Offset ($off) is negative\" )\n+    }\n+    if (len < 0) {\n+      throw new IllegalArgumentException(s\"Length ($len) is negative\" )\n+    }\n+    if (off + len > b.length) {\n+      throw new ArrayIndexOutOfBoundsException(\n+        s\"Last index (${off + len}) is greater than array length (${b.length})\")\n+    }\n+    if ( _position + len > _array.length ) {\n+      _array = FastByteArrayOutputStream.growArray(_array, _position + len, _position)\n+    }\n+    System.arraycopy(b, off, _array, _position, len)\n+    _position += len\n+  }\n+\n+  /** Return a ByteBuffer wrapping around the filled content of the underlying array. */\n+  def toByteBuffer: ByteBuffer = {\n+    ByteBuffer.wrap(_array, 0, _position)\n+  }\n+\n+  /**\n+   * Return a tuple, where the first element is the underlying array, and the second element\n+   * is the length of the filled content.\n+   */\n+  def toArray: (Array[Byte], Int) = (_array, _position)\n+\n+  /** Ensures that the length of the backing array is equal to [[length]]. */\n+  def trim(): this.type = {"
  }],
  "prId": 397
}]