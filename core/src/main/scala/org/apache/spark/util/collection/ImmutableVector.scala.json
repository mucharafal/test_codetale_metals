[{
  "comments": [{
    "author": {
      "login": "concretevitamin"
    },
    "body": "minor nit: add \"s\", same for the line above\n",
    "commit": "02a9bde62102facfd5f9146039a2d68cdc0f180b",
    "createdAt": "2014-07-06T22:42:20Z",
    "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.reflect.ClassTag\n+\n+/**\n+ * An immutable vector that supports efficient point updates. Similarly to\n+ * scala.collection.immutable.Vector, it is implemented using a 32-ary tree with 32-element arrays\n+ * at the leaves. Unlike Scala's Vector, it is specialized on the value type, making it much more\n+ * memory-efficient for primitive values.\n+ */\n+private[spark] class ImmutableVector[@specialized(Long, Int) A](val size: Int, root: VectorNode[A])\n+  extends Serializable {\n+\n+  def iterator: Iterator[A] = new VectorIterator[A](root)\n+  def apply(index: Int): A = root(index)\n+  def updated(index: Int, elem: A): ImmutableVector[A] =\n+    new ImmutableVector(size, root.updated(index, elem))\n+}\n+\n+private[spark] object ImmutableVector {\n+  def empty[A: ClassTag]: ImmutableVector[A] = new ImmutableVector(0, emptyNode)\n+\n+  def fromArray[A: ClassTag](array: Array[A]): ImmutableVector[A] = {\n+    fromArray(array, 0, array.length)\n+  }\n+\n+  def fromArray[A: ClassTag](array: Array[A], start: Int, end: Int): ImmutableVector[A] = {\n+    new ImmutableVector(end - start, nodeFromArray(array, start, end))\n+  }\n+\n+  def fill[A: ClassTag](n: Int)(a: A): ImmutableVector[A] = {\n+    // TODO: Implement this without allocating an extra array\n+    fromArray(Array.fill(n)(a), 0, n)\n+  }\n+\n+  /** Returns the root of a 32-ary tree representing the specified interval into the array. */\n+  private def nodeFromArray[A: ClassTag](array: Array[A], start: Int, end: Int): VectorNode[A] = {\n+    val length = end - start\n+    if (length == 0) {\n+      emptyNode\n+    } else {\n+      val depth = depthOf(length)\n+      if (depth == 0) {\n+        new LeafNode(array.slice(start, end))\n+      } else {\n+        val shift = 5 * depth\n+        val numChildren = ((length - 1) >> shift) + 1\n+        val children = new Array[VectorNode[A]](numChildren)\n+        var i = 0\n+        while (i < numChildren) {\n+          val childStart = start + (i << shift)\n+          var childEnd = start + ((i + 1) << shift)\n+          if (end < childEnd) {\n+            childEnd = end\n+          }\n+          children(i) = nodeFromArray(array, childStart, childEnd)\n+          i += 1\n+        }\n+        new InternalNode(children, depth)\n+      }\n+    }\n+  }\n+\n+  private def emptyNode[A: ClassTag] = new LeafNode(Array.empty)\n+\n+  /** Returns the required tree depth for an ImmutableVector of the given size. */\n+  private def depthOf(size: Int): Int = {\n+    var depth = 0\n+    var sizeLeft = (size - 1) >> 5\n+    while (sizeLeft > 0) {\n+      sizeLeft >>= 5\n+      depth += 1\n+    }\n+    depth\n+  }\n+}\n+\n+/** Trait representing nodes in the vector tree. */\n+private sealed trait VectorNode[@specialized(Long, Int) A] extends Serializable {\n+  def apply(index: Int): A\n+  def updated(index: Int, elem: A): VectorNode[A]\n+  def numChildren: Int\n+}\n+\n+/** An internal node in the vector tree (one containing other nodes rather than vector elements). */\n+private class InternalNode[@specialized(Long, Int) A: ClassTag](\n+    children: Array[VectorNode[A]],\n+    val depth: Int)\n+  extends VectorNode[A] {\n+\n+  require(children.length > 0, \"InternalNode must have children\")\n+  require(children.length <= 32, \"nodes cannot have more than 32 children (got ${children.length})\")\n+  require(depth >= 1, \"InternalNode must have depth >= 1 (got $depth)\")"
  }],
  "prId": 1297
}, {
  "comments": [{
    "author": {
      "login": "concretevitamin"
    },
    "body": "nit: add \"s\"\n",
    "commit": "02a9bde62102facfd5f9146039a2d68cdc0f180b",
    "createdAt": "2014-07-06T22:43:05Z",
    "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.util.collection\n+\n+import scala.reflect.ClassTag\n+\n+/**\n+ * An immutable vector that supports efficient point updates. Similarly to\n+ * scala.collection.immutable.Vector, it is implemented using a 32-ary tree with 32-element arrays\n+ * at the leaves. Unlike Scala's Vector, it is specialized on the value type, making it much more\n+ * memory-efficient for primitive values.\n+ */\n+private[spark] class ImmutableVector[@specialized(Long, Int) A](val size: Int, root: VectorNode[A])\n+  extends Serializable {\n+\n+  def iterator: Iterator[A] = new VectorIterator[A](root)\n+  def apply(index: Int): A = root(index)\n+  def updated(index: Int, elem: A): ImmutableVector[A] =\n+    new ImmutableVector(size, root.updated(index, elem))\n+}\n+\n+private[spark] object ImmutableVector {\n+  def empty[A: ClassTag]: ImmutableVector[A] = new ImmutableVector(0, emptyNode)\n+\n+  def fromArray[A: ClassTag](array: Array[A]): ImmutableVector[A] = {\n+    fromArray(array, 0, array.length)\n+  }\n+\n+  def fromArray[A: ClassTag](array: Array[A], start: Int, end: Int): ImmutableVector[A] = {\n+    new ImmutableVector(end - start, nodeFromArray(array, start, end))\n+  }\n+\n+  def fill[A: ClassTag](n: Int)(a: A): ImmutableVector[A] = {\n+    // TODO: Implement this without allocating an extra array\n+    fromArray(Array.fill(n)(a), 0, n)\n+  }\n+\n+  /** Returns the root of a 32-ary tree representing the specified interval into the array. */\n+  private def nodeFromArray[A: ClassTag](array: Array[A], start: Int, end: Int): VectorNode[A] = {\n+    val length = end - start\n+    if (length == 0) {\n+      emptyNode\n+    } else {\n+      val depth = depthOf(length)\n+      if (depth == 0) {\n+        new LeafNode(array.slice(start, end))\n+      } else {\n+        val shift = 5 * depth\n+        val numChildren = ((length - 1) >> shift) + 1\n+        val children = new Array[VectorNode[A]](numChildren)\n+        var i = 0\n+        while (i < numChildren) {\n+          val childStart = start + (i << shift)\n+          var childEnd = start + ((i + 1) << shift)\n+          if (end < childEnd) {\n+            childEnd = end\n+          }\n+          children(i) = nodeFromArray(array, childStart, childEnd)\n+          i += 1\n+        }\n+        new InternalNode(children, depth)\n+      }\n+    }\n+  }\n+\n+  private def emptyNode[A: ClassTag] = new LeafNode(Array.empty)\n+\n+  /** Returns the required tree depth for an ImmutableVector of the given size. */\n+  private def depthOf(size: Int): Int = {\n+    var depth = 0\n+    var sizeLeft = (size - 1) >> 5\n+    while (sizeLeft > 0) {\n+      sizeLeft >>= 5\n+      depth += 1\n+    }\n+    depth\n+  }\n+}\n+\n+/** Trait representing nodes in the vector tree. */\n+private sealed trait VectorNode[@specialized(Long, Int) A] extends Serializable {\n+  def apply(index: Int): A\n+  def updated(index: Int, elem: A): VectorNode[A]\n+  def numChildren: Int\n+}\n+\n+/** An internal node in the vector tree (one containing other nodes rather than vector elements). */\n+private class InternalNode[@specialized(Long, Int) A: ClassTag](\n+    children: Array[VectorNode[A]],\n+    val depth: Int)\n+  extends VectorNode[A] {\n+\n+  require(children.length > 0, \"InternalNode must have children\")\n+  require(children.length <= 32, \"nodes cannot have more than 32 children (got ${children.length})\")\n+  require(depth >= 1, \"InternalNode must have depth >= 1 (got $depth)\")\n+\n+  def childAt(index: Int): VectorNode[A] = children(index)\n+\n+  override def apply(index: Int): A = {\n+    var cur: VectorNode[A] = this\n+    var continue: Boolean = true\n+    var result: A = null.asInstanceOf[A]\n+    while (continue) {\n+      cur match {\n+        case internal: InternalNode[A] =>\n+          val shift = 5 * internal.depth\n+          val localIndex = (index >> shift) & 31\n+          cur = internal.childAt(localIndex)\n+        case leaf: LeafNode[A] =>\n+          continue = false\n+          result = leaf(index & 31)\n+      }\n+    }\n+    result\n+  }\n+\n+  override def updated(index: Int, elem: A) = {\n+    val shift = 5 * depth\n+    val localIndex = (index >> shift) & 31\n+    val childIndex = index & ~(31 << shift)\n+\n+    val newChildren = new Array[VectorNode[A]](children.length)\n+    System.arraycopy(children, 0, newChildren, 0, children.length)\n+    newChildren(localIndex) = children(localIndex).updated(childIndex, elem)\n+    new InternalNode(newChildren, depth)\n+  }\n+\n+  override def numChildren = children.length\n+}\n+\n+/** A leaf node in the vector tree containing up to 32 vector elements. */\n+private class LeafNode[@specialized(Long, Int) A: ClassTag](\n+    children: Array[A])\n+  extends VectorNode[A] {\n+\n+  require(children.length <= 32, \"nodes cannot have more than 32 children (got ${children.length})\")"
  }],
  "prId": 1297
}]