[{
  "comments": [{
    "author": {
      "login": "dcapwell"
    },
    "body": "Should be able to use `Epoll.isAvailable` rather than relying on the function to fail.\n",
    "commit": "f9214216fe33e365375a071e522cc915be8acd67",
    "createdAt": "2014-08-12T18:51:29Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.net.InetSocketAddress\n+import java.util.concurrent.TimeoutException\n+\n+import io.netty.bootstrap.Bootstrap\n+import io.netty.buffer.{ByteBuf, PooledByteBufAllocator}\n+import io.netty.channel.socket.SocketChannel\n+import io.netty.channel._\n+import io.netty.channel.epoll.{EpollEventLoopGroup, EpollSocketChannel}\n+import io.netty.channel.nio.NioEventLoopGroup\n+import io.netty.channel.oio.OioEventLoopGroup\n+import io.netty.channel.socket.nio.NioSocketChannel\n+import io.netty.channel.socket.oio.OioSocketChannel\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder\n+import io.netty.handler.codec.string.StringEncoder\n+import io.netty.util.CharsetUtil\n+\n+import org.apache.spark.{Logging, SparkConf}\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Factory for creating [[BlockFetchingClient]] by using createClient. This factory reuses\n+ * the worker thread pool for Netty.\n+ *\n+ * Concurrency: It is possible to have multiple instances of this class, but we should only use\n+ * a single instance and use that to create multiple [[BlockFetchingClient]]s.\n+ */\n+class BlockFetchingClientFactory(conf: SparkConf) {\n+\n+  /** IO mode: nio, oio, epoll, or auto (try epoll first and then nio). */\n+  val ioMode = conf.get(\"spark.shuffle.io.mode\", \"auto\").toLowerCase\n+\n+  /** Connection timeout in secs. Default 60 secs. */\n+  val connectionTimeoutMs = conf.getInt(\"spark.shuffle.io.connectionTimeout\", 60) * 1000\n+\n+  /** A thread factory so the threads are named (for debugging). */\n+  val threadFactory = Utils.namedThreadFactory(\"spark-shuffle-client\")\n+\n+  /** The following two are instantiated by the [[init]] method, depending the [[ioMode]]. */\n+  var socketChannelClass: Class[_ <: Channel] = _\n+  var workerGroup: EventLoopGroup = _\n+\n+  init()\n+\n+  /** Initialize [[socketChannelClass]] and [[workerGroup]] based on the value of [[ioMode]]. */\n+  private def init(): Unit = {\n+    def initOio(): Unit = {\n+      socketChannelClass = classOf[OioSocketChannel]\n+      workerGroup = new OioEventLoopGroup(0, threadFactory)\n+    }\n+    def initNio(): Unit = {\n+      socketChannelClass = classOf[NioSocketChannel]\n+      workerGroup = new NioEventLoopGroup(0, threadFactory)\n+    }\n+    def initEpoll(): Unit = {\n+      socketChannelClass = classOf[EpollSocketChannel]\n+      workerGroup = new EpollEventLoopGroup(0, threadFactory)\n+    }\n+\n+    ioMode match {\n+      case \"nio\" => initNio()\n+      case \"oio\" => initOio()\n+      case \"epoll\" => initEpoll()\n+      case \"auto\" =>\n+        // For auto mode, first try epoll (only available on Linux), then nio.\n+        try {\n+          initEpoll()"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "That class is actually not available on the version of Netty we use (it was added in June I believe).\n",
    "commit": "f9214216fe33e365375a071e522cc915be8acd67",
    "createdAt": "2014-08-12T19:14:16Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.net.InetSocketAddress\n+import java.util.concurrent.TimeoutException\n+\n+import io.netty.bootstrap.Bootstrap\n+import io.netty.buffer.{ByteBuf, PooledByteBufAllocator}\n+import io.netty.channel.socket.SocketChannel\n+import io.netty.channel._\n+import io.netty.channel.epoll.{EpollEventLoopGroup, EpollSocketChannel}\n+import io.netty.channel.nio.NioEventLoopGroup\n+import io.netty.channel.oio.OioEventLoopGroup\n+import io.netty.channel.socket.nio.NioSocketChannel\n+import io.netty.channel.socket.oio.OioSocketChannel\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder\n+import io.netty.handler.codec.string.StringEncoder\n+import io.netty.util.CharsetUtil\n+\n+import org.apache.spark.{Logging, SparkConf}\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * Factory for creating [[BlockFetchingClient]] by using createClient. This factory reuses\n+ * the worker thread pool for Netty.\n+ *\n+ * Concurrency: It is possible to have multiple instances of this class, but we should only use\n+ * a single instance and use that to create multiple [[BlockFetchingClient]]s.\n+ */\n+class BlockFetchingClientFactory(conf: SparkConf) {\n+\n+  /** IO mode: nio, oio, epoll, or auto (try epoll first and then nio). */\n+  val ioMode = conf.get(\"spark.shuffle.io.mode\", \"auto\").toLowerCase\n+\n+  /** Connection timeout in secs. Default 60 secs. */\n+  val connectionTimeoutMs = conf.getInt(\"spark.shuffle.io.connectionTimeout\", 60) * 1000\n+\n+  /** A thread factory so the threads are named (for debugging). */\n+  val threadFactory = Utils.namedThreadFactory(\"spark-shuffle-client\")\n+\n+  /** The following two are instantiated by the [[init]] method, depending the [[ioMode]]. */\n+  var socketChannelClass: Class[_ <: Channel] = _\n+  var workerGroup: EventLoopGroup = _\n+\n+  init()\n+\n+  /** Initialize [[socketChannelClass]] and [[workerGroup]] based on the value of [[ioMode]]. */\n+  private def init(): Unit = {\n+    def initOio(): Unit = {\n+      socketChannelClass = classOf[OioSocketChannel]\n+      workerGroup = new OioEventLoopGroup(0, threadFactory)\n+    }\n+    def initNio(): Unit = {\n+      socketChannelClass = classOf[NioSocketChannel]\n+      workerGroup = new NioEventLoopGroup(0, threadFactory)\n+    }\n+    def initEpoll(): Unit = {\n+      socketChannelClass = classOf[EpollSocketChannel]\n+      workerGroup = new EpollEventLoopGroup(0, threadFactory)\n+    }\n+\n+    ioMode match {\n+      case \"nio\" => initNio()\n+      case \"oio\" => initOio()\n+      case \"epoll\" => initEpoll()\n+      case \"auto\" =>\n+        // For auto mode, first try epoll (only available on Linux), then nio.\n+        try {\n+          initEpoll()"
  }],
  "prId": 1907
}]