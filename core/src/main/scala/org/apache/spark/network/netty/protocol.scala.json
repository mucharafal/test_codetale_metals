[{
  "comments": [{
    "author": {
      "login": "colorant"
    },
    "body": "do we need to call data.retain() here?\n",
    "commit": "bdab2c74111c8bce382323f68732f87ca9b080a9",
    "createdAt": "2014-09-12T01:56:44Z",
    "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.util.{List => JList}\n+\n+import io.netty.buffer.ByteBuf\n+import io.netty.channel.ChannelHandlerContext\n+import io.netty.channel.ChannelHandler.Sharable\n+import io.netty.handler.codec._\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.{NettyManagedBuffer, ManagedBuffer}\n+\n+\n+/** Messages from the client to the server. */\n+sealed trait ClientRequest {\n+  def id: Byte\n+}\n+\n+/**\n+ * Request to fetch a sequence of blocks from the server. A single [[BlockFetchRequest]] can\n+ * correspond to multiple [[ServerResponse]]s.\n+ */\n+final case class BlockFetchRequest(blocks: Seq[String]) extends ClientRequest {\n+  override def id = 0\n+}\n+\n+/**\n+ * Request to upload a block to the server. Currently the server does not ack the upload request.\n+ */\n+final case class BlockUploadRequest(blockId: String, data: ManagedBuffer) extends ClientRequest {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 1\n+}\n+\n+\n+/** Messages from server to client (usually in response to some [[ClientRequest]]. */\n+sealed trait ServerResponse {\n+  def id: Byte\n+}\n+\n+/** Response to [[BlockFetchRequest]] when a block exists and has been successfully fetched. */\n+final case class BlockFetchSuccess(blockId: String, data: ManagedBuffer) extends ServerResponse {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 0\n+}\n+\n+/** Response to [[BlockFetchRequest]] when there is an error fetching the block. */\n+final case class BlockFetchFailure(blockId: String, error: String) extends ServerResponse {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 1\n+}\n+\n+\n+/**\n+ * Encoder for [[ClientRequest]] used in client side.\n+ *\n+ * This encoder is stateless so it is safe to be shared by multiple threads.\n+ */\n+@Sharable\n+final class ClientRequestEncoder extends MessageToMessageEncoder[ClientRequest] {\n+  override def encode(ctx: ChannelHandlerContext, in: ClientRequest, out: JList[Object]): Unit = {\n+    in match {\n+      case BlockFetchRequest(blocks) =>\n+        // 8 bytes: frame size\n+        // 1 byte: BlockFetchRequest vs BlockUploadRequest\n+        // 4 byte: num blocks\n+        // then for each block id write 1 byte for blockId.length and then blockId itself\n+        val frameLength = 8 + 1 + 4 + blocks.size + blocks.map(_.size).fold(0)(_ + _)\n+        val buf = ctx.alloc().buffer(frameLength)\n+\n+        buf.writeLong(frameLength)\n+        buf.writeByte(in.id)\n+        buf.writeInt(blocks.size)\n+        blocks.foreach { blockId =>\n+          ProtocolUtils.writeBlockId(buf, blockId)\n+        }\n+\n+        assert(buf.writableBytes() == 0)\n+        out.add(buf)\n+\n+      case BlockUploadRequest(blockId, data) =>\n+        // 8 bytes: frame size\n+        // 1 byte: msg id (BlockFetchRequest vs BlockUploadRequest)\n+        // 1 byte: blockId.length\n+        // data itself (length can be derived from: frame size - 1 - blockId.length)\n+        val headerLength = 8 + 1 + 1 + blockId.length\n+        val frameLength = headerLength + data.size\n+        val header = ctx.alloc().buffer(headerLength)\n+\n+        // Call this before we add header to out so in case of exceptions\n+        // we don't send anything at all.\n+        val body = data.convertToNetty()\n+\n+        header.writeLong(frameLength)\n+        header.writeByte(in.id)\n+        ProtocolUtils.writeBlockId(header, blockId)\n+\n+        assert(header.writableBytes() == 0)\n+        out.add(header)\n+        out.add(body)\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * Decoder in the server side to decode client requests.\n+ * This decoder is stateless so it is safe to be shared by multiple threads.\n+ *\n+ * This assumes the inbound messages have been processed by a frame decoder created by\n+ * [[ProtocolUtils.createFrameDecoder()]].\n+ */\n+@Sharable\n+final class ClientRequestDecoder extends MessageToMessageDecoder[ByteBuf] {\n+  override protected def decode(ctx: ChannelHandlerContext, in: ByteBuf, out: JList[AnyRef]): Unit =\n+  {\n+    val msgTypeId = in.readByte()\n+    val decoded = msgTypeId match {\n+      case 0 =>  // BlockFetchRequest\n+        val numBlocks = in.readInt()\n+        val blockIds = Seq.fill(numBlocks) { ProtocolUtils.readBlockId(in) }\n+        BlockFetchRequest(blockIds)\n+\n+      case 1 =>  // BlockUploadRequest\n+        val blockId = ProtocolUtils.readBlockId(in)\n+        in.retain()  // retain the bytebuf so we don't recycle it immediately.\n+        BlockUploadRequest(blockId, new NettyManagedBuffer(in))\n+    }\n+\n+    assert(decoded.id == msgTypeId)\n+    out.add(decoded)\n+  }\n+}\n+\n+\n+/**\n+ * Encoder used by the server side to encode server-to-client responses.\n+ * This encoder is stateless so it is safe to be shared by multiple threads.\n+ */\n+@Sharable\n+final class ServerResponseEncoder extends MessageToMessageEncoder[ServerResponse] with Logging {\n+  override def encode(ctx: ChannelHandlerContext, in: ServerResponse, out: JList[Object]): Unit = {\n+    in match {\n+      case BlockFetchSuccess(blockId, data) =>\n+        // Handle the body first so if we encounter an error getting the body, we can respond\n+        // with an error instead.\n+        var body: AnyRef = null\n+        try {\n+          body = data.convertToNetty()",
    "line": 201
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "the initial count for the reference is actually 1.\n",
    "commit": "bdab2c74111c8bce382323f68732f87ca9b080a9",
    "createdAt": "2014-09-29T19:08:52Z",
    "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.util.{List => JList}\n+\n+import io.netty.buffer.ByteBuf\n+import io.netty.channel.ChannelHandlerContext\n+import io.netty.channel.ChannelHandler.Sharable\n+import io.netty.handler.codec._\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.{NettyManagedBuffer, ManagedBuffer}\n+\n+\n+/** Messages from the client to the server. */\n+sealed trait ClientRequest {\n+  def id: Byte\n+}\n+\n+/**\n+ * Request to fetch a sequence of blocks from the server. A single [[BlockFetchRequest]] can\n+ * correspond to multiple [[ServerResponse]]s.\n+ */\n+final case class BlockFetchRequest(blocks: Seq[String]) extends ClientRequest {\n+  override def id = 0\n+}\n+\n+/**\n+ * Request to upload a block to the server. Currently the server does not ack the upload request.\n+ */\n+final case class BlockUploadRequest(blockId: String, data: ManagedBuffer) extends ClientRequest {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 1\n+}\n+\n+\n+/** Messages from server to client (usually in response to some [[ClientRequest]]. */\n+sealed trait ServerResponse {\n+  def id: Byte\n+}\n+\n+/** Response to [[BlockFetchRequest]] when a block exists and has been successfully fetched. */\n+final case class BlockFetchSuccess(blockId: String, data: ManagedBuffer) extends ServerResponse {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 0\n+}\n+\n+/** Response to [[BlockFetchRequest]] when there is an error fetching the block. */\n+final case class BlockFetchFailure(blockId: String, error: String) extends ServerResponse {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 1\n+}\n+\n+\n+/**\n+ * Encoder for [[ClientRequest]] used in client side.\n+ *\n+ * This encoder is stateless so it is safe to be shared by multiple threads.\n+ */\n+@Sharable\n+final class ClientRequestEncoder extends MessageToMessageEncoder[ClientRequest] {\n+  override def encode(ctx: ChannelHandlerContext, in: ClientRequest, out: JList[Object]): Unit = {\n+    in match {\n+      case BlockFetchRequest(blocks) =>\n+        // 8 bytes: frame size\n+        // 1 byte: BlockFetchRequest vs BlockUploadRequest\n+        // 4 byte: num blocks\n+        // then for each block id write 1 byte for blockId.length and then blockId itself\n+        val frameLength = 8 + 1 + 4 + blocks.size + blocks.map(_.size).fold(0)(_ + _)\n+        val buf = ctx.alloc().buffer(frameLength)\n+\n+        buf.writeLong(frameLength)\n+        buf.writeByte(in.id)\n+        buf.writeInt(blocks.size)\n+        blocks.foreach { blockId =>\n+          ProtocolUtils.writeBlockId(buf, blockId)\n+        }\n+\n+        assert(buf.writableBytes() == 0)\n+        out.add(buf)\n+\n+      case BlockUploadRequest(blockId, data) =>\n+        // 8 bytes: frame size\n+        // 1 byte: msg id (BlockFetchRequest vs BlockUploadRequest)\n+        // 1 byte: blockId.length\n+        // data itself (length can be derived from: frame size - 1 - blockId.length)\n+        val headerLength = 8 + 1 + 1 + blockId.length\n+        val frameLength = headerLength + data.size\n+        val header = ctx.alloc().buffer(headerLength)\n+\n+        // Call this before we add header to out so in case of exceptions\n+        // we don't send anything at all.\n+        val body = data.convertToNetty()\n+\n+        header.writeLong(frameLength)\n+        header.writeByte(in.id)\n+        ProtocolUtils.writeBlockId(header, blockId)\n+\n+        assert(header.writableBytes() == 0)\n+        out.add(header)\n+        out.add(body)\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * Decoder in the server side to decode client requests.\n+ * This decoder is stateless so it is safe to be shared by multiple threads.\n+ *\n+ * This assumes the inbound messages have been processed by a frame decoder created by\n+ * [[ProtocolUtils.createFrameDecoder()]].\n+ */\n+@Sharable\n+final class ClientRequestDecoder extends MessageToMessageDecoder[ByteBuf] {\n+  override protected def decode(ctx: ChannelHandlerContext, in: ByteBuf, out: JList[AnyRef]): Unit =\n+  {\n+    val msgTypeId = in.readByte()\n+    val decoded = msgTypeId match {\n+      case 0 =>  // BlockFetchRequest\n+        val numBlocks = in.readInt()\n+        val blockIds = Seq.fill(numBlocks) { ProtocolUtils.readBlockId(in) }\n+        BlockFetchRequest(blockIds)\n+\n+      case 1 =>  // BlockUploadRequest\n+        val blockId = ProtocolUtils.readBlockId(in)\n+        in.retain()  // retain the bytebuf so we don't recycle it immediately.\n+        BlockUploadRequest(blockId, new NettyManagedBuffer(in))\n+    }\n+\n+    assert(decoded.id == msgTypeId)\n+    out.add(decoded)\n+  }\n+}\n+\n+\n+/**\n+ * Encoder used by the server side to encode server-to-client responses.\n+ * This encoder is stateless so it is safe to be shared by multiple threads.\n+ */\n+@Sharable\n+final class ServerResponseEncoder extends MessageToMessageEncoder[ServerResponse] with Logging {\n+  override def encode(ctx: ChannelHandlerContext, in: ServerResponse, out: JList[Object]): Unit = {\n+    in match {\n+      case BlockFetchSuccess(blockId, data) =>\n+        // Handle the body first so if we encounter an error getting the body, we can respond\n+        // with an error instead.\n+        var body: AnyRef = null\n+        try {\n+          body = data.convertToNetty()",
    "line": 201
  }],
  "prId": 2330
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Maybe add a comment that this is guaranteed <128.\n",
    "commit": "bdab2c74111c8bce382323f68732f87ca9b080a9",
    "createdAt": "2014-09-12T05:44:29Z",
    "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.util.{List => JList}\n+\n+import io.netty.buffer.ByteBuf\n+import io.netty.channel.ChannelHandlerContext\n+import io.netty.channel.ChannelHandler.Sharable\n+import io.netty.handler.codec._\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.{NettyManagedBuffer, ManagedBuffer}\n+\n+\n+/** Messages from the client to the server. */\n+sealed trait ClientRequest {\n+  def id: Byte\n+}\n+\n+/**\n+ * Request to fetch a sequence of blocks from the server. A single [[BlockFetchRequest]] can\n+ * correspond to multiple [[ServerResponse]]s.\n+ */\n+final case class BlockFetchRequest(blocks: Seq[String]) extends ClientRequest {\n+  override def id = 0\n+}\n+\n+/**\n+ * Request to upload a block to the server. Currently the server does not ack the upload request.\n+ */\n+final case class BlockUploadRequest(blockId: String, data: ManagedBuffer) extends ClientRequest {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 1\n+}\n+\n+\n+/** Messages from server to client (usually in response to some [[ClientRequest]]. */\n+sealed trait ServerResponse {\n+  def id: Byte\n+}\n+\n+/** Response to [[BlockFetchRequest]] when a block exists and has been successfully fetched. */\n+final case class BlockFetchSuccess(blockId: String, data: ManagedBuffer) extends ServerResponse {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 0\n+}\n+\n+/** Response to [[BlockFetchRequest]] when there is an error fetching the block. */\n+final case class BlockFetchFailure(blockId: String, error: String) extends ServerResponse {\n+  require(blockId.length <= Byte.MaxValue)\n+  override def id = 1\n+}\n+\n+\n+/**\n+ * Encoder for [[ClientRequest]] used in client side.\n+ *\n+ * This encoder is stateless so it is safe to be shared by multiple threads.\n+ */\n+@Sharable\n+final class ClientRequestEncoder extends MessageToMessageEncoder[ClientRequest] {\n+  override def encode(ctx: ChannelHandlerContext, in: ClientRequest, out: JList[Object]): Unit = {\n+    in match {\n+      case BlockFetchRequest(blocks) =>\n+        // 8 bytes: frame size\n+        // 1 byte: BlockFetchRequest vs BlockUploadRequest\n+        // 4 byte: num blocks\n+        // then for each block id write 1 byte for blockId.length and then blockId itself\n+        val frameLength = 8 + 1 + 4 + blocks.size + blocks.map(_.size).fold(0)(_ + _)\n+        val buf = ctx.alloc().buffer(frameLength)\n+\n+        buf.writeLong(frameLength)\n+        buf.writeByte(in.id)\n+        buf.writeInt(blocks.size)\n+        blocks.foreach { blockId =>\n+          ProtocolUtils.writeBlockId(buf, blockId)\n+        }\n+\n+        assert(buf.writableBytes() == 0)\n+        out.add(buf)\n+\n+      case BlockUploadRequest(blockId, data) =>\n+        // 8 bytes: frame size\n+        // 1 byte: msg id (BlockFetchRequest vs BlockUploadRequest)\n+        // 1 byte: blockId.length\n+        // data itself (length can be derived from: frame size - 1 - blockId.length)\n+        val headerLength = 8 + 1 + 1 + blockId.length\n+        val frameLength = headerLength + data.size\n+        val header = ctx.alloc().buffer(headerLength)\n+\n+        // Call this before we add header to out so in case of exceptions\n+        // we don't send anything at all.\n+        val body = data.convertToNetty()\n+\n+        header.writeLong(frameLength)\n+        header.writeByte(in.id)\n+        ProtocolUtils.writeBlockId(header, blockId)\n+\n+        assert(header.writableBytes() == 0)\n+        out.add(header)\n+        out.add(body)\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * Decoder in the server side to decode client requests.\n+ * This decoder is stateless so it is safe to be shared by multiple threads.\n+ *\n+ * This assumes the inbound messages have been processed by a frame decoder created by\n+ * [[ProtocolUtils.createFrameDecoder()]].\n+ */\n+@Sharable\n+final class ClientRequestDecoder extends MessageToMessageDecoder[ByteBuf] {\n+  override protected def decode(ctx: ChannelHandlerContext, in: ByteBuf, out: JList[AnyRef]): Unit =\n+  {\n+    val msgTypeId = in.readByte()\n+    val decoded = msgTypeId match {\n+      case 0 =>  // BlockFetchRequest\n+        val numBlocks = in.readInt()\n+        val blockIds = Seq.fill(numBlocks) { ProtocolUtils.readBlockId(in) }\n+        BlockFetchRequest(blockIds)\n+\n+      case 1 =>  // BlockUploadRequest\n+        val blockId = ProtocolUtils.readBlockId(in)\n+        in.retain()  // retain the bytebuf so we don't recycle it immediately.\n+        BlockUploadRequest(blockId, new NettyManagedBuffer(in))\n+    }\n+\n+    assert(decoded.id == msgTypeId)\n+    out.add(decoded)\n+  }\n+}\n+\n+\n+/**\n+ * Encoder used by the server side to encode server-to-client responses.\n+ * This encoder is stateless so it is safe to be shared by multiple threads.\n+ */\n+@Sharable\n+final class ServerResponseEncoder extends MessageToMessageEncoder[ServerResponse] with Logging {\n+  override def encode(ctx: ChannelHandlerContext, in: ServerResponse, out: JList[Object]): Unit = {\n+    in match {\n+      case BlockFetchSuccess(blockId, data) =>\n+        // Handle the body first so if we encounter an error getting the body, we can respond\n+        // with an error instead.\n+        var body: AnyRef = null\n+        try {\n+          body = data.convertToNetty()\n+        } catch {\n+          case e: Exception =>\n+            // Re-encode this message as BlockFetchFailure.\n+            logError(s\"Error opening block $blockId for client ${ctx.channel.remoteAddress}\", e)\n+            encode(ctx, new BlockFetchFailure(blockId, e.getMessage), out)\n+            return\n+        }\n+\n+        // If we got here, body cannot be null\n+        // 8 bytes = long for frame length\n+        // 1 byte = message id (type)\n+        // 1 byte = block id length\n+        // followed by block id itself\n+        val headerLength = 8 + 1 + 1 + blockId.length\n+        val frameLength = headerLength + data.size\n+        val header = ctx.alloc().buffer(headerLength)\n+        header.writeLong(frameLength)\n+        header.writeByte(in.id)\n+        ProtocolUtils.writeBlockId(header, blockId)\n+\n+        assert(header.writableBytes() == 0)\n+        out.add(header)\n+        out.add(body)\n+\n+      case BlockFetchFailure(blockId, error) =>\n+        val frameLength = 8 + 1 + 1 + blockId.length + error.length\n+        val buf = ctx.alloc().buffer(frameLength)\n+        buf.writeLong(frameLength)\n+        buf.writeByte(in.id)\n+        ProtocolUtils.writeBlockId(buf, blockId)\n+        buf.writeBytes(error.getBytes)\n+\n+        assert(buf.writableBytes() == 0)\n+        out.add(buf)\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * Decoder in the client side to decode server responses.\n+ * This decoder is stateless so it is safe to be shared by multiple threads.\n+ *\n+ * This assumes the inbound messages have been processed by a frame decoder created by\n+ * [[ProtocolUtils.createFrameDecoder()]].\n+ */\n+@Sharable\n+final class ServerResponseDecoder extends MessageToMessageDecoder[ByteBuf] {\n+  override def decode(ctx: ChannelHandlerContext, in: ByteBuf, out: JList[AnyRef]): Unit = {\n+    val msgId = in.readByte()\n+    val decoded = msgId match {\n+      case 0 =>  // BlockFetchSuccess\n+        val blockId = ProtocolUtils.readBlockId(in)\n+        in.retain()\n+        new BlockFetchSuccess(blockId, new NettyManagedBuffer(in))\n+\n+      case 1 =>  // BlockFetchFailure\n+        val blockId = ProtocolUtils.readBlockId(in)\n+        val errorBytes = new Array[Byte](in.readableBytes())\n+        in.readBytes(errorBytes)\n+        new BlockFetchFailure(blockId, new String(errorBytes))\n+    }\n+\n+    assert(decoded.id == msgId)\n+    out.add(decoded)\n+  }\n+}\n+\n+\n+private[netty] object ProtocolUtils {\n+\n+  /** LengthFieldBasedFrameDecoder used before all decoders. */\n+  def createFrameDecoder(): ByteToMessageDecoder = {\n+    // maxFrameLength = 2G\n+    // lengthFieldOffset = 0\n+    // lengthFieldLength = 8\n+    // lengthAdjustment = -8, i.e. exclude the 8 byte length itself\n+    // initialBytesToStrip = 8, i.e. strip out the length field itself\n+    new LengthFieldBasedFrameDecoder(Int.MaxValue, 0, 8, -8, 8)\n+  }\n+\n+  // TODO(rxin): Make sure these work for all charsets.\n+  def readBlockId(in: ByteBuf): String = {\n+    val numBytesToRead = in.readByte().toInt",
    "line": 316
  }],
  "prId": 2330
}]