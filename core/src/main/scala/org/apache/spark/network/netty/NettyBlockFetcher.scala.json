[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "does this even need to be a class on its own? if yes, maybe have a separate init method so we don't get a weird object ctor failure\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-13T07:23:25Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      buffer.retain()\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "actually - why don't we simply put this in fetchBlocks?\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-14T05:26:19Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      buffer.retain()\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "It's not in fetchBlocks because it's simply one of many possible RPCs. For instance, I just added the UploadBlock RPC and anticipate more in the future.\n\nI'm not sure I understand the concern with the constructor.\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-17T07:08:40Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      buffer.retain()\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "as written here it is fine, but in general complicated constructor that can throw exceptions are more error prone in the future. see  http://stackoverflow.com/questions/1371369/can-constructors-throw-exceptions-in-java\n\nthat's why it might be better to just take these stuff out of the ctor.\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-26T19:49:42Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      buffer.retain()\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "note that this is worse in scala because scala doesn't have checked exceptions, i.e. the caller might not know it needs to handle the exceptions or do null check. it is fine when you are the one writing the caller code, but in the future when somebody else changes the code, it becomes more error prone.\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-26T19:51:58Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      buffer.retain()\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "Ahh, gotcha, totally misunderstood your initial concern. Sure, I can put it in a method. This is not a common pattern in Spark because Scala makes it so convenient to make constructors complicated, but I do agree it's better design.\n\nThe reason it's a class onto itself is because there is state related to the fetching of a single set of blocks. Previously, it was more complicated because we were doing chunking over large blocks -- I got rid of that to minimize changes, but I don't want all that logic and state to be buried inside the NettyBlockTransferService code, especially once we add it back in.\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-26T21:02:32Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      buffer.retain()\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can the fields here be private?\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-26T19:50:30Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.{SparkConf, Logging}\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.network.netty.NettyMessages._\n+import org.apache.spark.serializer.{JavaSerializer, Serializer}\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "Absolutely!\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T05:25:48Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.{SparkConf, Logging}\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.network.netty.NettyMessages._\n+import org.apache.spark.serializer.{JavaSerializer, Serializer}\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "wrap this around a try catch block so we call all block ids even if onBlockFetchFailure throws an exception?\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-26T19:57:14Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.{SparkConf, Logging}\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.network.netty.NettyMessages._\n+import org.apache.spark.serializer.{JavaSerializer, Serializer}\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),\n+    new RpcResponseCallback {\n+      override def onSuccess(response: Array[Byte]): Unit = {\n+        try {\n+          streamHandle = ser.deserialize[ShuffleStreamHandle](ByteBuffer.wrap(response))\n+          logTrace(s\"Successfully opened block set: $streamHandle! Preparing to fetch chunks.\")\n+\n+          // Immediately request all chunks -- we expect that the total size of the request is\n+          // reasonable due to higher level chunking in [[ShuffleBlockFetcherIterator]].\n+          for (i <- 0 until streamHandle.numChunks) {\n+            client.fetchChunk(streamHandle.streamId, i, chunkCallback)\n+          }\n+        } catch {\n+          case e: Exception =>\n+            logError(\"Failed while starting block fetches\", e)\n+            blockIds.foreach(listener.onBlockFetchFailure(_, e))"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "here too\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-26T19:57:19Z",
    "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.{SparkConf, Logging}\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.network.netty.NettyMessages._\n+import org.apache.spark.serializer.{JavaSerializer, Serializer}\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, SluiceClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: SluiceClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  val ser = serializer.newInstance()\n+\n+  var streamHandle: ShuffleStreamHandle = _\n+\n+  val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+  client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),\n+    new RpcResponseCallback {\n+      override def onSuccess(response: Array[Byte]): Unit = {\n+        try {\n+          streamHandle = ser.deserialize[ShuffleStreamHandle](ByteBuffer.wrap(response))\n+          logTrace(s\"Successfully opened block set: $streamHandle! Preparing to fetch chunks.\")\n+\n+          // Immediately request all chunks -- we expect that the total size of the request is\n+          // reasonable due to higher level chunking in [[ShuffleBlockFetcherIterator]].\n+          for (i <- 0 until streamHandle.numChunks) {\n+            client.fetchChunk(streamHandle.streamId, i, chunkCallback)\n+          }\n+        } catch {\n+          case e: Exception =>\n+            logError(\"Failed while starting block fetches\", e)\n+            blockIds.foreach(listener.onBlockFetchFailure(_, e))\n+        }\n+      }\n+\n+      override def onFailure(e: Throwable): Unit = {\n+        logError(\"Failed while starting block fetches\")\n+        blockIds.foreach(listener.onBlockFetchFailure(_, e))"
  }],
  "prId": 2753
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "log e here as well?\n",
    "commit": "cadfd28f116f0dbca11e580a23caf82060bcf922",
    "createdAt": "2014-10-27T18:49:27Z",
    "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import org.apache.spark.{SparkConf, Logging}\n+import org.apache.spark.network.BlockFetchingListener\n+import org.apache.spark.network.netty.NettyMessages._\n+import org.apache.spark.serializer.{JavaSerializer, Serializer}\n+import org.apache.spark.network.buffer.ManagedBuffer\n+import org.apache.spark.network.client.{RpcResponseCallback, ChunkReceivedCallback, TransportClient}\n+import org.apache.spark.storage.BlockId\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Responsible for holding the state for a request for a single set of blocks. This assumes that\n+ * the chunks will be returned in the same order as requested, and that there will be exactly\n+ * one chunk per block.\n+ *\n+ * Upon receipt of any block, the listener will be called back. Upon failure part way through,\n+ * the listener will receive a failure callback for each outstanding block.\n+ */\n+class NettyBlockFetcher(\n+    serializer: Serializer,\n+    client: TransportClient,\n+    blockIds: Seq[String],\n+    listener: BlockFetchingListener)\n+  extends Logging {\n+\n+  require(blockIds.nonEmpty)\n+\n+  private val ser = serializer.newInstance()\n+\n+  private var streamHandle: ShuffleStreamHandle = _\n+\n+  private val chunkCallback = new ChunkReceivedCallback {\n+    // On receipt of a chunk, pass it upwards as a block.\n+    def onSuccess(chunkIndex: Int, buffer: ManagedBuffer): Unit = Utils.logUncaughtExceptions {\n+      listener.onBlockFetchSuccess(blockIds(chunkIndex), buffer)\n+    }\n+\n+    // On receipt of a failure, fail every block from chunkIndex onwards.\n+    def onFailure(chunkIndex: Int, e: Throwable): Unit = {\n+      blockIds.drop(chunkIndex).foreach { blockId =>\n+        listener.onBlockFetchFailure(blockId, e);\n+      }\n+    }\n+  }\n+\n+  /** Begins the fetching process, calling the listener with every block fetched. */\n+  def start(): Unit = {\n+    // Send the RPC to open the given set of blocks. This will return a ShuffleStreamHandle.\n+    client.sendRpc(ser.serialize(OpenBlocks(blockIds.map(BlockId.apply))).array(),\n+      new RpcResponseCallback {\n+        override def onSuccess(response: Array[Byte]): Unit = {\n+          try {\n+            streamHandle = ser.deserialize[ShuffleStreamHandle](ByteBuffer.wrap(response))\n+            logTrace(s\"Successfully opened block set: $streamHandle! Preparing to fetch chunks.\")\n+\n+            // Immediately request all chunks -- we expect that the total size of the request is\n+            // reasonable due to higher level chunking in [[ShuffleBlockFetcherIterator]].\n+            for (i <- 0 until streamHandle.numChunks) {\n+              client.fetchChunk(streamHandle.streamId, i, chunkCallback)\n+            }\n+          } catch {\n+            case e: Exception =>\n+              logError(\"Failed while starting block fetches\", e)\n+              blockIds.foreach(blockId => Utils.tryLog(listener.onBlockFetchFailure(blockId, e)))\n+          }\n+        }\n+\n+        override def onFailure(e: Throwable): Unit = {\n+          logError(\"Failed while starting block fetches\")"
  }],
  "prId": 2753
}]