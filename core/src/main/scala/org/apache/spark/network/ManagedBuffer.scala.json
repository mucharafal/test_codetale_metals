[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "getName does not return the full path, we should probably use the path instead\n",
    "commit": "e724a9f118e98c056592424ac3bc27a330a4fed7",
    "createdAt": "2014-10-28T03:17:53Z",
    "diffHunk": "@@ -81,7 +81,13 @@ final class FileSegmentManagedBuffer(val file: File, val offset: Long, val lengt\n       // Just copy the buffer if it's sufficiently small, as memory mapping has a high overhead.\n       if (length < MIN_MEMORY_MAP_BYTES) {\n         val buf = ByteBuffer.allocate(length.toInt)\n-        channel.read(buf, offset)\n+        channel.position(offset)\n+        while (buf.remaining() != 0) {\n+          if (channel.read(buf) == -1) {\n+            throw new IOException(\"Reached EOF before filling buffer\\n\" +\n+              s\"offset=$offset\\nfile=${file.getName}\\nbuf.remaining=${buf.remaining}\")"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Good catch; I've updated this to use `getAbsolutePath`.\n",
    "commit": "e724a9f118e98c056592424ac3bc27a330a4fed7",
    "createdAt": "2014-10-28T03:23:27Z",
    "diffHunk": "@@ -81,7 +81,13 @@ final class FileSegmentManagedBuffer(val file: File, val offset: Long, val lengt\n       // Just copy the buffer if it's sufficiently small, as memory mapping has a high overhead.\n       if (length < MIN_MEMORY_MAP_BYTES) {\n         val buf = ByteBuffer.allocate(length.toInt)\n-        channel.read(buf, offset)\n+        channel.position(offset)\n+        while (buf.remaining() != 0) {\n+          if (channel.read(buf) == -1) {\n+            throw new IOException(\"Reached EOF before filling buffer\\n\" +\n+              s\"offset=$offset\\nfile=${file.getName}\\nbuf.remaining=${buf.remaining}\")"
  }],
  "prId": 2969
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "what is the problem with the old code here?\n",
    "commit": "e724a9f118e98c056592424ac3bc27a330a4fed7",
    "createdAt": "2014-10-28T05:49:43Z",
    "diffHunk": "@@ -106,7 +112,7 @@ final class FileSegmentManagedBuffer(val file: File, val offset: Long, val lengt\n     var is: FileInputStream = null\n     try {\n       is = new FileInputStream(file)\n-      is.skip(offset)",
    "line": 19
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "http://docs.oracle.com/javase/7/docs/api/java/io/FileInputStream.html#skip(long):\n\n> Skips over and discards n bytes of data from the input stream.\n> \n> The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. If n is negative, an IOException is thrown, even though the skip method of the InputStream superclass does nothing in this case. The actual number of bytes skipped is returned.\n> \n> This method may skip more bytes than are remaining in the backing file. This produces no exception and the number of bytes skipped may include some number of bytes that were beyond the EOF of the backing file. Attempting to read from the stream after skipping past the end will result in -1 indicating the end of the file.\n",
    "commit": "e724a9f118e98c056592424ac3bc27a330a4fed7",
    "createdAt": "2014-10-28T05:57:26Z",
    "diffHunk": "@@ -106,7 +112,7 @@ final class FileSegmentManagedBuffer(val file: File, val offset: Long, val lengt\n     var is: FileInputStream = null\n     try {\n       is = new FileInputStream(file)\n-      is.skip(offset)",
    "line": 19
  }],
  "prId": 2969
}]