[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "You got rid of the TODO - is it done?\n",
    "commit": "332422fefb1b450de92fe8c31098ea036e7f3860",
    "createdAt": "2014-08-10T20:31:57Z",
    "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.net.InetSocketAddress\n+\n+import io.netty.bootstrap.ServerBootstrap\n+import io.netty.channel.{ChannelFuture, ChannelOption, EventLoopGroup}\n+import io.netty.channel.oio.OioEventLoopGroup\n+import io.netty.channel.socket.oio.OioServerSocketChannel\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * Server that accept the path of a file an echo back its content.\n+ */\n+class FileServer(pResolver: PathResolver, private var port: Int) extends Logging {\n+\n+  private val addr: InetSocketAddress = new InetSocketAddress(port)\n+  private var bossGroup: EventLoopGroup = new OioEventLoopGroup\n+  private var workerGroup: EventLoopGroup = new OioEventLoopGroup\n+\n+  private var channelFuture: ChannelFuture = {\n+    val bootstrap = new ServerBootstrap\n+    bootstrap.group(bossGroup, workerGroup)\n+      .channel(classOf[OioServerSocketChannel])\n+      .option(ChannelOption.SO_BACKLOG, java.lang.Integer.valueOf(100))\n+      .option(ChannelOption.SO_RCVBUF, java.lang.Integer.valueOf(1500))\n+      .childHandler(new FileServerChannelInitializer(pResolver))\n+    bootstrap.bind(addr)\n+  }\n+\n+  try {\n+    val boundAddress = channelFuture.sync.channel.localAddress.asInstanceOf[InetSocketAddress]\n+    port = boundAddress.getPort\n+  } catch {\n+    case ie: InterruptedException =>\n+      port = 0\n+  }\n+\n+  /** Start the file server asynchronously in a new thread. */\n+  def start(): Unit = {\n+    val blockingThread: Thread = new Thread {\n+      override def run(): Unit = {\n+        try {\n+          channelFuture.channel.closeFuture.sync\n+          logInfo(\"FileServer exiting\")\n+        } catch {\n+          case e: InterruptedException =>\n+            logError(\"File server start got interrupted\", e)\n+        }\n+      }\n+    }\n+    blockingThread.setDaemon(true)\n+    blockingThread.start()\n+  }\n+\n+  def getPort: Int = port\n+\n+  def stop(): Unit = {\n+    if (channelFuture != null) {\n+      channelFuture.channel().close().awaitUninterruptibly()\n+      channelFuture = null\n+    }\n+    if (bossGroup != null) {\n+      bossGroup.shutdownGracefully()\n+      bossGroup = null\n+    }\n+    if (workerGroup != null) {\n+      workerGroup.shutdownGracefully()\n+      workerGroup = null\n+    }",
    "line": 88
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "that TODO was a question, whose answer was \"not neeed\"\n",
    "commit": "332422fefb1b450de92fe8c31098ea036e7f3860",
    "createdAt": "2014-08-11T00:54:14Z",
    "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.net.InetSocketAddress\n+\n+import io.netty.bootstrap.ServerBootstrap\n+import io.netty.channel.{ChannelFuture, ChannelOption, EventLoopGroup}\n+import io.netty.channel.oio.OioEventLoopGroup\n+import io.netty.channel.socket.oio.OioServerSocketChannel\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * Server that accept the path of a file an echo back its content.\n+ */\n+class FileServer(pResolver: PathResolver, private var port: Int) extends Logging {\n+\n+  private val addr: InetSocketAddress = new InetSocketAddress(port)\n+  private var bossGroup: EventLoopGroup = new OioEventLoopGroup\n+  private var workerGroup: EventLoopGroup = new OioEventLoopGroup\n+\n+  private var channelFuture: ChannelFuture = {\n+    val bootstrap = new ServerBootstrap\n+    bootstrap.group(bossGroup, workerGroup)\n+      .channel(classOf[OioServerSocketChannel])\n+      .option(ChannelOption.SO_BACKLOG, java.lang.Integer.valueOf(100))\n+      .option(ChannelOption.SO_RCVBUF, java.lang.Integer.valueOf(1500))\n+      .childHandler(new FileServerChannelInitializer(pResolver))\n+    bootstrap.bind(addr)\n+  }\n+\n+  try {\n+    val boundAddress = channelFuture.sync.channel.localAddress.asInstanceOf[InetSocketAddress]\n+    port = boundAddress.getPort\n+  } catch {\n+    case ie: InterruptedException =>\n+      port = 0\n+  }\n+\n+  /** Start the file server asynchronously in a new thread. */\n+  def start(): Unit = {\n+    val blockingThread: Thread = new Thread {\n+      override def run(): Unit = {\n+        try {\n+          channelFuture.channel.closeFuture.sync\n+          logInfo(\"FileServer exiting\")\n+        } catch {\n+          case e: InterruptedException =>\n+            logError(\"File server start got interrupted\", e)\n+        }\n+      }\n+    }\n+    blockingThread.setDaemon(true)\n+    blockingThread.start()\n+  }\n+\n+  def getPort: Int = port\n+\n+  def stop(): Unit = {\n+    if (channelFuture != null) {\n+      channelFuture.channel().close().awaitUninterruptibly()\n+      channelFuture = null\n+    }\n+    if (bossGroup != null) {\n+      bossGroup.shutdownGracefully()\n+      bossGroup = null\n+    }\n+    if (workerGroup != null) {\n+      workerGroup.shutdownGracefully()\n+      workerGroup = null\n+    }",
    "line": 88
  }],
  "prId": 1865
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "You got rid of NOTE, that seemed useful\n",
    "commit": "332422fefb1b450de92fe8c31098ea036e7f3860",
    "createdAt": "2014-08-10T20:32:35Z",
    "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.netty\n+\n+import java.net.InetSocketAddress\n+\n+import io.netty.bootstrap.ServerBootstrap\n+import io.netty.channel.{ChannelFuture, ChannelOption, EventLoopGroup}\n+import io.netty.channel.oio.OioEventLoopGroup\n+import io.netty.channel.socket.oio.OioServerSocketChannel\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * Server that accept the path of a file an echo back its content.\n+ */\n+class FileServer(pResolver: PathResolver, private var port: Int) extends Logging {\n+\n+  private val addr: InetSocketAddress = new InetSocketAddress(port)\n+  private var bossGroup: EventLoopGroup = new OioEventLoopGroup\n+  private var workerGroup: EventLoopGroup = new OioEventLoopGroup\n+\n+  private var channelFuture: ChannelFuture = {\n+    val bootstrap = new ServerBootstrap\n+    bootstrap.group(bossGroup, workerGroup)\n+      .channel(classOf[OioServerSocketChannel])\n+      .option(ChannelOption.SO_BACKLOG, java.lang.Integer.valueOf(100))\n+      .option(ChannelOption.SO_RCVBUF, java.lang.Integer.valueOf(1500))\n+      .childHandler(new FileServerChannelInitializer(pResolver))\n+    bootstrap.bind(addr)\n+  }\n+\n+  try {\n+    val boundAddress = channelFuture.sync.channel.localAddress.asInstanceOf[InetSocketAddress]\n+    port = boundAddress.getPort\n+  } catch {\n+    case ie: InterruptedException =>\n+      port = 0\n+  }\n+\n+  /** Start the file server asynchronously in a new thread. */\n+  def start(): Unit = {\n+    val blockingThread: Thread = new Thread {\n+      override def run(): Unit = {\n+        try {\n+          channelFuture.channel.closeFuture.sync\n+          logInfo(\"FileServer exiting\")\n+        } catch {\n+          case e: InterruptedException =>\n+            logError(\"File server start got interrupted\", e)\n+        }",
    "line": 66
  }],
  "prId": 1865
}]