[{
  "comments": [{
    "author": {
      "login": "shivaram"
    },
    "body": "Is this implemented here just for ease of testing ? I mean why do we need this single block fetch + blocking listener as a special case ?\n",
    "commit": "64cd9d7f258530b3252e8cd4aaa7fd04f6752278",
    "createdAt": "2014-09-03T03:25:34Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+abstract class BlockTransferService {\n+\n+  /**\n+   * Initialize the transfer service by giving it the BlockDataManager that can be used to fetch\n+   * local blocks or put local blocks.\n+   */\n+  def init(blockDataManager: BlockDataManager)\n+\n+  /**\n+   * Tear down the transfer service.\n+   */\n+  def stop(): Unit\n+\n+  /**\n+   * Port number the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def port: Int\n+\n+  /**\n+   * Host name the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def hostName: String\n+\n+  /**\n+   * Fetch a sequence of blocks from a remote node asynchronously,\n+   * available only after [[init]] is invoked.\n+   *\n+   * Note that [[BlockFetchingListener.onBlockFetchSuccess]] is called once per block,\n+   * while [[BlockFetchingListener.onBlockFetchSuccess]] is called once per failure.\n+   *\n+   * This takes a sequence so the implementation can batch requests.\n+   */\n+  def fetchBlocks(\n+      hostName: String,\n+      port: Int,\n+      blockIds: Seq[String],\n+      listener: BlockFetchingListener): Unit\n+\n+  /**\n+   * Fetch a single block from a remote node, synchronously,\n+   * available only after [[init]] is invoked.\n+   */\n+  def fetchBlock(hostName: String, port: Int, blockId: String): ManagedBuffer = {"
  }],
  "prId": 2240
}, {
  "comments": [{
    "author": {
      "login": "shivaram"
    },
    "body": "you mean onBlockFetchFailure in the second line ? And could you reword to `it is called exactly once for every failed block` ?\n",
    "commit": "64cd9d7f258530b3252e8cd4aaa7fd04f6752278",
    "createdAt": "2014-09-03T03:26:41Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+abstract class BlockTransferService {\n+\n+  /**\n+   * Initialize the transfer service by giving it the BlockDataManager that can be used to fetch\n+   * local blocks or put local blocks.\n+   */\n+  def init(blockDataManager: BlockDataManager)\n+\n+  /**\n+   * Tear down the transfer service.\n+   */\n+  def stop(): Unit\n+\n+  /**\n+   * Port number the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def port: Int\n+\n+  /**\n+   * Host name the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def hostName: String\n+\n+  /**\n+   * Fetch a sequence of blocks from a remote node asynchronously,\n+   * available only after [[init]] is invoked.\n+   *\n+   * Note that [[BlockFetchingListener.onBlockFetchSuccess]] is called once per block,\n+   * while [[BlockFetchingListener.onBlockFetchSuccess]] is called once per failure."
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "yes - going to update it.\n",
    "commit": "64cd9d7f258530b3252e8cd4aaa7fd04f6752278",
    "createdAt": "2014-09-03T05:07:42Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+abstract class BlockTransferService {\n+\n+  /**\n+   * Initialize the transfer service by giving it the BlockDataManager that can be used to fetch\n+   * local blocks or put local blocks.\n+   */\n+  def init(blockDataManager: BlockDataManager)\n+\n+  /**\n+   * Tear down the transfer service.\n+   */\n+  def stop(): Unit\n+\n+  /**\n+   * Port number the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def port: Int\n+\n+  /**\n+   * Host name the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def hostName: String\n+\n+  /**\n+   * Fetch a sequence of blocks from a remote node asynchronously,\n+   * available only after [[init]] is invoked.\n+   *\n+   * Note that [[BlockFetchingListener.onBlockFetchSuccess]] is called once per block,\n+   * while [[BlockFetchingListener.onBlockFetchSuccess]] is called once per failure."
  }],
  "prId": 2240
}, {
  "comments": [{
    "author": {
      "login": "shivaram"
    },
    "body": "Why don't we have a non-blocking version of this ? (and make the blocking version a special case)\n",
    "commit": "64cd9d7f258530b3252e8cd4aaa7fd04f6752278",
    "createdAt": "2014-09-03T03:27:17Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+abstract class BlockTransferService {\n+\n+  /**\n+   * Initialize the transfer service by giving it the BlockDataManager that can be used to fetch\n+   * local blocks or put local blocks.\n+   */\n+  def init(blockDataManager: BlockDataManager)\n+\n+  /**\n+   * Tear down the transfer service.\n+   */\n+  def stop(): Unit\n+\n+  /**\n+   * Port number the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def port: Int\n+\n+  /**\n+   * Host name the service is listening on, available only after [[init]] is invoked.\n+   */\n+  def hostName: String\n+\n+  /**\n+   * Fetch a sequence of blocks from a remote node asynchronously,\n+   * available only after [[init]] is invoked.\n+   *\n+   * Note that [[BlockFetchingListener.onBlockFetchSuccess]] is called once per block,\n+   * while [[BlockFetchingListener.onBlockFetchSuccess]] is called once per failure.\n+   *\n+   * This takes a sequence so the implementation can batch requests.\n+   */\n+  def fetchBlocks(\n+      hostName: String,\n+      port: Int,\n+      blockIds: Seq[String],\n+      listener: BlockFetchingListener): Unit\n+\n+  /**\n+   * Fetch a single block from a remote node, synchronously,\n+   * available only after [[init]] is invoked.\n+   */\n+  def fetchBlock(hostName: String, port: Int, blockId: String): ManagedBuffer = {\n+    // TODO(rxin): Add timeout?\n+\n+    // A monitor for the thread to wait on.\n+    val lock = new Object\n+    @volatile var result: Either[ManagedBuffer, Throwable] = null\n+    fetchBlocks(hostName, port, Seq(blockId), new BlockFetchingListener {\n+      override def onBlockFetchFailure(exception: Throwable): Unit = {\n+        lock.synchronized {\n+          result = Right(exception)\n+          lock.notify()\n+        }\n+      }\n+      override def onBlockFetchSuccess(blockId: String, data: ManagedBuffer): Unit = {\n+        lock.synchronized {\n+          result = Left(data)\n+          lock.notify()\n+        }\n+      }\n+    })\n+\n+    // Sleep until result is no longer null\n+    lock.synchronized {\n+      while (result == null) {\n+        try {\n+          lock.wait()\n+        } catch {\n+          case e: InterruptedException =>\n+        }\n+      }\n+    }\n+\n+    result match {\n+      case Left(data) => data\n+      case Right(e) => throw e\n+    }\n+  }\n+\n+  /**\n+   * Upload a single block to a remote node, available only after [[init]] is invoked.\n+   *\n+   * This call blocks until the upload completes, or throws an exception upon failures.\n+   */\n+  def uploadBlock("
  }],
  "prId": 2240
}]