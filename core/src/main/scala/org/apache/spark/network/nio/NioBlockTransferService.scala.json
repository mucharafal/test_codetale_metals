[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "note to reviewer: everything after this line is copied from old BlockManagerWorker code\n",
    "commit": "64cd9d7f258530b3252e8cd4aaa7fd04f6752278",
    "createdAt": "2014-09-03T06:04:41Z",
    "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.nio\n+\n+import java.nio.ByteBuffer\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.{SparkException, Logging, SecurityManager, SparkConf}\n+import org.apache.spark.network._\n+import org.apache.spark.storage.{BlockId, StorageLevel}\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * A [[BlockTransferService]] implementation based on [[ConnectionManager]], a custom\n+ * implementation using Java NIO.\n+ */\n+final class NioBlockTransferService(conf: SparkConf, securityManager: SecurityManager)\n+  extends BlockTransferService with Logging {\n+\n+  private var cm: ConnectionManager = _\n+\n+  private var blockDataManager: BlockDataManager = _\n+\n+  /**\n+   * Port number the service is listening on, available only after [[init]] is invoked.\n+   */\n+  override def port: Int = {\n+    checkInit()\n+    cm.id.port\n+  }\n+\n+  /**\n+   * Host name the service is listening on, available only after [[init]] is invoked.\n+   */\n+  override def hostName: String = {\n+    checkInit()\n+    cm.id.host\n+  }\n+\n+  /**\n+   * Initialize the transfer service by giving it the BlockDataManager that can be used to fetch\n+   * local blocks or put local blocks.\n+   */\n+  override def init(blockDataManager: BlockDataManager): Unit = {\n+    this.blockDataManager = blockDataManager\n+    cm = new ConnectionManager(\n+      conf.getInt(\"spark.blockManager.port\", 0),\n+      conf,\n+      securityManager,\n+      \"Connection manager for block manager\")\n+    cm.onReceiveMessage(onBlockMessageReceive)\n+  }\n+\n+  /**\n+   * Tear down the transfer service.\n+   */\n+  override def stop(): Unit = {\n+    if (cm != null) {\n+      cm.stop()\n+    }\n+  }\n+\n+  override def fetchBlocks(\n+      hostName: String,\n+      port: Int,\n+      blockIds: Seq[String],\n+      listener: BlockFetchingListener): Unit = {\n+    checkInit()\n+\n+    val cmId = new ConnectionManagerId(hostName, port)\n+    val blockMessageArray = new BlockMessageArray(blockIds.map { blockId =>\n+      BlockMessage.fromGetBlock(GetBlock(BlockId(blockId)))\n+    })\n+\n+    val future = cm.sendMessageReliably(cmId, blockMessageArray.toBufferMessage)\n+\n+    // Register the listener on success/failure future callback.\n+    future.onSuccess { case message =>\n+      val bufferMessage = message.asInstanceOf[BufferMessage]\n+      val blockMessageArray = BlockMessageArray.fromBufferMessage(bufferMessage)\n+\n+      for (blockMessage <- blockMessageArray) {\n+        if (blockMessage.getType != BlockMessage.TYPE_GOT_BLOCK) {\n+          listener.onBlockFetchFailure(\n+            new SparkException(s\"Unexpected message ${blockMessage.getType} received from $cmId\"))\n+        } else {\n+          val blockId = blockMessage.getId\n+          val networkSize = blockMessage.getData.limit()\n+          listener.onBlockFetchSuccess(\n+            blockId.toString, new NioByteBufferManagedBuffer(blockMessage.getData))\n+        }\n+      }\n+    }(cm.futureExecContext)\n+\n+    future.onFailure { case exception =>\n+      listener.onBlockFetchFailure(exception)\n+    }(cm.futureExecContext)\n+  }\n+\n+  /**\n+   * Upload a single block to a remote node, available only after [[init]] is invoked.\n+   *\n+   * This call blocks until the upload completes, or throws an exception upon failures.\n+   */\n+  override def uploadBlock(\n+      hostname: String,\n+      port: Int,\n+      blockId: String,\n+      blockData: ManagedBuffer,\n+      level: StorageLevel)\n+    : Future[Unit] = {\n+    checkInit()\n+    val msg = PutBlock(BlockId(blockId), blockData.nioByteBuffer(), level)\n+    val blockMessageArray = new BlockMessageArray(BlockMessage.fromPutBlock(msg))\n+    val remoteCmId = new ConnectionManagerId(hostName, port)\n+    val reply = cm.sendMessageReliably(remoteCmId, blockMessageArray.toBufferMessage)\n+    reply.map(x => ())(cm.futureExecContext)\n+  }\n+\n+  private def checkInit(): Unit = if (cm == null) {\n+    throw new IllegalStateException(getClass.getName + \" has not been initialized\")\n+  }\n+\n+  private def onBlockMessageReceive(msg: Message, id: ConnectionManagerId): Option[Message] = {",
    "line": 141
  }],
  "prId": 2240
}]