[{
  "comments": [{
    "author": {
      "login": "dragos"
    },
    "body": "I don't think this check is necessary. If the key wasn't there, the map simply returns `None`, no exception is thrown.\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-02T16:03:53Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+import org.apache.mesos.Protos.SlaveID\n+\n+/**\n+ * Tracks all the launched or running drivers in the Mesos cluster scheduler.\n+ * @param state Persistence engine to store tasks state.\n+ */\n+private[mesos] class LaunchedDrivers(state: MesosClusterPersistenceEngine) {\n+  private val drivers = new mutable.HashMap[String, MesosClusterTaskState]\n+\n+  // Holds the list of tasks that needs to reconciliation from the master.\n+  // All states that are loaded after failover are added here.\n+  val pendingRecover = new mutable.HashMap[String, SlaveID]\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosClusterTaskState]().foreach { case state =>\n+      drivers(state.taskId.getValue) = state\n+      pendingRecover(state.taskId.getValue) = state.slaveId\n+    }\n+  }\n+\n+  def size: Int = drivers.size\n+\n+  def get(submissionId: String): MesosClusterTaskState = drivers(submissionId)\n+\n+  def states: Iterable[MesosClusterTaskState] = {\n+    drivers.values.map(_.copy()).toList\n+  }\n+\n+  def contains(submissionId: String): Boolean = drivers.contains(submissionId)\n+\n+  def remove(submissionId: String): Option[MesosClusterTaskState] = {\n+    if (pendingRecover.contains(submissionId)) {"
  }, {
    "author": {
      "login": "tnachen"
    },
    "body": "Yes you're right, my scala needs more work!\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-02T22:18:24Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+import org.apache.mesos.Protos.SlaveID\n+\n+/**\n+ * Tracks all the launched or running drivers in the Mesos cluster scheduler.\n+ * @param state Persistence engine to store tasks state.\n+ */\n+private[mesos] class LaunchedDrivers(state: MesosClusterPersistenceEngine) {\n+  private val drivers = new mutable.HashMap[String, MesosClusterTaskState]\n+\n+  // Holds the list of tasks that needs to reconciliation from the master.\n+  // All states that are loaded after failover are added here.\n+  val pendingRecover = new mutable.HashMap[String, SlaveID]\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosClusterTaskState]().foreach { case state =>\n+      drivers(state.taskId.getValue) = state\n+      pendingRecover(state.taskId.getValue) = state.slaveId\n+    }\n+  }\n+\n+  def size: Int = drivers.size\n+\n+  def get(submissionId: String): MesosClusterTaskState = drivers(submissionId)\n+\n+  def states: Iterable[MesosClusterTaskState] = {\n+    drivers.values.map(_.copy()).toList\n+  }\n+\n+  def contains(submissionId: String): Boolean = drivers.contains(submissionId)\n+\n+  def remove(submissionId: String): Option[MesosClusterTaskState] = {\n+    if (pendingRecover.contains(submissionId)) {"
  }],
  "prId": 5144
}]