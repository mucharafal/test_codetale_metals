[{
  "comments": [{
    "author": {
      "login": "tnachen"
    },
    "body": "I think we've consistently put the function parameters that are longer than 100 in newlines so far, can you move `d: SchedulerDriver` to the next line?\n",
    "commit": "68cee1c5c701257a51e7b1f0edff98e56fcfe2ee",
    "createdAt": "2015-12-17T03:23:09Z",
    "diffHunk": "@@ -210,12 +216,18 @@ private[spark] class MesosSchedulerBackend(\n   }\n \n   /**\n-   * Method called by Mesos to offer resources on slaves. We respond by asking our active task sets\n-   * for tasks in order of priority. We fill each node with tasks in a round-robin manner so that\n-   * tasks are balanced across the cluster.\n+   * Return the usable Mesos offers and corresponding WorkerOffers.\n+   *\n+   * This method declines Mesos offers that don't meet minimum cpu, memory or attribute\n+   * requirements.\n+   *\n+   * @param d Mesos SchedulerDriver to decline offers\n+   * @param offers Mesos offers to be considered\n+   * @return a pair of Mesos offers and corresponding WorkerOffer that can be used by the\n+   *         fine-grained scheduler.\n    */\n-  override def resourceOffers(d: SchedulerDriver, offers: JList[Offer]) {\n-    inClassLoader() {\n+  private[spark] def usableWorkerOffers(d: SchedulerDriver,",
    "line": 43
  }],
  "prId": 9027
}, {
  "comments": [{
    "author": {
      "login": "tnachen"
    },
    "body": "I think technically this is not correct (which exists in code before, not your change). We can still launch new tasks if there is already an executor running without mesosExecutoreCores. Probably fix this in the future.\n",
    "commit": "68cee1c5c701257a51e7b1f0edff98e56fcfe2ee",
    "createdAt": "2015-12-17T04:48:17Z",
    "diffHunk": "@@ -239,44 +250,69 @@ private[spark] class MesosSchedulerBackend(\n           .setRefuseSeconds(rejectOfferDurationForUnmetConstraints).build())\n       }\n \n-      // Of the matching constraints, see which ones give us enough memory and cores\n-      val (usableOffers, unUsableOffers) = offersMatchingConstraints.partition { o =>\n-        val mem = getResource(o.getResourcesList, \"mem\")\n-        val cpus = getResource(o.getResourcesList, \"cpus\")\n-        val slaveId = o.getSlaveId.getValue\n-        val offerAttributes = toAttributeMap(o.getAttributesList)\n-\n-        // check offers for\n-        //  1. Memory requirements\n-        //  2. CPU requirements - need at least 1 for executor, 1 for task\n-        val meetsMemoryRequirements = mem >= calculateTotalMemory(sc)\n-        val meetsCPURequirements = cpus >= (mesosExecutorCores + scheduler.CPUS_PER_TASK)\n-        val meetsRequirements =\n-          (meetsMemoryRequirements && meetsCPURequirements) ||\n+    // Of the matching constraints, see which ones give us enough memory and cores\n+    val (usableOffers, unUsableOffers) = offersMatchingConstraints.partition { o =>\n+      val mem = getResource(o.getResourcesList, \"mem\")\n+      val cpus = getResource(o.getResourcesList, \"cpus\")\n+      val slaveId = o.getSlaveId.getValue\n+      val offerAttributes = toAttributeMap(o.getAttributesList)\n+\n+      // check offers for\n+      //  1. Memory requirements\n+      //  2. CPU requirements - need at least 1 for executor, 1 for task\n+      val meetsMemoryRequirements = mem >= calculateTotalMemory(sc)\n+      val meetsCPURequirements = cpus >= (mesosExecutorCores + scheduler.CPUS_PER_TASK)",
    "line": 87
  }],
  "prId": 9027
}, {
  "comments": [{
    "author": {
      "login": "tnachen"
    },
    "body": "What happens if we hit the limit and don't run any more tasks on the remaining usableOffers? We need to decline those too right?\n",
    "commit": "68cee1c5c701257a51e7b1f0edff98e56fcfe2ee",
    "createdAt": "2015-12-17T04:49:25Z",
    "diffHunk": "@@ -239,44 +250,69 @@ private[spark] class MesosSchedulerBackend(\n           .setRefuseSeconds(rejectOfferDurationForUnmetConstraints).build())\n       }\n \n-      // Of the matching constraints, see which ones give us enough memory and cores\n-      val (usableOffers, unUsableOffers) = offersMatchingConstraints.partition { o =>\n-        val mem = getResource(o.getResourcesList, \"mem\")\n-        val cpus = getResource(o.getResourcesList, \"cpus\")\n-        val slaveId = o.getSlaveId.getValue\n-        val offerAttributes = toAttributeMap(o.getAttributesList)\n-\n-        // check offers for\n-        //  1. Memory requirements\n-        //  2. CPU requirements - need at least 1 for executor, 1 for task\n-        val meetsMemoryRequirements = mem >= calculateTotalMemory(sc)\n-        val meetsCPURequirements = cpus >= (mesosExecutorCores + scheduler.CPUS_PER_TASK)\n-        val meetsRequirements =\n-          (meetsMemoryRequirements && meetsCPURequirements) ||\n+    // Of the matching constraints, see which ones give us enough memory and cores\n+    val (usableOffers, unUsableOffers) = offersMatchingConstraints.partition { o =>\n+      val mem = getResource(o.getResourcesList, \"mem\")\n+      val cpus = getResource(o.getResourcesList, \"cpus\")\n+      val slaveId = o.getSlaveId.getValue\n+      val offerAttributes = toAttributeMap(o.getAttributesList)\n+\n+      // check offers for\n+      //  1. Memory requirements\n+      //  2. CPU requirements - need at least 1 for executor, 1 for task\n+      val meetsMemoryRequirements = mem >= calculateTotalMemory(sc)\n+      val meetsCPURequirements = cpus >= (mesosExecutorCores + scheduler.CPUS_PER_TASK)\n+      val meetsRequirements =\n+        (meetsMemoryRequirements && meetsCPURequirements) ||\n           (slaveIdToExecutorInfo.contains(slaveId) && cpus >= scheduler.CPUS_PER_TASK)\n-        val debugstr = if (meetsRequirements) \"Accepting\" else \"Declining\"\n-        logDebug(s\"$debugstr offer: ${o.getId.getValue} with attributes: \"\n-          + s\"$offerAttributes mem: $mem cpu: $cpus\")\n+      val debugstr = if (meetsRequirements) \"Accepting\" else \"Declining\"\n+      logDebug(s\"$debugstr offer: ${o.getId.getValue} with attributes: \"\n+ \t\t\t\t+ s\"$offerAttributes mem: $mem cpu: $cpus\")\n+\n+      meetsRequirements\n+    }\n+\n+    // Decline offers we ruled out immediately\n+    unUsableOffers.foreach(o => d.declineOffer(o.getId))\n+\n+    var availableCores = Math.max(0, maxCores - totalCoresAcquired)\n \n-        meetsRequirements\n+    val workerOffers = (for (o <- usableOffers) yield {\n+      val coresInOffer = getResource(o.getResourcesList, \"cpus\").toInt\n+      val extraCores = if (slaveIdToExecutorInfo.contains(o.getSlaveId.getValue)) {\n+        0D\n+      } else {\n+        // If the Mesos executor has not been started on this slave yet, set aside a few\n+        // cores for the Mesos executor by offering fewer cores to the Spark executor\n+        mesosExecutorCores\n       }\n \n-      // Decline offers we ruled out immediately\n-      unUsableOffers.foreach(o => d.declineOffer(o.getId))\n+      // the cores we can offer for tasks on workers should not exceed neither availableCores\n+      // nor cores in the current offer, after accounting for non-task cores\n+      val taskCores = Math.min(availableCores - extraCores, coresInOffer - extraCores)\n \n-      val workerOffers = usableOffers.map { o =>\n-        val cpus = if (slaveIdToExecutorInfo.contains(o.getSlaveId.getValue)) {\n-          getResource(o.getResourcesList, \"cpus\").toInt\n-        } else {\n-          // If the Mesos executor has not been started on this slave yet, set aside a few\n-          // cores for the Mesos executor by offering fewer cores to the Spark executor\n-          (getResource(o.getResourcesList, \"cpus\") - mesosExecutorCores).toInt\n-        }\n-        new WorkerOffer(\n+      if (taskCores > 0) {\n+        availableCores -= taskCores + extraCores\n+        Option(new WorkerOffer(\n           o.getSlaveId.getValue,\n           o.getHostname,\n-          cpus)\n+          taskCores.toInt))\n+      } else {\n+        None\n       }\n+    }).flatten\n+\n+    (usableOffers, workerOffers)",
    "line": 144
  }],
  "prId": 9027
}, {
  "comments": [{
    "author": {
      "login": "tnachen"
    },
    "body": "We should only account for executor resources once per slave, not for every task\n",
    "commit": "68cee1c5c701257a51e7b1f0edff98e56fcfe2ee",
    "createdAt": "2015-12-17T04:50:32Z",
    "diffHunk": "@@ -304,20 +340,25 @@ private[spark] class MesosSchedulerBackend(\n             mesosTasks.getOrElseUpdate(slaveId, new JArrayList[MesosTaskInfo])\n               .add(mesosTask)\n             slaveIdToResources(slaveId) = remainingResources\n+\n+            totalCoresAcquired += getResource(mesosTask.getResourcesList, \"cpus\")\n           }\n         }\n \n       // Reply to the offers\n       val filters = Filters.newBuilder().setRefuseSeconds(1).build() // TODO: lower timeout?\n \n-      mesosTasks.foreach { case (slaveId, tasks) =>\n-        slaveIdToWorkerOffer.get(slaveId).foreach(o =>\n-          listenerBus.post(SparkListenerExecutorAdded(System.currentTimeMillis(), slaveId,\n-            // TODO: Add support for log urls for Mesos\n-            new ExecutorInfo(o.host, o.cores, Map.empty)))\n-        )\n-        logTrace(s\"Launching Mesos tasks on slave '$slaveId', tasks:\\n${getTasksSummary(tasks)}\")\n-        d.launchTasks(Collections.singleton(slaveIdToOffer(slaveId).getId), tasks, filters)\n+      mesosTasks.foreach {\n+        case (slaveId, tasks) =>\n+          // add the cores reserved for each Mesos executor (one per slave)\n+          totalCoresAcquired += getResource(tasks.get(0).getExecutor.getResourcesList, \"cpus\")",
    "line": 181
  }],
  "prId": 9027
}]