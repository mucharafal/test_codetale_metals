[{
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "Would be good to shuffle workOffset's for this class too.\nPractically, this ensures that initial heap will be randomized when cores are the same.\n\nThis will also mean that Ordering below will need to handle case of x.cores == y.cores but x != y\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-04T20:24:40Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 86
  }, {
    "author": {
      "login": "zhzhan"
    },
    "body": "BTW, I don't think need to handle the case of x.cores == y.cores, which means they are equal, and depends on the algorithm in priority queue to decide the behavior.\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-06T21:34:39Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 86
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "Returning 0 implies equality - which is not the case here (x != y but x.cores == y.cores).\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-06T22:12:47Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 86
  }, {
    "author": {
      "login": "zhzhan"
    },
    "body": "@mridulm Thanks for the comments. But I am lost here. My understanding is Ordering-wise, x is equal to y if x.cores == y.cores. This ordering is used by priority queue to construct the data structure.  Following is an example from trait Ordering. PersonA will be equal to PersionB if they are the same age. Do I miss anything?\n- import scala.util.Sorting\n  *\n  - case class Person(name:String, age:Int)\n  - val people = Array(Person(\"bob\", 30), Person(\"ann\", 32), Person(\"carl\", 19))\n    *\n  - // sort by age\n  - object AgeOrdering extends Ordering[Person] {\n  -   def compare(a:Person, b:Person) = a.age compare b.age\n  - }\n  - Sorting.quickSort(people)(AgeOrdering)\n  - }}}\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-07T02:33:00Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 86
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "You are right, my bad. I was thinking of Ordered\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-07T04:56:01Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 86
  }, {
    "author": {
      "login": "wangmiao1981"
    },
    "body": "In `class PackedAssigner`, you add space between functions. Do you want to be consistent with the style?\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-18T22:17:03Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 86
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "We need more documentation here to explain what this class does.\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:22:27Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var maxHeap: PriorityQueue[OfferState] = _\n+  var current: OfferState = _\n+\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  implicit val ord: Ordering[OfferState] = new Ordering[OfferState] {\n+    def compare(x: OfferState, y: OfferState): Int = {\n+      return Ordering[Int].compare(x.cores, y.cores)\n+    }\n+  }\n+  def init(): Unit = {\n+    maxHeap = new PriorityQueue[OfferState]()\n+    offer.filter(_.cores >= CPUS_PER_TASK).foreach(maxHeap.enqueue(_))\n+  }\n+  override def hasNext: Boolean = {\n+    maxHeap.size > 0\n+  }\n+  override def getNext(): OfferState = {\n+    current = maxHeap.dequeue()\n+    current\n+  }\n+\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    if (current.cores >= CPUS_PER_TASK && assigned) {\n+      maxHeap.enqueue(current)\n+    }\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    maxHeap = null\n+    current = null\n+  }\n+}\n+\n+class PackedAssigner(conf: SparkConf) extends TaskAssigner(conf) {",
    "line": 122
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "all these variables should be private\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:22:37Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var maxHeap: PriorityQueue[OfferState] = _\n+  var current: OfferState = _\n+\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  implicit val ord: Ordering[OfferState] = new Ordering[OfferState] {\n+    def compare(x: OfferState, y: OfferState): Int = {\n+      return Ordering[Int].compare(x.cores, y.cores)\n+    }\n+  }\n+  def init(): Unit = {\n+    maxHeap = new PriorityQueue[OfferState]()\n+    offer.filter(_.cores >= CPUS_PER_TASK).foreach(maxHeap.enqueue(_))\n+  }\n+  override def hasNext: Boolean = {\n+    maxHeap.size > 0\n+  }\n+  override def getNext(): OfferState = {\n+    current = maxHeap.dequeue()\n+    current\n+  }\n+\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    if (current.cores >= CPUS_PER_TASK && assigned) {\n+      maxHeap.enqueue(current)\n+    }\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    maxHeap = null\n+    current = null\n+  }\n+}\n+\n+class PackedAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+\n+  var sorted: Seq[OfferState] = _",
    "line": 124
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "this should have parentheses since it has side effect\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:23:02Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {",
    "line": 58
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we need documentation explaining what this class does\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:24:35Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {",
    "line": 26
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Also case classes are supposed to have mostly immutable state -- if you want cores to be mutable, I'd just make this a normal class.\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:24:57Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {",
    "line": 26
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "I read more code. Shouldn't cores be coresRemaining, or coresAvailable?\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:30:24Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {",
    "line": 26
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "Again I think you need to document what this actually does. My guess (without having looked at rest of the code) is that the index indicates some worker id, but I'm not sure and I might be wrong. We need to explain it here.\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:26:31Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)",
    "line": 28
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Ah ok - my guess was wrong. It would be great to actually say what this list means, e.g. is this a queue?\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:27:06Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)",
    "line": 28
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "instead of taking in a generic SparkConf, I'd just take in the cpu per task for now, until we see a clear need to be more generic. This simplifies the dependencies of the class.\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T05:39:30Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {",
    "line": 31
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Any better variable name?\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T23:10:44Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0",
    "line": 64
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "`override`\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-16T23:16:02Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.\n+  def taskAssigned(assigned: Boolean): Unit\n+\n+  // Release internally maintained resources. Subclass is responsible to\n+  // release its own private resources.\n+  def reset: Unit = {\n+    offer = null\n+  }\n+}\n+\n+class RoundRobinAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var i = 0\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  override def init(): Unit = {\n+    i = 0\n+  }\n+  override def hasNext: Boolean = {\n+    i < offer.size\n+  }\n+  override def getNext(): OfferState = {\n+    offer(i)\n+  }\n+  override def taskAssigned(assigned: Boolean): Unit = {\n+    i += 1\n+  }\n+  override def reset: Unit = {\n+    super.reset\n+    i = 0\n+  }\n+}\n+\n+class BalancedAssigner(conf: SparkConf) extends TaskAssigner(conf) {\n+  var maxHeap: PriorityQueue[OfferState] = _\n+  var current: OfferState = _\n+\n+  override def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = Random.shuffle(workOffer.map(o => OfferState(o, o.cores)))\n+  }\n+  implicit val ord: Ordering[OfferState] = new Ordering[OfferState] {\n+    def compare(x: OfferState, y: OfferState): Int = {\n+      return Ordering[Int].compare(x.cores, y.cores)\n+    }\n+  }\n+  def init(): Unit = {",
    "line": 98
  }],
  "prId": 15218
}, {
  "comments": [{
    "author": {
      "login": "wangmiao1981"
    },
    "body": "\"In\" should be \"in\"\n",
    "commit": "98a974756ecf6c7e29a955010b440f4b8f116692",
    "createdAt": "2016-10-18T22:08:41Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.collection.mutable.PriorityQueue\n+import scala.util.Random\n+\n+import org.apache.spark.SparkConf\n+\n+case class OfferState(workOffer: WorkerOffer, var cores: Int) {\n+  // Build a list of tasks to assign to each worker.\n+  val tasks = new ArrayBuffer[TaskDescription](cores)\n+}\n+\n+abstract class TaskAssigner(conf: SparkConf) {\n+  var offer: Seq[OfferState] = _\n+  val CPUS_PER_TASK = conf.getInt(\"spark.task.cpus\", 1)\n+\n+  // The final assigned offer returned to TaskScheduler.\n+  def tasks(): Seq[ArrayBuffer[TaskDescription]] = offer.map(_.tasks)\n+\n+  // construct the assigner by the workoffer.\n+  def construct(workOffer: Seq[WorkerOffer]): Unit = {\n+    offer = workOffer.map(o => OfferState(o, o.cores))\n+  }\n+\n+  // Invoked in each round of Taskset assignment to initialize the internal structure.\n+  def init(): Unit\n+\n+  // Indicating whether there is offer available to be used by one round of Taskset assignment.\n+  def hasNext(): Boolean\n+\n+  // Next available offer returned to one round of Taskset assignment.\n+  def getNext(): OfferState\n+\n+  // Called by the TaskScheduler to indicate whether the current offer is accepted\n+  // In order to decide whether the current is valid for the next offering.",
    "line": 53
  }],
  "prId": 15218
}]