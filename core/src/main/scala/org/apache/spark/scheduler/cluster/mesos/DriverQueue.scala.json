[{
  "comments": [{
    "author": {
      "login": "dragos"
    },
    "body": "Isn't this the same as calling `queue.contains`? You'd save a closure allocation.\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-02T15:58:15Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.mesos.MesosDriverDescription\n+\n+/**\n+ * A request queue for launching drivers in Mesos cluster mode.\n+ * This queue automatically stores the state after each pop/push\n+ * so it can be recovered later.\n+ * This queue is also bounded and rejects offers when it's full.\n+ * @param state Mesos state abstraction to fetch persistent state.\n+ */\n+private[mesos] class DriverQueue(state: MesosClusterPersistenceEngine, capacity: Int) {\n+  var queue: mutable.Queue[MesosDriverDescription] = new mutable.Queue[MesosDriverDescription]()\n+  private var count = 0\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosDriverDescription]().foreach(d => queue.enqueue(d))\n+\n+    // This size might be larger than the passed in capacity, but we allow\n+    // this so we don't lose queued drivers.\n+    count = queue.size\n+  }\n+\n+  def isFull = count >= capacity\n+\n+  def size: Int = count\n+\n+  def contains(submissionId: String): Boolean = {\n+    queue.exists(s => s.submissionId.equals(submissionId))"
  }, {
    "author": {
      "login": "tnachen"
    },
    "body": "I can override equal in MesosDriverDescription and use contains instead.\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-02T22:19:08Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.mesos.MesosDriverDescription\n+\n+/**\n+ * A request queue for launching drivers in Mesos cluster mode.\n+ * This queue automatically stores the state after each pop/push\n+ * so it can be recovered later.\n+ * This queue is also bounded and rejects offers when it's full.\n+ * @param state Mesos state abstraction to fetch persistent state.\n+ */\n+private[mesos] class DriverQueue(state: MesosClusterPersistenceEngine, capacity: Int) {\n+  var queue: mutable.Queue[MesosDriverDescription] = new mutable.Queue[MesosDriverDescription]()\n+  private var count = 0\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosDriverDescription]().foreach(d => queue.enqueue(d))\n+\n+    // This size might be larger than the passed in capacity, but we allow\n+    // this so we don't lose queued drivers.\n+    count = queue.size\n+  }\n+\n+  def isFull = count >= capacity\n+\n+  def size: Int = count\n+\n+  def contains(submissionId: String): Boolean = {\n+    queue.exists(s => s.submissionId.equals(submissionId))"
  }, {
    "author": {
      "login": "tnachen"
    },
    "body": "Actually since in the queue I store MesosDriverDescription, it's easier to use a exists call here.\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-03T07:13:43Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.mesos.MesosDriverDescription\n+\n+/**\n+ * A request queue for launching drivers in Mesos cluster mode.\n+ * This queue automatically stores the state after each pop/push\n+ * so it can be recovered later.\n+ * This queue is also bounded and rejects offers when it's full.\n+ * @param state Mesos state abstraction to fetch persistent state.\n+ */\n+private[mesos] class DriverQueue(state: MesosClusterPersistenceEngine, capacity: Int) {\n+  var queue: mutable.Queue[MesosDriverDescription] = new mutable.Queue[MesosDriverDescription]()\n+  private var count = 0\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosDriverDescription]().foreach(d => queue.enqueue(d))\n+\n+    // This size might be larger than the passed in capacity, but we allow\n+    // this so we don't lose queued drivers.\n+    count = queue.size\n+  }\n+\n+  def isFull = count >= capacity\n+\n+  def size: Int = count\n+\n+  def contains(submissionId: String): Boolean = {\n+    queue.exists(s => s.submissionId.equals(submissionId))"
  }, {
    "author": {
      "login": "dragos"
    },
    "body": "You are right, I missed the fact that the queue isn't storing `submissionId`s directly. Ignore this :)\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-04T10:48:33Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.mesos.MesosDriverDescription\n+\n+/**\n+ * A request queue for launching drivers in Mesos cluster mode.\n+ * This queue automatically stores the state after each pop/push\n+ * so it can be recovered later.\n+ * This queue is also bounded and rejects offers when it's full.\n+ * @param state Mesos state abstraction to fetch persistent state.\n+ */\n+private[mesos] class DriverQueue(state: MesosClusterPersistenceEngine, capacity: Int) {\n+  var queue: mutable.Queue[MesosDriverDescription] = new mutable.Queue[MesosDriverDescription]()\n+  private var count = 0\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosDriverDescription]().foreach(d => queue.enqueue(d))\n+\n+    // This size might be larger than the passed in capacity, but we allow\n+    // this so we don't lose queued drivers.\n+    count = queue.size\n+  }\n+\n+  def isFull = count >= capacity\n+\n+  def size: Int = count\n+\n+  def contains(submissionId: String): Boolean = {\n+    queue.exists(s => s.submissionId.equals(submissionId))"
  }],
  "prId": 5144
}, {
  "comments": [{
    "author": {
      "login": "dragos"
    },
    "body": "This is a \"check-then-act\" pattern, are you sure this class is only called from one thread? Maybe a line in the scaladoc would be useful to warn future users.\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-02T16:00:57Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.mesos.MesosDriverDescription\n+\n+/**\n+ * A request queue for launching drivers in Mesos cluster mode.\n+ * This queue automatically stores the state after each pop/push\n+ * so it can be recovered later.\n+ * This queue is also bounded and rejects offers when it's full.\n+ * @param state Mesos state abstraction to fetch persistent state.\n+ */\n+private[mesos] class DriverQueue(state: MesosClusterPersistenceEngine, capacity: Int) {\n+  var queue: mutable.Queue[MesosDriverDescription] = new mutable.Queue[MesosDriverDescription]()\n+  private var count = 0\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosDriverDescription]().foreach(d => queue.enqueue(d))\n+\n+    // This size might be larger than the passed in capacity, but we allow\n+    // this so we don't lose queued drivers.\n+    count = queue.size\n+  }\n+\n+  def isFull = count >= capacity\n+\n+  def size: Int = count\n+\n+  def contains(submissionId: String): Boolean = {\n+    queue.exists(s => s.submissionId.equals(submissionId))\n+  }\n+\n+  def offer(submission: MesosDriverDescription): Boolean = {\n+    if (isFull) {\n+      return false\n+    }\n+\n+    queue.enqueue(submission)"
  }, {
    "author": {
      "login": "tnachen"
    },
    "body": "Yes all the strcutures I introduced is all assuming a single thread access for now. I originally added @NotThreadSafe but didn't see anyone else using it in Spark so left it out. Good idae about the  comment though, I'll add one.\n",
    "commit": "069e9463b377d1a0c7e4c35619e06213eae07fc2",
    "createdAt": "2015-04-02T22:18:03Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.mesos.MesosDriverDescription\n+\n+/**\n+ * A request queue for launching drivers in Mesos cluster mode.\n+ * This queue automatically stores the state after each pop/push\n+ * so it can be recovered later.\n+ * This queue is also bounded and rejects offers when it's full.\n+ * @param state Mesos state abstraction to fetch persistent state.\n+ */\n+private[mesos] class DriverQueue(state: MesosClusterPersistenceEngine, capacity: Int) {\n+  var queue: mutable.Queue[MesosDriverDescription] = new mutable.Queue[MesosDriverDescription]()\n+  private var count = 0\n+\n+  initialize()\n+\n+  def initialize(): Unit = {\n+    state.fetchAll[MesosDriverDescription]().foreach(d => queue.enqueue(d))\n+\n+    // This size might be larger than the passed in capacity, but we allow\n+    // this so we don't lose queued drivers.\n+    count = queue.size\n+  }\n+\n+  def isFull = count >= capacity\n+\n+  def size: Int = count\n+\n+  def contains(submissionId: String): Boolean = {\n+    queue.exists(s => s.submissionId.equals(submissionId))\n+  }\n+\n+  def offer(submission: MesosDriverDescription): Boolean = {\n+    if (isFull) {\n+      return false\n+    }\n+\n+    queue.enqueue(submission)"
  }],
  "prId": 5144
}]