[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "why the ThreadLocal here, but not for CoarseGrainedSchedulerBackend?  Is this unrelated to this change?  If not, can you add a comment explaining",
    "commit": "b2b1eec3c41873eb217cf041f3cf6d71d4cfa265",
    "createdAt": "2016-12-19T17:21:24Z",
    "diffHunk": "@@ -59,6 +62,12 @@ private[spark] class LocalEndpoint(\n   private val executor = new Executor(\n     localExecutorId, localExecutorHostname, SparkEnv.get, userClassPath, isLocal = true)\n \n+  private val serializer = new ThreadLocal[SerializerInstance] {"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "LocalEndpoint does not support multiple threads,the ThreadLocal is not necessary.",
    "commit": "b2b1eec3c41873eb217cf041f3cf6d71d4cfa265",
    "createdAt": "2016-12-22T02:46:40Z",
    "diffHunk": "@@ -59,6 +62,12 @@ private[spark] class LocalEndpoint(\n   private val executor = new Executor(\n     localExecutorId, localExecutorHostname, SparkEnv.get, userClassPath, isLocal = true)\n \n+  private val serializer = new ThreadLocal[SerializerInstance] {"
  }],
  "prId": 15505
}, {
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "Can you add a comment here about why we're serializing (and then immediately deserializing) the task?",
    "commit": "b2b1eec3c41873eb217cf041f3cf6d71d4cfa265",
    "createdAt": "2017-02-28T22:41:10Z",
    "diffHunk": "@@ -82,9 +88,15 @@ private[spark] class LocalEndpoint(\n \n   def reviveOffers() {\n     val offers = IndexedSeq(new WorkerOffer(localExecutorId, localExecutorHostname, freeCores))\n+    val abortTaskSet = new HashSet[TaskSetManager]()\n     for (task <- scheduler.resourceOffers(offers).flatten) {\n-      freeCores -= scheduler.CPUS_PER_TASK\n-      executor.launchTask(executorBackend, task)\n+      val buffer = prepareSerializedTask(scheduler, task,"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "Done",
    "commit": "b2b1eec3c41873eb217cf041f3cf6d71d4cfa265",
    "createdAt": "2017-03-01T08:25:45Z",
    "diffHunk": "@@ -82,9 +88,15 @@ private[spark] class LocalEndpoint(\n \n   def reviveOffers() {\n     val offers = IndexedSeq(new WorkerOffer(localExecutorId, localExecutorHostname, freeCores))\n+    val abortTaskSet = new HashSet[TaskSetManager]()\n     for (task <- scheduler.resourceOffers(offers).flatten) {\n-      freeCores -= scheduler.CPUS_PER_TASK\n-      executor.launchTask(executorBackend, task)\n+      val buffer = prepareSerializedTask(scheduler, task,"
  }],
  "prId": 15505
}]