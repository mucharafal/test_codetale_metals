[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Just add `try...finally` to wrap this line and fix the style",
    "commit": "5c500686ad91e1c95e1b2fe9985686a813ff1d12",
    "createdAt": "2017-05-11T00:35:59Z",
    "diffHunk": "@@ -115,26 +115,33 @@ private[spark] abstract class Task[T](\n           case t: Throwable =>\n             e.addSuppressed(t)\n         }\n+        context.markTaskCompleted(Some(e))\n         throw e\n     } finally {\n-      // Call the task completion callbacks.\n-      context.markTaskCompleted()\n       try {\n-        Utils.tryLogNonFatalError {\n-          // Release memory used by this thread for unrolling blocks\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.ON_HEAP)\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.OFF_HEAP)\n-          // Notify any tasks waiting for execution memory to be freed to wake up and try to\n-          // acquire memory again. This makes impossible the scenario where a task sleeps forever\n-          // because there are no other tasks left to notify it. Since this is safe to do but may\n-          // not be strictly necessary, we should revisit whether we can remove this in the future.\n-          val memoryManager = SparkEnv.get.memoryManager\n-          memoryManager.synchronized { memoryManager.notifyAll() }\n-        }\n+        // Call the task completion callbacks. If \"markTaskCompleted\" is called twice, the second\n+        // one is no-op.\n+        context.markTaskCompleted(None)",
    "line": 23
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "We end up calling `markTaskCompleted` twice when there is an exception thrown, right ?\r\nPerhaps do this one when no `Throwable` is thrown.",
    "commit": "5c500686ad91e1c95e1b2fe9985686a813ff1d12",
    "createdAt": "2017-05-11T08:20:13Z",
    "diffHunk": "@@ -115,26 +115,33 @@ private[spark] abstract class Task[T](\n           case t: Throwable =>\n             e.addSuppressed(t)\n         }\n+        context.markTaskCompleted(Some(e))\n         throw e\n     } finally {\n-      // Call the task completion callbacks.\n-      context.markTaskCompleted()\n       try {\n-        Utils.tryLogNonFatalError {\n-          // Release memory used by this thread for unrolling blocks\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.ON_HEAP)\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.OFF_HEAP)\n-          // Notify any tasks waiting for execution memory to be freed to wake up and try to\n-          // acquire memory again. This makes impossible the scenario where a task sleeps forever\n-          // because there are no other tasks left to notify it. Since this is safe to do but may\n-          // not be strictly necessary, we should revisit whether we can remove this in the future.\n-          val memoryManager = SparkEnv.get.memoryManager\n-          memoryManager.synchronized { memoryManager.notifyAll() }\n-        }\n+        // Call the task completion callbacks. If \"markTaskCompleted\" is called twice, the second\n+        // one is no-op.\n+        context.markTaskCompleted(None)",
    "line": 23
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "> We end up calling markTaskCompleted twice when there is an exception thrown, right ?\r\n\r\nYes.\r\n\r\n> Perhaps do this one when no Throwable is thrown.\r\n\r\nThen if `context.markTaskCompleted(None)` throws an exception, `context.markTaskFailed(e)` will be called, so TaskFailureListener may be called after TaskCompletionListener. This is a slight behavior change. Not sure if it's safe. Someone may depend on the order of calling listeners?",
    "commit": "5c500686ad91e1c95e1b2fe9985686a813ff1d12",
    "createdAt": "2017-05-11T18:09:12Z",
    "diffHunk": "@@ -115,26 +115,33 @@ private[spark] abstract class Task[T](\n           case t: Throwable =>\n             e.addSuppressed(t)\n         }\n+        context.markTaskCompleted(Some(e))\n         throw e\n     } finally {\n-      // Call the task completion callbacks.\n-      context.markTaskCompleted()\n       try {\n-        Utils.tryLogNonFatalError {\n-          // Release memory used by this thread for unrolling blocks\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.ON_HEAP)\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.OFF_HEAP)\n-          // Notify any tasks waiting for execution memory to be freed to wake up and try to\n-          // acquire memory again. This makes impossible the scenario where a task sleeps forever\n-          // because there are no other tasks left to notify it. Since this is safe to do but may\n-          // not be strictly necessary, we should revisit whether we can remove this in the future.\n-          val memoryManager = SparkEnv.get.memoryManager\n-          memoryManager.synchronized { memoryManager.notifyAll() }\n-        }\n+        // Call the task completion callbacks. If \"markTaskCompleted\" is called twice, the second\n+        // one is no-op.\n+        context.markTaskCompleted(None)",
    "line": 23
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "What I meant was, when there is an exception is throw, there will be two invocations of `context.markTaskCompleted`.\r\nOne with Throwable passed in, and another with None.\r\n\r\nThis would be confusing to the listeners - no ?",
    "commit": "5c500686ad91e1c95e1b2fe9985686a813ff1d12",
    "createdAt": "2017-05-12T01:48:29Z",
    "diffHunk": "@@ -115,26 +115,33 @@ private[spark] abstract class Task[T](\n           case t: Throwable =>\n             e.addSuppressed(t)\n         }\n+        context.markTaskCompleted(Some(e))\n         throw e\n     } finally {\n-      // Call the task completion callbacks.\n-      context.markTaskCompleted()\n       try {\n-        Utils.tryLogNonFatalError {\n-          // Release memory used by this thread for unrolling blocks\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.ON_HEAP)\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.OFF_HEAP)\n-          // Notify any tasks waiting for execution memory to be freed to wake up and try to\n-          // acquire memory again. This makes impossible the scenario where a task sleeps forever\n-          // because there are no other tasks left to notify it. Since this is safe to do but may\n-          // not be strictly necessary, we should revisit whether we can remove this in the future.\n-          val memoryManager = SparkEnv.get.memoryManager\n-          memoryManager.synchronized { memoryManager.notifyAll() }\n-        }\n+        // Call the task completion callbacks. If \"markTaskCompleted\" is called twice, the second\n+        // one is no-op.\n+        context.markTaskCompleted(None)",
    "line": 23
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "@mridulm there is a `completed` flag in `markTaskCompleted`.",
    "commit": "5c500686ad91e1c95e1b2fe9985686a813ff1d12",
    "createdAt": "2017-05-12T02:46:25Z",
    "diffHunk": "@@ -115,26 +115,33 @@ private[spark] abstract class Task[T](\n           case t: Throwable =>\n             e.addSuppressed(t)\n         }\n+        context.markTaskCompleted(Some(e))\n         throw e\n     } finally {\n-      // Call the task completion callbacks.\n-      context.markTaskCompleted()\n       try {\n-        Utils.tryLogNonFatalError {\n-          // Release memory used by this thread for unrolling blocks\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.ON_HEAP)\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.OFF_HEAP)\n-          // Notify any tasks waiting for execution memory to be freed to wake up and try to\n-          // acquire memory again. This makes impossible the scenario where a task sleeps forever\n-          // because there are no other tasks left to notify it. Since this is safe to do but may\n-          // not be strictly necessary, we should revisit whether we can remove this in the future.\n-          val memoryManager = SparkEnv.get.memoryManager\n-          memoryManager.synchronized { memoryManager.notifyAll() }\n-        }\n+        // Call the task completion callbacks. If \"markTaskCompleted\" is called twice, the second\n+        // one is no-op.\n+        context.markTaskCompleted(None)",
    "line": 23
  }],
  "prId": 17942
}, {
  "comments": [{
    "author": {
      "login": "mridulm"
    },
    "body": "Missed this comment.\r\nLGTM. Thanks for clarifying @zsxwing ",
    "commit": "5c500686ad91e1c95e1b2fe9985686a813ff1d12",
    "createdAt": "2017-05-12T03:56:33Z",
    "diffHunk": "@@ -115,26 +115,33 @@ private[spark] abstract class Task[T](\n           case t: Throwable =>\n             e.addSuppressed(t)\n         }\n+        context.markTaskCompleted(Some(e))\n         throw e\n     } finally {\n-      // Call the task completion callbacks.\n-      context.markTaskCompleted()\n       try {\n-        Utils.tryLogNonFatalError {\n-          // Release memory used by this thread for unrolling blocks\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.ON_HEAP)\n-          SparkEnv.get.blockManager.memoryStore.releaseUnrollMemoryForThisTask(MemoryMode.OFF_HEAP)\n-          // Notify any tasks waiting for execution memory to be freed to wake up and try to\n-          // acquire memory again. This makes impossible the scenario where a task sleeps forever\n-          // because there are no other tasks left to notify it. Since this is safe to do but may\n-          // not be strictly necessary, we should revisit whether we can remove this in the future.\n-          val memoryManager = SparkEnv.get.memoryManager\n-          memoryManager.synchronized { memoryManager.notifyAll() }\n-        }\n+        // Call the task completion callbacks. If \"markTaskCompleted\" is called twice, the second\n+        // one is no-op.",
    "line": 22
  }],
  "prId": 17942
}]