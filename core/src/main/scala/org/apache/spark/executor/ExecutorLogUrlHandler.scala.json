[{
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "This is nearly same as old `HistoryAppStatusStore.replaceLogUrls`: the only difference is this method returns new log urls instead of replacing log urls in ExecutorSummary.",
    "commit": "709b111e12697990fde8dcab77fe865dd15f41e2",
    "createdAt": "2019-02-14T14:06:51Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.executor\n+\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.util.matching.Regex\n+\n+import org.apache.spark.internal.Logging\n+\n+private[spark] class ExecutorLogUrlHandler(logUrlPattern: Option[String]) extends Logging {\n+  import ExecutorLogUrlHandler._\n+\n+  private val informedForMissingAttributes = new AtomicBoolean(false)\n+\n+  def applyPattern(\n+      logUrls: Map[String, String],\n+      attributes: Map[String, String]): Map[String, String] = {\n+    logUrlPattern match {\n+      case Some(pattern) => doApplyPattern(logUrls, attributes, pattern)\n+      case None => logUrls\n+    }\n+  }\n+\n+  private def doApplyPattern(",
    "line": 40
  }],
  "prId": 23790
}, {
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "This is same as old `HistoryAppStatusStore. logFailToRenewLogUrls`.",
    "commit": "709b111e12697990fde8dcab77fe865dd15f41e2",
    "createdAt": "2019-02-14T14:07:59Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.executor\n+\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.util.matching.Regex\n+\n+import org.apache.spark.internal.Logging\n+\n+private[spark] class ExecutorLogUrlHandler(logUrlPattern: Option[String]) extends Logging {\n+  import ExecutorLogUrlHandler._\n+\n+  private val informedForMissingAttributes = new AtomicBoolean(false)\n+\n+  def applyPattern(\n+      logUrls: Map[String, String],\n+      attributes: Map[String, String]): Map[String, String] = {\n+    logUrlPattern match {\n+      case Some(pattern) => doApplyPattern(logUrls, attributes, pattern)\n+      case None => logUrls\n+    }\n+  }\n+\n+  private def doApplyPattern(\n+      logUrls: Map[String, String],\n+      attributes: Map[String, String],\n+      urlPattern: String): Map[String, String] = {\n+    // Relation between pattern {{FILE_NAME}} and attribute {{LOG_FILES}}\n+    // Given that this class don't know which types of log files can be provided\n+    // from resource manager, we require resource manager to provide available types of log\n+    // files, which are encouraged to be same as types of log files provided in original log URLs.\n+    // Once we get the list of log files, we need to expose them to end users as a pattern\n+    // so that end users can compose custom log URL(s) including log file name(s).\n+    val allPatterns = CUSTOM_URL_PATTERN_REGEX.findAllMatchIn(urlPattern).map(_.group(1)).toSet\n+    val allPatternsExceptFileName = allPatterns.filter(_ != \"FILE_NAME\")\n+    val allAttributeKeys = attributes.keySet\n+    val allAttributeKeysExceptLogFiles = allAttributeKeys.filter(_ != \"LOG_FILES\")\n+\n+    if (allPatternsExceptFileName.diff(allAttributeKeysExceptLogFiles).nonEmpty) {\n+      logFailToRenewLogUrls(\"some of required attributes are missing in app's event log.\",\n+        allPatternsExceptFileName, allAttributeKeys)\n+      logUrls\n+    } else if (allPatterns.contains(\"FILE_NAME\") && !allAttributeKeys.contains(\"LOG_FILES\")) {\n+      logFailToRenewLogUrls(\"'FILE_NAME' parameter is provided, but file information is \" +\n+        \"missing in app's event log.\", allPatternsExceptFileName, allAttributeKeys)\n+      logUrls\n+    } else {\n+      val updatedUrl = allPatternsExceptFileName.foldLeft(urlPattern) { case (orig, patt) =>\n+        // we already checked the existence of attribute when comparing keys\n+        orig.replace(s\"{{$patt}}\", attributes(patt))\n+      }\n+\n+      if (allPatterns.contains(\"FILE_NAME\")) {\n+        // allAttributeKeys should contain \"LOG_FILES\"\n+        attributes(\"LOG_FILES\").split(\",\").map { file =>\n+          file -> updatedUrl.replace(\"{{FILE_NAME}}\", file)\n+        }.toMap\n+      } else {\n+        Map(\"log\" -> updatedUrl)\n+      }\n+    }\n+  }\n+\n+  private def logFailToRenewLogUrls(",
    "line": 80
  }],
  "prId": 23790
}]