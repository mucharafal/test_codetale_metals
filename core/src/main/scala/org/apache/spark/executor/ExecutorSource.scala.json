[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "This metric is useful for users? The task cpu time metric is not enough?",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-25T02:08:12Z",
    "diffHunk": "@@ -73,6 +75,13 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process (JVM) CPU time.\n+  // The value is returned in nanoseconds, the method return -1 if this operation is not supported.\n+  val osMXBean = ManagementFactory.getOperatingSystemMXBean.asInstanceOf[OperatingSystemMXBean]\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {\n+    override def getValue: Long = osMXBean.getProcessCpuTime()"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "I believe the proposed metric tracking the executor CPU time is useful and adds additional information and convenience on top of the task CPU metric, as implemented in SPARK-22190. A couple of considerations to support this argument from some of the recent findings and experimentation on this:\r\n- the process CPU time contains all the CPU consumed by the JVM, notably including the CPU consumed by garbage collection, which can be important in some cases and definitely something we want to measure and analyze\r\n- the CPU time collected from the tasks is \"harder to consume\" in a dashboard as the CPU value is only updated at the end of the successful execution of the task, which makes it harder to handle for a dashboard in case of long-running tasks. In contrast, the executor process CPU time \"dropwizard gauge\" gives an up-to-date value of the CPU consumed by the executor at any time as it takes it directly from the OS.\r\n",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-27T10:33:28Z",
    "diffHunk": "@@ -73,6 +75,13 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process (JVM) CPU time.\n+  // The value is returned in nanoseconds, the method return -1 if this operation is not supported.\n+  val osMXBean = ManagementFactory.getOperatingSystemMXBean.asInstanceOf[OperatingSystemMXBean]\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {\n+    override def getValue: Long = osMXBean.getProcessCpuTime()"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Is this com.sun class going to be available in all JDKs? Thinking of OpenJDK and IBM JDKs",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-25T14:20:02Z",
    "diffHunk": "@@ -17,11 +17,13 @@\n \n package org.apache.spark.executor\n \n+import java.lang.management.ManagementFactory\n import java.util.concurrent.ThreadPoolExecutor\n \n import scala.collection.JavaConverters._\n \n import com.codahale.metrics.{Gauge, MetricRegistry}\n+import com.sun.management.OperatingSystemMXBean"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Good point.\r\nThis class cannot be loaded at least on IBM JDK as reported [here](https://issues.apache.org/jira/browse/DRILL-6702).",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-26T17:23:43Z",
    "diffHunk": "@@ -17,11 +17,13 @@\n \n package org.apache.spark.executor\n \n+import java.lang.management.ManagementFactory\n import java.util.concurrent.ThreadPoolExecutor\n \n import scala.collection.JavaConverters._\n \n import com.codahale.metrics.{Gauge, MetricRegistry}\n+import com.sun.management.OperatingSystemMXBean"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "Indeed this is a very good point that I had overlooked. I have now directly checked and this appears to work OK on OpenJDK (and on Oracle JVM of course). In addition, I tested manually with IBM JDK (IBM J9 VM, Java 1.8.0_181,  where one would indeed suspect incompatibilities and surprisingly this appears to work in that case too. I believe this may come from recent work by IBM to make `com.ibm.lang.management.OperatingSystemMXBean.getProcessCpuTime` compatible with `com.sun.management.OperatingSystemMXBean.getProcessCpuTime`? See also [this link](https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/dcomibmlangmanagementosmxbeaniscputime100ns.html)\r\n\r\nI guess that if this is confirmed, we should be fine with a large fraction of the commonly used JDKs. In addition, we could handle the exception in case getProcessCpuTime is not available on a particular platform where the executor is running, for example returning the value -1 for this gauge in that case. Any thoughts/suggestions on this proposal?\r\n",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-27T11:04:41Z",
    "diffHunk": "@@ -17,11 +17,13 @@\n \n package org.apache.spark.executor\n \n+import java.lang.management.ManagementFactory\n import java.util.concurrent.ThreadPoolExecutor\n \n import scala.collection.JavaConverters._\n \n import com.codahale.metrics.{Gauge, MetricRegistry}\n+import com.sun.management.OperatingSystemMXBean"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I think it's safest to a little reflection here to make sure this doesn't cause the whole app to crash every time.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-27T12:57:46Z",
    "diffHunk": "@@ -17,11 +17,13 @@\n \n package org.apache.spark.executor\n \n+import java.lang.management.ManagementFactory\n import java.util.concurrent.ThreadPoolExecutor\n \n import scala.collection.JavaConverters._\n \n import com.codahale.metrics.{Gauge, MetricRegistry}\n+import com.sun.management.OperatingSystemMXBean"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "I have refactored the code with a different approach using the BeanServer which should address the comments about avialability of com.sun.management.OperatingSystemMXBean across different JDKs.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T15:36:12Z",
    "diffHunk": "@@ -17,11 +17,13 @@\n \n package org.apache.spark.executor\n \n+import java.lang.management.ManagementFactory\n import java.util.concurrent.ThreadPoolExecutor\n \n import scala.collection.JavaConverters._\n \n import com.codahale.metrics.{Gauge, MetricRegistry}\n+import com.sun.management.OperatingSystemMXBean"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Can you just inline this method below?",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T16:57:59Z",
    "diffHunk": "@@ -73,6 +75,31 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // will try to get JVM Process CPU time or return -1 otherwise\n+  // will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean if available\n+  def tryToGetJVMProcessPCUTime() : Long = {"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: pull onto previous line",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T16:58:27Z",
    "diffHunk": "@@ -73,6 +75,31 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // will try to get JVM Process CPU time or return -1 otherwise\n+  // will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean if available\n+  def tryToGetJVMProcessPCUTime() : Long = {\n+    val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+    try {\n+      val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+      val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+      if (attribute != null) {\n+        attribute.asInstanceOf[Long]\n+      }\n+      else {"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: the comments should begin on the next line. But this is scaladoc syntax, and inside a code block, normally we just use `//` block comments.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T21:58:35Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time."
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "The problem here is that these become fields in the parent object. These should go inside the `new Gauge... {` I think?",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T21:59:18Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "`case NonFatal(_) => -1`?",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T22:35:41Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+  val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {\n+          attribute.asInstanceOf[Long]\n+        } else {\n+          -1L\n+        }\n+      } catch {\n+        case _ : Exception => -1L"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "a little confused with the exsiting `cpuTime`. How about `jvmCpuTime`?",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T22:40:16Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+  val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "nit: `name(\"executorCPUTime\" )` -> `name(\"executorCPUTime\")`\r\n",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-01T05:29:11Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+  val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Any reason to return -1 instead of 0?",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-08-31T22:41:44Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+  val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {\n+          attribute.asInstanceOf[Long]\n+        } else {\n+          -1L"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "I took the idea from com.sun.management.OperatingSystemMXBean.getProcessCpuTime, according to the documentation: \"Returns: the CPU time used by the process in nanoseconds, or -1 if this operation is not supported.\"\r\nI guess it makes sense to return an invalid value as -1L for the CPU time if something goes wrong with gathering CPU Time values, so the error condition will appear evident to the end user of the metric. Returning 0 is also possible, of course.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-01T19:36:37Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+  val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {\n+          attribute.asInstanceOf[Long]\n+        } else {\n+          -1L"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "ok, thanks.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-03T01:32:25Z",
    "diffHunk": "@@ -73,6 +75,29 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  /** Dropwizard metrics gauge measuring the executor's process CPU time.\n+   *  This code will try to get JVM Process CPU time or return -1 otherwise.\n+   *  The CPU time value is returned in nanoseconds.\n+   *  It will use proprietary extensions as com.sun.management.OperatingSystemMXBean or\n+   *  com.ibm.lang.management.OperatingSystemMXBean if available\n+   */\n+  val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+  val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+  metricRegistry.register(MetricRegistry.name(\"executorCPUTime\" ), new Gauge[Long] {\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {\n+          attribute.asInstanceOf[Long]\n+        } else {\n+          -1L"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Although I actually mean to put these inside the anonymous `Gauge` instance but outside the method, so as to compute them once, I doubt there is much overhead here. Getting the bean is just returning a field, although constructing the ObjectName is a little non-trivial. I suppose metrics are infrequently computed so this doesn't matter much.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-01T20:03:38Z",
    "diffHunk": "@@ -73,6 +76,28 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process CPU time.\n+  // This Gauge will try to get and return the JVM Process CPU time or return -1 otherwise.\n+  // The CPU time value is returned in nanoseconds.\n+  // It will use proprietary extensions such as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean, if available.\n+  metricRegistry.register(MetricRegistry.name(\"jvmCpuTime\"), new Gauge[Long] {\n+    override def getValue: Long = {\n+      val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer"
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "So this isn't exposed except through dropwizard... not plumbed through to the driver too like some of the metrics below? just checking that this is all that needs to happen, that the metric can be used by external users but is not otherwise touched by Spark.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-02T15:14:42Z",
    "diffHunk": "@@ -73,6 +76,28 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process CPU time.\n+  // This Gauge will try to get and return the JVM Process CPU time or return -1 otherwise.\n+  // The CPU time value is returned in nanoseconds.\n+  // It will use proprietary extensions such as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean, if available.\n+  metricRegistry.register(MetricRegistry.name(\"jvmCpuTime\"), new Gauge[Long] {",
    "line": 22
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "Indeed, this is exposed only through dropwizard metrics system and not used otherwise in the Spark code. Another point worth mentioning is that currently executorSource is not registered when running in local mode.\r\nOn a related topic (although maybe for a more general discussion than the scope of this PR) I was wondering if it would make sense to introduce a few SparkConf properties to switch on/off certain families of (dropwizard) metrics in the Spark, as the list of available metrics is mecoming long in recent versions.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-02T18:59:07Z",
    "diffHunk": "@@ -73,6 +76,28 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process CPU time.\n+  // This Gauge will try to get and return the JVM Process CPU time or return -1 otherwise.\n+  // The CPU time value is returned in nanoseconds.\n+  // It will use proprietary extensions such as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean, if available.\n+  metricRegistry.register(MetricRegistry.name(\"jvmCpuTime\"), new Gauge[Long] {",
    "line": 22
  }],
  "prId": 22218
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "I checked the doc for `getAttribute though, when does it return null?\r\nhttps://docs.oracle.com/javase/8/docs/api/javax/management/MBeanServerConnection.html#getAttribute-javax.management.ObjectName-java.lang.String-",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-03T01:41:59Z",
    "diffHunk": "@@ -73,6 +76,28 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process CPU time.\n+  // This Gauge will try to get and return the JVM Process CPU time or return -1 otherwise.\n+  // The CPU time value is returned in nanoseconds.\n+  // It will use proprietary extensions such as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean, if available.\n+  metricRegistry.register(MetricRegistry.name(\"jvmCpuTime\"), new Gauge[Long] {\n+    val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+    val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {"
  }, {
    "author": {
      "login": "LucaCanali"
    },
    "body": "Indeed good point. I'll remove this additional check for null value.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-03T08:07:15Z",
    "diffHunk": "@@ -73,6 +76,28 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process CPU time.\n+  // This Gauge will try to get and return the JVM Process CPU time or return -1 otherwise.\n+  // The CPU time value is returned in nanoseconds.\n+  // It will use proprietary extensions such as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean, if available.\n+  metricRegistry.register(MetricRegistry.name(\"jvmCpuTime\"), new Gauge[Long] {\n+    val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+    val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I personally don't mind the defensive checks, because who knows what to really expect from these implementations? but this is OK by me. In case of a bad impl this would still return -1.",
    "commit": "e72966e38dc50be7b501387a9f719f85017a7aa8",
    "createdAt": "2018-09-03T12:34:17Z",
    "diffHunk": "@@ -73,6 +76,28 @@ class ExecutorSource(threadPool: ThreadPoolExecutor, executorId: String) extends\n     registerFileSystemStat(scheme, \"write_ops\", _.getWriteOps(), 0)\n   }\n \n+  // Dropwizard metrics gauge measuring the executor's process CPU time.\n+  // This Gauge will try to get and return the JVM Process CPU time or return -1 otherwise.\n+  // The CPU time value is returned in nanoseconds.\n+  // It will use proprietary extensions such as com.sun.management.OperatingSystemMXBean or\n+  // com.ibm.lang.management.OperatingSystemMXBean, if available.\n+  metricRegistry.register(MetricRegistry.name(\"jvmCpuTime\"), new Gauge[Long] {\n+    val mBean: MBeanServer = ManagementFactory.getPlatformMBeanServer\n+    val name = new ObjectName(\"java.lang\", \"type\", \"OperatingSystem\")\n+    override def getValue: Long = {\n+      try {\n+        val attribute = mBean.getAttribute(name, \"ProcessCpuTime\")\n+        if (attribute != null) {"
  }],
  "prId": 22218
}]