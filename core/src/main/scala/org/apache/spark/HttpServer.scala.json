[{
  "comments": [{
    "author": {
      "login": "epahomov"
    },
    "body": "code about selecting port to start I can see twice. Let encapsulate it in single method\n",
    "commit": "038a579a26ffcfc1c5540f28176f236779eef12a",
    "createdAt": "2014-06-18T10:38:43Z",
    "diffHunk": "@@ -41,45 +41,73 @@ private[spark] class ServerStateException(message: String) extends Exception(mes\n  * as well as classes created by the interpreter when the user types in code. This is just a wrapper\n  * around a Jetty server.\n  */\n-private[spark] class HttpServer(resourceBase: File, securityManager: SecurityManager)\n-    extends Logging {\n+private[spark] class HttpServer(resourceBase: File,\n+                                securityManager: SecurityManager,\n+                                localPort: Int = 0) extends Logging {\n   private var server: Server = null\n-  private var port: Int = -1\n+  private var port: Int = localPort\n+\n+  private def startOnPort(startPort: Int): Tuple2[Server,Int] = {\n+    val server = new Server()\n+    val connector = new SocketConnector\n+    connector.setMaxIdleTime(60*1000)\n+    connector.setSoLingerTime(-1)\n+    connector.setPort(startPort)\n+    server.addConnector(connector)\n+\n+    val threadPool = new QueuedThreadPool\n+    threadPool.setDaemon(true)\n+    server.setThreadPool(threadPool)\n+    val resHandler = new ResourceHandler\n+    resHandler.setResourceBase(resourceBase.getAbsolutePath)\n+\n+    val handlerList = new HandlerList\n+    handlerList.setHandlers(Array(resHandler, new DefaultHandler))\n+\n+    if (securityManager.isAuthenticationEnabled()) {\n+      logDebug(\"HttpServer is using security\")\n+      val sh = setupSecurityHandler(securityManager)\n+      // make sure we go through security handler to get resources\n+      sh.setHandler(handlerList)\n+      server.setHandler(sh)\n+    } else {\n+      logDebug(\"HttpServer is not using security\")\n+      server.setHandler(handlerList)\n+    }\n+\n+    server.start()\n+    val actualPort = server.getConnectors()(0).getLocalPort()\n+\n+    return (server, actualPort)\n+  }\n+\n+  private def startWithIncrements(startPort: Int, maxRetries: Int): Tuple2[Server,Int] = {\n+    for( offset <- 0 to maxRetries) {"
  }, {
    "author": {
      "login": "ash211"
    },
    "body": "Agreed.  It's slightly tricky since starting the service is slightly different between the Jetty server and the raw socket, but I think I can wrap the side effects up with a parametrized function on the method and make it work\n\nSomething like:\n\n`startWithIncrements[T](startPort: Int, maxRetries: Int, startListening: Unit => T) : Tuple2[T,Int] = {`\n\nDoes that sound right?\n\nI'm not going to be able to work on this for a bit so if you'd like to take a whack go for it.  Otherwise I may have something late on Friday.\n",
    "commit": "038a579a26ffcfc1c5540f28176f236779eef12a",
    "createdAt": "2014-06-19T06:42:12Z",
    "diffHunk": "@@ -41,45 +41,73 @@ private[spark] class ServerStateException(message: String) extends Exception(mes\n  * as well as classes created by the interpreter when the user types in code. This is just a wrapper\n  * around a Jetty server.\n  */\n-private[spark] class HttpServer(resourceBase: File, securityManager: SecurityManager)\n-    extends Logging {\n+private[spark] class HttpServer(resourceBase: File,\n+                                securityManager: SecurityManager,\n+                                localPort: Int = 0) extends Logging {\n   private var server: Server = null\n-  private var port: Int = -1\n+  private var port: Int = localPort\n+\n+  private def startOnPort(startPort: Int): Tuple2[Server,Int] = {\n+    val server = new Server()\n+    val connector = new SocketConnector\n+    connector.setMaxIdleTime(60*1000)\n+    connector.setSoLingerTime(-1)\n+    connector.setPort(startPort)\n+    server.addConnector(connector)\n+\n+    val threadPool = new QueuedThreadPool\n+    threadPool.setDaemon(true)\n+    server.setThreadPool(threadPool)\n+    val resHandler = new ResourceHandler\n+    resHandler.setResourceBase(resourceBase.getAbsolutePath)\n+\n+    val handlerList = new HandlerList\n+    handlerList.setHandlers(Array(resHandler, new DefaultHandler))\n+\n+    if (securityManager.isAuthenticationEnabled()) {\n+      logDebug(\"HttpServer is using security\")\n+      val sh = setupSecurityHandler(securityManager)\n+      // make sure we go through security handler to get resources\n+      sh.setHandler(handlerList)\n+      server.setHandler(sh)\n+    } else {\n+      logDebug(\"HttpServer is not using security\")\n+      server.setHandler(handlerList)\n+    }\n+\n+    server.start()\n+    val actualPort = server.getConnectors()(0).getLocalPort()\n+\n+    return (server, actualPort)\n+  }\n+\n+  private def startWithIncrements(startPort: Int, maxRetries: Int): Tuple2[Server,Int] = {\n+    for( offset <- 0 to maxRetries) {"
  }],
  "prId": 1107
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "this should go down with the other spark import\nhttps://cwiki.apache.org/confluence/display/SPARK/Spark+Code+Style+Guide#SparkCodeStyleGuide-Imports\n",
    "commit": "038a579a26ffcfc1c5540f28176f236779eef12a",
    "createdAt": "2014-07-31T00:20:01Z",
    "diffHunk": "@@ -19,6 +19,7 @@ package org.apache.spark\n \n import java.io.File\n \n+import org.apache.spark.network.PortManager",
    "line": 4
  }],
  "prId": 1107
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "could this be called `requestedPort` to make it a bit more clear?\n",
    "commit": "038a579a26ffcfc1c5540f28176f236779eef12a",
    "createdAt": "2014-07-31T00:24:18Z",
    "diffHunk": "@@ -41,45 +42,54 @@ private[spark] class ServerStateException(message: String) extends Exception(mes\n  * as well as classes created by the interpreter when the user types in code. This is just a wrapper\n  * around a Jetty server.\n  */\n-private[spark] class HttpServer(resourceBase: File, securityManager: SecurityManager)\n-    extends Logging {\n+private[spark] class HttpServer(resourceBase: File,\n+                                securityManager: SecurityManager,\n+                                localPort: Int = 0) extends Logging {",
    "line": 16
  }],
  "prId": 1107
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Would it be a good idea to modify `startWithIncrements` to accept the name of the service being started? I'm a bit worried about the case where the user tries to lock down all the ports, but there is contention. Instead of failing there Spark will just log a WARN message, so at least we should say what component is contended in the WARN message.\n",
    "commit": "038a579a26ffcfc1c5540f28176f236779eef12a",
    "createdAt": "2014-07-31T00:27:05Z",
    "diffHunk": "@@ -41,45 +42,54 @@ private[spark] class ServerStateException(message: String) extends Exception(mes\n  * as well as classes created by the interpreter when the user types in code. This is just a wrapper\n  * around a Jetty server.\n  */\n-private[spark] class HttpServer(resourceBase: File, securityManager: SecurityManager)\n-    extends Logging {\n+private[spark] class HttpServer(resourceBase: File,\n+                                securityManager: SecurityManager,\n+                                localPort: Int = 0) extends Logging {\n   private var server: Server = null\n-  private var port: Int = -1\n+  private var port: Int = localPort\n+\n+  private def startOnPort(startPort: Int): (Server, Int) = {\n+    val server = new Server()\n+    val connector = new SocketConnector\n+    connector.setMaxIdleTime(60*1000)\n+    connector.setSoLingerTime(-1)\n+    connector.setPort(startPort)\n+    server.addConnector(connector)\n+\n+    val threadPool = new QueuedThreadPool\n+    threadPool.setDaemon(true)\n+    server.setThreadPool(threadPool)\n+    val resHandler = new ResourceHandler\n+    resHandler.setResourceBase(resourceBase.getAbsolutePath)\n+\n+    val handlerList = new HandlerList\n+    handlerList.setHandlers(Array(resHandler, new DefaultHandler))\n+\n+    if (securityManager.isAuthenticationEnabled()) {\n+      logDebug(\"HttpServer is using security\")\n+      val sh = setupSecurityHandler(securityManager)\n+      // make sure we go through security handler to get resources\n+      sh.setHandler(handlerList)\n+      server.setHandler(sh)\n+    } else {\n+      logDebug(\"HttpServer is not using security\")\n+      server.setHandler(handlerList)\n+    }\n+\n+    server.start()\n+    val actualPort = server.getConnectors()(0).getLocalPort()\n+\n+    (server, actualPort)\n+  }\n \n   def start() {\n     if (server != null) {\n       throw new ServerStateException(\"Server is already started\")\n     } else {\n       logInfo(\"Starting HTTP Server\")\n-      server = new Server()\n-      val connector = new SocketConnector\n-      connector.setMaxIdleTime(60*1000)\n-      connector.setSoLingerTime(-1)\n-      connector.setPort(0)\n-      server.addConnector(connector)\n-\n-      val threadPool = new QueuedThreadPool\n-      threadPool.setDaemon(true)\n-      server.setThreadPool(threadPool)\n-      val resHandler = new ResourceHandler\n-      resHandler.setResourceBase(resourceBase.getAbsolutePath)\n-\n-      val handlerList = new HandlerList\n-      handlerList.setHandlers(Array(resHandler, new DefaultHandler))\n-\n-      if (securityManager.isAuthenticationEnabled()) {\n-        logDebug(\"HttpServer is using security\")\n-        val sh = setupSecurityHandler(securityManager)\n-        // make sure we go through security handler to get resources\n-        sh.setHandler(handlerList)\n-        server.setHandler(sh)\n-      } else {\n-        logDebug(\"HttpServer is not using security\")\n-        server.setHandler(handlerList)\n-      }\n-\n-      server.start()\n-      port = server.getConnectors()(0).getLocalPort()\n+      val (actualServer, actualPort) = PortManager.startWithIncrements(localPort, 3, startOnPort)",
    "line": 89
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "you could just add an argument:\n\n```\ndef startWithIncrements[T](startPort: Int, maxRetries: Int, startService: Int => (T, Int), serviceName: String):\n```\n",
    "commit": "038a579a26ffcfc1c5540f28176f236779eef12a",
    "createdAt": "2014-07-31T00:27:42Z",
    "diffHunk": "@@ -41,45 +42,54 @@ private[spark] class ServerStateException(message: String) extends Exception(mes\n  * as well as classes created by the interpreter when the user types in code. This is just a wrapper\n  * around a Jetty server.\n  */\n-private[spark] class HttpServer(resourceBase: File, securityManager: SecurityManager)\n-    extends Logging {\n+private[spark] class HttpServer(resourceBase: File,\n+                                securityManager: SecurityManager,\n+                                localPort: Int = 0) extends Logging {\n   private var server: Server = null\n-  private var port: Int = -1\n+  private var port: Int = localPort\n+\n+  private def startOnPort(startPort: Int): (Server, Int) = {\n+    val server = new Server()\n+    val connector = new SocketConnector\n+    connector.setMaxIdleTime(60*1000)\n+    connector.setSoLingerTime(-1)\n+    connector.setPort(startPort)\n+    server.addConnector(connector)\n+\n+    val threadPool = new QueuedThreadPool\n+    threadPool.setDaemon(true)\n+    server.setThreadPool(threadPool)\n+    val resHandler = new ResourceHandler\n+    resHandler.setResourceBase(resourceBase.getAbsolutePath)\n+\n+    val handlerList = new HandlerList\n+    handlerList.setHandlers(Array(resHandler, new DefaultHandler))\n+\n+    if (securityManager.isAuthenticationEnabled()) {\n+      logDebug(\"HttpServer is using security\")\n+      val sh = setupSecurityHandler(securityManager)\n+      // make sure we go through security handler to get resources\n+      sh.setHandler(handlerList)\n+      server.setHandler(sh)\n+    } else {\n+      logDebug(\"HttpServer is not using security\")\n+      server.setHandler(handlerList)\n+    }\n+\n+    server.start()\n+    val actualPort = server.getConnectors()(0).getLocalPort()\n+\n+    (server, actualPort)\n+  }\n \n   def start() {\n     if (server != null) {\n       throw new ServerStateException(\"Server is already started\")\n     } else {\n       logInfo(\"Starting HTTP Server\")\n-      server = new Server()\n-      val connector = new SocketConnector\n-      connector.setMaxIdleTime(60*1000)\n-      connector.setSoLingerTime(-1)\n-      connector.setPort(0)\n-      server.addConnector(connector)\n-\n-      val threadPool = new QueuedThreadPool\n-      threadPool.setDaemon(true)\n-      server.setThreadPool(threadPool)\n-      val resHandler = new ResourceHandler\n-      resHandler.setResourceBase(resourceBase.getAbsolutePath)\n-\n-      val handlerList = new HandlerList\n-      handlerList.setHandlers(Array(resHandler, new DefaultHandler))\n-\n-      if (securityManager.isAuthenticationEnabled()) {\n-        logDebug(\"HttpServer is using security\")\n-        val sh = setupSecurityHandler(securityManager)\n-        // make sure we go through security handler to get resources\n-        sh.setHandler(handlerList)\n-        server.setHandler(sh)\n-      } else {\n-        logDebug(\"HttpServer is not using security\")\n-        server.setHandler(handlerList)\n-      }\n-\n-      server.start()\n-      port = server.getConnectors()(0).getLocalPort()\n+      val (actualServer, actualPort) = PortManager.startWithIncrements(localPort, 3, startOnPort)",
    "line": 89
  }],
  "prId": 1107
}]