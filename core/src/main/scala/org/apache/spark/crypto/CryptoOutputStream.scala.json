[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: parameters are not aligned according to Spark style.\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-08T23:48:35Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,"
  }],
  "prId": 8880
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: this line should be indented.\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-08T23:48:44Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,\n+                         keyVal: Array[Byte], ivVal: Array[Byte], streamOffsetVal: Long) extends\n+FilterOutputStream(out: OutputStream) with Logging {"
  }],
  "prId": 8880
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This catch block isn't really doing anything.\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-08T23:50:16Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,\n+                         keyVal: Array[Byte], ivVal: Array[Byte], streamOffsetVal: Long) extends\n+FilterOutputStream(out: OutputStream) with Logging {\n+  var codec: CryptoCodec = null\n+  var encryptor: Encryptor = null\n+  var bufferSize: Int = 0\n+  /**\n+   * Input data buffer. The data starts at inBuffer.position() and ends at\n+   * inBuffer.limit().\n+   */\n+  var inBuffer: ByteBuffer = null\n+  /**\n+   * Encrypted data buffer. The data starts at outBuffer.position() and ends at\n+   * outBuffer.limit();\n+   */\n+  var outBuffer: ByteBuffer = null\n+  var streamOffset: Long = 0\n+  /**\n+   * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}\n+   * before any other data goes in. The purpose of padding is to put input data\n+   * at proper position.\n+   */\n+  var padding: Byte = 0\n+  var closed: Boolean = false\n+  var key: Array[Byte] = null\n+  var initIV: Array[Byte] = null\n+  var iv: Array[Byte] = null\n+  var tmpBuf: Array[Byte] = null\n+  val oneByteBuf: Array[Byte] = new Array[Byte](1)\n+\n+  CryptoStreamUtils.checkCodec(codecVal)\n+  bufferSize = CryptoStreamUtils.checkBufferSize(codecVal, bufferSizeVal)\n+  codec = codecVal\n+  key = keyVal.clone\n+  initIV = ivVal.clone\n+  iv = ivVal.clone\n+  inBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  outBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  streamOffset = streamOffsetVal\n+  try {\n+    encryptor = codec.createEncryptor\n+  }\n+  catch {"
  }],
  "prId": 8880
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "These methods need to be properly declared. I'll stop pointing these out.\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-08T23:51:02Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,\n+                         keyVal: Array[Byte], ivVal: Array[Byte], streamOffsetVal: Long) extends\n+FilterOutputStream(out: OutputStream) with Logging {\n+  var codec: CryptoCodec = null\n+  var encryptor: Encryptor = null\n+  var bufferSize: Int = 0\n+  /**\n+   * Input data buffer. The data starts at inBuffer.position() and ends at\n+   * inBuffer.limit().\n+   */\n+  var inBuffer: ByteBuffer = null\n+  /**\n+   * Encrypted data buffer. The data starts at outBuffer.position() and ends at\n+   * outBuffer.limit();\n+   */\n+  var outBuffer: ByteBuffer = null\n+  var streamOffset: Long = 0\n+  /**\n+   * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}\n+   * before any other data goes in. The purpose of padding is to put input data\n+   * at proper position.\n+   */\n+  var padding: Byte = 0\n+  var closed: Boolean = false\n+  var key: Array[Byte] = null\n+  var initIV: Array[Byte] = null\n+  var iv: Array[Byte] = null\n+  var tmpBuf: Array[Byte] = null\n+  val oneByteBuf: Array[Byte] = new Array[Byte](1)\n+\n+  CryptoStreamUtils.checkCodec(codecVal)\n+  bufferSize = CryptoStreamUtils.checkBufferSize(codecVal, bufferSizeVal)\n+  codec = codecVal\n+  key = keyVal.clone\n+  initIV = ivVal.clone\n+  iv = ivVal.clone\n+  inBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  outBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  streamOffset = streamOffsetVal\n+  try {\n+    encryptor = codec.createEncryptor\n+  }\n+  catch {\n+    case e: GeneralSecurityException => {\n+      throw e\n+    }\n+  }\n+  updateEncryptor\n+\n+\n+  def this(out: OutputStream, codec: CryptoCodec, bufferSize: Int, key: Array[Byte],\n+           iv: Array[Byte]) {\n+    this(out, codec, bufferSize, key, iv, 0)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte], streamOffset:\n+  Long) {\n+    this(out, codec, CryptoStreamUtils.getBufferSize, key, iv, streamOffset)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte]) {\n+    this(out, codec, key, iv, 0)\n+  }\n+\n+  def getWrappedStream: OutputStream = {\n+    out\n+  }\n+\n+  /**\n+   * Encryption is buffer based.\n+   * If there is enough room in {@link #inBuffer}, then write to this buffer.\n+   * If {@link #inBuffer} is full, then do encryption and write data to the\n+   * underlying stream.\n+   * @param b the data.\n+   * @param offVal the start offset in the data.\n+   * @param lenVal the number of bytes to write.\n+   * @throws IOException\n+   */\n+  override def write(b: Array[Byte], offVal: Int, lenVal: Int) {\n+    var off = offVal\n+    var len = lenVal\n+    checkStream\n+    if (b == null) {\n+      throw new NullPointerException\n+    }\n+    else if (off < 0 || len < 0 || off > b.length || len > b.length - off) {\n+      throw new IndexOutOfBoundsException\n+    }\n+    while (len > 0) {\n+      val remaining: Int = inBuffer.remaining\n+      if (len < remaining) {\n+        inBuffer.put(b, off, len)\n+        len = 0\n+      }\n+      else {\n+        inBuffer.put(b, off, remaining)\n+        off += remaining\n+        len -= remaining\n+        encrypt\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Do the encryption, input is {@link #inBuffer} and output is\n+   * {@link #outBuffer}.\n+   */\n+  def encrypt {"
  }],
  "prId": 8880
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "You could use `Preconditions.checkNotNull`.\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-08T23:52:02Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,\n+                         keyVal: Array[Byte], ivVal: Array[Byte], streamOffsetVal: Long) extends\n+FilterOutputStream(out: OutputStream) with Logging {\n+  var codec: CryptoCodec = null\n+  var encryptor: Encryptor = null\n+  var bufferSize: Int = 0\n+  /**\n+   * Input data buffer. The data starts at inBuffer.position() and ends at\n+   * inBuffer.limit().\n+   */\n+  var inBuffer: ByteBuffer = null\n+  /**\n+   * Encrypted data buffer. The data starts at outBuffer.position() and ends at\n+   * outBuffer.limit();\n+   */\n+  var outBuffer: ByteBuffer = null\n+  var streamOffset: Long = 0\n+  /**\n+   * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}\n+   * before any other data goes in. The purpose of padding is to put input data\n+   * at proper position.\n+   */\n+  var padding: Byte = 0\n+  var closed: Boolean = false\n+  var key: Array[Byte] = null\n+  var initIV: Array[Byte] = null\n+  var iv: Array[Byte] = null\n+  var tmpBuf: Array[Byte] = null\n+  val oneByteBuf: Array[Byte] = new Array[Byte](1)\n+\n+  CryptoStreamUtils.checkCodec(codecVal)\n+  bufferSize = CryptoStreamUtils.checkBufferSize(codecVal, bufferSizeVal)\n+  codec = codecVal\n+  key = keyVal.clone\n+  initIV = ivVal.clone\n+  iv = ivVal.clone\n+  inBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  outBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  streamOffset = streamOffsetVal\n+  try {\n+    encryptor = codec.createEncryptor\n+  }\n+  catch {\n+    case e: GeneralSecurityException => {\n+      throw e\n+    }\n+  }\n+  updateEncryptor\n+\n+\n+  def this(out: OutputStream, codec: CryptoCodec, bufferSize: Int, key: Array[Byte],\n+           iv: Array[Byte]) {\n+    this(out, codec, bufferSize, key, iv, 0)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte], streamOffset:\n+  Long) {\n+    this(out, codec, CryptoStreamUtils.getBufferSize, key, iv, streamOffset)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte]) {\n+    this(out, codec, key, iv, 0)\n+  }\n+\n+  def getWrappedStream: OutputStream = {\n+    out\n+  }\n+\n+  /**\n+   * Encryption is buffer based.\n+   * If there is enough room in {@link #inBuffer}, then write to this buffer.\n+   * If {@link #inBuffer} is full, then do encryption and write data to the\n+   * underlying stream.\n+   * @param b the data.\n+   * @param offVal the start offset in the data.\n+   * @param lenVal the number of bytes to write.\n+   * @throws IOException\n+   */\n+  override def write(b: Array[Byte], offVal: Int, lenVal: Int) {\n+    var off = offVal\n+    var len = lenVal\n+    checkStream\n+    if (b == null) {"
  }],
  "prId": 8880
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why not initialize this in the constructor? Lazy initialization doesn't seem to be buying anything (unless you never write anything to the stream).\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-09T00:01:18Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,\n+                         keyVal: Array[Byte], ivVal: Array[Byte], streamOffsetVal: Long) extends\n+FilterOutputStream(out: OutputStream) with Logging {\n+  var codec: CryptoCodec = null\n+  var encryptor: Encryptor = null\n+  var bufferSize: Int = 0\n+  /**\n+   * Input data buffer. The data starts at inBuffer.position() and ends at\n+   * inBuffer.limit().\n+   */\n+  var inBuffer: ByteBuffer = null\n+  /**\n+   * Encrypted data buffer. The data starts at outBuffer.position() and ends at\n+   * outBuffer.limit();\n+   */\n+  var outBuffer: ByteBuffer = null\n+  var streamOffset: Long = 0\n+  /**\n+   * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}\n+   * before any other data goes in. The purpose of padding is to put input data\n+   * at proper position.\n+   */\n+  var padding: Byte = 0\n+  var closed: Boolean = false\n+  var key: Array[Byte] = null\n+  var initIV: Array[Byte] = null\n+  var iv: Array[Byte] = null\n+  var tmpBuf: Array[Byte] = null\n+  val oneByteBuf: Array[Byte] = new Array[Byte](1)\n+\n+  CryptoStreamUtils.checkCodec(codecVal)\n+  bufferSize = CryptoStreamUtils.checkBufferSize(codecVal, bufferSizeVal)\n+  codec = codecVal\n+  key = keyVal.clone\n+  initIV = ivVal.clone\n+  iv = ivVal.clone\n+  inBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  outBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  streamOffset = streamOffsetVal\n+  try {\n+    encryptor = codec.createEncryptor\n+  }\n+  catch {\n+    case e: GeneralSecurityException => {\n+      throw e\n+    }\n+  }\n+  updateEncryptor\n+\n+\n+  def this(out: OutputStream, codec: CryptoCodec, bufferSize: Int, key: Array[Byte],\n+           iv: Array[Byte]) {\n+    this(out, codec, bufferSize, key, iv, 0)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte], streamOffset:\n+  Long) {\n+    this(out, codec, CryptoStreamUtils.getBufferSize, key, iv, streamOffset)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte]) {\n+    this(out, codec, key, iv, 0)\n+  }\n+\n+  def getWrappedStream: OutputStream = {\n+    out\n+  }\n+\n+  /**\n+   * Encryption is buffer based.\n+   * If there is enough room in {@link #inBuffer}, then write to this buffer.\n+   * If {@link #inBuffer} is full, then do encryption and write data to the\n+   * underlying stream.\n+   * @param b the data.\n+   * @param offVal the start offset in the data.\n+   * @param lenVal the number of bytes to write.\n+   * @throws IOException\n+   */\n+  override def write(b: Array[Byte], offVal: Int, lenVal: Int) {\n+    var off = offVal\n+    var len = lenVal\n+    checkStream\n+    if (b == null) {\n+      throw new NullPointerException\n+    }\n+    else if (off < 0 || len < 0 || off > b.length || len > b.length - off) {\n+      throw new IndexOutOfBoundsException\n+    }\n+    while (len > 0) {\n+      val remaining: Int = inBuffer.remaining\n+      if (len < remaining) {\n+        inBuffer.put(b, off, len)\n+        len = 0\n+      }\n+      else {\n+        inBuffer.put(b, off, remaining)\n+        off += remaining\n+        len -= remaining\n+        encrypt\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Do the encryption, input is {@link #inBuffer} and output is\n+   * {@link #outBuffer}.\n+   */\n+  def encrypt {\n+    Preconditions.checkState(inBuffer.position >= padding)\n+    if (inBuffer.position != padding) {\n+      inBuffer.flip\n+      outBuffer.clear\n+      encryptor.encrypt(inBuffer, outBuffer)\n+      inBuffer.clear\n+      outBuffer.flip\n+      if (padding > 0) {\n+        outBuffer.position(padding)\n+        padding = 0\n+      }\n+      val len: Int = outBuffer.remaining\n+      val tmp: Array[Byte] = getTmpBuf\n+      outBuffer.get(tmp, 0, len)\n+      out.write(tmp, 0, len)\n+      streamOffset += len\n+      if (encryptor.isContextReset) {\n+        updateEncryptor\n+      }\n+    }\n+  }\n+\n+  /** Update the {@link #encryptor}: calculate counter and {@link #padding}. */\n+  def updateEncryptor {\n+    val counter: Long = streamOffset / codec.getCipherSuite.algoBlockSize\n+    padding = (streamOffset % codec.getCipherSuite.algoBlockSize).asInstanceOf[Byte]\n+    inBuffer.position(padding)\n+    codec.calculateIV(initIV, counter, iv)\n+    encryptor.init(key, iv)\n+  }\n+\n+  def getTmpBuf: Array[Byte] = {\n+    if (tmpBuf == null) {"
  }],
  "prId": 8880
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "There's no other synchronization in this class, which makes me think this one is unnecessary. The stream is just not thread-safe.\n",
    "commit": "928a59bc4566ec40e6caeccbc628369f050c31c9",
    "createdAt": "2015-10-09T00:04:59Z",
    "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.crypto\n+\n+import java.io.{IOException, FilterOutputStream, OutputStream}\n+import java.nio.ByteBuffer\n+import java.security.GeneralSecurityException\n+\n+import com.google.common.base.Preconditions\n+\n+import org.apache.spark.Logging\n+\n+/**\n+ * CryptoOutputStream encrypts data. It is not thread-safe. AES CTR mode is\n+ * required in order to ensure that the plain text and cipher text have a 1:1\n+ * mapping. The encryption is buffer based. The key points of the encryption are\n+ * (1) calculating counter and (2) padding through stream position.\n+ * <p/>\n+ * counter = base + pos/(algorithm blocksize);\n+ * padding = pos%(algorithm blocksize);\n+ * <p/>\n+ * The underlying stream offset is maintained as state.\n+ */\n+class CryptoOutputStream(out: OutputStream, codecVal: CryptoCodec, bufferSizeVal: Int,\n+                         keyVal: Array[Byte], ivVal: Array[Byte], streamOffsetVal: Long) extends\n+FilterOutputStream(out: OutputStream) with Logging {\n+  var codec: CryptoCodec = null\n+  var encryptor: Encryptor = null\n+  var bufferSize: Int = 0\n+  /**\n+   * Input data buffer. The data starts at inBuffer.position() and ends at\n+   * inBuffer.limit().\n+   */\n+  var inBuffer: ByteBuffer = null\n+  /**\n+   * Encrypted data buffer. The data starts at outBuffer.position() and ends at\n+   * outBuffer.limit();\n+   */\n+  var outBuffer: ByteBuffer = null\n+  var streamOffset: Long = 0\n+  /**\n+   * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}\n+   * before any other data goes in. The purpose of padding is to put input data\n+   * at proper position.\n+   */\n+  var padding: Byte = 0\n+  var closed: Boolean = false\n+  var key: Array[Byte] = null\n+  var initIV: Array[Byte] = null\n+  var iv: Array[Byte] = null\n+  var tmpBuf: Array[Byte] = null\n+  val oneByteBuf: Array[Byte] = new Array[Byte](1)\n+\n+  CryptoStreamUtils.checkCodec(codecVal)\n+  bufferSize = CryptoStreamUtils.checkBufferSize(codecVal, bufferSizeVal)\n+  codec = codecVal\n+  key = keyVal.clone\n+  initIV = ivVal.clone\n+  iv = ivVal.clone\n+  inBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  outBuffer = ByteBuffer.allocateDirect(bufferSize)\n+  streamOffset = streamOffsetVal\n+  try {\n+    encryptor = codec.createEncryptor\n+  }\n+  catch {\n+    case e: GeneralSecurityException => {\n+      throw e\n+    }\n+  }\n+  updateEncryptor\n+\n+\n+  def this(out: OutputStream, codec: CryptoCodec, bufferSize: Int, key: Array[Byte],\n+           iv: Array[Byte]) {\n+    this(out, codec, bufferSize, key, iv, 0)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte], streamOffset:\n+  Long) {\n+    this(out, codec, CryptoStreamUtils.getBufferSize, key, iv, streamOffset)\n+  }\n+\n+  def this(out: OutputStream, codec: CryptoCodec, key: Array[Byte], iv: Array[Byte]) {\n+    this(out, codec, key, iv, 0)\n+  }\n+\n+  def getWrappedStream: OutputStream = {\n+    out\n+  }\n+\n+  /**\n+   * Encryption is buffer based.\n+   * If there is enough room in {@link #inBuffer}, then write to this buffer.\n+   * If {@link #inBuffer} is full, then do encryption and write data to the\n+   * underlying stream.\n+   * @param b the data.\n+   * @param offVal the start offset in the data.\n+   * @param lenVal the number of bytes to write.\n+   * @throws IOException\n+   */\n+  override def write(b: Array[Byte], offVal: Int, lenVal: Int) {\n+    var off = offVal\n+    var len = lenVal\n+    checkStream\n+    if (b == null) {\n+      throw new NullPointerException\n+    }\n+    else if (off < 0 || len < 0 || off > b.length || len > b.length - off) {\n+      throw new IndexOutOfBoundsException\n+    }\n+    while (len > 0) {\n+      val remaining: Int = inBuffer.remaining\n+      if (len < remaining) {\n+        inBuffer.put(b, off, len)\n+        len = 0\n+      }\n+      else {\n+        inBuffer.put(b, off, remaining)\n+        off += remaining\n+        len -= remaining\n+        encrypt\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Do the encryption, input is {@link #inBuffer} and output is\n+   * {@link #outBuffer}.\n+   */\n+  def encrypt {\n+    Preconditions.checkState(inBuffer.position >= padding)\n+    if (inBuffer.position != padding) {\n+      inBuffer.flip\n+      outBuffer.clear\n+      encryptor.encrypt(inBuffer, outBuffer)\n+      inBuffer.clear\n+      outBuffer.flip\n+      if (padding > 0) {\n+        outBuffer.position(padding)\n+        padding = 0\n+      }\n+      val len: Int = outBuffer.remaining\n+      val tmp: Array[Byte] = getTmpBuf\n+      outBuffer.get(tmp, 0, len)\n+      out.write(tmp, 0, len)\n+      streamOffset += len\n+      if (encryptor.isContextReset) {\n+        updateEncryptor\n+      }\n+    }\n+  }\n+\n+  /** Update the {@link #encryptor}: calculate counter and {@link #padding}. */\n+  def updateEncryptor {\n+    val counter: Long = streamOffset / codec.getCipherSuite.algoBlockSize\n+    padding = (streamOffset % codec.getCipherSuite.algoBlockSize).asInstanceOf[Byte]\n+    inBuffer.position(padding)\n+    codec.calculateIV(initIV, counter, iv)\n+    encryptor.init(key, iv)\n+  }\n+\n+  def getTmpBuf: Array[Byte] = {\n+    if (tmpBuf == null) {\n+      tmpBuf = new Array[Byte](bufferSize)\n+    }\n+    tmpBuf\n+  }\n+\n+  override def close {\n+    this.synchronized {"
  }],
  "prId": 8880
}]