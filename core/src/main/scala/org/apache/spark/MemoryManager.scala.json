[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can you move this somewhere else that's not at the top level? I'd like to minimize the number of private[spark] that appears in the top level.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-07T20:09:40Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "+1 on moving this out of the top-level and into a new package (maybe `spark.memory` ?). This will also provide a convenient way to group the memory-related classes together post-refactoring.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T19:33:48Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This releases all storage memory acquired JVM-wide, across all tasks?\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T18:43:10Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {\n+\n+  /**\n+   * Acquire N bytes of memory for execution.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireExecutionMemory(numBytes: Long): Long\n+\n+  /**\n+   * Acquire N bytes of memory to cache the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (0 or N).\n+   */\n+  def acquireStorageMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Acquire N bytes of memory to unroll the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireUnrollMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Release N bytes of execution memory.\n+   */\n+  def releaseExecutionMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release N bytes of storage memory.\n+   */\n+  def releaseStorageMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release all storage memory acquired."
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "yes, it's called in `MemoryStore#clear`\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T19:11:06Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {\n+\n+  /**\n+   * Acquire N bytes of memory for execution.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireExecutionMemory(numBytes: Long): Long\n+\n+  /**\n+   * Acquire N bytes of memory to cache the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (0 or N).\n+   */\n+  def acquireStorageMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Acquire N bytes of memory to unroll the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireUnrollMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Release N bytes of execution memory.\n+   */\n+  def releaseExecutionMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release N bytes of storage memory.\n+   */\n+  def releaseStorageMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release all storage memory acquired."
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Ah. It looks like `BlockStore#clear` is only called during SparkContext shutdown, so I guess it technically doesn't matter if you update the memory accounting there. Doesn't hurt, I guess, but not strictly necessary.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T19:30:48Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {\n+\n+  /**\n+   * Acquire N bytes of memory for execution.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireExecutionMemory(numBytes: Long): Long\n+\n+  /**\n+   * Acquire N bytes of memory to cache the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (0 or N).\n+   */\n+  def acquireStorageMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Acquire N bytes of memory to unroll the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireUnrollMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Release N bytes of execution memory.\n+   */\n+  def releaseExecutionMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release N bytes of storage memory.\n+   */\n+  def releaseStorageMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release all storage memory acquired."
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "You know, if `def releaseStorageMemory(numBytes: Long)` doesn't throw when releasing more than the total amount of storage memory, you could just eliminate this method and call `releaseStorageMemory(Long.MAX_VALUE)` instead.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:17:07Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {\n+\n+  /**\n+   * Acquire N bytes of memory for execution.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireExecutionMemory(numBytes: Long): Long\n+\n+  /**\n+   * Acquire N bytes of memory to cache the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (0 or N).\n+   */\n+  def acquireStorageMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Acquire N bytes of memory to unroll the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireUnrollMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Release N bytes of execution memory.\n+   */\n+  def releaseExecutionMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release N bytes of storage memory.\n+   */\n+  def releaseStorageMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release all storage memory acquired."
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "I think releasing more than you have is a bad sign. I actually log a warning for that. It's probably OK to just keep this method.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-09T01:03:52Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage.\n+ *\n+ * In this context, execution memory refers to that used for computation in shuffles, joins,\n+ * sorts and aggregations, while storage memory refers to that used for caching and propagating\n+ * internal data across the cluster.\n+ */\n+private[spark] abstract class MemoryManager {\n+\n+  /**\n+   * Acquire N bytes of memory for execution.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireExecutionMemory(numBytes: Long): Long\n+\n+  /**\n+   * Acquire N bytes of memory to cache the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (0 or N).\n+   */\n+  def acquireStorageMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Acquire N bytes of memory to unroll the given block, evicting existing ones if necessary.\n+   * Blocks evicted in the process, if any, are added to `evictedBlocks`.\n+   * @return number of bytes successfully granted (<= N).\n+   */\n+  def acquireUnrollMemory(\n+      blockId: BlockId,\n+      numBytes: Long,\n+      evictedBlocks: mutable.Buffer[(BlockId, BlockStatus)]): Long\n+\n+  /**\n+   * Release N bytes of execution memory.\n+   */\n+  def releaseExecutionMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release N bytes of storage memory.\n+   */\n+  def releaseStorageMemory(numBytes: Long): Unit\n+\n+  /**\n+   * Release all storage memory acquired."
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Can you add a comment to clarify whether this is a one-per-JVM component or one-per-task component?\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T18:46:41Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+/**\n+ * An abstract memory manager that enforces how memory is shared between execution and storage."
  }],
  "prId": 9000
}]