[{
  "comments": [{
    "author": {
      "login": "holdenk"
    },
    "body": "Similar comment to as above - does this do what we want?\n",
    "commit": "a1f2faa99f7b6875885820893070c8b039ecddd7",
    "createdAt": "2016-09-28T15:21:17Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.broadcast\n+\n+import java.io.ObjectOutputStream\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.{BlockId, BlockResult, BroadcastBlockId, RDDBlockId, StorageLevel}\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A BitTorrent-like implementation of [[org.apache.spark.broadcast.Broadcast]].\n+ *\n+ * Different to [[TorrentBroadcast]], this implementation doesn't divide the object to broadcast.\n+ * In contrast, this implementation performs broadcast on executor side for a RDD. So the results\n+ * of the RDD does not need to collect first back to the driver before broadcasting.\n+ *\n+ * The mechanism is as follows:\n+ *\n+ * On each executor, the executor first attempts to fetch the object from its BlockManager. If\n+ * it doesn not exist, it then uses remote fetches to fetch the blocks of the RDD from other\n+ * executors if available. Once it gets the blocks, it puts the blocks in its own BlockManager,\n+ * ready for other executors to fetch from.\n+ *\n+ * @tparam T The type of the element of RDD to be broadcasted.\n+ * @tparam U The type of object transformed from the collection of elements of the RDD.\n+ *\n+ * @param numBlocks Total number of blocks this broadcast variable contains.\n+ * @param rddId The id of the RDD to be broadcasted on executors.\n+ * @param mode The [[BroadcastMode]] object used to transform the result of RDD to the object which\n+ *             will be stored in the [[BlockManager]].\n+ * @param id A unique identifier for the broadcast variable.\n+ */\n+private[spark] class TorrentExecutorBroadcast[T: ClassTag, U: ClassTag](\n+    numBlocks: Int,\n+    rddId: Int,\n+    mode: BroadcastMode[T],\n+    id: Long) extends Broadcast[U](id) with Logging with Serializable {\n+\n+  /**\n+   * Value of the broadcast object on executors. This is reconstructed by [[readBroadcastBlock]],\n+   * which builds this value by reading blocks from other executors.\n+   */\n+  @transient private lazy val _value: U = readBroadcastBlock()\n+\n+  private val broadcastId = BroadcastBlockId(id)\n+\n+  override protected def getValue() = {\n+    _value\n+  }\n+\n+  /** Fetch torrent blocks from other executors. */\n+  private def readBlocks(): Array[T] = {\n+    // Fetch chunks of data. Note that all these chunks are stored in the BlockManager and reported\n+    // to the driver, so other executors can pull these chunks from this executor as well.\n+    val blocks = new Array[Array[T]](numBlocks)\n+    val bm = SparkEnv.get.blockManager\n+\n+    for (pid <- Random.shuffle(Seq.range(0, numBlocks))) {\n+      val pieceId = RDDBlockId(rddId, pid)\n+      // First try getLocalValues because there is a chance that previous attempts to fetch the\n+      // broadcast blocks have already fetched some of the blocks. In that case, some blocks\n+      // would be available locally (on this executor).\n+      bm.getLocalValues(pieceId) match {\n+        case Some(block: BlockResult) =>\n+          blocks(pid) = block.data.asInstanceOf[Iterator[T]].toArray\n+        case None =>\n+          bm.get[T](pieceId) match {\n+            case Some(b) =>\n+              val data = b.data.asInstanceOf[Iterator[T]].toArray\n+              // We found the block from remote executors' BlockManager, so put the block\n+              // in this executor's BlockManager.\n+              if (!bm.putIterator(pieceId, data.toIterator,\n+                  StorageLevel.MEMORY_AND_DISK_SER, tellMaster = true)) {\n+                throw new SparkException(\n+                  s\"Failed to store $pieceId of $broadcastId in local BlockManager\")\n+              }\n+              blocks(pid) = data\n+            case None =>\n+              throw new SparkException(s\"Failed to get $pieceId of $broadcastId\")\n+          }\n+      }\n+    }\n+    blocks.flatMap(x => x)\n+  }\n+\n+  /**\n+   * Remove all persisted state associated with this Torrent broadcast on the executors.\n+   */\n+  override protected def doUnpersist(blocking: Boolean) {\n+    TorrentBroadcast.unpersist(id, removeFromDriver = false, blocking)",
    "line": 115
  }],
  "prId": 15178
}, {
  "comments": [{
    "author": {
      "login": "holdenk"
    },
    "body": "So were storing an RDD pieceId here, but I think in unpersist only things with `BroadcastBlockId` and the correct ID will be removed. Maybe it would be good to add a test around unpersistance to verify its behaving as expected?\n",
    "commit": "a1f2faa99f7b6875885820893070c8b039ecddd7",
    "createdAt": "2016-09-28T15:29:19Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.broadcast\n+\n+import java.io.ObjectOutputStream\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.{BlockId, BlockResult, BroadcastBlockId, RDDBlockId, StorageLevel}\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A BitTorrent-like implementation of [[org.apache.spark.broadcast.Broadcast]].\n+ *\n+ * Different to [[TorrentBroadcast]], this implementation doesn't divide the object to broadcast.\n+ * In contrast, this implementation performs broadcast on executor side for a RDD. So the results\n+ * of the RDD does not need to collect first back to the driver before broadcasting.\n+ *\n+ * The mechanism is as follows:\n+ *\n+ * On each executor, the executor first attempts to fetch the object from its BlockManager. If\n+ * it doesn not exist, it then uses remote fetches to fetch the blocks of the RDD from other\n+ * executors if available. Once it gets the blocks, it puts the blocks in its own BlockManager,\n+ * ready for other executors to fetch from.\n+ *\n+ * @tparam T The type of the element of RDD to be broadcasted.\n+ * @tparam U The type of object transformed from the collection of elements of the RDD.\n+ *\n+ * @param numBlocks Total number of blocks this broadcast variable contains.\n+ * @param rddId The id of the RDD to be broadcasted on executors.\n+ * @param mode The [[BroadcastMode]] object used to transform the result of RDD to the object which\n+ *             will be stored in the [[BlockManager]].\n+ * @param id A unique identifier for the broadcast variable.\n+ */\n+private[spark] class TorrentExecutorBroadcast[T: ClassTag, U: ClassTag](\n+    numBlocks: Int,\n+    rddId: Int,\n+    mode: BroadcastMode[T],\n+    id: Long) extends Broadcast[U](id) with Logging with Serializable {\n+\n+  /**\n+   * Value of the broadcast object on executors. This is reconstructed by [[readBroadcastBlock]],\n+   * which builds this value by reading blocks from other executors.\n+   */\n+  @transient private lazy val _value: U = readBroadcastBlock()\n+\n+  private val broadcastId = BroadcastBlockId(id)\n+\n+  override protected def getValue() = {\n+    _value\n+  }\n+\n+  /** Fetch torrent blocks from other executors. */\n+  private def readBlocks(): Array[T] = {\n+    // Fetch chunks of data. Note that all these chunks are stored in the BlockManager and reported\n+    // to the driver, so other executors can pull these chunks from this executor as well.\n+    val blocks = new Array[Array[T]](numBlocks)\n+    val bm = SparkEnv.get.blockManager\n+\n+    for (pid <- Random.shuffle(Seq.range(0, numBlocks))) {\n+      val pieceId = RDDBlockId(rddId, pid)\n+      // First try getLocalValues because there is a chance that previous attempts to fetch the\n+      // broadcast blocks have already fetched some of the blocks. In that case, some blocks\n+      // would be available locally (on this executor).\n+      bm.getLocalValues(pieceId) match {\n+        case Some(block: BlockResult) =>\n+          blocks(pid) = block.data.asInstanceOf[Iterator[T]].toArray\n+        case None =>\n+          bm.get[T](pieceId) match {\n+            case Some(b) =>\n+              val data = b.data.asInstanceOf[Iterator[T]].toArray\n+              // We found the block from remote executors' BlockManager, so put the block\n+              // in this executor's BlockManager.\n+              if (!bm.putIterator(pieceId, data.toIterator,",
    "line": 97
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "For RDD, there is a cleaning mechanism that the persisted pieces will be removed once the RDD is not referred. Because we fetch and use RDD pieces here instead of broadcast pieces in driver side broadcast, I think it should be fine to deliver the cleaning to current mechanism.\n",
    "commit": "a1f2faa99f7b6875885820893070c8b039ecddd7",
    "createdAt": "2016-09-29T01:45:47Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.broadcast\n+\n+import java.io.ObjectOutputStream\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.{BlockId, BlockResult, BroadcastBlockId, RDDBlockId, StorageLevel}\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A BitTorrent-like implementation of [[org.apache.spark.broadcast.Broadcast]].\n+ *\n+ * Different to [[TorrentBroadcast]], this implementation doesn't divide the object to broadcast.\n+ * In contrast, this implementation performs broadcast on executor side for a RDD. So the results\n+ * of the RDD does not need to collect first back to the driver before broadcasting.\n+ *\n+ * The mechanism is as follows:\n+ *\n+ * On each executor, the executor first attempts to fetch the object from its BlockManager. If\n+ * it doesn not exist, it then uses remote fetches to fetch the blocks of the RDD from other\n+ * executors if available. Once it gets the blocks, it puts the blocks in its own BlockManager,\n+ * ready for other executors to fetch from.\n+ *\n+ * @tparam T The type of the element of RDD to be broadcasted.\n+ * @tparam U The type of object transformed from the collection of elements of the RDD.\n+ *\n+ * @param numBlocks Total number of blocks this broadcast variable contains.\n+ * @param rddId The id of the RDD to be broadcasted on executors.\n+ * @param mode The [[BroadcastMode]] object used to transform the result of RDD to the object which\n+ *             will be stored in the [[BlockManager]].\n+ * @param id A unique identifier for the broadcast variable.\n+ */\n+private[spark] class TorrentExecutorBroadcast[T: ClassTag, U: ClassTag](\n+    numBlocks: Int,\n+    rddId: Int,\n+    mode: BroadcastMode[T],\n+    id: Long) extends Broadcast[U](id) with Logging with Serializable {\n+\n+  /**\n+   * Value of the broadcast object on executors. This is reconstructed by [[readBroadcastBlock]],\n+   * which builds this value by reading blocks from other executors.\n+   */\n+  @transient private lazy val _value: U = readBroadcastBlock()\n+\n+  private val broadcastId = BroadcastBlockId(id)\n+\n+  override protected def getValue() = {\n+    _value\n+  }\n+\n+  /** Fetch torrent blocks from other executors. */\n+  private def readBlocks(): Array[T] = {\n+    // Fetch chunks of data. Note that all these chunks are stored in the BlockManager and reported\n+    // to the driver, so other executors can pull these chunks from this executor as well.\n+    val blocks = new Array[Array[T]](numBlocks)\n+    val bm = SparkEnv.get.blockManager\n+\n+    for (pid <- Random.shuffle(Seq.range(0, numBlocks))) {\n+      val pieceId = RDDBlockId(rddId, pid)\n+      // First try getLocalValues because there is a chance that previous attempts to fetch the\n+      // broadcast blocks have already fetched some of the blocks. In that case, some blocks\n+      // would be available locally (on this executor).\n+      bm.getLocalValues(pieceId) match {\n+        case Some(block: BlockResult) =>\n+          blocks(pid) = block.data.asInstanceOf[Iterator[T]].toArray\n+        case None =>\n+          bm.get[T](pieceId) match {\n+            case Some(b) =>\n+              val data = b.data.asInstanceOf[Iterator[T]].toArray\n+              // We found the block from remote executors' BlockManager, so put the block\n+              // in this executor's BlockManager.\n+              if (!bm.putIterator(pieceId, data.toIterator,",
    "line": 97
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "One solution might be to store the fetched RDD pieces with broadcast piece ID, so in unpersist we can remove all the fetched pieces. However, then we must consider fetch both RDD piece IDs broadcast IDs from other executors under the BitTorrent-like approach. Thus I would prefer the above way and let current cleaning mechanism do its work.\n",
    "commit": "a1f2faa99f7b6875885820893070c8b039ecddd7",
    "createdAt": "2016-09-29T01:49:34Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.broadcast\n+\n+import java.io.ObjectOutputStream\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.storage.{BlockId, BlockResult, BroadcastBlockId, RDDBlockId, StorageLevel}\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A BitTorrent-like implementation of [[org.apache.spark.broadcast.Broadcast]].\n+ *\n+ * Different to [[TorrentBroadcast]], this implementation doesn't divide the object to broadcast.\n+ * In contrast, this implementation performs broadcast on executor side for a RDD. So the results\n+ * of the RDD does not need to collect first back to the driver before broadcasting.\n+ *\n+ * The mechanism is as follows:\n+ *\n+ * On each executor, the executor first attempts to fetch the object from its BlockManager. If\n+ * it doesn not exist, it then uses remote fetches to fetch the blocks of the RDD from other\n+ * executors if available. Once it gets the blocks, it puts the blocks in its own BlockManager,\n+ * ready for other executors to fetch from.\n+ *\n+ * @tparam T The type of the element of RDD to be broadcasted.\n+ * @tparam U The type of object transformed from the collection of elements of the RDD.\n+ *\n+ * @param numBlocks Total number of blocks this broadcast variable contains.\n+ * @param rddId The id of the RDD to be broadcasted on executors.\n+ * @param mode The [[BroadcastMode]] object used to transform the result of RDD to the object which\n+ *             will be stored in the [[BlockManager]].\n+ * @param id A unique identifier for the broadcast variable.\n+ */\n+private[spark] class TorrentExecutorBroadcast[T: ClassTag, U: ClassTag](\n+    numBlocks: Int,\n+    rddId: Int,\n+    mode: BroadcastMode[T],\n+    id: Long) extends Broadcast[U](id) with Logging with Serializable {\n+\n+  /**\n+   * Value of the broadcast object on executors. This is reconstructed by [[readBroadcastBlock]],\n+   * which builds this value by reading blocks from other executors.\n+   */\n+  @transient private lazy val _value: U = readBroadcastBlock()\n+\n+  private val broadcastId = BroadcastBlockId(id)\n+\n+  override protected def getValue() = {\n+    _value\n+  }\n+\n+  /** Fetch torrent blocks from other executors. */\n+  private def readBlocks(): Array[T] = {\n+    // Fetch chunks of data. Note that all these chunks are stored in the BlockManager and reported\n+    // to the driver, so other executors can pull these chunks from this executor as well.\n+    val blocks = new Array[Array[T]](numBlocks)\n+    val bm = SparkEnv.get.blockManager\n+\n+    for (pid <- Random.shuffle(Seq.range(0, numBlocks))) {\n+      val pieceId = RDDBlockId(rddId, pid)\n+      // First try getLocalValues because there is a chance that previous attempts to fetch the\n+      // broadcast blocks have already fetched some of the blocks. In that case, some blocks\n+      // would be available locally (on this executor).\n+      bm.getLocalValues(pieceId) match {\n+        case Some(block: BlockResult) =>\n+          blocks(pid) = block.data.asInstanceOf[Iterator[T]].toArray\n+        case None =>\n+          bm.get[T](pieceId) match {\n+            case Some(b) =>\n+              val data = b.data.asInstanceOf[Iterator[T]].toArray\n+              // We found the block from remote executors' BlockManager, so put the block\n+              // in this executor's BlockManager.\n+              if (!bm.putIterator(pieceId, data.toIterator,",
    "line": 97
  }],
  "prId": 15178
}]