[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maybe IllegalStateException?\n",
    "commit": "a5def400a54ac99e004dbf82764a36c9af092248",
    "createdAt": "2015-10-23T03:58:54Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc.netty\n+\n+import java.util.concurrent.Callable\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.network.client.{RpcResponseCallback, TransportClient}\n+import org.apache.spark.rpc.RpcAddress\n+\n+private[netty] case class OutboxMessage(content: Array[Byte], callback: RpcResponseCallback)\n+\n+private[netty] class Outbox(nettyEnv: NettyRpcEnv, val address: RpcAddress) {\n+\n+  outbox => // Give this an alias so we can use it more clearly in closures.\n+\n+  @GuardedBy(\"this\")\n+  private val messages = new java.util.LinkedList[OutboxMessage]\n+\n+  @GuardedBy(\"this\")\n+  private var client: TransportClient = null\n+\n+  /**\n+   * connectFuture points to the connect task. If there is no connect task, connectFuture will be\n+   * null.\n+   */\n+  @GuardedBy(\"this\")\n+  private var connectFuture: java.util.concurrent.Future[Unit] = null\n+\n+  @GuardedBy(\"this\")\n+  private var stopped = false\n+\n+  /**\n+   * If there is any thread draining the message queue\n+   */\n+  @GuardedBy(\"this\")\n+  private var draining = false\n+\n+  /**\n+   * Send a message. If there is no active connection, cache it and launch a new connection. If\n+   * [[Outbox]] is stopped, the sender will be notified with a [[SparkException]].",
    "line": 59
  }],
  "prId": 9197
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "dropped -> dropMessage or shouldDrop?\n",
    "commit": "a5def400a54ac99e004dbf82764a36c9af092248",
    "createdAt": "2015-10-23T03:59:31Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc.netty\n+\n+import java.util.concurrent.Callable\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.network.client.{RpcResponseCallback, TransportClient}\n+import org.apache.spark.rpc.RpcAddress\n+\n+private[netty] case class OutboxMessage(content: Array[Byte], callback: RpcResponseCallback)\n+\n+private[netty] class Outbox(nettyEnv: NettyRpcEnv, val address: RpcAddress) {\n+\n+  outbox => // Give this an alias so we can use it more clearly in closures.\n+\n+  @GuardedBy(\"this\")\n+  private val messages = new java.util.LinkedList[OutboxMessage]\n+\n+  @GuardedBy(\"this\")\n+  private var client: TransportClient = null\n+\n+  /**\n+   * connectFuture points to the connect task. If there is no connect task, connectFuture will be\n+   * null.\n+   */\n+  @GuardedBy(\"this\")\n+  private var connectFuture: java.util.concurrent.Future[Unit] = null\n+\n+  @GuardedBy(\"this\")\n+  private var stopped = false\n+\n+  /**\n+   * If there is any thread draining the message queue\n+   */\n+  @GuardedBy(\"this\")\n+  private var draining = false\n+\n+  /**\n+   * Send a message. If there is no active connection, cache it and launch a new connection. If\n+   * [[Outbox]] is stopped, the sender will be notified with a [[SparkException]].\n+   */\n+  def send(message: OutboxMessage): Unit = {\n+    val dropped = synchronized {",
    "line": 62
  }],
  "prId": 9197
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "The SparkException can be constructed outside the while loop and reused.\n",
    "commit": "a5def400a54ac99e004dbf82764a36c9af092248",
    "createdAt": "2015-10-23T15:12:54Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc.netty\n+\n+import java.util.concurrent.Callable\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.network.client.{RpcResponseCallback, TransportClient}\n+import org.apache.spark.rpc.RpcAddress\n+\n+private[netty] case class OutboxMessage(content: Array[Byte], callback: RpcResponseCallback)\n+\n+private[netty] class Outbox(nettyEnv: NettyRpcEnv, val address: RpcAddress) {\n+\n+  outbox => // Give this an alias so we can use it more clearly in closures.\n+\n+  @GuardedBy(\"this\")\n+  private val messages = new java.util.LinkedList[OutboxMessage]\n+\n+  @GuardedBy(\"this\")\n+  private var client: TransportClient = null\n+\n+  /**\n+   * connectFuture points to the connect task. If there is no connect task, connectFuture will be\n+   * null.\n+   */\n+  @GuardedBy(\"this\")\n+  private var connectFuture: java.util.concurrent.Future[Unit] = null\n+\n+  @GuardedBy(\"this\")\n+  private var stopped = false\n+\n+  /**\n+   * If there is any thread draining the message queue\n+   */\n+  @GuardedBy(\"this\")\n+  private var draining = false\n+\n+  /**\n+   * Send a message. If there is no active connection, cache it and launch a new connection. If\n+   * [[Outbox]] is stopped, the sender will be notified with a [[SparkException]].\n+   */\n+  def send(message: OutboxMessage): Unit = {\n+    val dropped = synchronized {\n+      if (stopped) {\n+        true\n+      } else {\n+        messages.add(message)\n+        false\n+      }\n+    }\n+    if (dropped) {\n+      message.callback.onFailure(new SparkException(\"Message is dropped because Outbox is stopped\"))\n+    } else {\n+      drainOutbox()\n+    }\n+  }\n+\n+  /**\n+   * Drain the message queue. If there is other draining thread, just exit. If the connection has\n+   * not been established, launch a task in the `nettyEnv.clientConnectionExecutor` to setup the\n+   * connection.\n+   */\n+  private def drainOutbox(): Unit = {\n+    var message: OutboxMessage = null\n+    synchronized {\n+      if (stopped) {\n+        return\n+      }\n+      if (connectFuture != null) {\n+        // We are connecting to the remote address, so just exit\n+        return\n+      }\n+      if (client == null) {\n+        // There is no connect task but client is null, so we need to launch the connect task.\n+        launchConnectTask()\n+        return\n+      }\n+      if (draining) {\n+        // There is some thread draining, so just exit\n+        return\n+      }\n+      message = messages.poll()\n+      if (message == null) {\n+        return\n+      }\n+      draining = true\n+    }\n+    while (true) {\n+      try {\n+        val _client = synchronized { client }\n+        if (_client != null) {\n+          _client.sendRpc(message.content, message.callback)\n+        } else {\n+          assert(stopped == true)\n+        }\n+      } catch {\n+        case NonFatal(e) =>\n+          handleNetworkFailure(e)\n+          return\n+      }\n+      synchronized {\n+        if (stopped) {\n+          return\n+        }\n+        message = messages.poll()\n+        if (message == null) {\n+          draining = false\n+          return\n+        }\n+      }\n+    }\n+  }\n+\n+  private def launchConnectTask(): Unit = {\n+    connectFuture = nettyEnv.clientConnectionExecutor.submit(new Callable[Unit] {\n+\n+      override def call(): Unit = {\n+        try {\n+          val _client = nettyEnv.createClient(address)\n+          outbox.synchronized {\n+            client = _client\n+            if (stopped) {\n+              closeClient()\n+            }\n+          }\n+        } catch {\n+          case ie: InterruptedException =>\n+            // exit\n+            return\n+          case NonFatal(e) =>\n+            outbox.synchronized { connectFuture = null }\n+            handleNetworkFailure(e)\n+            return\n+        }\n+        outbox.synchronized { connectFuture = null }\n+        // It's possible that no thread is draining now. If we don't drain here, we cannot send the\n+        // messages until the next message arrives.\n+        drainOutbox()\n+      }\n+    })\n+  }\n+\n+  /**\n+   * Stop [[Inbox]] and notify the waiting messages with the cause.\n+   */\n+  private def handleNetworkFailure(e: Throwable): Unit = {\n+    synchronized {\n+      assert(connectFuture == null)\n+      if (stopped) {\n+        return\n+      }\n+      stopped = true\n+      closeClient()\n+    }\n+    // Remove this Outbox from nettyEnv so that the further messages will create a new Outbox along\n+    // with a new connection\n+    nettyEnv.removeOutbox(address)\n+\n+    // Notify the connection failure for the remaining messages\n+    //\n+    // We always check `stopped` before updating messages, so here we can make sure no thread will\n+    // update messages and it's safe to just drain the queue.\n+    var message = messages.poll()\n+    while (message != null) {\n+      message.callback.onFailure(e)\n+      message = messages.poll()\n+    }\n+    assert(messages.isEmpty)\n+  }\n+\n+  private def closeClient(): Unit = synchronized {\n+    // Not sure if `client.close` is idempotent. Just for safety.\n+    if (client != null) {\n+      client.close()\n+    }\n+    client = null\n+  }\n+\n+  /**\n+   * Stop [[Outbox]]. The remaining messages in the [[Outbox]] will be notified with a\n+   * [[SparkException]].\n+   */\n+  def stop(): Unit = {\n+    synchronized {\n+      if (stopped) {\n+        return\n+      }\n+      stopped = true\n+      if (connectFuture != null) {\n+        connectFuture.cancel(true)\n+      }\n+      closeClient()\n+    }\n+\n+    // We always check `stopped` before updating messages, so here we can make sure no thread will\n+    // update messages and it's safe to just drain the queue.\n+    var message = messages.poll()\n+    while (message != null) {\n+      message.callback.onFailure(new SparkException(\"Message is dropped because Outbox is stopped\"))",
    "line": 218
  }],
  "prId": 9197
}]