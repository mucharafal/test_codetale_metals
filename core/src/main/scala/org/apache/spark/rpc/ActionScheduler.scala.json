[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "what does this comment mean?\n",
    "commit": "fe3df4cbd9efa052803f0c3d12544874b649728b",
    "createdAt": "2015-02-24T21:36:50Z",
    "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc\n+\n+import java.util.concurrent.atomic.AtomicReference\n+import java.util.concurrent.{SynchronousQueue, TimeUnit, ThreadPoolExecutor}\n+\n+import scala.concurrent.duration.FiniteDuration\n+import scala.concurrent.ExecutionContext\n+import scala.util.control.NonFatal\n+\n+import io.netty.util.{Timeout, TimerTask, HashedWheelTimer}\n+\n+import org.apache.spark.util.Utils\n+import org.apache.spark.{Logging, SparkConf}\n+\n+/**\n+ * It's very common that executing some actions in other threads to avoid blocking the event loop\n+ * in a RpcEndpoint. [[ActionScheduler]] is designed for such use cases.\n+ */\n+private[spark] trait ActionScheduler {\n+\n+  /**\n+   * Run the action in the IO thread pool. The thread name will be `name` when running this action.\n+   */\n+  def executeIOAction(name: String)(action: => Unit): Unit\n+\n+  /**\n+   * Run the action in the CPU thread pool. The thread name will be `name` when running this action.\n+   */\n+  def executeCPUAction(name: String)(action: => Unit): Unit\n+\n+  /**\n+   * Run the action after `delay`. The thread name will be `name` when running this action.\n+   */\n+  def schedule(name: String, delay: FiniteDuration)(action: => Unit): Cancellable\n+\n+\n+  /**\n+   * Run the action every `interval`. The thread name will be `name` when running this action.\n+   */\n+  def schedulePeriodically(name: String, interval: FiniteDuration)(action: => Unit): Cancellable = {\n+    schedulePeriodically(name, interval, interval)(action)\n+  }\n+\n+  /**\n+   * Run the action every `interval`. The thread name will be `name` when running this action.\n+   */\n+  def schedulePeriodically(\n+      name: String, delay: FiniteDuration, interval: FiniteDuration)(action: => Unit): Cancellable\n+}\n+\n+private[spark] trait Cancellable {\n+  // Should be reentrant"
  }],
  "prId": 4588
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i find the class hierarchy slightly daunting here. maybe we can have just one? \n",
    "commit": "fe3df4cbd9efa052803f0c3d12544874b649728b",
    "createdAt": "2015-02-24T22:08:31Z",
    "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc\n+\n+import java.util.concurrent.atomic.AtomicReference\n+import java.util.concurrent.{SynchronousQueue, TimeUnit, ThreadPoolExecutor}\n+\n+import scala.concurrent.duration.FiniteDuration\n+import scala.concurrent.ExecutionContext\n+import scala.util.control.NonFatal\n+\n+import io.netty.util.{Timeout, TimerTask, HashedWheelTimer}\n+\n+import org.apache.spark.util.Utils\n+import org.apache.spark.{Logging, SparkConf}\n+\n+/**\n+ * It's very common that executing some actions in other threads to avoid blocking the event loop\n+ * in a RpcEndpoint. [[ActionScheduler]] is designed for such use cases.\n+ */\n+private[spark] trait ActionScheduler {\n+\n+  /**\n+   * Run the action in the IO thread pool. The thread name will be `name` when running this action.\n+   */\n+  def executeIOAction(name: String)(action: => Unit): Unit\n+\n+  /**\n+   * Run the action in the CPU thread pool. The thread name will be `name` when running this action.\n+   */\n+  def executeCPUAction(name: String)(action: => Unit): Unit\n+\n+  /**\n+   * Run the action after `delay`. The thread name will be `name` when running this action.\n+   */\n+  def schedule(name: String, delay: FiniteDuration)(action: => Unit): Cancellable\n+\n+\n+  /**\n+   * Run the action every `interval`. The thread name will be `name` when running this action.\n+   */\n+  def schedulePeriodically(name: String, interval: FiniteDuration)(action: => Unit): Cancellable = {\n+    schedulePeriodically(name, interval, interval)(action)\n+  }\n+\n+  /**\n+   * Run the action every `interval`. The thread name will be `name` when running this action.\n+   */\n+  def schedulePeriodically(\n+      name: String, delay: FiniteDuration, interval: FiniteDuration)(action: => Unit): Cancellable\n+}\n+\n+private[spark] trait Cancellable {\n+  // Should be reentrant\n+  def cancel(): Unit\n+}\n+\n+private[rpc] object NopCancellable extends Cancellable {\n+  override def cancel(): Unit = {}\n+}\n+\n+private[rpc] class SettableCancellable extends Cancellable {"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "I removed NopCancellable and add a const in object SettableCancellable.\n",
    "commit": "fe3df4cbd9efa052803f0c3d12544874b649728b",
    "createdAt": "2015-02-26T12:09:51Z",
    "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc\n+\n+import java.util.concurrent.atomic.AtomicReference\n+import java.util.concurrent.{SynchronousQueue, TimeUnit, ThreadPoolExecutor}\n+\n+import scala.concurrent.duration.FiniteDuration\n+import scala.concurrent.ExecutionContext\n+import scala.util.control.NonFatal\n+\n+import io.netty.util.{Timeout, TimerTask, HashedWheelTimer}\n+\n+import org.apache.spark.util.Utils\n+import org.apache.spark.{Logging, SparkConf}\n+\n+/**\n+ * It's very common that executing some actions in other threads to avoid blocking the event loop\n+ * in a RpcEndpoint. [[ActionScheduler]] is designed for such use cases.\n+ */\n+private[spark] trait ActionScheduler {\n+\n+  /**\n+   * Run the action in the IO thread pool. The thread name will be `name` when running this action.\n+   */\n+  def executeIOAction(name: String)(action: => Unit): Unit\n+\n+  /**\n+   * Run the action in the CPU thread pool. The thread name will be `name` when running this action.\n+   */\n+  def executeCPUAction(name: String)(action: => Unit): Unit\n+\n+  /**\n+   * Run the action after `delay`. The thread name will be `name` when running this action.\n+   */\n+  def schedule(name: String, delay: FiniteDuration)(action: => Unit): Cancellable\n+\n+\n+  /**\n+   * Run the action every `interval`. The thread name will be `name` when running this action.\n+   */\n+  def schedulePeriodically(name: String, interval: FiniteDuration)(action: => Unit): Cancellable = {\n+    schedulePeriodically(name, interval, interval)(action)\n+  }\n+\n+  /**\n+   * Run the action every `interval`. The thread name will be `name` when running this action.\n+   */\n+  def schedulePeriodically(\n+      name: String, delay: FiniteDuration, interval: FiniteDuration)(action: => Unit): Cancellable\n+}\n+\n+private[spark] trait Cancellable {\n+  // Should be reentrant\n+  def cancel(): Unit\n+}\n+\n+private[rpc] object NopCancellable extends Cancellable {\n+  override def cancel(): Unit = {}\n+}\n+\n+private[rpc] class SettableCancellable extends Cancellable {"
  }],
  "prId": 4588
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can you list some use cases for executeIOAction vs executeCPUAction?\n",
    "commit": "fe3df4cbd9efa052803f0c3d12544874b649728b",
    "createdAt": "2015-02-24T22:09:05Z",
    "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc\n+\n+import java.util.concurrent.atomic.AtomicReference\n+import java.util.concurrent.{SynchronousQueue, TimeUnit, ThreadPoolExecutor}\n+\n+import scala.concurrent.duration.FiniteDuration\n+import scala.concurrent.ExecutionContext\n+import scala.util.control.NonFatal\n+\n+import io.netty.util.{Timeout, TimerTask, HashedWheelTimer}\n+\n+import org.apache.spark.util.Utils\n+import org.apache.spark.{Logging, SparkConf}\n+\n+/**\n+ * It's very common that executing some actions in other threads to avoid blocking the event loop\n+ * in a RpcEndpoint. [[ActionScheduler]] is designed for such use cases.\n+ */\n+private[spark] trait ActionScheduler {"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "`executeIOAction` is used to run some blocking but non-CPU actions, such as reading files or sending/receiving via the network. `executeCPUAction` is used to run some CPU actions, such as compress/decompress, or serialize/deserialize. \n",
    "commit": "fe3df4cbd9efa052803f0c3d12544874b649728b",
    "createdAt": "2015-02-26T12:14:47Z",
    "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.rpc\n+\n+import java.util.concurrent.atomic.AtomicReference\n+import java.util.concurrent.{SynchronousQueue, TimeUnit, ThreadPoolExecutor}\n+\n+import scala.concurrent.duration.FiniteDuration\n+import scala.concurrent.ExecutionContext\n+import scala.util.control.NonFatal\n+\n+import io.netty.util.{Timeout, TimerTask, HashedWheelTimer}\n+\n+import org.apache.spark.util.Utils\n+import org.apache.spark.{Logging, SparkConf}\n+\n+/**\n+ * It's very common that executing some actions in other threads to avoid blocking the event loop\n+ * in a RpcEndpoint. [[ActionScheduler]] is designed for such use cases.\n+ */\n+private[spark] trait ActionScheduler {"
  }],
  "prId": 4588
}]