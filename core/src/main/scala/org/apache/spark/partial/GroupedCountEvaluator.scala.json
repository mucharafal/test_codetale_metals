[{
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Put a space before the `{`. Same thing applies elsewhere in the diff.\n",
    "commit": "2601129416667f9add986407adb35018162d659b",
    "createdAt": "2014-04-05T01:35:31Z",
    "diffHunk": "@@ -22,36 +22,33 @@ import java.util.{HashMap => JHashMap}\n import scala.collection.JavaConversions.mapAsScalaMap\n import scala.collection.Map\n import scala.collection.mutable.HashMap\n+import scala.reflect.ClassTag\n \n import cern.jet.stat.Probability\n-import it.unimi.dsi.fastutil.objects.{Object2LongOpenHashMap => OLMap}\n+\n+import org.apache.spark.util.collection.OpenHashMap\n \n /**\n  * An ApproximateEvaluator for counts by key. Returns a map of key to confidence interval.\n  */\n-private[spark] class GroupedCountEvaluator[T](totalOutputs: Int, confidence: Double)\n-  extends ApproximateEvaluator[OLMap[T], Map[T, BoundedDouble]] {\n+private[spark] class GroupedCountEvaluator[T : ClassTag](totalOutputs: Int, confidence: Double)\n+  extends ApproximateEvaluator[OpenHashMap[T,Long], Map[T, BoundedDouble]] {\n \n   var outputsMerged = 0\n-  var sums = new OLMap[T]   // Sum of counts for each key\n+  var sums = new OpenHashMap[T,Long]()   // Sum of counts for each key\n \n-  override def merge(outputId: Int, taskResult: OLMap[T]) {\n+  override def merge(outputId: Int, taskResult: OpenHashMap[T,Long]) {\n     outputsMerged += 1\n-    val iter = taskResult.object2LongEntrySet.fastIterator()\n-    while (iter.hasNext) {\n-      val entry = iter.next()\n-      sums.put(entry.getKey, sums.getLong(entry.getKey) + entry.getLongValue)\n+    taskResult.foreach{ case (key,value) =>\n+      sums.changeValue(key, value, _ + value)\n     }"
  }],
  "prId": 266
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Put a space before the `{` and after the `,`\n",
    "commit": "2601129416667f9add986407adb35018162d659b",
    "createdAt": "2014-04-05T01:35:50Z",
    "diffHunk": "@@ -22,36 +22,33 @@ import java.util.{HashMap => JHashMap}\n import scala.collection.JavaConversions.mapAsScalaMap\n import scala.collection.Map\n import scala.collection.mutable.HashMap\n+import scala.reflect.ClassTag\n \n import cern.jet.stat.Probability\n-import it.unimi.dsi.fastutil.objects.{Object2LongOpenHashMap => OLMap}\n+\n+import org.apache.spark.util.collection.OpenHashMap\n \n /**\n  * An ApproximateEvaluator for counts by key. Returns a map of key to confidence interval.\n  */\n-private[spark] class GroupedCountEvaluator[T](totalOutputs: Int, confidence: Double)\n-  extends ApproximateEvaluator[OLMap[T], Map[T, BoundedDouble]] {\n+private[spark] class GroupedCountEvaluator[T : ClassTag](totalOutputs: Int, confidence: Double)\n+  extends ApproximateEvaluator[OpenHashMap[T,Long], Map[T, BoundedDouble]] {\n \n   var outputsMerged = 0\n-  var sums = new OLMap[T]   // Sum of counts for each key\n+  var sums = new OpenHashMap[T,Long]()   // Sum of counts for each key\n \n-  override def merge(outputId: Int, taskResult: OLMap[T]) {\n+  override def merge(outputId: Int, taskResult: OpenHashMap[T,Long]) {\n     outputsMerged += 1\n-    val iter = taskResult.object2LongEntrySet.fastIterator()\n-    while (iter.hasNext) {\n-      val entry = iter.next()\n-      sums.put(entry.getKey, sums.getLong(entry.getKey) + entry.getLongValue)\n+    taskResult.foreach{ case (key,value) =>\n+      sums.changeValue(key, value, _ + value)\n     }\n   }\n \n   override def currentResult(): Map[T, BoundedDouble] = {\n     if (outputsMerged == totalOutputs) {\n       val result = new JHashMap[T, BoundedDouble](sums.size)\n-      val iter = sums.object2LongEntrySet.fastIterator()\n-      while (iter.hasNext) {\n-        val entry = iter.next()\n-        val sum = entry.getLongValue()\n-        result(entry.getKey) = new BoundedDouble(sum, 1.0, sum, sum)\n+      sums.foreach{ case (key,sum) =>"
  }],
  "prId": 266
}]