[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`NaN != NaN`; you'd have to use `Double.isNaN`\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T13:38:28Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {"
  }, {
    "author": {
      "login": "mtustin-handy"
    },
    "body": "Ah good catch\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-30T13:57:58Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {"
  }],
  "prId": 12016
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This is unnecessary, as you say. Just remove this branch right?\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T13:38:55Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }, {
    "author": {
      "login": "mtustin-handy"
    },
    "body": "Unfortunately without the final branch confFactor resolves to Any type.\nThat last branch is necessary to keep it as double - either by returning a\ndummy value or throwing an exception. I think an exception is safer because\nit's more easily detected that it is no longer impossible.\n\nI'll work on the tests tomorrow.\n\nOn Tuesday, March 29, 2016, Sean Owen notifications@github.com wrote:\n\n> In core/src/main/scala/org/apache/spark/partial/SumEvaluator.scala\n> https://github.com/apache/spark/pull/12016#discussion_r57723805:\n> \n> > ```\n> >        val degreesOfFreedom = (counter.count - 1).toInt\n> >        new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n> > ```\n> > -        } else {\n> > -          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")\n> \n> This is unnecessary, as you say. Just remove this branch right?\n> \n> —\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/apache/spark/pull/12016/files/3faecc4f18094686c843060a1e53b81b9e04e75d#r57723805\n\n## \n\nWant to work at Handy? Check out our culture deck and open roles \nhttp://www.handy.com/careers\nLatest news http://www.handy.com/press at Handy\nHandy just raised $50m \nhttp://venturebeat.com/2015/11/02/on-demand-home-service-handy-raises-50m-in-round-led-by-fidelity/ led \nby Fidelity\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T13:54:27Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "... but I'm suggesting there be no third branch at all, like before. I understand the types.\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T13:57:19Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }, {
    "author": {
      "login": "mtustin-handy"
    },
    "body": "Right, but then you have to have an unconditional else as the final branch. This whole bug stems from that code being unsuitable for an unconditional else. With the code with three branches, and the final branch being an exception, you'll know if changes in the logic above have re-introduced the same error condition. With an unconditional else holding the call to TDistribution you won't. \n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T14:24:59Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "You've already handled the count=0 and count=1 cases earlier. Checking count > 1 doesn't do anything since it can't be false so having a branch for it is odd. Tests are how we catch regressions.\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T14:28:49Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }, {
    "author": {
      "login": "mtustin-handy"
    },
    "body": "I understand that the check does nothing for the computer but it makes it\neasier to read. It's slightly better than a comment because it won't lie\naround being incorrect and stale.\n\nNevertheless I can fix it up to your preference together the tests.\n\nOn Tuesday, March 29, 2016, Sean Owen notifications@github.com wrote:\n\n> In core/src/main/scala/org/apache/spark/partial/SumEvaluator.scala\n> https://github.com/apache/spark/pull/12016#discussion_r57732511:\n> \n> > ```\n> >        val degreesOfFreedom = (counter.count - 1).toInt\n> >        new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n> > ```\n> > -        } else {\n> > -          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")\n> \n> You've already handled the count=0 and count=1 cases earlier. Checking\n> count > 1 doesn't do anything since it can't happen so having a branch for\n> it is odd. Tests are how we catch regressions.\n> \n> —\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/apache/spark/pull/12016/files/3faecc4f18094686c843060a1e53b81b9e04e75d#r57732511\n\n## \n\nWant to work at Handy? Check out our culture deck and open roles \nhttp://www.handy.com/careers\nLatest news http://www.handy.com/press at Handy\nHandy just raised $50m \nhttp://venturebeat.com/2015/11/02/on-demand-home-service-handy-raises-50m-in-round-led-by-fidelity/ led \nby Fidelity\n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T14:34:40Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I don't think it's easier to read since it's more code and suggests this branch can happen, when it should be impossible. \n",
    "commit": "4040e0ec2421d5abe9b89785955e1e3d2215676e",
    "createdAt": "2016-03-29T15:07:36Z",
    "diffHunk": "@@ -40,30 +41,39 @@ private[spark] class SumEvaluator(totalOutputs: Int, confidence: Double)\n   override def currentResult(): BoundedDouble = {\n     if (outputsMerged == totalOutputs) {\n       new BoundedDouble(counter.sum, 1.0, counter.sum, counter.sum)\n-    } else if (outputsMerged == 0) {\n+    } else if (outputsMerged == 0 || counter.count == 0) {\n       new BoundedDouble(0, 0.0, Double.NegativeInfinity, Double.PositiveInfinity)\n     } else {\n       val p = outputsMerged.toDouble / totalOutputs\n       val meanEstimate = counter.mean\n-      val meanVar = counter.sampleVariance / counter.count\n       val countEstimate = (counter.count + 1 - p) / p\n-      val countVar = (counter.count + 1) * (1 - p) / (p * p)\n       val sumEstimate = meanEstimate * countEstimate\n-      val sumVar = (meanEstimate * meanEstimate * countVar) +\n-                   (countEstimate * countEstimate * meanVar) +\n-                   (meanVar * countVar)\n-      val sumStdev = math.sqrt(sumVar)\n-      val confFactor = {\n-        if (counter.count > 100) {\n+\n+      val meanVar = counter.sampleVariance / counter.count\n+\n+      // branch at this point because counter.count == 1 implies counter.sampleVariance == Nan\n+      // and we don't want to ever return a bound of NaN\n+      if (meanVar == Double.NaN || counter.count == 1) {\n+        new BoundedDouble(sumEstimate, confidence, Double.NegativeInfinity, Double.PositiveInfinity)\n+      } else {\n+        val countVar = (counter.count + 1) * (1 - p) / (p * p)\n+        val sumVar = (meanEstimate * meanEstimate * countVar) +\n+          (countEstimate * countEstimate * meanVar) +\n+          (meanVar * countVar)\n+        val sumStdev = math.sqrt(sumVar)\n+        val confFactor = if (counter.count > 100) {\n           new NormalDistribution().inverseCumulativeProbability(1 - (1 - confidence) / 2)\n-        } else {\n+        } else if (counter.count > 1) {\n           val degreesOfFreedom = (counter.count - 1).toInt\n           new TDistribution(degreesOfFreedom).inverseCumulativeProbability(1 - (1 - confidence) / 2)\n+        } else {\n+          throw new Exception(\"Counter.count <= 1; this should be impossible at this point\")"
  }],
  "prId": 12016
}]