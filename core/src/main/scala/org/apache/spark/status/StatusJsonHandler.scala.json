[{
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "would be a little easier to read if you put this into a class on its own\n",
    "commit": "da1e35f39cd60878f32b5446438afdf25d868d7b",
    "createdAt": "2015-02-07T02:10:13Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.status\n+\n+import javax.servlet.http.{HttpServletResponse, HttpServlet, HttpServletRequest}\n+\n+import com.fasterxml.jackson.annotation.JsonInclude\n+import com.fasterxml.jackson.databind.{SerializationFeature, ObjectMapper}\n+import org.apache.spark.status.api.ApplicationInfo\n+import org.apache.spark.ui.SparkUI\n+import org.apache.spark.ui.exec.ExecutorsJsonRoute\n+import org.apache.spark.ui.jobs.{AllJobsJsonRoute, OneStageJsonRoute, AllStagesJsonRoute}\n+import org.apache.spark.ui.storage.{AllRDDJsonRoute, RDDJsonRoute}\n+import org.eclipse.jetty.servlet.{ServletHolder, ServletContextHandler}\n+\n+import scala.util.matching.Regex\n+\n+import org.apache.spark.{Logging, SecurityManager}\n+import org.apache.spark.deploy.history.{OneApplicationJsonRoute, AllApplicationsJsonRoute}\n+\n+\n+/**\n+ * get the response for one endpoint in the json status api.\n+ *\n+ * Implementations only need to return the objects that are to be converted to json -- the framework\n+ * will convert to json via jackson\n+ */\n+private[spark] trait StatusJsonRoute[T] {\n+  def renderJson(request: HttpServletRequest): T\n+}\n+\n+private[spark] class JsonRequestHandler(uiRoot: UIRoot, securityManager: SecurityManager) extends Logging {\n+  def route(req: HttpServletRequest) : Option[StatusJsonRoute[_]] = {\n+    specs.collectFirst { case (pattern, route) if pattern.pattern.matcher(req.getPathInfo()).matches() =>\n+      route\n+    }\n+  }\n+\n+  private val noSlash = \"\"\"[^/]\"\"\"\n+\n+  private val specs: IndexedSeq[(Regex, StatusJsonRoute[_])] = IndexedSeq(\n+    \"/applications/?\".r -> new AllApplicationsJsonRoute(uiRoot),\n+    s\"/applications/$noSlash+/?\".r -> new OneApplicationJsonRoute(uiRoot),\n+    s\"/applications/$noSlash+/jobs/?\".r -> new AllJobsJsonRoute(this),\n+    s\"/applications/$noSlash+/executors/?\".r -> new ExecutorsJsonRoute(this),\n+    s\"/applications/$noSlash+/stages/?\".r -> new AllStagesJsonRoute(this),\n+    s\"/applications/$noSlash+/stages/$noSlash+/?\".r -> new OneStageJsonRoute(this),\n+    s\"/applications/$noSlash+/storage/rdd/?\".r -> new AllRDDJsonRoute(this),\n+    s\"/applications/$noSlash+/storage/rdd/$noSlash+/?\".r -> new RDDJsonRoute(this)\n+  )\n+\n+  private val jsonMapper = {\n+    val t = new ObjectMapper()\n+    t.registerModule(com.fasterxml.jackson.module.scala.DefaultScalaModule)\n+    t.enable(SerializationFeature.INDENT_OUTPUT)\n+    t.setSerializationInclusion(JsonInclude.Include.NON_NULL)\n+    t\n+  }\n+\n+  val jsonContextHandler = {\n+\n+    //TODO throw out all the JettyUtils stuff, so I can set the response status code, etc.\n+    val servlet = new HttpServlet {\n+      override def doGet(request: HttpServletRequest, response: HttpServletResponse) {\n+        if (securityManager.checkUIViewPermissions(request.getRemoteUser)) {\n+          response.setContentType(\"text/json;charset=utf-8\")\n+          route(request) match {\n+            case Some(jsonRoute) =>\n+              response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+              try {\n+                val responseObj = jsonRoute.renderJson(request)\n+                val result = jsonMapper.writeValueAsString(responseObj)\n+                response.setStatus(HttpServletResponse.SC_OK)\n+                response.getWriter.println(result)\n+              } catch {\n+                case iae: IllegalArgumentException =>\n+                  response.setStatus(HttpServletResponse.SC_BAD_REQUEST)\n+                  response.getOutputStream.print(iae.getMessage())\n+              }\n+            case None =>\n+              println(\"no match for path: \" + request.getPathInfo)\n+              response.setStatus(HttpServletResponse.SC_NOT_FOUND)\n+          }\n+        } else {\n+          response.setStatus(HttpServletResponse.SC_UNAUTHORIZED)\n+          response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n+            \"User is not authorized to access this page.\")\n+        }\n+      }\n+    }\n+    val path = \"/json/v1\"\n+    val contextHandler = new ServletContextHandler\n+    val holder = new ServletHolder(servlet)\n+    contextHandler.setContextPath(path)\n+    contextHandler.addServlet(holder, \"/*\")\n+    contextHandler\n+  }"
  }],
  "prId": 4435
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Can you add a line of Scaladoc to this method?  I guess its use is probably obvious from context, but explicit documentation wouldn't hurt.\n",
    "commit": "da1e35f39cd60878f32b5446438afdf25d868d7b",
    "createdAt": "2015-03-09T18:21:47Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.status\n+\n+import javax.servlet.http.{HttpServletResponse, HttpServlet, HttpServletRequest}\n+\n+import com.fasterxml.jackson.annotation.JsonInclude\n+import com.fasterxml.jackson.databind.{SerializationFeature, ObjectMapper}\n+import org.apache.spark.status.api.ApplicationInfo\n+import org.apache.spark.ui.SparkUI\n+import org.apache.spark.ui.exec.ExecutorsJsonRoute\n+import org.apache.spark.ui.jobs.{AllJobsJsonRoute, OneStageJsonRoute, AllStagesJsonRoute}\n+import org.apache.spark.ui.storage.{AllRDDJsonRoute, RDDJsonRoute}\n+import org.eclipse.jetty.servlet.{ServletHolder, ServletContextHandler}\n+\n+import scala.util.matching.Regex\n+\n+import org.apache.spark.{Logging, SecurityManager}\n+import org.apache.spark.deploy.history.{OneApplicationJsonRoute, AllApplicationsJsonRoute}\n+\n+\n+/**\n+ * get the response for one endpoint in the json status api.\n+ *\n+ * Implementations only need to return the objects that are to be converted to json -- the framework\n+ * will convert to json via jackson\n+ */\n+private[spark] trait StatusJsonRoute[T] {\n+  def renderJson(request: HttpServletRequest): T\n+}\n+\n+private[spark] class JsonRequestHandler(uiRoot: UIRoot, securityManager: SecurityManager) extends Logging {\n+  def route(req: HttpServletRequest) : Option[StatusJsonRoute[_]] = {\n+    specs.collectFirst { case (pattern, route) if pattern.pattern.matcher(req.getPathInfo()).matches() =>\n+      route\n+    }\n+  }\n+\n+  private val noSlash = \"\"\"[^/]\"\"\"\n+\n+  private val specs: IndexedSeq[(Regex, StatusJsonRoute[_])] = IndexedSeq(\n+    \"/applications/?\".r -> new AllApplicationsJsonRoute(uiRoot),\n+    s\"/applications/$noSlash+/?\".r -> new OneApplicationJsonRoute(uiRoot),\n+    s\"/applications/$noSlash+/jobs/?\".r -> new AllJobsJsonRoute(this),\n+    s\"/applications/$noSlash+/executors/?\".r -> new ExecutorsJsonRoute(this),\n+    s\"/applications/$noSlash+/stages/?\".r -> new AllStagesJsonRoute(this),\n+    s\"/applications/$noSlash+/stages/$noSlash+/?\".r -> new OneStageJsonRoute(this),\n+    s\"/applications/$noSlash+/storage/rdd/?\".r -> new AllRDDJsonRoute(this),\n+    s\"/applications/$noSlash+/storage/rdd/$noSlash+/?\".r -> new RDDJsonRoute(this)\n+  )\n+\n+  private val jsonMapper = {\n+    val t = new ObjectMapper()\n+    t.registerModule(com.fasterxml.jackson.module.scala.DefaultScalaModule)\n+    t.enable(SerializationFeature.INDENT_OUTPUT)\n+    t.setSerializationInclusion(JsonInclude.Include.NON_NULL)\n+    t\n+  }\n+\n+  val jsonContextHandler = {\n+\n+    //TODO throw out all the JettyUtils stuff, so I can set the response status code, etc.\n+    val servlet = new HttpServlet {\n+      override def doGet(request: HttpServletRequest, response: HttpServletResponse) {\n+        if (securityManager.checkUIViewPermissions(request.getRemoteUser)) {\n+          response.setContentType(\"text/json;charset=utf-8\")\n+          route(request) match {\n+            case Some(jsonRoute) =>\n+              response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+              try {\n+                val responseObj = jsonRoute.renderJson(request)\n+                val result = jsonMapper.writeValueAsString(responseObj)\n+                response.setStatus(HttpServletResponse.SC_OK)\n+                response.getWriter.println(result)\n+              } catch {\n+                case iae: IllegalArgumentException =>\n+                  response.setStatus(HttpServletResponse.SC_BAD_REQUEST)\n+                  response.getOutputStream.print(iae.getMessage())\n+              }\n+            case None =>\n+              println(\"no match for path: \" + request.getPathInfo)\n+              response.setStatus(HttpServletResponse.SC_NOT_FOUND)\n+          }\n+        } else {\n+          response.setStatus(HttpServletResponse.SC_UNAUTHORIZED)\n+          response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n+            \"User is not authorized to access this page.\")\n+        }\n+      }\n+    }\n+    val path = \"/json/v1\"\n+    val contextHandler = new ServletContextHandler\n+    val holder = new ServletHolder(servlet)\n+    contextHandler.setContextPath(path)\n+    contextHandler.addServlet(holder, \"/*\")\n+    contextHandler\n+  }\n+\n+  def withSparkUI[T](request: HttpServletRequest)(f: (SparkUI, HttpServletRequest) => T): T = {"
  }],
  "prId": 4435
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "What does this method do?  I could read it and figure it out, but a one-sentence Scaladoc description would be helpful (maybe an example of an input and output)?\n",
    "commit": "da1e35f39cd60878f32b5446438afdf25d868d7b",
    "createdAt": "2015-03-09T18:26:03Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.status\n+\n+import javax.servlet.http.{HttpServletResponse, HttpServlet, HttpServletRequest}\n+\n+import com.fasterxml.jackson.annotation.JsonInclude\n+import com.fasterxml.jackson.databind.{SerializationFeature, ObjectMapper}\n+import org.apache.spark.status.api.ApplicationInfo\n+import org.apache.spark.ui.SparkUI\n+import org.apache.spark.ui.exec.ExecutorsJsonRoute\n+import org.apache.spark.ui.jobs.{AllJobsJsonRoute, OneStageJsonRoute, AllStagesJsonRoute}\n+import org.apache.spark.ui.storage.{AllRDDJsonRoute, RDDJsonRoute}\n+import org.eclipse.jetty.servlet.{ServletHolder, ServletContextHandler}\n+\n+import scala.util.matching.Regex\n+\n+import org.apache.spark.{Logging, SecurityManager}\n+import org.apache.spark.deploy.history.{OneApplicationJsonRoute, AllApplicationsJsonRoute}\n+\n+\n+/**\n+ * get the response for one endpoint in the json status api.\n+ *\n+ * Implementations only need to return the objects that are to be converted to json -- the framework\n+ * will convert to json via jackson\n+ */\n+private[spark] trait StatusJsonRoute[T] {\n+  def renderJson(request: HttpServletRequest): T\n+}\n+\n+private[spark] class JsonRequestHandler(uiRoot: UIRoot, securityManager: SecurityManager) extends Logging {\n+  def route(req: HttpServletRequest) : Option[StatusJsonRoute[_]] = {\n+    specs.collectFirst { case (pattern, route) if pattern.pattern.matcher(req.getPathInfo()).matches() =>\n+      route\n+    }\n+  }\n+\n+  private val noSlash = \"\"\"[^/]\"\"\"\n+\n+  private val specs: IndexedSeq[(Regex, StatusJsonRoute[_])] = IndexedSeq(\n+    \"/applications/?\".r -> new AllApplicationsJsonRoute(uiRoot),\n+    s\"/applications/$noSlash+/?\".r -> new OneApplicationJsonRoute(uiRoot),\n+    s\"/applications/$noSlash+/jobs/?\".r -> new AllJobsJsonRoute(this),\n+    s\"/applications/$noSlash+/executors/?\".r -> new ExecutorsJsonRoute(this),\n+    s\"/applications/$noSlash+/stages/?\".r -> new AllStagesJsonRoute(this),\n+    s\"/applications/$noSlash+/stages/$noSlash+/?\".r -> new OneStageJsonRoute(this),\n+    s\"/applications/$noSlash+/storage/rdd/?\".r -> new AllRDDJsonRoute(this),\n+    s\"/applications/$noSlash+/storage/rdd/$noSlash+/?\".r -> new RDDJsonRoute(this)\n+  )\n+\n+  private val jsonMapper = {\n+    val t = new ObjectMapper()\n+    t.registerModule(com.fasterxml.jackson.module.scala.DefaultScalaModule)\n+    t.enable(SerializationFeature.INDENT_OUTPUT)\n+    t.setSerializationInclusion(JsonInclude.Include.NON_NULL)\n+    t\n+  }\n+\n+  val jsonContextHandler = {\n+\n+    //TODO throw out all the JettyUtils stuff, so I can set the response status code, etc.\n+    val servlet = new HttpServlet {\n+      override def doGet(request: HttpServletRequest, response: HttpServletResponse) {\n+        if (securityManager.checkUIViewPermissions(request.getRemoteUser)) {\n+          response.setContentType(\"text/json;charset=utf-8\")\n+          route(request) match {\n+            case Some(jsonRoute) =>\n+              response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+              try {\n+                val responseObj = jsonRoute.renderJson(request)\n+                val result = jsonMapper.writeValueAsString(responseObj)\n+                response.setStatus(HttpServletResponse.SC_OK)\n+                response.getWriter.println(result)\n+              } catch {\n+                case iae: IllegalArgumentException =>\n+                  response.setStatus(HttpServletResponse.SC_BAD_REQUEST)\n+                  response.getOutputStream.print(iae.getMessage())\n+              }\n+            case None =>\n+              println(\"no match for path: \" + request.getPathInfo)\n+              response.setStatus(HttpServletResponse.SC_NOT_FOUND)\n+          }\n+        } else {\n+          response.setStatus(HttpServletResponse.SC_UNAUTHORIZED)\n+          response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n+          response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n+            \"User is not authorized to access this page.\")\n+        }\n+      }\n+    }\n+    val path = \"/json/v1\"\n+    val contextHandler = new ServletContextHandler\n+    val holder = new ServletHolder(servlet)\n+    contextHandler.setContextPath(path)\n+    contextHandler.addServlet(holder, \"/*\")\n+    contextHandler\n+  }\n+\n+  def withSparkUI[T](request: HttpServletRequest)(f: (SparkUI, HttpServletRequest) => T): T = {\n+    val appIdOpt = JsonRequestHandler.extractAppId(request.getPathInfo)\n+    appIdOpt match {\n+      case Some(appId) =>\n+        uiRoot.getSparkUI(appId) match {\n+          case Some(ui) => f(ui, request)\n+          case None => throw new IllegalArgumentException(\"no such app: \" + appId)\n+        }\n+      case None =>\n+        throw new IllegalArgumentException(\"no app id\")\n+    }\n+  }\n+}\n+\n+private[spark] object JsonRequestHandler {\n+  val appId = \"\"\"/applications/([^/]+)\"\"\".r\n+  val stageId = \"\"\"/applications/[^/]+/stages/(\\d+)\"\"\".r\n+  val rddId = \"\"\"/applications/[^/]+/storage/rdd/(\\d+)\"\"\".r\n+  def extractAppId(pathInfo: String): Option[String] = appId.findFirstMatchIn(pathInfo).map{_.group(1)}\n+  def extractStageId(pathInfo: String): Option[Int] = stageId.findFirstMatchIn(pathInfo).map{_.group(1).toInt}\n+  def extractRDDId(pathInfo: String): Option[Int] = rddId.findFirstMatchIn(pathInfo).map{_.group(1).toInt}\n+}\n+\n+private[spark] trait UIRoot {\n+  def getSparkUI(appKey: String): Option[SparkUI]\n+  def getApplicationInfoList: Seq[ApplicationInfo]\n+}\n+\n+\n+object RouteUtils {\n+  def extractParamSet[T <: Enum[T]]("
  }],
  "prId": 4435
}]