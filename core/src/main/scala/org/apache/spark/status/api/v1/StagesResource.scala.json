[{
  "comments": [{
    "author": {
      "login": "abellina"
    },
    "body": "Could this be rewritten as a range loop `for (r <- ret)`",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-11T22:03:52Z",
    "diffHunk": "@@ -40,8 +43,25 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (i <- 0 to (ret.length - 1)) {"
  }, {
    "author": {
      "login": "abellina"
    },
    "body": "I would also think that things like `executorSummary.get.get(execId)` could be stored somewhere in the stack, e.g. clean up a bit. It's hard to follow what you are setting.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-11T22:05:45Z",
    "diffHunk": "@@ -40,8 +43,25 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (i <- 0 to (ret.length - 1)) {"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-14T18:07:32Z",
    "diffHunk": "@@ -40,8 +43,25 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (i <- 0 to (ret.length - 1)) {"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "assume this isn't needed",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T17:30:15Z",
    "diffHunk": "@@ -16,15 +16,18 @@\n  */\n package org.apache.spark.status.api.v1\n \n-import java.util.{List => JList}\n+import java.util"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:26:18Z",
    "diffHunk": "@@ -16,15 +16,18 @@\n  */\n package org.apache.spark.status.api.v1\n \n-import java.util.{List => JList}\n+import java.util"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "add comment in here about what we are doing",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T17:32:32Z",
    "diffHunk": "@@ -40,8 +43,27 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (r <- ret) {"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:26:26Z",
    "diffHunk": "@@ -40,8 +43,27 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (r <- ret) {"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "remove executorIdArray and just put r.executorSummary.get.keys.toArray inside for",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T17:33:04Z",
    "diffHunk": "@@ -40,8 +43,27 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (r <- ret) {\n+          val executorIdArray = r.executorSummary.get.keys.toArray"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:26:33Z",
    "diffHunk": "@@ -40,8 +43,27 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        for (r <- ret) {\n+          val executorIdArray = r.executorSummary.get.keys.toArray"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "put @Context on next line",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T17:47:43Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:26:42Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "going with my comment above, I don't want to be modifying the StageData by changing the parameters to var, we should either get all the data we need from stageData or we could perhaps create a separate call to get these.  Will have to look in more depth",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T18:42:47Z",
    "diffHunk": "@@ -40,8 +43,27 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:27:17Z",
    "diffHunk": "@@ -40,8 +43,27 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "add comment that this needs to stay formatted exactly because used by the datatable for the stages page ",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T18:50:29Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(",
    "line": 27
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:27:28Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(",
    "line": 27
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "seems like this is returning all the data when you don't match, which you shouldn't do, you would just want to see empty table",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T19:52:21Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+      }\n+      if (_tasksToShow.nonEmpty) {\n+        val iterator = _tasksToShow.iterator\n+        while(iterator.hasNext) {\n+          val t1: TaskData = iterator.next()\n+          val execId = t1.executorId\n+          val executorLogs = ui.store.executorSummary(execId).executorLogs\n+          t1.executorLogs = executorLogs\n+          t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+          t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+        }\n+        val ret = new util.HashMap[String, Object]()\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = ui.store.filterTaskList(_tasksToShow, searchValue)\n+          if (filteredTaskList.length > 0) {\n+            ret.put(\"aaData\", filteredTaskList)\n+          } else {\n+            _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)"
  }, {
    "author": {
      "login": "tgravescs"
    },
    "body": "although I think you still want to do the pagination stuff on the filtered list here ",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T20:11:39Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+      }\n+      if (_tasksToShow.nonEmpty) {\n+        val iterator = _tasksToShow.iterator\n+        while(iterator.hasNext) {\n+          val t1: TaskData = iterator.next()\n+          val execId = t1.executorId\n+          val executorLogs = ui.store.executorSummary(execId).executorLogs\n+          t1.executorLogs = executorLogs\n+          t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+          t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+        }\n+        val ret = new util.HashMap[String, Object]()\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = ui.store.filterTaskList(_tasksToShow, searchValue)\n+          if (filteredTaskList.length > 0) {\n+            ret.put(\"aaData\", filteredTaskList)\n+          } else {\n+            _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)"
  }, {
    "author": {
      "login": "tgravescs"
    },
    "body": "we may also want to look at pushing the search functionality down into the store itself.  There is a bunch of optimization in keys and such to do the sorting and try to keep from filling memory, we should investigate if we can push it down so at least with the history server where it uses levelDB we don't have to pull everything into memory.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T20:14:20Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+      }\n+      if (_tasksToShow.nonEmpty) {\n+        val iterator = _tasksToShow.iterator\n+        while(iterator.hasNext) {\n+          val t1: TaskData = iterator.next()\n+          val execId = t1.executorId\n+          val executorLogs = ui.store.executorSummary(execId).executorLogs\n+          t1.executorLogs = executorLogs\n+          t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+          t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+        }\n+        val ret = new util.HashMap[String, Object]()\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = ui.store.filterTaskList(_tasksToShow, searchValue)\n+          if (filteredTaskList.length > 0) {\n+            ret.put(\"aaData\", filteredTaskList)\n+          } else {\n+            _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Added sorting and pagination capability on search results as well.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:28:09Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+      }\n+      if (_tasksToShow.nonEmpty) {\n+        val iterator = _tasksToShow.iterator\n+        while(iterator.hasNext) {\n+          val t1: TaskData = iterator.next()\n+          val execId = t1.executorId\n+          val executorLogs = ui.store.executorSummary(execId).executorLogs\n+          t1.executorLogs = executorLogs\n+          t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+          t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+        }\n+        val ret = new util.HashMap[String, Object]()\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = ui.store.filterTaskList(_tasksToShow, searchValue)\n+          if (filteredTaskList.length > 0) {\n+            ret.put(\"aaData\", filteredTaskList)\n+          } else {\n+            _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "We aren't handling sorting here.  If I search on somethign and then sort on column it should sort here as well.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T20:08:40Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:28:33Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "recordsFiltered needs to be adjusted to what was filtered right?",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-20T20:17:45Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+      }\n+      if (_tasksToShow.nonEmpty) {\n+        val iterator = _tasksToShow.iterator\n+        while(iterator.hasNext) {\n+          val t1: TaskData = iterator.next()\n+          val execId = t1.executorId\n+          val executorLogs = ui.store.executorSummary(execId).executorLogs\n+          t1.executorLogs = executorLogs\n+          t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+          t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+        }\n+        val ret = new util.HashMap[String, Object]()\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = ui.store.filterTaskList(_tasksToShow, searchValue)\n+          if (filteredTaskList.length > 0) {\n+            ret.put(\"aaData\", filteredTaskList)\n+          } else {\n+            _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+            val iterator = _tasksToShow.iterator\n+            while(iterator.hasNext) {\n+              val t1: TaskData = iterator.next()\n+              val execId = t1.executorId\n+              val executorLogs = ui.store.executorSummary(execId).executorLogs\n+              t1.executorLogs = executorLogs\n+              t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+              t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+            }\n+            ret.put(\"aaData\", _tasksToShow)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+        ret.put(\"recordsTotal\", totalRecords)"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-25T16:28:40Z",
    "diffHunk": "@@ -102,4 +124,87 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean, @Context uriInfo: UriInfo):\n+  util.HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = ui.store.taskList(stageId, stageAttemptId, 0, totalRecords.toInt,\n+          indexName(\"Index\"), true)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+      }\n+      if (_tasksToShow.nonEmpty) {\n+        val iterator = _tasksToShow.iterator\n+        while(iterator.hasNext) {\n+          val t1: TaskData = iterator.next()\n+          val execId = t1.executorId\n+          val executorLogs = ui.store.executorSummary(execId).executorLogs\n+          t1.executorLogs = executorLogs\n+          t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+          t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+        }\n+        val ret = new util.HashMap[String, Object]()\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = ui.store.filterTaskList(_tasksToShow, searchValue)\n+          if (filteredTaskList.length > 0) {\n+            ret.put(\"aaData\", filteredTaskList)\n+          } else {\n+            _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId)\n+            val iterator = _tasksToShow.iterator\n+            while(iterator.hasNext) {\n+              val t1: TaskData = iterator.next()\n+              val execId = t1.executorId\n+              val executorLogs = ui.store.executorSummary(execId).executorLogs\n+              t1.executorLogs = executorLogs\n+              t1.schedulerDelay = AppStatusUtils.schedulerDelay(t1)\n+              t1.gettingResultTime = AppStatusUtils.gettingResultTime(t1)\n+            }\n+            ret.put(\"aaData\", _tasksToShow)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+        ret.put(\"recordsTotal\", totalRecords)"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "this shouldn't be needed?",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-24T19:42:42Z",
    "diffHunk": "@@ -40,8 +42,29 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        // Some of the data that we want to display for the tasks like executorLogs,\n+        // schedulerDelay etc. comes from other sources, thus, we basically add them to the\n+        // executor and task data object before passing them to the client.\n+        for (r <- ret) {\n+          for (execId <- r.executorSummary.get.keys.toArray) {\n+            val executorLogs = ui.store.executorSummary(execId).executorLogs\n+            val hostPort = ui.store.executorSummary(execId).hostPort\n+            val taskDataArray = r.tasks.get.keys.toArray\n+            var execStageSummary = r.executorSummary.get.get(execId).get\n+            execStageSummary.executorLogs = executorLogs\n+            execStageSummary.hostPort = hostPort\n+            for (taskData <- taskDataArray) {\n+              var taskDataObject = r.tasks.get.get(taskData).get\n+              taskDataObject.executorLogs = executorLogs"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-09-28T14:03:39Z",
    "diffHunk": "@@ -40,8 +42,29 @@ private[v1] class StagesResource extends BaseAppResource {\n       @PathParam(\"stageId\") stageId: Int,\n       @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean): Seq[StageData] = {\n     withUI { ui =>\n-      val ret = ui.store.stageData(stageId, details = details)\n+      var ret = ui.store.stageData(stageId, details = details)\n       if (ret.nonEmpty) {\n+        // Some of the data that we want to display for the tasks like executorLogs,\n+        // schedulerDelay etc. comes from other sources, thus, we basically add them to the\n+        // executor and task data object before passing them to the client.\n+        for (r <- ret) {\n+          for (execId <- r.executorSummary.get.keys.toArray) {\n+            val executorLogs = ui.store.executorSummary(execId).executorLogs\n+            val hostPort = ui.store.executorSummary(execId).hostPort\n+            val taskDataArray = r.tasks.get.keys.toArray\n+            var execStageSummary = r.executorSummary.get.get(execId).get\n+            execStageSummary.executorLogs = executorLogs\n+            execStageSummary.hostPort = hostPort\n+            for (taskData <- taskDataArray) {\n+              var taskDataObject = r.tasks.get.get(taskData).get\n+              taskDataObject.executorLogs = executorLogs"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "michal-databricks"
    },
    "body": "This function should have `val containsValue = (haystack: Any) => haystack.toString.toLowerCase(Locale.ROOT).contains(searchValueLowerCase)` to repetition in all this code below.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-05T11:47:02Z",
    "diffHunk": "@@ -102,4 +103,159 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+      new InputMetrics(0, 0), new OutputMetrics(0, 0),\n+      new ShuffleReadMetrics(0, 0, 0, 0, 0, 0, 0), new ShuffleWriteMetrics(0, 0, 0))\n+    val searchValueLowerCase = searchValue.toLowerCase(Locale.ROOT)\n+    val filteredTaskDataSequence: Seq[TaskData] = taskDataList.filter(f =>",
    "line": 126
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-05T20:03:30Z",
    "diffHunk": "@@ -102,4 +103,159 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+      new InputMetrics(0, 0), new OutputMetrics(0, 0),\n+      new ShuffleReadMetrics(0, 0, 0, 0, 0, 0, 0), new ShuffleWriteMetrics(0, 0, 0))\n+    val searchValueLowerCase = searchValue.toLowerCase(Locale.ROOT)\n+    val filteredTaskDataSequence: Seq[TaskData] = taskDataList.filter(f =>",
    "line": 126
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "michal-databricks"
    },
    "body": "Why not splitting task metrics matching to a separate function like: `val taskMetricsContainsValue = (task: TaskData) => task.taskMetrics match { case None => false case Some(metrics) => ... }` This would avoid requiring changes to this line every time TaskMetrics structure changes.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-05T12:00:06Z",
    "diffHunk": "@@ -102,4 +103,159 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "I did not get your comment clearly here, do you mean that I should have all task metric filters in a separate function or should I wrap dummytaskmetrics in an Option? Can you please elaborate a little? Thank you. ",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-05T20:11:37Z",
    "diffHunk": "@@ -102,4 +103,159 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
  }, {
    "author": {
      "login": "abellina"
    },
    "body": "I think @michal-databricks 's comment is to remove:\r\n\r\n```\r\n|| containsValue(f.taskMetrics.getOrElse(dummyTaskMetrics).executorDeserializeTime)\r\n```\r\nuntil\r\n```\r\n|| containsValue(f.taskMetrics.getOrElse(dummyTaskMetrics).shuffleWriteMetrics.writeTime)\r\n```\r\nAnd replace them in this function with:\r\n```\r\n|| taskMetricsContainsValue(f)\r\n```\r\nwhere this function switches on `f.taskMetrics` being not `None`, which should allow you to remove the `dummyTaskMetrics` variable.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-09T21:20:01Z",
    "diffHunk": "@@ -102,4 +103,159 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "ok, thanks for clarifying @abellina , fixed it.",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-16T14:17:19Z",
    "diffHunk": "@@ -102,4 +103,159 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "abellina"
    },
    "body": "I think this should also search on \"errorMessage\"",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-10T14:41:02Z",
    "diffHunk": "@@ -102,4 +103,124 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+      new InputMetrics(0, 0), new OutputMetrics(0, 0),\n+      new ShuffleReadMetrics(0, 0, 0, 0, 0, 0, 0), new ShuffleWriteMetrics(0, 0, 0))\n+    val searchValueLowerCase = searchValue.toLowerCase(Locale.ROOT)\n+    val containsValue = (taskDataParams: Any) => taskDataParams.toString.toLowerCase(\n+      Locale.ROOT).contains(searchValueLowerCase)\n+    val filteredTaskDataSequence: Seq[TaskData] = taskDataList.filter(f =>\n+      (containsValue(f.taskId) || containsValue(f.index) || containsValue(f.attempt)",
    "line": 127
  }, {
    "author": {
      "login": "abellina"
    },
    "body": "nm it's already there, thanks for clarifying @pgandhi999 \r\n",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-10T18:34:23Z",
    "diffHunk": "@@ -102,4 +103,124 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, true,\n+          totalRecords.toInt)\n+        isSearch = true\n+        searchValue = uriQueryParameters.getFirst(\"search[value]\")\n+      } else {\n+        _tasksToShow = doPagination(uriQueryParameters, stageId, stageAttemptId, false,\n+          totalRecords.toInt)\n+      }\n+      val ret = new HashMap[String, Object]()\n+      if (_tasksToShow.nonEmpty) {\n+        // Performs server-side search based on input from user\n+        if (isSearch) {\n+          val filteredTaskList = filterTaskList(_tasksToShow, searchValue)\n+          filteredRecords = filteredTaskList.length.toString\n+          if (filteredTaskList.length > 0) {\n+            val pageStartIndex = uriQueryParameters.getFirst(\"start\").toInt\n+            val pageLength = uriQueryParameters.getFirst(\"length\").toInt\n+            ret.put(\"aaData\", filteredTaskList.slice(pageStartIndex, pageStartIndex + pageLength))\n+          } else {\n+            ret.put(\"aaData\", filteredTaskList)\n+          }\n+        } else {\n+          ret.put(\"aaData\", _tasksToShow)\n+        }\n+      } else {\n+        ret.put(\"aaData\", _tasksToShow)\n+      }\n+      ret.put(\"recordsTotal\", totalRecords)\n+      ret.put(\"recordsFiltered\", filteredRecords)\n+      ret\n+    }\n+  }\n+\n+  // Performs pagination on the server side\n+  def doPagination(queryParameters: MultivaluedMap[String, String], stageId: Int,\n+    stageAttemptId: Int, isSearch: Boolean, totalRecords: Int): Seq[TaskData] = {\n+    val queryParams = queryParameters.keySet()\n+    var columnToSort = 0\n+    if (queryParams.contains(\"order[0][column]\")) {\n+      columnToSort = queryParameters.getFirst(\"order[0][column]\").toInt\n+    }\n+    var columnNameToSort = queryParameters.getFirst(\"columns[\" + columnToSort + \"][name]\")\n+    if (columnNameToSort.equalsIgnoreCase(\"Logs\")) {\n+      columnNameToSort = \"Index\"\n+      columnToSort = 0\n+    }\n+    val isAscendingStr = queryParameters.getFirst(\"order[0][dir]\")\n+    var pageStartIndex = 0\n+    var pageLength = totalRecords\n+    if (!isSearch) {\n+      pageStartIndex = queryParameters.getFirst(\"start\").toInt\n+      pageLength = queryParameters.getFirst(\"length\").toInt\n+    }\n+    return withUI(_.store.taskList(stageId, stageAttemptId, pageStartIndex, pageLength,\n+      indexName(columnNameToSort), isAscendingStr.equalsIgnoreCase(\"asc\")))\n+  }\n+\n+  // Filters task list based on search parameter\n+  def filterTaskList(\n+    taskDataList: Seq[TaskData],\n+    searchValue: String): Seq[TaskData] = {\n+    val defaultOptionString: String = \"d\"\n+    // The task metrics dummy object below has been added to avoid throwing exception in cases\n+    // when task metrics for a particular task do not exist as of yet\n+    val dummyTaskMetrics: TaskMetrics = new TaskMetrics(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+      new InputMetrics(0, 0), new OutputMetrics(0, 0),\n+      new ShuffleReadMetrics(0, 0, 0, 0, 0, 0, 0), new ShuffleWriteMetrics(0, 0, 0))\n+    val searchValueLowerCase = searchValue.toLowerCase(Locale.ROOT)\n+    val containsValue = (taskDataParams: Any) => taskDataParams.toString.toLowerCase(\n+      Locale.ROOT).contains(searchValueLowerCase)\n+    val filteredTaskDataSequence: Seq[TaskData] = taskDataList.filter(f =>\n+      (containsValue(f.taskId) || containsValue(f.index) || containsValue(f.attempt)",
    "line": 127
  }],
  "prId": 21688
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "can we easily point somewhere for the datatable api so if someone tries to read this they can see the values?  Or put an example here",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-10T21:00:39Z",
    "diffHunk": "@@ -102,4 +103,124 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {",
    "line": 44
  }, {
    "author": {
      "login": "pgandhi999"
    },
    "body": "Done",
    "commit": "8f6efbda4ad6b7fc4c86f4a2ae43e49847243826",
    "createdAt": "2018-10-16T14:16:29Z",
    "diffHunk": "@@ -102,4 +103,124 @@ private[v1] class StagesResource extends BaseAppResource {\n     withUI(_.store.taskList(stageId, stageAttemptId, offset, length, sortBy))\n   }\n \n+  // This api needs to stay formatted exactly as it is below, since, it is being used by the\n+  // datatables for the stages page.\n+  @GET\n+  @Path(\"{stageId: \\\\d+}/{stageAttemptId: \\\\d+}/taskTable\")\n+  def taskTable(\n+    @PathParam(\"stageId\") stageId: Int,\n+    @PathParam(\"stageAttemptId\") stageAttemptId: Int,\n+    @QueryParam(\"details\") @DefaultValue(\"true\") details: Boolean,\n+    @Context uriInfo: UriInfo):\n+  HashMap[String, Object] = {\n+    withUI { ui =>\n+      val uriQueryParameters = uriInfo.getQueryParameters(true)\n+      val totalRecords = uriQueryParameters.getFirst(\"numTasks\")\n+      var isSearch = false\n+      var searchValue: String = null\n+      var filteredRecords = totalRecords\n+      var _tasksToShow: Seq[TaskData] = null\n+      if (uriQueryParameters.getFirst(\"search[value]\") != null &&\n+        uriQueryParameters.getFirst(\"search[value]\").length > 0) {",
    "line": 44
  }],
  "prId": 21688
}]