[{
  "comments": [{
    "author": {
      "login": "xuanyuanking"
    },
    "body": "nit: Source {",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-09-10T15:58:40Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.metrics.source.Source\n+\n+private[spark] class AppStatusSource extends Source{"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": ":+1: ",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-09-10T18:41:27Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.metrics.source.Source\n+\n+private[spark] class AppStatusSource extends Source{"
  }],
  "prId": 22381
}, {
  "comments": [{
    "author": {
      "login": "skonto"
    },
    "body": "this is not used, need to remove.",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-09-10T20:57:11Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.metrics.source.Source\n+\n+private[spark] class AppStatusSource extends Source{\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val JOB_DURATION = metricRegistry.histogram(MetricRegistry.name(\"jobDuration\"))\n+\n+  val FAILED_STAGES = metricRegistry.counter(MetricRegistry.name(\"failedStages\"))\n+\n+  val SKIPPED_STAGES = metricRegistry.counter(MetricRegistry.name(\"skippedStages\"))\n+\n+  val COMPLETED_STAGES = metricRegistry.counter(MetricRegistry.name(\"completedStages\"))\n+\n+  val COMPLETED_JOBS = metricRegistry.counter(MetricRegistry.name(\"completedJobs\"))"
  }],
  "prId": 22381
}, {
  "comments": [{
    "author": {
      "login": "aditanase"
    },
    "body": "I would suggest creating groups of metrics by adding a prefix with the \"context\", e.g. `stages`, `jobs`, `tasks`.\r\nThis is a best practice followed by other sources. See:\r\n- https://github.com/apache/spark/blob/9fed6abfdcb7afcf92be56e5ccbed6599fe66bc4/core/src/main/scala/org/apache/spark/scheduler/DAGSchedulerSource.scala#L29\r\n- https://github.com/apache/spark/blob/a4491626ed8169f0162a0dfb78736c9b9e7fb434/core/src/main/scala/org/apache/spark/storage/BlockManagerSource.scala#L38",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-09T11:51:15Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = metricRegistry.counter(MetricRegistry.name(\"failedStages\"))"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "ok makes sense",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-10T13:19:38Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = metricRegistry.counter(MetricRegistry.name(\"failedStages\"))"
  }],
  "prId": 22381
}, {
  "comments": [{
    "author": {
      "login": "aditanase"
    },
    "body": "Given that most metrics are counters, I would add a small inline function that reduces some of the repetition here, e.g.\r\n```scala\r\ndef getCounter(prefix: String, name: String): Counter =\r\n  metricRegistry.counter(MetricRegistry.name(prefix, name))\r\n```",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-09T11:53:17Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = metricRegistry.counter(MetricRegistry.name(\"failedStages\"))\n+\n+  val SKIPPED_STAGES = metricRegistry.counter(MetricRegistry.name(\"skippedStages\"))\n+\n+  val COMPLETED_STAGES = metricRegistry.counter(MetricRegistry.name(\"completedStages\"))\n+\n+  val SUCCEEDED_JOBS = metricRegistry.counter(MetricRegistry.name(\"succeededJobs\"))\n+\n+  val FAILED_JOBS = metricRegistry.counter(MetricRegistry.name(\"failedJobs\"))\n+\n+  val COMPLETED_TASKS = metricRegistry.counter(MetricRegistry.name(\"completedTasks\"))\n+\n+  val FAILED_TASKS = metricRegistry.counter(MetricRegistry.name(\"failedTasks\"))\n+\n+  val KILLED_TASKS = metricRegistry.counter(MetricRegistry.name(\"killedTasks\"))\n+\n+  val SKIPPED_TASKS = metricRegistry.counter(MetricRegistry.name(\"skippedTasks\"))\n+\n+  val BLACKLISTED_EXECUTORS = metricRegistry.counter(MetricRegistry.name(\"blackListedExecutors\"))"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "+1",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-10T13:17:50Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import com.codahale.metrics.{Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = metricRegistry.counter(MetricRegistry.name(\"failedStages\"))\n+\n+  val SKIPPED_STAGES = metricRegistry.counter(MetricRegistry.name(\"skippedStages\"))\n+\n+  val COMPLETED_STAGES = metricRegistry.counter(MetricRegistry.name(\"completedStages\"))\n+\n+  val SUCCEEDED_JOBS = metricRegistry.counter(MetricRegistry.name(\"succeededJobs\"))\n+\n+  val FAILED_JOBS = metricRegistry.counter(MetricRegistry.name(\"failedJobs\"))\n+\n+  val COMPLETED_TASKS = metricRegistry.counter(MetricRegistry.name(\"completedTasks\"))\n+\n+  val FAILED_TASKS = metricRegistry.counter(MetricRegistry.name(\"failedTasks\"))\n+\n+  val KILLED_TASKS = metricRegistry.counter(MetricRegistry.name(\"killedTasks\"))\n+\n+  val SKIPPED_TASKS = metricRegistry.counter(MetricRegistry.name(\"skippedTasks\"))\n+\n+  val BLACKLISTED_EXECUTORS = metricRegistry.counter(MetricRegistry.name(\"blackListedExecutors\"))"
  }],
  "prId": 22381
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.map { foo => blah }`",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-15T20:21:40Z",
    "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import AppStatusSource.getCounter\n+import com.codahale.metrics.{Counter, Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override implicit val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = getCounter(\"stages\", \"failedStages\")\n+\n+  val SKIPPED_STAGES = getCounter(\"stages\", \"skippedStages\")\n+\n+  val COMPLETED_STAGES = getCounter(\"stages\", \"completedStages\")\n+\n+  val SUCCEEDED_JOBS = getCounter(\"jobs\", \"succeededJobs\")\n+\n+  val FAILED_JOBS = getCounter(\"jobs\", \"failedJobs\")\n+\n+  val COMPLETED_TASKS = getCounter(\"tasks\", \"completedTasks\")\n+\n+  val FAILED_TASKS = getCounter(\"tasks\", \"failedTasks\")\n+\n+  val KILLED_TASKS = getCounter(\"tasks\", \"killedTasks\")\n+\n+  val SKIPPED_TASKS = getCounter(\"tasks\", \"skippedTasks\")\n+\n+  val BLACKLISTED_EXECUTORS = getCounter(\"tasks\", \"blackListedExecutors\")\n+\n+  val UNBLACKLISTED_EXECUTORS = getCounter(\"tasks\", \"unblackListedExecutors\")\n+}\n+\n+private[spark] object AppStatusSource {\n+\n+  def getCounter(prefix: String, name: String)(implicit metricRegistry: MetricRegistry): Counter = {\n+    metricRegistry.counter (MetricRegistry.name (prefix, name) )\n+  }\n+\n+  def createSource(conf: SparkConf): Option[AppStatusSource] = {\n+    Option(conf.get(AppStatusSource.APP_STATUS_METRICS_ENABLED))\n+      .filter(identity)\n+      .map(_ => new AppStatusSource())"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "ok ",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-15T22:36:29Z",
    "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import AppStatusSource.getCounter\n+import com.codahale.metrics.{Counter, Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override implicit val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = getCounter(\"stages\", \"failedStages\")\n+\n+  val SKIPPED_STAGES = getCounter(\"stages\", \"skippedStages\")\n+\n+  val COMPLETED_STAGES = getCounter(\"stages\", \"completedStages\")\n+\n+  val SUCCEEDED_JOBS = getCounter(\"jobs\", \"succeededJobs\")\n+\n+  val FAILED_JOBS = getCounter(\"jobs\", \"failedJobs\")\n+\n+  val COMPLETED_TASKS = getCounter(\"tasks\", \"completedTasks\")\n+\n+  val FAILED_TASKS = getCounter(\"tasks\", \"failedTasks\")\n+\n+  val KILLED_TASKS = getCounter(\"tasks\", \"killedTasks\")\n+\n+  val SKIPPED_TASKS = getCounter(\"tasks\", \"skippedTasks\")\n+\n+  val BLACKLISTED_EXECUTORS = getCounter(\"tasks\", \"blackListedExecutors\")\n+\n+  val UNBLACKLISTED_EXECUTORS = getCounter(\"tasks\", \"unblackListedExecutors\")\n+}\n+\n+private[spark] object AppStatusSource {\n+\n+  def getCounter(prefix: String, name: String)(implicit metricRegistry: MetricRegistry): Counter = {\n+    metricRegistry.counter (MetricRegistry.name (prefix, name) )\n+  }\n+\n+  def createSource(conf: SparkConf): Option[AppStatusSource] = {\n+    Option(conf.get(AppStatusSource.APP_STATUS_METRICS_ENABLED))\n+      .filter(identity)\n+      .map(_ => new AppStatusSource())"
  }],
  "prId": 22381
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: no space before `(`",
    "commit": "a08836cc9ca91164cf5dd95a63929d0613779cf2",
    "createdAt": "2018-10-16T21:56:31Z",
    "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.status\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import AppStatusSource.getCounter\n+import com.codahale.metrics.{Counter, Gauge, MetricRegistry}\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.internal.config.ConfigBuilder\n+import org.apache.spark.metrics.source.Source\n+\n+private [spark] class JobDuration(val value: AtomicLong) extends Gauge[Long] {\n+  override def getValue: Long = value.get()\n+}\n+\n+private[spark] class AppStatusSource extends Source {\n+\n+  override implicit val metricRegistry = new MetricRegistry()\n+\n+  override val sourceName = \"appStatus\"\n+\n+  val jobDuration = new JobDuration(new AtomicLong(0L))\n+\n+  // Duration of each job in milliseconds\n+  val JOB_DURATION = metricRegistry\n+    .register(MetricRegistry.name(\"jobDuration\"), jobDuration)\n+\n+  val FAILED_STAGES = getCounter(\"stages\", \"failedStages\")\n+\n+  val SKIPPED_STAGES = getCounter(\"stages\", \"skippedStages\")\n+\n+  val COMPLETED_STAGES = getCounter(\"stages\", \"completedStages\")\n+\n+  val SUCCEEDED_JOBS = getCounter(\"jobs\", \"succeededJobs\")\n+\n+  val FAILED_JOBS = getCounter(\"jobs\", \"failedJobs\")\n+\n+  val COMPLETED_TASKS = getCounter(\"tasks\", \"completedTasks\")\n+\n+  val FAILED_TASKS = getCounter(\"tasks\", \"failedTasks\")\n+\n+  val KILLED_TASKS = getCounter(\"tasks\", \"killedTasks\")\n+\n+  val SKIPPED_TASKS = getCounter(\"tasks\", \"skippedTasks\")\n+\n+  val BLACKLISTED_EXECUTORS = getCounter(\"tasks\", \"blackListedExecutors\")\n+\n+  val UNBLACKLISTED_EXECUTORS = getCounter(\"tasks\", \"unblackListedExecutors\")\n+}\n+\n+private[spark] object AppStatusSource {\n+\n+  def getCounter(prefix: String, name: String)(implicit metricRegistry: MetricRegistry): Counter = {\n+    metricRegistry.counter (MetricRegistry.name (prefix, name) )",
    "line": 70
  }],
  "prId": 22381
}]