[{
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Can you please add some comments about the purpose of this change.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-01T10:09:34Z",
    "diffHunk": "@@ -249,7 +249,9 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    if (maxNumExecutorsNeeded() == 0) {"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "Done.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-04T04:35:07Z",
    "diffHunk": "@@ -249,7 +249,9 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    if (maxNumExecutorsNeeded() == 0) {"
  }],
  "prId": 17480
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "I think it is not a yarn only issue, the description is not precise.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-05T09:31:51Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled, resetting the initializing field may cause\n+     * it to not be set to false in yarn."
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "Also can you elaborate more, I think this issue only exists in initial executor = 0 and stages are running scenario",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-05T09:33:19Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled, resetting the initializing field may cause\n+     * it to not be set to false in yarn."
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "Currently this method will only be called in yarn-client mode when AM re-registers after a failure.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-07T10:33:14Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled, resetting the initializing field may cause\n+     * it to not be set to false in yarn."
  }],
  "prId": 17480
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This kinda raises the question. Is it ever correct to set this to `true` here?\r\n\r\nThis method is only called when the YARN client-mode AM is restarted, and at that point I'd expect initialization to have already happened (so I don't see a need to reset the field in any situation).",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-10T17:38:30Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "@jerryshao  Can you explain the following  comments? I do not understand.\r\n```scala\r\n if (initializing) {\r\n      // Do not change our target while we are still initializing,\r\n      // Otherwise the first job may have to ramp up unnecessarily\r\n      0\r\n    } else if (maxNeeded < numExecutorsTarget) {\r\n```",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T01:03:26Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "In the original design of dynamic executor allocation,  this flag is set to \"true\" to avoid sudden executor number ramp up (because of first job submission) during initializing. You could check the comment.\r\n\r\nAnd for the AM restart scenario, because all the executors will be re-spawned, this is similar to AM first start scenario (if the job is submitted during restart), so we set this flag to true.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T01:14:16Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Sorry but that doesn't really explain much. Why is it bad to ramp up quickly? At which point are things not \"initializing\" anymore?\r\n\r\nIsn't the AM restarting the definition of \"I should ramp up quickly because I might be in the middle of a big job being run\"?",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T01:57:26Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "@vanzin sorry I think I didn't explain well.\r\n\r\nIf this flag `initializing` is set to false during initialization, `updateAndSyncNumExecutorsTarget` will recalculate the required executor number and ramp down the executors if there's no job in the current time. And then if first job is submitted, it still requires to ramp up executors to meet the requirement.\r\n\r\nFor the AM restart scenario I think it is similar during initializing. One exception is the scenario mentioned here, for the case here should ramp up soon to meet the requirement.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T02:13:53Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "`updateAndSyncNumExecutorsTarget` is a weird method. It returns a value that is never used anywhere, the actual variables it sets internally are what matters...\r\n\r\nBut I still don't understand why, when the AM restarts, should `updateAndSyncNumExecutorsTarget` be a no-op except in this case. What is different about this case that makes it an exception? Shouldn't `updateAndSyncNumExecutorsTarget` be called instead from `reset()` or very soon after, so the code can update its internal state to match the current status of the app?\r\n\r\nThe thing I don't understand is why is it ever ok for `updateAndSyncNumExecutorsTarget` to just do nothing.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T02:22:50Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "The following code should have a similar function?\r\n\r\n```scala\r\nnumExecutorsTarget = initialNumExecutors // The default value is 0\r\nnumExecutorsToAdd = 1\r\n```\r\nThe incoming parameters of the client.requestTotalExecutors method are 1,2,4,8,16...",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T02:33:58Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "I think the purpose of \"initializing\" is to avoid unnecessary executors ramp down before the stage submitted or executor timeout. For example if min executor number is 0, initial number is 10. If \"initializing\" is set to false, executor number will ramp down to 0 immediately, and during this time if stage is submitted, then still requires unnecessary executor ramp up to meet this stage's requirement.\r\n\r\nIn the AM restart scenario, if we set \"initializing\" to false in `reset`, then we may also meet the situation mentioned above, I think that's possible.\r\n\r\n",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-11T02:39:02Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "OK. I've got it, thx.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-12T13:45:05Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "This is the comment attached to `initializing`:\r\n\r\n```\r\n  // Whether we are still waiting for the initial set of executors to be allocated.\r\n  // While this is true, we will not cancel outstanding executor requests. This is\r\n  // set to false when:\r\n  //   (1) a stage is submitted, or\r\n  //   (2) an executor idle timeout has elapsed.\r\n```\r\n\r\nNone of those situations are true in reset; we're not waiting for the initial set of executors anymore. A stage might have been submitted already and flipped the value of `initializing`. Many other things have happened.\r\n\r\nSo I still don't understand why is it /ever/ correct to set initializing to true in `reset`.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-12T16:56:05Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "For the 2nd point `an executor idle timeout has elapsed.`, in the `reset` we also clear the executor idle timeout tracking info, which means executor idle timeout will be recalculated based on newly registered executors. I think this point could be true.\r\n\r\nYes we could set this flag `initializing` to false in reset, but I think the scenario I mentioned above still should be concerned.\r\n\r\n>the purpose of \"initializing\" is to avoid unnecessary executors ramp down before the stage submitted or executor timeout. For example if min executor number is 0, initial number is 10. If \"initializing\" is set to false, executor number will ramp down to 0 immediately, and during this time if stage is submitted, then still requires unnecessary executor ramp up to meet this stage's requirement.\r\n",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T00:59:46Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "It seems that what you're describing is that reset is broken and instead it shouldn't have any effect on the current number of needed executors. So why is reset changing `numExecutorsTarget` at all?",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T01:50:41Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": ">instead it shouldn't have any effect on the current number of needed executors\r\n\r\nI think I don't say `reset` shouldn't have any effect on the current required executor numbers.\r\n\r\n`reset` is happened in yarn client mode AM failure situation. In this situation, executors will be re-spawned to the initial executor number. So `numExecutorsTarget` should also set to this value to match in the initial state.\r\n\r\nIIUC, your purpose of reset is to change the state (executor number) to be the same as final state of last attempt. For example we have 10 executors before AM gone, my understanding is that you want dynamic allocation to reset to 10 after AM restart, am I right?\r\n\r\nAnd the original implementation of `reset` is to change the state to the first state of last attempt, which means if the initial state is 1 executors, then after reset we also change to \"1\".\r\n\r\n",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T02:04:41Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "What I'm asking is why reset is trying to change the state at all? It may die in the middle of a stage, or in between two stages, or while the driver is idle and nothing is happening. But the fact is, `reset()` has none of that information, but it is deciding that it should be resetting things to some initial state that is not based on the current status of the application at all.\r\n\r\nSo why is reset doing that? What good is that achieving?\r\n\r\nAs far as I can see, the only thing reset needs to account for is executors that the driver thought it asked to be killed. Those will die by themselves, so the code can just empty the \"kill request\" queue and update the related state appropriately.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T02:09:23Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "One downside could be:\r\n\r\n> During running tasks, when the total number of executors is the value of spark.dynamicAllocation.maxExecutors and the AM is failed. Then a new AM restarts. Because in ExecutorAllocationManager, the total number of executors does not changed, driver does not send RequestExecutors to AM to ask executors. Then the total number of executors is the value of spark.dynamicAllocation.initialExecutors . So the total number of executors in driver and AM is different.\r\n\r\nBecause when AM is restarted, it will change it's state to the initial state, whereas if `ExecutorAllocationManager`'s state is still the current state, then the state maintained in two sides will be out of sync, and required executor number calculated in AM side will be wrong.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T02:20:02Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You're just saying that when a new AM registers the driver needs to tell it how many executors it wants. So, basically, instead of the driver doing that, currently the driver just resets itself to the initial state, hurting any running jobs.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T02:21:23Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "> when a new AM registers the driver needs to tell it how many executors it wants.\r\n\r\nWhen a AM registers, it leverages configuration to decide the initial number of executors should be created, not driver who told him how many executors it wants. That's why in the driver side if we don't change the executor number to match the AM side, we will meet the problem as mentioned above (because driver hasn't yet told AM the executor number).",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T02:34:11Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You're explaining what the code does as a justification for why a hacky fix should be applied to this issue. I'm asking why the code needs to behave like that. If there's no actual *need* for the code to behave like that, it should be fixed.\r\n\r\nBasically, imagine that at t1 the AM dies, and at t2 a new AM comes up and registers. What should happen from the driver's point of view? (Note, what *should happen*, not what the code does.)\r\n\r\nIn my view, the answer is \"nothing\". The driver knows what it needs, so the new AM should start as closely as possible to the state of the previous AM. Doing that might be hard (e.g. caching the complete list of known containers somewhere, probably the driver), so some things are sub-optimal (containers will be re-started). But as far as numbers go, the new AM should basically start up with the same number of containers the previous AM was managing (ignoring the time needed to start them up).\r\n\r\nIf the AM doesn't do that currently, then why is that? It asks the driver for state related to the previous AM already (see `RetrieveLastAllocatedExecutorId` call). Why can't that call return more state needed for the new AM to sync up to what the driver needs?",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-13T16:54:59Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }, {
    "author": {
      "login": "jerryshao"
    },
    "body": "Well, I understood your thinking.\r\n\r\nThis actually comes from the definition of reset, should it be the initial state or the last state before failure. In our previous commit we chose the former to roll back to the initial state. But here you suggest the latter is better. I agree with you the latter looks more reasonable, also could address the problem here. Thanks for the clarification.\r\n\r\n",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-14T02:37:12Z",
    "diffHunk": "@@ -249,7 +249,14 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true\n+    /**\n+     * When some tasks need to be scheduled and initial executor = 0, resetting the initializing\n+     * field may cause it to not be set to false in yarn.\n+     * SPARK-20079: https://issues.apache.org/jira/browse/SPARK-20079\n+     */\n+    if (maxNumExecutorsNeeded() == 0) {\n+      initializing = true"
  }],
  "prId": 17480
}, {
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "@jerryshao  @vanzin\r\n I think that deleting the `initializing = true` is a good idea.",
    "commit": "d3e69cf66d77ba02cfa13e8e27273e59248885f1",
    "createdAt": "2017-04-23T05:02:56Z",
    "diffHunk": "@@ -249,7 +249,6 @@ private[spark] class ExecutorAllocationManager(\n    * yarn-client mode when AM re-registers after a failure.\n    */\n   def reset(): Unit = synchronized {\n-    initializing = true",
    "line": 4
  }],
  "prId": 17480
}]