[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "`poolSize / minMemoryPerTask` should be `minMemoryPerTask - curMem`\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T06:02:51Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {\n         // We want to let each task get at least 1 / (2 * numActiveTasks) before blocking;\n         // if we can't give it this much now, wait for other tasks to free up memory\n         // (this happens if older tasks allocated lots of memory before N grew)\n-        if (memoryFree >= math.min(maxToGrant, poolSize / (2 * numActiveTasks) - curMem)) {\n+        if (memoryFree >= math.min(maxToGrant, poolSize / minMemoryPerTask)) {"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "oops good catch!!\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T06:46:18Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {\n         // We want to let each task get at least 1 / (2 * numActiveTasks) before blocking;\n         // if we can't give it this much now, wait for other tasks to free up memory\n         // (this happens if older tasks allocated lots of memory before N grew)\n-        if (memoryFree >= math.min(maxToGrant, poolSize / (2 * numActiveTasks) - curMem)) {\n+        if (memoryFree >= math.min(maxToGrant, poolSize / minMemoryPerTask)) {"
  }],
  "prId": 10240
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "I'd like to change this block as this:\n\n```\nif (toGrant < numBytes && curMem + toGrant < minMemoryPerTask) {\n  lock.wait()\n} else {\n  memoryForTask(taskAttemptId) += toGrant\n  return toGrant\n}\n```\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T06:07:51Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "that looks fine, but is it completely equivalent to the old code? It's not 100% clear to me.\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T08:23:22Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "If not, the old code is not correct.\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T08:55:07Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "The current code is hard to understand, I can prove that it's the same with mine one.\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T18:54:53Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "yeah, I agree, though it's an unrelated issue that we can always fix separately so we don't block the release. Let's defer the judgment to @JoshRosen.\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T19:03:18Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "I was able to prove their equivalence myself. I summarized my thoughts in this gist: https://gist.github.com/andrewor14/aea58796dd25d2ec9f20\n\nThat said, I would still prefer to do this separately since this PR is already passing tests. :)\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T19:51:27Z",
    "diffHunk": "@@ -91,23 +108,34 @@ private[memory] class ExecutionMemoryPool(\n       val numActiveTasks = memoryForTask.keys.size\n       val curMem = memoryForTask(taskAttemptId)\n \n-      // How much we can grant this task; don't let it grow to more than 1 / numActiveTasks;\n-      // don't let it be negative\n-      val maxToGrant =\n-        math.min(numBytes, math.max(0, (poolSize / numActiveTasks) - curMem))\n+      // In every iteration of this loop, we should first try to reclaim any borrowed execution\n+      // space from storage. This is necessary because of the potential race condition where new\n+      // storage blocks may steal the free execution memory that this task was waiting for.\n+      maybeGrowPool(numBytes - memoryFree)\n+\n+      // Maximum size the pool would have after potentially growing the pool.\n+      // This is used to compute the upper bound of how much memory each task can occupy. This\n+      // must take into account potential free memory as well as the amount this pool currently\n+      // occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,\n+      // we did not take into account space that could have been freed by evicting cached blocks.\n+      val maxPoolSize = computeMaxPoolSize()\n+      val maxMemoryPerTask = maxPoolSize / numActiveTasks\n+      val minMemoryPerTask = poolSize / (2 * numActiveTasks)\n+\n+      // How much we can grant this task; keep its share within 0 <= X <= 1 / numActiveTasks\n+      val maxToGrant = math.min(numBytes, math.max(0, maxMemoryPerTask - curMem))\n       // Only give it as much memory as is free, which might be none if it reached 1 / numTasks\n       val toGrant = math.min(maxToGrant, memoryFree)\n \n-      if (curMem < poolSize / (2 * numActiveTasks)) {\n+      if (curMem < minMemoryPerTask) {"
  }],
  "prId": 10240
}, {
  "comments": [{
    "author": {
      "login": "nongli"
    },
    "body": "If you take into account the memory that can be freed then isn't this a fixed value?\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T20:32:40Z",
    "diffHunk": "@@ -70,11 +70,28 @@ private[memory] class ExecutionMemoryPool(\n    * active tasks) before it is forced to spill. This can happen if the number of tasks increase\n    * but an older task had a lot of memory already.\n    *\n+   * @param numBytes number of bytes to acquire\n+   * @param taskAttemptId the task attempt acquiring memory\n+   * @param maybeGrowPool a callback that potentially grows the size of this pool. It takes in\n+   *                      one parameter (Long) that represents the desired amount of memory by\n+   *                      which this pool should be expanded.\n+   * @param computeMaxPoolSize a callback that returns the maximum allowable size of this pool",
    "line": 9
  }, {
    "author": {
      "login": "davies"
    },
    "body": "The actual used memory by storage could be changed, so it's not a fixed value\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T20:36:54Z",
    "diffHunk": "@@ -70,11 +70,28 @@ private[memory] class ExecutionMemoryPool(\n    * active tasks) before it is forced to spill. This can happen if the number of tasks increase\n    * but an older task had a lot of memory already.\n    *\n+   * @param numBytes number of bytes to acquire\n+   * @param taskAttemptId the task attempt acquiring memory\n+   * @param maybeGrowPool a callback that potentially grows the size of this pool. It takes in\n+   *                      one parameter (Long) that represents the desired amount of memory by\n+   *                      which this pool should be expanded.\n+   * @param computeMaxPoolSize a callback that returns the maximum allowable size of this pool",
    "line": 9
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "Nvm, I see now.\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T20:36:55Z",
    "diffHunk": "@@ -70,11 +70,28 @@ private[memory] class ExecutionMemoryPool(\n    * active tasks) before it is forced to spill. This can happen if the number of tasks increase\n    * but an older task had a lot of memory already.\n    *\n+   * @param numBytes number of bytes to acquire\n+   * @param taskAttemptId the task attempt acquiring memory\n+   * @param maybeGrowPool a callback that potentially grows the size of this pool. It takes in\n+   *                      one parameter (Long) that represents the desired amount of memory by\n+   *                      which this pool should be expanded.\n+   * @param computeMaxPoolSize a callback that returns the maximum allowable size of this pool",
    "line": 9
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "no, because if storage memory used is below a certain mark (default 0.5 of max memory) then it cannot be evicted. In this case the max pool size depends on how much unevictable storage memory there is, which varies over time.\n",
    "commit": "292964002cbbf695b621afd205269b0cb0198c83",
    "createdAt": "2015-12-10T20:39:24Z",
    "diffHunk": "@@ -70,11 +70,28 @@ private[memory] class ExecutionMemoryPool(\n    * active tasks) before it is forced to spill. This can happen if the number of tasks increase\n    * but an older task had a lot of memory already.\n    *\n+   * @param numBytes number of bytes to acquire\n+   * @param taskAttemptId the task attempt acquiring memory\n+   * @param maybeGrowPool a callback that potentially grows the size of this pool. It takes in\n+   *                      one parameter (Long) that represents the desired amount of memory by\n+   *                      which this pool should be expanded.\n+   * @param computeMaxPoolSize a callback that returns the maximum allowable size of this pool",
    "line": 9
  }],
  "prId": 10240
}]