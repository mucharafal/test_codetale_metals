[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Here should be updated to MAXIMUM_PARTITION_ID + 1\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T05:57:09Z",
    "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.apache.spark.HashPartitioner;\n+import org.apache.spark.unsafe.PlatformDependent;\n+import org.apache.spark.unsafe.memory.ExecutorMemoryManager;\n+import org.apache.spark.unsafe.memory.MemoryAllocator;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.memory.TaskMemoryManager;\n+\n+public class UnsafeShuffleSorterSuite {\n+\n+  private static String getStringFromDataPage(Object baseObject, long baseOffset, int strLength) {\n+    final byte[] strBytes = new byte[strLength];\n+    PlatformDependent.copyMemory(\n+      baseObject,\n+      baseOffset,\n+      strBytes,\n+      PlatformDependent.BYTE_ARRAY_OFFSET, strLength);\n+    return new String(strBytes);\n+  }\n+\n+  @Test\n+  public void testSortingEmptyInput() {\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(100);\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    assert(!iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testBasicSorting() throws Exception {\n+    final String[] dataToSort = new String[] {\n+      \"Boba\",\n+      \"Pearls\",\n+      \"Tapioca\",\n+      \"Taho\",\n+      \"Condensed Milk\",\n+      \"Jasmine\",\n+      \"Milk Tea\",\n+      \"Lychee\",\n+      \"Mango\"\n+    };\n+    final TaskMemoryManager memoryManager =\n+      new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.HEAP));\n+    final MemoryBlock dataPage = memoryManager.allocatePage(2048);\n+    final Object baseObject = dataPage.getBaseObject();\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    final HashPartitioner hashPartitioner = new HashPartitioner(4);\n+\n+    // Write the records into the data page and store pointers into the sorter\n+    long position = dataPage.getBaseOffset();\n+    for (String str : dataToSort) {\n+      final long recordAddress = memoryManager.encodePageNumberAndOffset(dataPage, position);\n+      final byte[] strBytes = str.getBytes(\"utf-8\");\n+      PlatformDependent.UNSAFE.putInt(baseObject, position, strBytes.length);\n+      position += 4;\n+      PlatformDependent.copyMemory(\n+        strBytes,\n+        PlatformDependent.BYTE_ARRAY_OFFSET,\n+        baseObject,\n+        position,\n+        strBytes.length);\n+      position += strBytes.length;\n+      sorter.insertRecord(recordAddress, hashPartitioner.getPartition(str));\n+    }\n+\n+    // Sort the records\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    int prevPartitionId = -1;\n+    Arrays.sort(dataToSort);\n+    for (int i = 0; i < dataToSort.length; i++) {\n+      Assert.assertTrue(iter.hasNext());\n+      iter.loadNext();\n+      final int partitionId = iter.packedRecordPointer.getPartitionId();\n+      Assert.assertTrue(partitionId >= 0 && partitionId <= 3);\n+      Assert.assertTrue(\"Partition id \" + partitionId + \" should be >= prev id \" + prevPartitionId,\n+        partitionId >= prevPartitionId);\n+      final long recordAddress = iter.packedRecordPointer.getRecordPointer();\n+      final int recordLength = PlatformDependent.UNSAFE.getInt(\n+        memoryManager.getPage(recordAddress), memoryManager.getOffsetInPage(recordAddress));\n+      final String str = getStringFromDataPage(\n+        memoryManager.getPage(recordAddress),\n+        memoryManager.getOffsetInPage(recordAddress) + 4, // skip over record length\n+        recordLength);\n+      Assert.assertTrue(Arrays.binarySearch(dataToSort, str) != -1);\n+    }\n+    Assert.assertFalse(iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testSortingManyNumbers() throws Exception {\n+    UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    int[] numbersToSort = new int[128000];\n+    Random random = new Random(16);\n+    for (int i = 0; i < numbersToSort.length; i++) {\n+      numbersToSort[i] = random.nextInt(PackedRecordPointer.MAXIMUM_PARTITION_ID);"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Actually, I think that this case should be left as-is, since MAXIMUM_PARTITION_ID is the maximum value that can be sorted.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T18:47:06Z",
    "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.apache.spark.HashPartitioner;\n+import org.apache.spark.unsafe.PlatformDependent;\n+import org.apache.spark.unsafe.memory.ExecutorMemoryManager;\n+import org.apache.spark.unsafe.memory.MemoryAllocator;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.memory.TaskMemoryManager;\n+\n+public class UnsafeShuffleSorterSuite {\n+\n+  private static String getStringFromDataPage(Object baseObject, long baseOffset, int strLength) {\n+    final byte[] strBytes = new byte[strLength];\n+    PlatformDependent.copyMemory(\n+      baseObject,\n+      baseOffset,\n+      strBytes,\n+      PlatformDependent.BYTE_ARRAY_OFFSET, strLength);\n+    return new String(strBytes);\n+  }\n+\n+  @Test\n+  public void testSortingEmptyInput() {\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(100);\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    assert(!iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testBasicSorting() throws Exception {\n+    final String[] dataToSort = new String[] {\n+      \"Boba\",\n+      \"Pearls\",\n+      \"Tapioca\",\n+      \"Taho\",\n+      \"Condensed Milk\",\n+      \"Jasmine\",\n+      \"Milk Tea\",\n+      \"Lychee\",\n+      \"Mango\"\n+    };\n+    final TaskMemoryManager memoryManager =\n+      new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.HEAP));\n+    final MemoryBlock dataPage = memoryManager.allocatePage(2048);\n+    final Object baseObject = dataPage.getBaseObject();\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    final HashPartitioner hashPartitioner = new HashPartitioner(4);\n+\n+    // Write the records into the data page and store pointers into the sorter\n+    long position = dataPage.getBaseOffset();\n+    for (String str : dataToSort) {\n+      final long recordAddress = memoryManager.encodePageNumberAndOffset(dataPage, position);\n+      final byte[] strBytes = str.getBytes(\"utf-8\");\n+      PlatformDependent.UNSAFE.putInt(baseObject, position, strBytes.length);\n+      position += 4;\n+      PlatformDependent.copyMemory(\n+        strBytes,\n+        PlatformDependent.BYTE_ARRAY_OFFSET,\n+        baseObject,\n+        position,\n+        strBytes.length);\n+      position += strBytes.length;\n+      sorter.insertRecord(recordAddress, hashPartitioner.getPartition(str));\n+    }\n+\n+    // Sort the records\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    int prevPartitionId = -1;\n+    Arrays.sort(dataToSort);\n+    for (int i = 0; i < dataToSort.length; i++) {\n+      Assert.assertTrue(iter.hasNext());\n+      iter.loadNext();\n+      final int partitionId = iter.packedRecordPointer.getPartitionId();\n+      Assert.assertTrue(partitionId >= 0 && partitionId <= 3);\n+      Assert.assertTrue(\"Partition id \" + partitionId + \" should be >= prev id \" + prevPartitionId,\n+        partitionId >= prevPartitionId);\n+      final long recordAddress = iter.packedRecordPointer.getRecordPointer();\n+      final int recordLength = PlatformDependent.UNSAFE.getInt(\n+        memoryManager.getPage(recordAddress), memoryManager.getOffsetInPage(recordAddress));\n+      final String str = getStringFromDataPage(\n+        memoryManager.getPage(recordAddress),\n+        memoryManager.getOffsetInPage(recordAddress) + 4, // skip over record length\n+        recordLength);\n+      Assert.assertTrue(Arrays.binarySearch(dataToSort, str) != -1);\n+    }\n+    Assert.assertFalse(iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testSortingManyNumbers() throws Exception {\n+    UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    int[] numbersToSort = new int[128000];\n+    Random random = new Random(16);\n+    for (int i = 0; i < numbersToSort.length; i++) {\n+      numbersToSort[i] = random.nextInt(PackedRecordPointer.MAXIMUM_PARTITION_ID);"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "From the `nextInt` doc: `@param bound the upper bound (exclusive).  Must be positive.` I think `MAXIMUM_PARTITION_ID` is also a valid value in your test. Right? \n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T19:03:35Z",
    "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.apache.spark.HashPartitioner;\n+import org.apache.spark.unsafe.PlatformDependent;\n+import org.apache.spark.unsafe.memory.ExecutorMemoryManager;\n+import org.apache.spark.unsafe.memory.MemoryAllocator;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.memory.TaskMemoryManager;\n+\n+public class UnsafeShuffleSorterSuite {\n+\n+  private static String getStringFromDataPage(Object baseObject, long baseOffset, int strLength) {\n+    final byte[] strBytes = new byte[strLength];\n+    PlatformDependent.copyMemory(\n+      baseObject,\n+      baseOffset,\n+      strBytes,\n+      PlatformDependent.BYTE_ARRAY_OFFSET, strLength);\n+    return new String(strBytes);\n+  }\n+\n+  @Test\n+  public void testSortingEmptyInput() {\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(100);\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    assert(!iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testBasicSorting() throws Exception {\n+    final String[] dataToSort = new String[] {\n+      \"Boba\",\n+      \"Pearls\",\n+      \"Tapioca\",\n+      \"Taho\",\n+      \"Condensed Milk\",\n+      \"Jasmine\",\n+      \"Milk Tea\",\n+      \"Lychee\",\n+      \"Mango\"\n+    };\n+    final TaskMemoryManager memoryManager =\n+      new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.HEAP));\n+    final MemoryBlock dataPage = memoryManager.allocatePage(2048);\n+    final Object baseObject = dataPage.getBaseObject();\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    final HashPartitioner hashPartitioner = new HashPartitioner(4);\n+\n+    // Write the records into the data page and store pointers into the sorter\n+    long position = dataPage.getBaseOffset();\n+    for (String str : dataToSort) {\n+      final long recordAddress = memoryManager.encodePageNumberAndOffset(dataPage, position);\n+      final byte[] strBytes = str.getBytes(\"utf-8\");\n+      PlatformDependent.UNSAFE.putInt(baseObject, position, strBytes.length);\n+      position += 4;\n+      PlatformDependent.copyMemory(\n+        strBytes,\n+        PlatformDependent.BYTE_ARRAY_OFFSET,\n+        baseObject,\n+        position,\n+        strBytes.length);\n+      position += strBytes.length;\n+      sorter.insertRecord(recordAddress, hashPartitioner.getPartition(str));\n+    }\n+\n+    // Sort the records\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    int prevPartitionId = -1;\n+    Arrays.sort(dataToSort);\n+    for (int i = 0; i < dataToSort.length; i++) {\n+      Assert.assertTrue(iter.hasNext());\n+      iter.loadNext();\n+      final int partitionId = iter.packedRecordPointer.getPartitionId();\n+      Assert.assertTrue(partitionId >= 0 && partitionId <= 3);\n+      Assert.assertTrue(\"Partition id \" + partitionId + \" should be >= prev id \" + prevPartitionId,\n+        partitionId >= prevPartitionId);\n+      final long recordAddress = iter.packedRecordPointer.getRecordPointer();\n+      final int recordLength = PlatformDependent.UNSAFE.getInt(\n+        memoryManager.getPage(recordAddress), memoryManager.getOffsetInPage(recordAddress));\n+      final String str = getStringFromDataPage(\n+        memoryManager.getPage(recordAddress),\n+        memoryManager.getOffsetInPage(recordAddress) + 4, // skip over record length\n+        recordLength);\n+      Assert.assertTrue(Arrays.binarySearch(dataToSort, str) != -1);\n+    }\n+    Assert.assertFalse(iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testSortingManyNumbers() throws Exception {\n+    UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    int[] numbersToSort = new int[128000];\n+    Random random = new Random(16);\n+    for (int i = 0; i < numbersToSort.length; i++) {\n+      numbersToSort[i] = random.nextInt(PackedRecordPointer.MAXIMUM_PARTITION_ID);"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Ah, right.  I'll fix this.\n",
    "commit": "ef0a86e41e9b390e6c0d60a6ed2105dbc54431f7",
    "createdAt": "2015-05-12T19:04:26Z",
    "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.unsafe;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.apache.spark.HashPartitioner;\n+import org.apache.spark.unsafe.PlatformDependent;\n+import org.apache.spark.unsafe.memory.ExecutorMemoryManager;\n+import org.apache.spark.unsafe.memory.MemoryAllocator;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.memory.TaskMemoryManager;\n+\n+public class UnsafeShuffleSorterSuite {\n+\n+  private static String getStringFromDataPage(Object baseObject, long baseOffset, int strLength) {\n+    final byte[] strBytes = new byte[strLength];\n+    PlatformDependent.copyMemory(\n+      baseObject,\n+      baseOffset,\n+      strBytes,\n+      PlatformDependent.BYTE_ARRAY_OFFSET, strLength);\n+    return new String(strBytes);\n+  }\n+\n+  @Test\n+  public void testSortingEmptyInput() {\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(100);\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    assert(!iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testBasicSorting() throws Exception {\n+    final String[] dataToSort = new String[] {\n+      \"Boba\",\n+      \"Pearls\",\n+      \"Tapioca\",\n+      \"Taho\",\n+      \"Condensed Milk\",\n+      \"Jasmine\",\n+      \"Milk Tea\",\n+      \"Lychee\",\n+      \"Mango\"\n+    };\n+    final TaskMemoryManager memoryManager =\n+      new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.HEAP));\n+    final MemoryBlock dataPage = memoryManager.allocatePage(2048);\n+    final Object baseObject = dataPage.getBaseObject();\n+    final UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    final HashPartitioner hashPartitioner = new HashPartitioner(4);\n+\n+    // Write the records into the data page and store pointers into the sorter\n+    long position = dataPage.getBaseOffset();\n+    for (String str : dataToSort) {\n+      final long recordAddress = memoryManager.encodePageNumberAndOffset(dataPage, position);\n+      final byte[] strBytes = str.getBytes(\"utf-8\");\n+      PlatformDependent.UNSAFE.putInt(baseObject, position, strBytes.length);\n+      position += 4;\n+      PlatformDependent.copyMemory(\n+        strBytes,\n+        PlatformDependent.BYTE_ARRAY_OFFSET,\n+        baseObject,\n+        position,\n+        strBytes.length);\n+      position += strBytes.length;\n+      sorter.insertRecord(recordAddress, hashPartitioner.getPartition(str));\n+    }\n+\n+    // Sort the records\n+    final UnsafeShuffleSorter.UnsafeShuffleSorterIterator iter = sorter.getSortedIterator();\n+    int prevPartitionId = -1;\n+    Arrays.sort(dataToSort);\n+    for (int i = 0; i < dataToSort.length; i++) {\n+      Assert.assertTrue(iter.hasNext());\n+      iter.loadNext();\n+      final int partitionId = iter.packedRecordPointer.getPartitionId();\n+      Assert.assertTrue(partitionId >= 0 && partitionId <= 3);\n+      Assert.assertTrue(\"Partition id \" + partitionId + \" should be >= prev id \" + prevPartitionId,\n+        partitionId >= prevPartitionId);\n+      final long recordAddress = iter.packedRecordPointer.getRecordPointer();\n+      final int recordLength = PlatformDependent.UNSAFE.getInt(\n+        memoryManager.getPage(recordAddress), memoryManager.getOffsetInPage(recordAddress));\n+      final String str = getStringFromDataPage(\n+        memoryManager.getPage(recordAddress),\n+        memoryManager.getOffsetInPage(recordAddress) + 4, // skip over record length\n+        recordLength);\n+      Assert.assertTrue(Arrays.binarySearch(dataToSort, str) != -1);\n+    }\n+    Assert.assertFalse(iter.hasNext());\n+  }\n+\n+  @Test\n+  public void testSortingManyNumbers() throws Exception {\n+    UnsafeShuffleSorter sorter = new UnsafeShuffleSorter(4);\n+    int[] numbersToSort = new int[128000];\n+    Random random = new Random(16);\n+    for (int i = 0; i < numbersToSort.length; i++) {\n+      numbersToSort[i] = random.nextInt(PackedRecordPointer.MAXIMUM_PARTITION_ID);"
  }],
  "prId": 5868
}]