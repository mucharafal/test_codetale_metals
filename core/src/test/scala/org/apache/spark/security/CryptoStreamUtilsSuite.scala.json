[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "since you're throwing a mock IOException above, this would be a little more clear if here you checked the message too\r\n\r\n```scala\r\nassert(intercept[IOException] {\r\n  errorHandler.read(out)\r\n}.getMessage() === (\"Cipher stream is closed.\"))\r\n```\r\n\r\n(you can also use `assertThrows` if you're not looking at the exception at all, though doesn't really matter)",
    "commit": "e6e538282d408b5a87d7fd81e1c2344e41854f5c",
    "createdAt": "2018-09-27T19:54:07Z",
    "diffHunk": "@@ -164,6 +167,34 @@ class CryptoStreamUtilsSuite extends SparkFunSuite {\n     }\n   }\n \n+  test(\"error handling wrapper\") {\n+    val wrapped = mock(classOf[ReadableByteChannel])\n+    val decrypted = mock(classOf[ReadableByteChannel])\n+    val errorHandler = new CryptoStreamUtils.ErrorHandlingReadableChannel(decrypted, wrapped)\n+\n+    when(decrypted.read(any(classOf[ByteBuffer])))\n+      .thenThrow(new IOException())\n+      .thenThrow(new InternalError())\n+      .thenReturn(1)\n+\n+    val out = ByteBuffer.allocate(1)\n+    intercept[IOException] {\n+      errorHandler.read(out)\n+    }\n+    intercept[InternalError] {\n+      errorHandler.read(out)\n+    }\n+    intercept[IOException] {\n+      errorHandler.read(out)\n+    }",
    "line": 43
  }],
  "prId": 22557
}]