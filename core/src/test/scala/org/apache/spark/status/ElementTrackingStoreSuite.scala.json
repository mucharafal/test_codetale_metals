[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "remove one empty line",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-20T20:26:53Z",
    "diffHunk": "@@ -17,14 +17,66 @@\n \n package org.apache.spark.status\n \n+import java.util.concurrent.atomic.AtomicInteger\n+\n import org.mockito.Mockito._\n \n import org.apache.spark.{SparkConf, SparkFunSuite}\n import org.apache.spark.internal.config.Status._\n+import org.apache.spark.status.ElementTrackingStore._\n import org.apache.spark.util.kvstore._\n \n class ElementTrackingStoreSuite extends SparkFunSuite {\n \n+  test(\"asynchronous tracking single-fire\") {\n+    val store = mock(classOf[KVStore])\n+    val tracking = new ElementTrackingStore(store, new SparkConf()\n+      .set(ASYNC_TRACKING_ENABLED, true))\n+\n+    val waiter = new Object()\n+    var done = false\n+    var type1 = new AtomicInteger(0)\n+    var queued0: WriteQueueResult = null\n+    var queued1: WriteQueueResult = null\n+    var queued2: WriteQueueResult = null\n+    var queued3: WriteQueueResult = null\n+",
    "line": 29
  }],
  "prId": 24616
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Hmmm... maybe add a timeout here (or use `eventually`)? The issue is that if there's a bug in your code, this may not actually return. (It's passing, but if a bug is added later then this would be an annoying thing to debug.)",
    "commit": "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "createdAt": "2019-05-20T20:30:38Z",
    "diffHunk": "@@ -17,14 +17,66 @@\n \n package org.apache.spark.status\n \n+import java.util.concurrent.atomic.AtomicInteger\n+\n import org.mockito.Mockito._\n \n import org.apache.spark.{SparkConf, SparkFunSuite}\n import org.apache.spark.internal.config.Status._\n+import org.apache.spark.status.ElementTrackingStore._\n import org.apache.spark.util.kvstore._\n \n class ElementTrackingStoreSuite extends SparkFunSuite {\n \n+  test(\"asynchronous tracking single-fire\") {\n+    val store = mock(classOf[KVStore])\n+    val tracking = new ElementTrackingStore(store, new SparkConf()\n+      .set(ASYNC_TRACKING_ENABLED, true))\n+\n+    val waiter = new Object()\n+    var done = false\n+    var type1 = new AtomicInteger(0)\n+    var queued0: WriteQueueResult = null\n+    var queued1: WriteQueueResult = null\n+    var queued2: WriteQueueResult = null\n+    var queued3: WriteQueueResult = null\n+\n+\n+    tracking.addTrigger(classOf[Type1], 1) { count =>\n+      val count = type1.getAndIncrement()\n+\n+      count match {\n+        case 0 =>\n+          // while in the asynchronous thread, attempt to increment twice.  The first should\n+          // succeed, the second should be skipped\n+          queued1 = tracking.write(new Type1, checkTriggers = true)\n+          queued2 = tracking.write(new Type1, checkTriggers = true)\n+        case 1 =>\n+          // Verify that once we've started deliver again, that we can enqueue another\n+          queued3 = tracking.write(new Type1, checkTriggers = true)\n+        case 2 =>\n+          waiter.synchronized {\n+            done = true\n+            waiter.notifyAll()\n+          }\n+      }\n+    }\n+\n+    when(store.count(classOf[Type1])).thenReturn(2L)\n+    queued0 = tracking.write(new Type1, checkTriggers = true)\n+    waiter.synchronized {\n+      if (!done) {\n+        waiter.wait()"
  }],
  "prId": 24616
}]