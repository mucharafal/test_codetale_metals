[{
  "comments": [{
    "author": {
      "login": "dragos"
    },
    "body": "The lines up to this one are boilerplate and repeated in each test. Do you think you could refactor this in a way that makes it less repetitive?\n",
    "commit": "ebadaf3c55e839a00a8cf534e7b2fd2c8e988475",
    "createdAt": "2015-10-22T08:46:51Z",
    "diffHunk": "@@ -72,4 +78,56 @@ class MesosClusterSchedulerSuite extends SparkFunSuite with LocalSparkContext wi\n     val state = scheduler.getSchedulerState()\n     assert(state.queuedDrivers.isEmpty)\n   }\n+\n+  test(\"can handle multiple roles\") {\n+    val conf = new SparkConf()\n+    conf.setMaster(\"mesos://localhost:5050\")\n+    conf.setAppName(\"spark mesos\")\n+    val scheduler = new MesosClusterScheduler(\n+      new BlackHoleMesosClusterPersistenceEngineFactory, conf) {\n+      override def start(): Unit = { ready = true }\n+    }\n+    scheduler.start()"
  }],
  "prId": 8872
}, {
  "comments": [{
    "author": {
      "login": "dragos"
    },
    "body": "Can you also test that the role is set? In other words, would this test fail without this patch?\n",
    "commit": "ebadaf3c55e839a00a8cf534e7b2fd2c8e988475",
    "createdAt": "2015-10-22T08:49:46Z",
    "diffHunk": "@@ -72,4 +78,56 @@ class MesosClusterSchedulerSuite extends SparkFunSuite with LocalSparkContext wi\n     val state = scheduler.getSchedulerState()\n     assert(state.queuedDrivers.isEmpty)\n   }\n+\n+  test(\"can handle multiple roles\") {\n+    val conf = new SparkConf()\n+    conf.setMaster(\"mesos://localhost:5050\")\n+    conf.setAppName(\"spark mesos\")\n+    val scheduler = new MesosClusterScheduler(\n+      new BlackHoleMesosClusterPersistenceEngineFactory, conf) {\n+      override def start(): Unit = { ready = true }\n+    }\n+    scheduler.start()\n+    val driver = mock[SchedulerDriver]\n+    val response = scheduler.submitDriver(\n+      new MesosDriverDescription(\"d1\", \"jar\", 1500, 1, true,\n+        command,\n+        Map((\"spark.mesos.executor.home\", \"test\"), (\"spark.app.name\", \"test\")),\n+        \"s1\",\n+        new Date()))\n+    assert(response.success)\n+    val offer = Offer.newBuilder()\n+      .addResources(\n+        Resource.newBuilder().setRole(\"*\")\n+          .setScalar(Scalar.newBuilder().setValue(1).build()).setName(\"cpus\").setType(Type.SCALAR))\n+      .addResources(\n+        Resource.newBuilder().setRole(\"*\")\n+          .setScalar(Scalar.newBuilder().setValue(1000).build()).setName(\"mem\").setType(Type.SCALAR))\n+      .addResources(\n+        Resource.newBuilder().setRole(\"role2\")\n+          .setScalar(Scalar.newBuilder().setValue(1).build()).setName(\"cpus\").setType(Type.SCALAR))\n+      .addResources(\n+        Resource.newBuilder().setRole(\"role2\")\n+          .setScalar(Scalar.newBuilder().setValue(500).build()).setName(\"mem\").setType(Type.SCALAR))\n+      .setId(OfferID.newBuilder().setValue(\"o1\").build())\n+      .setFrameworkId(FrameworkID.newBuilder().setValue(\"f1\").build())\n+      .setSlaveId(SlaveID.newBuilder().setValue(\"s1\").build())\n+      .setHostname(\"host1\")\n+      .build()\n+\n+    val capture = ArgumentCaptor.forClass(classOf[Collection[TaskInfo]])\n+\n+    when(\n+      driver.launchTasks(\n+        Matchers.eq(Collections.singleton(offer.getId)),\n+        capture.capture())\n+    ).thenReturn(Status.valueOf(1))\n+\n+    scheduler.resourceOffers(driver, List(offer).asJava)\n+\n+    verify(driver, times(1)).launchTasks("
  }],
  "prId": 8872
}]