[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "we use `FunSuite` style, and in particular all tests should now extend `SparkFunSuite`\n",
    "commit": "902535b1d9a8e5e8b11428bbdde5994c15b83223",
    "createdAt": "2015-06-25T16:18:20Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import org.apache.spark.{SparkConf, SparkContext}\n+import org.mockito.Mockito._\n+import org.scalatest._\n+import org.scalatest.mock.MockitoSugar\n+\n+class MesosSchedulerUtilsSuite extends FlatSpec with Matchers with MockitoSugar {"
  }],
  "prId": 5563
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I'd prefer we avoid crazy variable names, and stick w/ standard java style camelcase.  `offerWithNoTachyon` etc.\n",
    "commit": "902535b1d9a8e5e8b11428bbdde5994c15b83223",
    "createdAt": "2015-06-26T14:04:29Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import org.apache.spark.{SparkFunSuite, SparkConf, SparkContext}\n+import org.mockito.Mockito._\n+import org.scalatest._\n+import org.scalatest.mock.MockitoSugar\n+\n+class MesosSchedulerUtilsSuite extends SparkFunSuite with Matchers with MockitoSugar {\n+\n+  // scalastyle:off structural.type\n+  // this is the documented way of generating fixtures in scalatest\n+  def fixture: Object {val sc: SparkContext; val sparkConf: SparkConf} = new {\n+    val sparkConf = new SparkConf\n+    val sc = mock[SparkContext]\n+    when(sc.conf).thenReturn(sparkConf)\n+  }\n+  val utils = new MesosSchedulerUtils { }\n+  // scalastyle:on structural.type\n+\n+  test(\"use at-least minimum overhead\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(512)\n+    utils.calculateTotalMemory(f.sc) shouldBe 896\n+  }\n+\n+  test(\"use overhead if it is greater than minimum value\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(4096)\n+    utils.calculateTotalMemory(f.sc) shouldBe 4505\n+  }\n+\n+  test(\"use spark.mesos.executor.memoryOverhead (if set)\") {\n+    val f = fixture\n+    val utils = new MesosSchedulerUtils { }\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(1024)\n+    f.sparkConf.set(\"spark.mesos.executor.memoryOverhead\", \"512\")\n+    utils.calculateTotalMemory(f.sc) shouldBe 1536\n+  }\n+\n+  test(\"parse a non-empty constraint string correctly\") {\n+    val expectedMap = Map(\n+      \"tachyon\" -> Set(\"true\"),\n+      \"zone\" -> Set(\"us-east-1a\", \"us-east-1b\")\n+    )\n+    utils.parseConstraintString(\"tachyon:true;zone:us-east-1a,us-east-1b\") should be (expectedMap)\n+  }\n+\n+  test(\"parse an empty constraint string correctly\") {\n+    val utils = new MesosSchedulerUtils { }\n+    utils.parseConstraintString(\"\") shouldBe Map()\n+  }\n+\n+  test(\"throw an exception when the input is malformed\") {\n+    an[IllegalArgumentException] should be thrownBy\n+      utils.parseConstraintString(\"tachyon;zone:us-east\")\n+  }\n+\n+  test(\"empty values for attributes' constraints matches all values\") {\n+    val constraintsStr = \"tachyon:\"\n+    val parsedConstraints = utils.parseConstraintString(constraintsStr)\n+\n+    parsedConstraints shouldBe Map(\"tachyon\" -> Set())\n+\n+    val `offer with no tachyon` = Map(\"zone\" -> Set(\"us-east-1a\", \"us-east-1b\"))\n+    val `offer with tachyon:true` = Map(\"tachyon\" -> Set(\"true\"))\n+    val `offer with tachyon:false` = Map(\"tachyon\" -> Set(\"false\"))"
  }],
  "prId": 5563
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "same here on variable name\n",
    "commit": "902535b1d9a8e5e8b11428bbdde5994c15b83223",
    "createdAt": "2015-06-26T14:04:36Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import org.apache.spark.{SparkFunSuite, SparkConf, SparkContext}\n+import org.mockito.Mockito._\n+import org.scalatest._\n+import org.scalatest.mock.MockitoSugar\n+\n+class MesosSchedulerUtilsSuite extends SparkFunSuite with Matchers with MockitoSugar {\n+\n+  // scalastyle:off structural.type\n+  // this is the documented way of generating fixtures in scalatest\n+  def fixture: Object {val sc: SparkContext; val sparkConf: SparkConf} = new {\n+    val sparkConf = new SparkConf\n+    val sc = mock[SparkContext]\n+    when(sc.conf).thenReturn(sparkConf)\n+  }\n+  val utils = new MesosSchedulerUtils { }\n+  // scalastyle:on structural.type\n+\n+  test(\"use at-least minimum overhead\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(512)\n+    utils.calculateTotalMemory(f.sc) shouldBe 896\n+  }\n+\n+  test(\"use overhead if it is greater than minimum value\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(4096)\n+    utils.calculateTotalMemory(f.sc) shouldBe 4505\n+  }\n+\n+  test(\"use spark.mesos.executor.memoryOverhead (if set)\") {\n+    val f = fixture\n+    val utils = new MesosSchedulerUtils { }\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(1024)\n+    f.sparkConf.set(\"spark.mesos.executor.memoryOverhead\", \"512\")\n+    utils.calculateTotalMemory(f.sc) shouldBe 1536\n+  }\n+\n+  test(\"parse a non-empty constraint string correctly\") {\n+    val expectedMap = Map(\n+      \"tachyon\" -> Set(\"true\"),\n+      \"zone\" -> Set(\"us-east-1a\", \"us-east-1b\")\n+    )\n+    utils.parseConstraintString(\"tachyon:true;zone:us-east-1a,us-east-1b\") should be (expectedMap)\n+  }\n+\n+  test(\"parse an empty constraint string correctly\") {\n+    val utils = new MesosSchedulerUtils { }\n+    utils.parseConstraintString(\"\") shouldBe Map()\n+  }\n+\n+  test(\"throw an exception when the input is malformed\") {\n+    an[IllegalArgumentException] should be thrownBy\n+      utils.parseConstraintString(\"tachyon;zone:us-east\")\n+  }\n+\n+  test(\"empty values for attributes' constraints matches all values\") {\n+    val constraintsStr = \"tachyon:\"\n+    val parsedConstraints = utils.parseConstraintString(constraintsStr)\n+\n+    parsedConstraints shouldBe Map(\"tachyon\" -> Set())\n+\n+    val `offer with no tachyon` = Map(\"zone\" -> Set(\"us-east-1a\", \"us-east-1b\"))\n+    val `offer with tachyon:true` = Map(\"tachyon\" -> Set(\"true\"))\n+    val `offer with tachyon:false` = Map(\"tachyon\" -> Set(\"false\"))\n+\n+    utils.matchesAttributeRequirements(parsedConstraints, `offer with no tachyon`) shouldBe false\n+    utils.matchesAttributeRequirements(parsedConstraints, `offer with tachyon:true`) shouldBe true\n+    utils.matchesAttributeRequirements(parsedConstraints, `offer with tachyon:false`) shouldBe true\n+  }\n+\n+  test(\"subset match is performed constraint attributes\") {\n+    val `constraint with superset` = Map("
  }],
  "prId": 5563
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "is this outdated? also L55\n",
    "commit": "902535b1d9a8e5e8b11428bbdde5994c15b83223",
    "createdAt": "2015-07-02T00:02:16Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import org.apache.mesos.Protos.Value\n+import org.mockito.Mockito._\n+import org.scalatest._\n+import org.scalatest.mock.MockitoSugar\n+import org.apache.spark.{SparkConf, SparkContext, SparkFunSuite}\n+\n+class MesosSchedulerUtilsSuite extends SparkFunSuite with Matchers with MockitoSugar {\n+\n+  // scalastyle:off structural.type\n+  // this is the documented way of generating fixtures in scalatest\n+  def fixture: Object {val sc: SparkContext; val sparkConf: SparkConf} = new {\n+    val sparkConf = new SparkConf\n+    val sc = mock[SparkContext]\n+    when(sc.conf).thenReturn(sparkConf)\n+  }\n+  val utils = new MesosSchedulerUtils { }\n+  // scalastyle:on structural.type\n+\n+  test(\"use at-least minimum overhead\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(512)\n+    utils.calculateTotalMemory(f.sc) shouldBe 896\n+  }\n+\n+  test(\"use overhead if it is greater than minimum value\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896"
  }],
  "prId": 5563
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "do you need to create one here again when you already have one? Same in L54\n",
    "commit": "902535b1d9a8e5e8b11428bbdde5994c15b83223",
    "createdAt": "2015-07-02T00:03:23Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler.cluster.mesos\n+\n+import org.apache.mesos.Protos.Value\n+import org.mockito.Mockito._\n+import org.scalatest._\n+import org.scalatest.mock.MockitoSugar\n+import org.apache.spark.{SparkConf, SparkContext, SparkFunSuite}\n+\n+class MesosSchedulerUtilsSuite extends SparkFunSuite with Matchers with MockitoSugar {\n+\n+  // scalastyle:off structural.type\n+  // this is the documented way of generating fixtures in scalatest\n+  def fixture: Object {val sc: SparkContext; val sparkConf: SparkConf} = new {\n+    val sparkConf = new SparkConf\n+    val sc = mock[SparkContext]\n+    when(sc.conf).thenReturn(sparkConf)\n+  }\n+  val utils = new MesosSchedulerUtils { }\n+  // scalastyle:on structural.type\n+\n+  test(\"use at-least minimum overhead\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(512)\n+    utils.calculateTotalMemory(f.sc) shouldBe 896\n+  }\n+\n+  test(\"use overhead if it is greater than minimum value\") {\n+    val f = fixture\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(4096)\n+    utils.calculateTotalMemory(f.sc) shouldBe 4505\n+  }\n+\n+  test(\"use spark.mesos.executor.memoryOverhead (if set)\") {\n+    val f = fixture\n+    val utils = new MesosSchedulerUtils { }\n+    // 384 > sc.executorMemory * 0.1 => 512 + 384 = 896\n+    when(f.sc.executorMemory).thenReturn(1024)\n+    f.sparkConf.set(\"spark.mesos.executor.memoryOverhead\", \"512\")\n+    utils.calculateTotalMemory(f.sc) shouldBe 1536\n+  }\n+\n+  test(\"parse a non-empty constraint string correctly\") {\n+    val expectedMap = Map(\n+      \"tachyon\" -> Set(\"true\"),\n+      \"zone\" -> Set(\"us-east-1a\", \"us-east-1b\")\n+    )\n+    utils.parseConstraintString(\"tachyon:true;zone:us-east-1a,us-east-1b\") should be (expectedMap)\n+  }\n+\n+  test(\"parse an empty constraint string correctly\") {\n+    val utils = new MesosSchedulerUtils { }"
  }],
  "prId": 5563
}]