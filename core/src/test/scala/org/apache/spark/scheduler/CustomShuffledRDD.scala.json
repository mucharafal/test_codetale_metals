[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "`private[spark]`? Or should this be `@DeveloperAPI`?\n",
    "commit": "9eac9d651d52bd0b5fbe797f7d9b6da4f7c9b6a4",
    "createdAt": "2015-09-21T21:16:16Z",
    "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import java.util.Arrays\n+\n+import org.apache.spark._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * A Partitioner that might group together one or more partitions from the parent.\n+ *\n+ * @param parent a parent partitioner\n+ * @param partitionStartIndices indices of partitions in parent that should create new partitions\n+ *   in child (this should be an array of increasing partition IDs). For example, if we have a\n+ *   parent with 5 partitions, and partitionStartIndices is [0, 2, 4], we get three output\n+ *   partitions, corresponding to partition ranges [0, 1], [2, 3] and [4] of the parent partitioner.\n+ */\n+class CoalescedPartitioner(val parent: Partitioner, val partitionStartIndices: Array[Int])",
    "line": 34
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "This is a test class\n",
    "commit": "9eac9d651d52bd0b5fbe797f7d9b6da4f7c9b6a4",
    "createdAt": "2015-09-23T04:21:36Z",
    "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import java.util.Arrays\n+\n+import org.apache.spark._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * A Partitioner that might group together one or more partitions from the parent.\n+ *\n+ * @param parent a parent partitioner\n+ * @param partitionStartIndices indices of partitions in parent that should create new partitions\n+ *   in child (this should be an array of increasing partition IDs). For example, if we have a\n+ *   parent with 5 partitions, and partitionStartIndices is [0, 2, 4], we get three output\n+ *   partitions, corresponding to partition ranges [0, 1], [2, 3] and [4] of the parent partitioner.\n+ */\n+class CoalescedPartitioner(val parent: Partitioner, val partitionStartIndices: Array[Int])",
    "line": 34
  }],
  "prId": 8844
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Same comment here: should this be `private[spark]`?\n",
    "commit": "9eac9d651d52bd0b5fbe797f7d9b6da4f7c9b6a4",
    "createdAt": "2015-09-21T21:16:31Z",
    "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.scheduler\n+\n+import java.util.Arrays\n+\n+import org.apache.spark._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * A Partitioner that might group together one or more partitions from the parent.\n+ *\n+ * @param parent a parent partitioner\n+ * @param partitionStartIndices indices of partitions in parent that should create new partitions\n+ *   in child (this should be an array of increasing partition IDs). For example, if we have a\n+ *   parent with 5 partitions, and partitionStartIndices is [0, 2, 4], we get three output\n+ *   partitions, corresponding to partition ranges [0, 1], [2, 3] and [4] of the parent partitioner.\n+ */\n+class CoalescedPartitioner(val parent: Partitioner, val partitionStartIndices: Array[Int])\n+  extends Partitioner {\n+\n+  @transient private lazy val parentPartitionMapping: Array[Int] = {\n+    val n = parent.numPartitions\n+    val result = new Array[Int](n)\n+    for (i <- 0 until partitionStartIndices.length) {\n+      val start = partitionStartIndices(i)\n+      val end = if (i < partitionStartIndices.length - 1) partitionStartIndices(i + 1) else n\n+      for (j <- start until end) {\n+        result(j) = i\n+      }\n+    }\n+    result\n+  }\n+\n+  override def numPartitions: Int = partitionStartIndices.size\n+\n+  override def getPartition(key: Any): Int = {\n+    parentPartitionMapping(parent.getPartition(key))\n+  }\n+\n+  override def equals(other: Any): Boolean = other match {\n+    case c: CoalescedPartitioner =>\n+      c.parent == parent && Arrays.equals(c.partitionStartIndices, partitionStartIndices)\n+    case _ =>\n+      false\n+  }\n+}\n+\n+private[spark] class CustomShuffledRDDPartition(\n+    val index: Int, val startIndexInParent: Int, val endIndexInParent: Int)\n+  extends Partition {\n+\n+  override def hashCode(): Int = index\n+}\n+\n+/**\n+ * A special ShuffledRDD that supports a ShuffleDependency object from outside and launching reduce\n+ * tasks that read multiple map output partitions.\n+ */\n+class CustomShuffledRDD[K, V, C](",
    "line": 75
  }],
  "prId": 8844
}]