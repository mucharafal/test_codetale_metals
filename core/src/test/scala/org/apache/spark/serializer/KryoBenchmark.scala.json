[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "I find this function is over abstracted and actually makes it more confusing what's going on. I'd just remove it since it is almost no-op.\n",
    "commit": "cdf535e82c7c482ae030975d53683164854ef588",
    "createdAt": "2016-10-22T05:44:03Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.serializer\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.serializer.KryoTest._\n+import org.apache.spark.util.Benchmark\n+\n+class KryoBenchmark extends SparkFunSuite {\n+  val benchmark = new Benchmark(\"Benchmark Kryo Unsafe vs safe Serialization\", 1024 * 1024 * 15, 10)\n+\n+  ignore(s\"Benchmark Kryo Unsafe vs safe Serialization\") {\n+    Seq (true, false).foreach (runBenchmark)\n+    benchmark.run()\n+\n+    // scalastyle:off\n+    /*\n+      Benchmark Kryo Unsafe vs safe Serialization: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+      ------------------------------------------------------------------------------------------------\n+      basicTypes: Int unsafe:true                    160 /  178         98.5          10.1       1.0X\n+      basicTypes: Long unsafe:true                   210 /  218         74.9          13.4       0.8X\n+      basicTypes: Float unsafe:true                  203 /  213         77.5          12.9       0.8X\n+      basicTypes: Double unsafe:true                 226 /  235         69.5          14.4       0.7X\n+      Array: Int unsafe:true                        1087 / 1101         14.5          69.1       0.1X\n+      Array: Long unsafe:true                       2758 / 2844          5.7         175.4       0.1X\n+      Array: Float unsafe:true                      1511 / 1552         10.4          96.1       0.1X\n+      Array: Double unsafe:true                     2942 / 2972          5.3         187.0       0.1X\n+      Map of string->Double unsafe:true             2645 / 2739          5.9         168.2       0.1X\n+      basicTypes: Int unsafe:false                   211 /  218         74.7          13.4       0.8X\n+      basicTypes: Long unsafe:false                  247 /  253         63.6          15.7       0.6X\n+      basicTypes: Float unsafe:false                 211 /  216         74.5          13.4       0.8X\n+      basicTypes: Double unsafe:false                227 /  233         69.2          14.4       0.7X\n+      Array: Int unsafe:false                       3012 / 3032          5.2         191.5       0.1X\n+      Array: Long unsafe:false                      4463 / 4515          3.5         283.8       0.0X\n+      Array: Float unsafe:false                     2788 / 2868          5.6         177.2       0.1X\n+      Array: Double unsafe:false                    3558 / 3752          4.4         226.2       0.0X\n+      Map of string->Double unsafe:false            2806 / 2933          5.6         178.4       0.1X\n+    */\n+    // scalastyle:on\n+  }\n+\n+  private def runBenchmark(useUnsafe: Boolean): Unit = {\n+    def addBenchmark(name: String, values: Long)(f: => Long): Unit = {"
  }],
  "prId": 12913
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "the use of call by name for fn is really confusing, especially the way you are calling it.\n",
    "commit": "cdf535e82c7c482ae030975d53683164854ef588",
    "createdAt": "2016-10-22T05:45:03Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.serializer\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.serializer.KryoTest._\n+import org.apache.spark.util.Benchmark\n+\n+class KryoBenchmark extends SparkFunSuite {\n+  val benchmark = new Benchmark(\"Benchmark Kryo Unsafe vs safe Serialization\", 1024 * 1024 * 15, 10)\n+\n+  ignore(s\"Benchmark Kryo Unsafe vs safe Serialization\") {\n+    Seq (true, false).foreach (runBenchmark)\n+    benchmark.run()\n+\n+    // scalastyle:off\n+    /*\n+      Benchmark Kryo Unsafe vs safe Serialization: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+      ------------------------------------------------------------------------------------------------\n+      basicTypes: Int unsafe:true                    160 /  178         98.5          10.1       1.0X\n+      basicTypes: Long unsafe:true                   210 /  218         74.9          13.4       0.8X\n+      basicTypes: Float unsafe:true                  203 /  213         77.5          12.9       0.8X\n+      basicTypes: Double unsafe:true                 226 /  235         69.5          14.4       0.7X\n+      Array: Int unsafe:true                        1087 / 1101         14.5          69.1       0.1X\n+      Array: Long unsafe:true                       2758 / 2844          5.7         175.4       0.1X\n+      Array: Float unsafe:true                      1511 / 1552         10.4          96.1       0.1X\n+      Array: Double unsafe:true                     2942 / 2972          5.3         187.0       0.1X\n+      Map of string->Double unsafe:true             2645 / 2739          5.9         168.2       0.1X\n+      basicTypes: Int unsafe:false                   211 /  218         74.7          13.4       0.8X\n+      basicTypes: Long unsafe:false                  247 /  253         63.6          15.7       0.6X\n+      basicTypes: Float unsafe:false                 211 /  216         74.5          13.4       0.8X\n+      basicTypes: Double unsafe:false                227 /  233         69.2          14.4       0.7X\n+      Array: Int unsafe:false                       3012 / 3032          5.2         191.5       0.1X\n+      Array: Long unsafe:false                      4463 / 4515          3.5         283.8       0.0X\n+      Array: Float unsafe:false                     2788 / 2868          5.6         177.2       0.1X\n+      Array: Double unsafe:false                    3558 / 3752          4.4         226.2       0.0X\n+      Map of string->Double unsafe:false            2806 / 2933          5.6         178.4       0.1X\n+    */\n+    // scalastyle:on\n+  }\n+\n+  private def runBenchmark(useUnsafe: Boolean): Unit = {\n+    def addBenchmark(name: String, values: Long)(f: => Long): Unit = {\n+      benchmark.addCase(s\"$name unsafe:$useUnsafe\") { _ =>\n+        f\n+      }\n+    }\n+\n+    def check[T: ClassTag](t: T, ser: SerializerInstance): Int = {\n+      if (ser.deserialize[T](ser.serialize(t)) === t) 1 else 0\n+    }\n+\n+    val N1 = 1000000\n+    def basicTypes[T: ClassTag](name: String, fn: () => T): Unit = {"
  }],
  "prId": 12913
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "you are measuring largely the wrong thing here because the cost of random is part of this. It would make more sense to pre-generate the data in an array and then just loop over the array.\n",
    "commit": "cdf535e82c7c482ae030975d53683164854ef588",
    "createdAt": "2016-10-22T05:46:02Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.serializer\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.serializer.KryoTest._\n+import org.apache.spark.util.Benchmark\n+\n+class KryoBenchmark extends SparkFunSuite {\n+  val benchmark = new Benchmark(\"Benchmark Kryo Unsafe vs safe Serialization\", 1024 * 1024 * 15, 10)\n+\n+  ignore(s\"Benchmark Kryo Unsafe vs safe Serialization\") {\n+    Seq (true, false).foreach (runBenchmark)\n+    benchmark.run()\n+\n+    // scalastyle:off\n+    /*\n+      Benchmark Kryo Unsafe vs safe Serialization: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+      ------------------------------------------------------------------------------------------------\n+      basicTypes: Int unsafe:true                    160 /  178         98.5          10.1       1.0X\n+      basicTypes: Long unsafe:true                   210 /  218         74.9          13.4       0.8X\n+      basicTypes: Float unsafe:true                  203 /  213         77.5          12.9       0.8X\n+      basicTypes: Double unsafe:true                 226 /  235         69.5          14.4       0.7X\n+      Array: Int unsafe:true                        1087 / 1101         14.5          69.1       0.1X\n+      Array: Long unsafe:true                       2758 / 2844          5.7         175.4       0.1X\n+      Array: Float unsafe:true                      1511 / 1552         10.4          96.1       0.1X\n+      Array: Double unsafe:true                     2942 / 2972          5.3         187.0       0.1X\n+      Map of string->Double unsafe:true             2645 / 2739          5.9         168.2       0.1X\n+      basicTypes: Int unsafe:false                   211 /  218         74.7          13.4       0.8X\n+      basicTypes: Long unsafe:false                  247 /  253         63.6          15.7       0.6X\n+      basicTypes: Float unsafe:false                 211 /  216         74.5          13.4       0.8X\n+      basicTypes: Double unsafe:false                227 /  233         69.2          14.4       0.7X\n+      Array: Int unsafe:false                       3012 / 3032          5.2         191.5       0.1X\n+      Array: Long unsafe:false                      4463 / 4515          3.5         283.8       0.0X\n+      Array: Float unsafe:false                     2788 / 2868          5.6         177.2       0.1X\n+      Array: Double unsafe:false                    3558 / 3752          4.4         226.2       0.0X\n+      Map of string->Double unsafe:false            2806 / 2933          5.6         178.4       0.1X\n+    */\n+    // scalastyle:on\n+  }\n+\n+  private def runBenchmark(useUnsafe: Boolean): Unit = {\n+    def addBenchmark(name: String, values: Long)(f: => Long): Unit = {\n+      benchmark.addCase(s\"$name unsafe:$useUnsafe\") { _ =>\n+        f\n+      }\n+    }\n+\n+    def check[T: ClassTag](t: T, ser: SerializerInstance): Int = {\n+      if (ser.deserialize[T](ser.serialize(t)) === t) 1 else 0\n+    }\n+\n+    val N1 = 1000000\n+    def basicTypes[T: ClassTag](name: String, fn: () => T): Unit = {\n+      lazy val ser = createSerializer(useUnsafe)\n+      addBenchmark(s\"basicTypes: $name\", N1) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < N1) {\n+          sum += check(fn(), ser)"
  }],
  "prId": 12913
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "same thing here -- you are measuring the overhead of array fill and random number genreator a lot.\n",
    "commit": "cdf535e82c7c482ae030975d53683164854ef588",
    "createdAt": "2016-10-22T05:46:31Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.serializer\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.serializer.KryoTest._\n+import org.apache.spark.util.Benchmark\n+\n+class KryoBenchmark extends SparkFunSuite {\n+  val benchmark = new Benchmark(\"Benchmark Kryo Unsafe vs safe Serialization\", 1024 * 1024 * 15, 10)\n+\n+  ignore(s\"Benchmark Kryo Unsafe vs safe Serialization\") {\n+    Seq (true, false).foreach (runBenchmark)\n+    benchmark.run()\n+\n+    // scalastyle:off\n+    /*\n+      Benchmark Kryo Unsafe vs safe Serialization: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+      ------------------------------------------------------------------------------------------------\n+      basicTypes: Int unsafe:true                    160 /  178         98.5          10.1       1.0X\n+      basicTypes: Long unsafe:true                   210 /  218         74.9          13.4       0.8X\n+      basicTypes: Float unsafe:true                  203 /  213         77.5          12.9       0.8X\n+      basicTypes: Double unsafe:true                 226 /  235         69.5          14.4       0.7X\n+      Array: Int unsafe:true                        1087 / 1101         14.5          69.1       0.1X\n+      Array: Long unsafe:true                       2758 / 2844          5.7         175.4       0.1X\n+      Array: Float unsafe:true                      1511 / 1552         10.4          96.1       0.1X\n+      Array: Double unsafe:true                     2942 / 2972          5.3         187.0       0.1X\n+      Map of string->Double unsafe:true             2645 / 2739          5.9         168.2       0.1X\n+      basicTypes: Int unsafe:false                   211 /  218         74.7          13.4       0.8X\n+      basicTypes: Long unsafe:false                  247 /  253         63.6          15.7       0.6X\n+      basicTypes: Float unsafe:false                 211 /  216         74.5          13.4       0.8X\n+      basicTypes: Double unsafe:false                227 /  233         69.2          14.4       0.7X\n+      Array: Int unsafe:false                       3012 / 3032          5.2         191.5       0.1X\n+      Array: Long unsafe:false                      4463 / 4515          3.5         283.8       0.0X\n+      Array: Float unsafe:false                     2788 / 2868          5.6         177.2       0.1X\n+      Array: Double unsafe:false                    3558 / 3752          4.4         226.2       0.0X\n+      Map of string->Double unsafe:false            2806 / 2933          5.6         178.4       0.1X\n+    */\n+    // scalastyle:on\n+  }\n+\n+  private def runBenchmark(useUnsafe: Boolean): Unit = {\n+    def addBenchmark(name: String, values: Long)(f: => Long): Unit = {\n+      benchmark.addCase(s\"$name unsafe:$useUnsafe\") { _ =>\n+        f\n+      }\n+    }\n+\n+    def check[T: ClassTag](t: T, ser: SerializerInstance): Int = {\n+      if (ser.deserialize[T](ser.serialize(t)) === t) 1 else 0\n+    }\n+\n+    val N1 = 1000000\n+    def basicTypes[T: ClassTag](name: String, fn: () => T): Unit = {\n+      lazy val ser = createSerializer(useUnsafe)\n+      addBenchmark(s\"basicTypes: $name\", N1) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < N1) {\n+          sum += check(fn(), ser)\n+          i += 1\n+        }\n+        sum\n+      }\n+    }\n+    basicTypes(\"Int\", Random.nextInt)\n+    basicTypes(\"Long\", Random.nextLong)\n+    basicTypes(\"Float\", Random.nextFloat)\n+    basicTypes(\"Double\", Random.nextDouble)\n+\n+    val N2 = 10000\n+    def basicTypeArray[T: ClassTag](name: String, fn: () => T): Unit = {\n+      lazy val ser = createSerializer(useUnsafe)\n+      addBenchmark(s\"Array: $name\", N2) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < N2) {\n+          val arr = Array.fill[T](i)(fn())"
  }],
  "prId": 12913
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "here too ...\n",
    "commit": "cdf535e82c7c482ae030975d53683164854ef588",
    "createdAt": "2016-10-22T05:46:39Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.serializer\n+\n+import scala.reflect.ClassTag\n+import scala.util.Random\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.serializer.KryoTest._\n+import org.apache.spark.util.Benchmark\n+\n+class KryoBenchmark extends SparkFunSuite {\n+  val benchmark = new Benchmark(\"Benchmark Kryo Unsafe vs safe Serialization\", 1024 * 1024 * 15, 10)\n+\n+  ignore(s\"Benchmark Kryo Unsafe vs safe Serialization\") {\n+    Seq (true, false).foreach (runBenchmark)\n+    benchmark.run()\n+\n+    // scalastyle:off\n+    /*\n+      Benchmark Kryo Unsafe vs safe Serialization: Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+      ------------------------------------------------------------------------------------------------\n+      basicTypes: Int unsafe:true                    160 /  178         98.5          10.1       1.0X\n+      basicTypes: Long unsafe:true                   210 /  218         74.9          13.4       0.8X\n+      basicTypes: Float unsafe:true                  203 /  213         77.5          12.9       0.8X\n+      basicTypes: Double unsafe:true                 226 /  235         69.5          14.4       0.7X\n+      Array: Int unsafe:true                        1087 / 1101         14.5          69.1       0.1X\n+      Array: Long unsafe:true                       2758 / 2844          5.7         175.4       0.1X\n+      Array: Float unsafe:true                      1511 / 1552         10.4          96.1       0.1X\n+      Array: Double unsafe:true                     2942 / 2972          5.3         187.0       0.1X\n+      Map of string->Double unsafe:true             2645 / 2739          5.9         168.2       0.1X\n+      basicTypes: Int unsafe:false                   211 /  218         74.7          13.4       0.8X\n+      basicTypes: Long unsafe:false                  247 /  253         63.6          15.7       0.6X\n+      basicTypes: Float unsafe:false                 211 /  216         74.5          13.4       0.8X\n+      basicTypes: Double unsafe:false                227 /  233         69.2          14.4       0.7X\n+      Array: Int unsafe:false                       3012 / 3032          5.2         191.5       0.1X\n+      Array: Long unsafe:false                      4463 / 4515          3.5         283.8       0.0X\n+      Array: Float unsafe:false                     2788 / 2868          5.6         177.2       0.1X\n+      Array: Double unsafe:false                    3558 / 3752          4.4         226.2       0.0X\n+      Map of string->Double unsafe:false            2806 / 2933          5.6         178.4       0.1X\n+    */\n+    // scalastyle:on\n+  }\n+\n+  private def runBenchmark(useUnsafe: Boolean): Unit = {\n+    def addBenchmark(name: String, values: Long)(f: => Long): Unit = {\n+      benchmark.addCase(s\"$name unsafe:$useUnsafe\") { _ =>\n+        f\n+      }\n+    }\n+\n+    def check[T: ClassTag](t: T, ser: SerializerInstance): Int = {\n+      if (ser.deserialize[T](ser.serialize(t)) === t) 1 else 0\n+    }\n+\n+    val N1 = 1000000\n+    def basicTypes[T: ClassTag](name: String, fn: () => T): Unit = {\n+      lazy val ser = createSerializer(useUnsafe)\n+      addBenchmark(s\"basicTypes: $name\", N1) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < N1) {\n+          sum += check(fn(), ser)\n+          i += 1\n+        }\n+        sum\n+      }\n+    }\n+    basicTypes(\"Int\", Random.nextInt)\n+    basicTypes(\"Long\", Random.nextLong)\n+    basicTypes(\"Float\", Random.nextFloat)\n+    basicTypes(\"Double\", Random.nextDouble)\n+\n+    val N2 = 10000\n+    def basicTypeArray[T: ClassTag](name: String, fn: () => T): Unit = {\n+      lazy val ser = createSerializer(useUnsafe)\n+      addBenchmark(s\"Array: $name\", N2) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < N2) {\n+          val arr = Array.fill[T](i)(fn())\n+          sum += check(arr, ser)\n+          i += 1\n+        }\n+        sum\n+      }\n+    }\n+    basicTypeArray(\"Int\", Random.nextInt)\n+    basicTypeArray(\"Long\", Random.nextLong)\n+    basicTypeArray(\"Float\", Random.nextFloat)\n+    basicTypeArray(\"Double\", Random.nextDouble)\n+\n+    {\n+      val N3 = 1000\n+      lazy val ser = createSerializer(useUnsafe)\n+      addBenchmark(\"Map of string->Double\", N3) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < N3) {\n+          val map = Array.fill(i)((Random.nextString(i / 10), Random.nextDouble())).toMap"
  }],
  "prId": 12913
}]