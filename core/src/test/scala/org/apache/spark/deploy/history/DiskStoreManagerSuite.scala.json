[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "tests pass without this line ... and its kinda strange, I tried removing it because I was wondering why you would want this",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T15:43:46Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+\n+import org.mockito.Matchers.{any, anyBoolean, anyLong, eq => meq}\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.status.KVUtils\n+import org.apache.spark.util.{ManualClock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+class DiskStoreManagerSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import config._\n+\n+  private val MAX_USAGE = 3L\n+\n+  private var testDir: File = _\n+  private var store: KVStore = _\n+\n+  before {\n+    testDir = Utils.createTempDir()\n+    store = KVUtils.open(new File(testDir, \"listing\"), \"test\")\n+  }\n+\n+  after {\n+    store.close()\n+    if (testDir != null) {\n+      Utils.deleteRecursively(testDir)\n+    }\n+  }\n+\n+  private def mockManager(): DiskStoreManager = {\n+    val conf = new SparkConf().set(MAX_LOCAL_DISK_USAGE, MAX_USAGE)\n+    val manager = spy(new DiskStoreManager(conf, testDir, store, new ManualClock()))\n+    doReturn(0L).when(manager).sizeOf(any(classOf[File]))"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Just added in case the method was called with an unexpected file. Will remove.",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T21:14:15Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+\n+import org.mockito.Matchers.{any, anyBoolean, anyLong, eq => meq}\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.status.KVUtils\n+import org.apache.spark.util.{ManualClock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+class DiskStoreManagerSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import config._\n+\n+  private val MAX_USAGE = 3L\n+\n+  private var testDir: File = _\n+  private var store: KVStore = _\n+\n+  before {\n+    testDir = Utils.createTempDir()\n+    store = KVUtils.open(new File(testDir, \"listing\"), \"test\")\n+  }\n+\n+  after {\n+    store.close()\n+    if (testDir != null) {\n+      Utils.deleteRecursively(testDir)\n+    }\n+  }\n+\n+  private def mockManager(): DiskStoreManager = {\n+    val conf = new SparkConf().set(MAX_LOCAL_DISK_USAGE, MAX_USAGE)\n+    val manager = spy(new DiskStoreManager(conf, testDir, store, new ManualClock()))\n+    doReturn(0L).when(manager).sizeOf(any(classOf[File]))"
  }],
  "prId": 20011
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "nit: I don't think `hasFreeSpace` actually helps at all,  here you could replace both of these with `assert(manager.free() === 1)` and everywhere else do `assert(manager.free() === 0)` etc.",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T15:48:59Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+\n+import org.mockito.Matchers.{any, anyBoolean, anyLong, eq => meq}\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.status.KVUtils\n+import org.apache.spark.util.{ManualClock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+class DiskStoreManagerSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import config._\n+\n+  private val MAX_USAGE = 3L\n+\n+  private var testDir: File = _\n+  private var store: KVStore = _\n+\n+  before {\n+    testDir = Utils.createTempDir()\n+    store = KVUtils.open(new File(testDir, \"listing\"), \"test\")\n+  }\n+\n+  after {\n+    store.close()\n+    if (testDir != null) {\n+      Utils.deleteRecursively(testDir)\n+    }\n+  }\n+\n+  private def mockManager(): DiskStoreManager = {\n+    val conf = new SparkConf().set(MAX_LOCAL_DISK_USAGE, MAX_USAGE)\n+    val manager = spy(new DiskStoreManager(conf, testDir, store, new ManualClock()))\n+    doReturn(0L).when(manager).sizeOf(any(classOf[File]))\n+    doAnswer(new Answer[Long] {\n+      def answer(invocation: InvocationOnMock): Long = {\n+        invocation.getArguments()(0).asInstanceOf[Long]\n+      }\n+    }).when(manager).approximateSize(anyLong(), anyBoolean())\n+    manager\n+  }\n+\n+  private def hasFreeSpace(manager: DiskStoreManager, size: Long): Boolean = {\n+    size <= manager.free()\n+  }\n+\n+  test(\"leasing space\") {\n+    val manager = mockManager()\n+\n+    // Lease all available space.\n+    val lease1 = manager.lease(1)\n+    val lease2 = manager.lease(1)\n+    val lease3 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Revert one lease, get another one.\n+    lease1.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!lease1.path.exists())\n+\n+    val lease4 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Committing 2 should bring the \"used\" space up to 4, so there shouldn't be space left yet.\n+    doReturn(2L).when(manager).sizeOf(meq(lease2.path))\n+    val dst2 = lease2.commit(\"app2\", None)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Rollback 3 and 4, now there should be 1 left.\n+    lease3.rollback()\n+    lease4.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!hasFreeSpace(manager, 2))"
  }],
  "prId": 20011
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "can you switch the naming scheme to be leaseA, leaseB, etc.?  its a bit hard to tell when you're talking about sizes and when you're referring to specific leases.",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T15:59:17Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+\n+import org.mockito.Matchers.{any, anyBoolean, anyLong, eq => meq}\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.status.KVUtils\n+import org.apache.spark.util.{ManualClock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+class DiskStoreManagerSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import config._\n+\n+  private val MAX_USAGE = 3L\n+\n+  private var testDir: File = _\n+  private var store: KVStore = _\n+\n+  before {\n+    testDir = Utils.createTempDir()\n+    store = KVUtils.open(new File(testDir, \"listing\"), \"test\")\n+  }\n+\n+  after {\n+    store.close()\n+    if (testDir != null) {\n+      Utils.deleteRecursively(testDir)\n+    }\n+  }\n+\n+  private def mockManager(): DiskStoreManager = {\n+    val conf = new SparkConf().set(MAX_LOCAL_DISK_USAGE, MAX_USAGE)\n+    val manager = spy(new DiskStoreManager(conf, testDir, store, new ManualClock()))\n+    doReturn(0L).when(manager).sizeOf(any(classOf[File]))\n+    doAnswer(new Answer[Long] {\n+      def answer(invocation: InvocationOnMock): Long = {\n+        invocation.getArguments()(0).asInstanceOf[Long]\n+      }\n+    }).when(manager).approximateSize(anyLong(), anyBoolean())\n+    manager\n+  }\n+\n+  private def hasFreeSpace(manager: DiskStoreManager, size: Long): Boolean = {\n+    size <= manager.free()\n+  }\n+\n+  test(\"leasing space\") {\n+    val manager = mockManager()\n+\n+    // Lease all available space.\n+    val lease1 = manager.lease(1)\n+    val lease2 = manager.lease(1)\n+    val lease3 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Revert one lease, get another one.\n+    lease1.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!lease1.path.exists())\n+\n+    val lease4 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Committing 2 should bring the \"used\" space up to 4, so there shouldn't be space left yet.\n+    doReturn(2L).when(manager).sizeOf(meq(lease2.path))\n+    val dst2 = lease2.commit(\"app2\", None)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Rollback 3 and 4, now there should be 1 left."
  }],
  "prId": 20011
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "would help here to have a comment explaining the case this really represents -- replaying an app because the event log has been updated, so replacing the old kvstore.  Also just to make that clear you could add\r\n\r\n```\r\nval dst5 = lease5.commit(\"app2\", None)\r\nassert(dst5 === dst2)\r\n```\r\n(at first I thought \"app2\" was a copy/paste mistake here)",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T16:04:20Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+\n+import org.mockito.Matchers.{any, anyBoolean, anyLong, eq => meq}\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.status.KVUtils\n+import org.apache.spark.util.{ManualClock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+class DiskStoreManagerSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import config._\n+\n+  private val MAX_USAGE = 3L\n+\n+  private var testDir: File = _\n+  private var store: KVStore = _\n+\n+  before {\n+    testDir = Utils.createTempDir()\n+    store = KVUtils.open(new File(testDir, \"listing\"), \"test\")\n+  }\n+\n+  after {\n+    store.close()\n+    if (testDir != null) {\n+      Utils.deleteRecursively(testDir)\n+    }\n+  }\n+\n+  private def mockManager(): DiskStoreManager = {\n+    val conf = new SparkConf().set(MAX_LOCAL_DISK_USAGE, MAX_USAGE)\n+    val manager = spy(new DiskStoreManager(conf, testDir, store, new ManualClock()))\n+    doReturn(0L).when(manager).sizeOf(any(classOf[File]))\n+    doAnswer(new Answer[Long] {\n+      def answer(invocation: InvocationOnMock): Long = {\n+        invocation.getArguments()(0).asInstanceOf[Long]\n+      }\n+    }).when(manager).approximateSize(anyLong(), anyBoolean())\n+    manager\n+  }\n+\n+  private def hasFreeSpace(manager: DiskStoreManager, size: Long): Boolean = {\n+    size <= manager.free()\n+  }\n+\n+  test(\"leasing space\") {\n+    val manager = mockManager()\n+\n+    // Lease all available space.\n+    val lease1 = manager.lease(1)\n+    val lease2 = manager.lease(1)\n+    val lease3 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Revert one lease, get another one.\n+    lease1.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!lease1.path.exists())\n+\n+    val lease4 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Committing 2 should bring the \"used\" space up to 4, so there shouldn't be space left yet.\n+    doReturn(2L).when(manager).sizeOf(meq(lease2.path))\n+    val dst2 = lease2.commit(\"app2\", None)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Rollback 3 and 4, now there should be 1 left.\n+    lease3.rollback()\n+    lease4.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!hasFreeSpace(manager, 2))\n+\n+    // Release app 2 to make it available for eviction.\n+    doReturn(2L).when(manager).sizeOf(meq(dst2))\n+    manager.release(\"app2\", None)\n+\n+    // Lease 1, commit with size 3, replacing previously commited lease 2.\n+    val lease5 = manager.lease(1)\n+    doReturn(3L).when(manager).sizeOf(meq(lease5.path))\n+    lease5.commit(\"app2\", None)\n+    assert(dst2.exists())"
  }],
  "prId": 20011
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "add a case with getting another lease, even though you're already beyond the size limit (don't think that is covered?)",
    "commit": "931b2d262aa02880631ca4c693a84fa4c4d12318",
    "createdAt": "2017-12-22T16:08:54Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.deploy.history\n+\n+import java.io.File\n+\n+import org.mockito.Matchers.{any, anyBoolean, anyLong, eq => meq}\n+import org.mockito.Mockito._\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.status.KVUtils\n+import org.apache.spark.util.{ManualClock, Utils}\n+import org.apache.spark.util.kvstore.KVStore\n+\n+class DiskStoreManagerSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import config._\n+\n+  private val MAX_USAGE = 3L\n+\n+  private var testDir: File = _\n+  private var store: KVStore = _\n+\n+  before {\n+    testDir = Utils.createTempDir()\n+    store = KVUtils.open(new File(testDir, \"listing\"), \"test\")\n+  }\n+\n+  after {\n+    store.close()\n+    if (testDir != null) {\n+      Utils.deleteRecursively(testDir)\n+    }\n+  }\n+\n+  private def mockManager(): DiskStoreManager = {\n+    val conf = new SparkConf().set(MAX_LOCAL_DISK_USAGE, MAX_USAGE)\n+    val manager = spy(new DiskStoreManager(conf, testDir, store, new ManualClock()))\n+    doReturn(0L).when(manager).sizeOf(any(classOf[File]))\n+    doAnswer(new Answer[Long] {\n+      def answer(invocation: InvocationOnMock): Long = {\n+        invocation.getArguments()(0).asInstanceOf[Long]\n+      }\n+    }).when(manager).approximateSize(anyLong(), anyBoolean())\n+    manager\n+  }\n+\n+  private def hasFreeSpace(manager: DiskStoreManager, size: Long): Boolean = {\n+    size <= manager.free()\n+  }\n+\n+  test(\"leasing space\") {\n+    val manager = mockManager()\n+\n+    // Lease all available space.\n+    val lease1 = manager.lease(1)\n+    val lease2 = manager.lease(1)\n+    val lease3 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Revert one lease, get another one.\n+    lease1.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!lease1.path.exists())\n+\n+    val lease4 = manager.lease(1)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Committing 2 should bring the \"used\" space up to 4, so there shouldn't be space left yet.\n+    doReturn(2L).when(manager).sizeOf(meq(lease2.path))\n+    val dst2 = lease2.commit(\"app2\", None)\n+    assert(!hasFreeSpace(manager, 1))\n+\n+    // Rollback 3 and 4, now there should be 1 left.\n+    lease3.rollback()\n+    lease4.rollback()\n+    assert(hasFreeSpace(manager, 1))\n+    assert(!hasFreeSpace(manager, 2))\n+\n+    // Release app 2 to make it available for eviction.\n+    doReturn(2L).when(manager).sizeOf(meq(dst2))\n+    manager.release(\"app2\", None)\n+\n+    // Lease 1, commit with size 3, replacing previously commited lease 2.\n+    val lease5 = manager.lease(1)\n+    doReturn(3L).when(manager).sizeOf(meq(lease5.path))\n+    lease5.commit(\"app2\", None)\n+    assert(dst2.exists())\n+    assert(!lease5.path.exists())\n+    assert(!hasFreeSpace(manager, 1))\n+    manager.release(\"app2\", None)\n+\n+    // Try a big lease that should cause the committed app to be evicted.\n+    val lease6 = manager.lease(6)\n+    assert(!dst2.exists())\n+    assert(!hasFreeSpace(manager, 1))"
  }],
  "prId": 20011
}]