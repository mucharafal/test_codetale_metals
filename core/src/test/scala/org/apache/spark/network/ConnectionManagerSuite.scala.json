[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "How is the error generated?\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T17:31:36Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)",
    "line": 72
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Take a look at the next line: `managerServer` has a handler for processing received messages, but that handler just crashes by throwing an Exception.\n\nIn this test, `managerServer` is the remote server that crashes while processing messages, while `manager` is the \"client\" that sends a message to that buggy server.  Prior to this patch, `manager` would either hang or time out in this error condition, rather than raising an exception.\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T17:35:52Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)",
    "line": 72
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Oh right. Got it. \n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T17:39:03Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)",
    "line": 72
  }],
  "prId": 1758
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This test should probably use Await with an infinite timeout, or the `future` should come from sendMessageReliablySync so that we distinguish between timeouts and explicit acknowledgments of failure.\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T17:44:23Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)\n+    managerServer.onReceiveMessage((msg: Message, id: ConnectionManagerId) => {\n+      throw new Exception\n+    })\n \n+    val size = 10 * 1024 * 1024\n+    val buffer = ByteBuffer.allocate(size).put(Array.tabulate[Byte](size)(x => x.toByte))\n+    buffer.flip\n+    val bufferMessage = Message.createBufferMessage(buffer)\n+\n+    val future = manager.sendMessageReliably(managerServer.id, bufferMessage)\n+\n+    val message = Try(Await.result(future, 1 second))"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I am a little scared of dur.inf in testsuites (dont want jenkins to hang for another reason), however increasing it to something like 10 seconds should be good enough.\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T17:49:11Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)\n+    managerServer.onReceiveMessage((msg: Message, id: ConnectionManagerId) => {\n+      throw new Exception\n+    })\n \n+    val size = 10 * 1024 * 1024\n+    val buffer = ByteBuffer.allocate(size).put(Array.tabulate[Byte](size)(x => x.toByte))\n+    buffer.flip\n+    val bufferMessage = Message.createBufferMessage(buffer)\n+\n+    val future = manager.sendMessageReliably(managerServer.id, bufferMessage)\n+\n+    val message = Try(Await.result(future, 1 second))"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "I'll update the test to check whether the failure is due to a timeout exception or some other exception.  This might be important because I think this current test might have passed even with the old code due to the timeouts (the original PR didn't have this issue; I think I inadvertently messed it up while refactoring). \n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T18:00:42Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)\n+    managerServer.onReceiveMessage((msg: Message, id: ConnectionManagerId) => {\n+      throw new Exception\n+    })\n \n+    val size = 10 * 1024 * 1024\n+    val buffer = ByteBuffer.allocate(size).put(Array.tabulate[Byte](size)(x => x.toByte))\n+    buffer.flip\n+    val bufferMessage = Message.createBufferMessage(buffer)\n+\n+    val future = manager.sendMessageReliably(managerServer.id, bufferMessage)\n+\n+    val message = Try(Await.result(future, 1 second))"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "There are some other tests that use `sendMessageReliablySync`, which has an infinite timeout.  This method is only used in one or two places, so I'm going to remove it and force callers to supply their own timeouts.\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-05T20:28:15Z",
    "diffHunk": "@@ -223,7 +223,30 @@ class ConnectionManagerSuite extends FunSuite {\n     managerServer.stop()\n   }\n \n+  test(\"Ack error message\") {\n+    val conf = new SparkConf\n+    conf.set(\"spark.authenticate\", \"false\")\n+    val securityManager = new SecurityManager(conf)\n+    val manager = new ConnectionManager(0, conf, securityManager)\n+    val managerServer = new ConnectionManager(0, conf, securityManager)\n+    managerServer.onReceiveMessage((msg: Message, id: ConnectionManagerId) => {\n+      throw new Exception\n+    })\n \n+    val size = 10 * 1024 * 1024\n+    val buffer = ByteBuffer.allocate(size).put(Array.tabulate[Byte](size)(x => x.toByte))\n+    buffer.flip\n+    val bufferMessage = Message.createBufferMessage(buffer)\n+\n+    val future = manager.sendMessageReliably(managerServer.id, bufferMessage)\n+\n+    val message = Try(Await.result(future, 1 second))"
  }],
  "prId": 1758
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "here is your bug you aren't sending it to the managerSErver\n\nshould be:\nAwait.ready(manager.sendMessageReliably(managerServer.id, bufferMessage), 10 seconds)\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-06T20:44:16Z",
    "diffHunk": "@@ -79,7 +80,7 @@ class ConnectionManagerSuite extends FunSuite {\n \n     (0 until count).map(i => {\n       val bufferMessage = Message.createBufferMessage(buffer.duplicate)\n-      manager.sendMessageReliablySync(managerServer.id, bufferMessage)\n+      Await.ready(manager.sendMessageReliably(manager.id, bufferMessage), 10 seconds)"
  }],
  "prId": 1758
}, {
  "comments": [{
    "author": {
      "login": "tgravescs"
    },
    "body": "same here, send to managerServer\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-06T20:45:20Z",
    "diffHunk": "@@ -118,7 +119,7 @@ class ConnectionManagerSuite extends FunSuite {\n     val buffer = ByteBuffer.allocate(size).put(Array.tabulate[Byte](size)(x => x.toByte))\n     buffer.flip\n     val bufferMessage = Message.createBufferMessage(buffer.duplicate)\n-    manager.sendMessageReliablySync(managerServer.id, bufferMessage)\n+    Await.result(manager.sendMessageReliably(manager.id, bufferMessage), 10 seconds)"
  }],
  "prId": 1758
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This line is probably why I accidentally replaced `managerServer.id` with `manager.id`.  I think I replaced the now-removed `sendMessageReliablySync` here with the `Await` then copy-pasted this line's fix into the lines below.\n",
    "commit": "68620cbf73f91475483f49ebece358bf9c499f1c",
    "createdAt": "2014-08-06T20:57:33Z",
    "diffHunk": "@@ -46,7 +47,7 @@ class ConnectionManagerSuite extends FunSuite {\n     buffer.flip\n \n     val bufferMessage = Message.createBufferMessage(buffer.duplicate)\n-    manager.sendMessageReliablySync(manager.id, bufferMessage)",
    "line": 20
  }],
  "prId": 1758
}]