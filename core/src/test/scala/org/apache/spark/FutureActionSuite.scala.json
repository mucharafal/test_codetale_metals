[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This looks flaky. Even they are non blocking, there is NO guarantee that one of the 10 scheduled function `_ => ()` will finish by the end of this loop. So it may happen that in the 10th iteration, the previous 9 scheduled function are still not finished, the 10th on gets scheduled, and therefore the pool size = 10. \n",
    "commit": "17edbcd06086b6a8cad922b4c535eb2a6265b2e3",
    "createdAt": "2015-07-16T02:00:59Z",
    "diffHunk": "@@ -49,4 +50,20 @@ class FutureActionSuite\n     job.jobIds.size should be (2)\n   }\n \n+  test(\"simple async action callbacks should not tie up execution context threads (SPARK-9026)\") {\n+    val rdd = sc.parallelize(1 to 10, 2).map(_ => Thread.sleep(1000 * 1000))\n+    val pool = ThreadUtils.newDaemonCachedThreadPool(\"SimpleFutureActionTest\")\n+    val executionContext = ExecutionContext.fromExecutorService(pool)\n+    val job = rdd.countAsync()\n+    try {\n+      for (_ <- 1 to 10) {\n+        job.onComplete(_ => ())(executionContext)\n+        assert(pool.getLargestPoolSize < 10)"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "I think that my intention when writing this test was to have a test that demonstrated the eagerly-create-a-thread-per-callback problem with the old implementation of SimpleFutureAction.\n\nI don't think that this is flaky but I also don't think that this tests adds much value since we're unlikely to ever switch back to the old inefficient implementation.  I'll just drop this test, since I don't think it's adding any real value right now.\n",
    "commit": "17edbcd06086b6a8cad922b4c535eb2a6265b2e3",
    "createdAt": "2015-07-16T02:28:21Z",
    "diffHunk": "@@ -49,4 +50,20 @@ class FutureActionSuite\n     job.jobIds.size should be (2)\n   }\n \n+  test(\"simple async action callbacks should not tie up execution context threads (SPARK-9026)\") {\n+    val rdd = sc.parallelize(1 to 10, 2).map(_ => Thread.sleep(1000 * 1000))\n+    val pool = ThreadUtils.newDaemonCachedThreadPool(\"SimpleFutureActionTest\")\n+    val executionContext = ExecutionContext.fromExecutorService(pool)\n+    val job = rdd.countAsync()\n+    try {\n+      for (_ <- 1 to 10) {\n+        job.onComplete(_ => ())(executionContext)\n+        assert(pool.getLargestPoolSize < 10)"
  }],
  "prId": 7385
}]