[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "could do `val badKeys = badValues.map(_.swap)`",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T16:26:23Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.UUID\n+import javax.servlet.FilterChain\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.Mockito.{mock, never, times, verify, when}\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.config._\n+\n+class HttpSecurityFilterSuite extends SparkFunSuite {\n+\n+  test(\"disallow bad user input\") {\n+    val badValues = Map(\n+      \"encoded\" -> \"Encoding:base64%0d%0a%0d%0aPGh0bWw%2bjcmlwdD48L2h0bWw%2b\",\n+      \"alert1\" -> \"\"\">\"'><script>alert(401)<%2Fscript>\"\"\",\n+      \"alert2\" -> \"\"\"app-20161208133404-0002<iframe+src%3Djavascript%3Aalert(1705)>\"\"\",\n+      \"alert3\" -> \"\"\"stdout'%2Balert(60)%2B'\"\"\",\n+      \"html\" -> \"\"\"stdout'\"><iframe+id%3D1131+src%3Dhttp%3A%2F%2Fdemo.test.net%2Fphishing.html>\"\"\"\n+    )\n+    val badKeys = badValues.map { case (k, v) => v -> k }.toMap"
  }],
  "prId": 23302
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "won't these pass just because its a different Array anyway?  eg `assert(Array(x) != Array(x))` always passes.  I think you could do `assert(req.getParameterValues(k).toSeq != Seq(v))`",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T21:18:03Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.UUID\n+import javax.servlet.FilterChain\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.mockito.ArgumentCaptor\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.Mockito.{mock, never, times, verify, when}\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.config._\n+\n+class HttpSecurityFilterSuite extends SparkFunSuite {\n+\n+  test(\"filter bad user input\") {\n+    val badValues = Map(\n+      \"encoded\" -> \"Encoding:base64%0d%0a%0d%0aPGh0bWw%2bjcmlwdD48L2h0bWw%2b\",\n+      \"alert1\" -> \"\"\">\"'><script>alert(401)<%2Fscript>\"\"\",\n+      \"alert2\" -> \"\"\"app-20161208133404-0002<iframe+src%3Djavascript%3Aalert(1705)>\"\"\",\n+      \"alert3\" -> \"\"\"stdout'%2Balert(60)%2B'\"\"\",\n+      \"html\" -> \"\"\"stdout'\"><iframe+id%3D1131+src%3Dhttp%3A%2F%2Fdemo.test.net%2Fphishing.html>\"\"\"\n+    )\n+    val badKeys = badValues.map(_.swap)\n+    val goodInput = Map(\"goodKey\" -> \"goodValue\")\n+\n+    val conf = new SparkConf()\n+    val filter = new HttpSecurityFilter(conf, new SecurityManager(conf))\n+\n+    def newRequest(): HttpServletRequest = {\n+      val req = mock(classOf[HttpServletRequest])\n+      when(req.getParameterMap()).thenReturn(Map.empty[String, Array[String]].asJava)\n+      req\n+    }\n+\n+    def doRequest(k: String, v: String): HttpServletRequest = {\n+      val req = newRequest()\n+      when(req.getParameterMap()).thenReturn(Map(k -> Array(v)).asJava)\n+\n+      val chain = mock(classOf[FilterChain])\n+      val res = mock(classOf[HttpServletResponse])\n+      filter.doFilter(req, res, chain)\n+\n+      val captor = ArgumentCaptor.forClass(classOf[HttpServletRequest])\n+      verify(chain).doFilter(captor.capture(), any())\n+      captor.getValue()\n+    }\n+\n+    badKeys.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) === null)\n+      assert(req.getParameterValues(k) === null)\n+      assert(!req.getParameterMap().containsKey(k))\n+    }\n+\n+    badValues.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) != null)\n+      assert(req.getParameter(k) != v)\n+      assert(req.getParameterValues(k) != null)\n+      assert(req.getParameterValues(k) != Array(v))"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Guess I was relying on Scala's `!=` being smarter.",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T21:22:30Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.UUID\n+import javax.servlet.FilterChain\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.mockito.ArgumentCaptor\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.Mockito.{mock, never, times, verify, when}\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.config._\n+\n+class HttpSecurityFilterSuite extends SparkFunSuite {\n+\n+  test(\"filter bad user input\") {\n+    val badValues = Map(\n+      \"encoded\" -> \"Encoding:base64%0d%0a%0d%0aPGh0bWw%2bjcmlwdD48L2h0bWw%2b\",\n+      \"alert1\" -> \"\"\">\"'><script>alert(401)<%2Fscript>\"\"\",\n+      \"alert2\" -> \"\"\"app-20161208133404-0002<iframe+src%3Djavascript%3Aalert(1705)>\"\"\",\n+      \"alert3\" -> \"\"\"stdout'%2Balert(60)%2B'\"\"\",\n+      \"html\" -> \"\"\"stdout'\"><iframe+id%3D1131+src%3Dhttp%3A%2F%2Fdemo.test.net%2Fphishing.html>\"\"\"\n+    )\n+    val badKeys = badValues.map(_.swap)\n+    val goodInput = Map(\"goodKey\" -> \"goodValue\")\n+\n+    val conf = new SparkConf()\n+    val filter = new HttpSecurityFilter(conf, new SecurityManager(conf))\n+\n+    def newRequest(): HttpServletRequest = {\n+      val req = mock(classOf[HttpServletRequest])\n+      when(req.getParameterMap()).thenReturn(Map.empty[String, Array[String]].asJava)\n+      req\n+    }\n+\n+    def doRequest(k: String, v: String): HttpServletRequest = {\n+      val req = newRequest()\n+      when(req.getParameterMap()).thenReturn(Map(k -> Array(v)).asJava)\n+\n+      val chain = mock(classOf[FilterChain])\n+      val res = mock(classOf[HttpServletResponse])\n+      filter.doFilter(req, res, chain)\n+\n+      val captor = ArgumentCaptor.forClass(classOf[HttpServletRequest])\n+      verify(chain).doFilter(captor.capture(), any())\n+      captor.getValue()\n+    }\n+\n+    badKeys.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) === null)\n+      assert(req.getParameterValues(k) === null)\n+      assert(!req.getParameterMap().containsKey(k))\n+    }\n+\n+    badValues.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) != null)\n+      assert(req.getParameter(k) != v)\n+      assert(req.getParameterValues(k) != null)\n+      assert(req.getParameterValues(k) != Array(v))"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "How about `===` and `!==` from scalatest? I think they do what you intend but haven't checked.",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T21:34:20Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.UUID\n+import javax.servlet.FilterChain\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.mockito.ArgumentCaptor\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.Mockito.{mock, never, times, verify, when}\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.config._\n+\n+class HttpSecurityFilterSuite extends SparkFunSuite {\n+\n+  test(\"filter bad user input\") {\n+    val badValues = Map(\n+      \"encoded\" -> \"Encoding:base64%0d%0a%0d%0aPGh0bWw%2bjcmlwdD48L2h0bWw%2b\",\n+      \"alert1\" -> \"\"\">\"'><script>alert(401)<%2Fscript>\"\"\",\n+      \"alert2\" -> \"\"\"app-20161208133404-0002<iframe+src%3Djavascript%3Aalert(1705)>\"\"\",\n+      \"alert3\" -> \"\"\"stdout'%2Balert(60)%2B'\"\"\",\n+      \"html\" -> \"\"\"stdout'\"><iframe+id%3D1131+src%3Dhttp%3A%2F%2Fdemo.test.net%2Fphishing.html>\"\"\"\n+    )\n+    val badKeys = badValues.map(_.swap)\n+    val goodInput = Map(\"goodKey\" -> \"goodValue\")\n+\n+    val conf = new SparkConf()\n+    val filter = new HttpSecurityFilter(conf, new SecurityManager(conf))\n+\n+    def newRequest(): HttpServletRequest = {\n+      val req = mock(classOf[HttpServletRequest])\n+      when(req.getParameterMap()).thenReturn(Map.empty[String, Array[String]].asJava)\n+      req\n+    }\n+\n+    def doRequest(k: String, v: String): HttpServletRequest = {\n+      val req = newRequest()\n+      when(req.getParameterMap()).thenReturn(Map(k -> Array(v)).asJava)\n+\n+      val chain = mock(classOf[FilterChain])\n+      val res = mock(classOf[HttpServletResponse])\n+      filter.doFilter(req, res, chain)\n+\n+      val captor = ArgumentCaptor.forClass(classOf[HttpServletRequest])\n+      verify(chain).doFilter(captor.capture(), any())\n+      captor.getValue()\n+    }\n+\n+    badKeys.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) === null)\n+      assert(req.getParameterValues(k) === null)\n+      assert(!req.getParameterMap().containsKey(k))\n+    }\n+\n+    badValues.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) != null)\n+      assert(req.getParameter(k) != v)\n+      assert(req.getParameterValues(k) != null)\n+      assert(req.getParameterValues(k) != Array(v))"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "yeah, that works. Never used `!==` before.",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T21:37:53Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.UUID\n+import javax.servlet.FilterChain\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.mockito.ArgumentCaptor\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.Mockito.{mock, never, times, verify, when}\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.config._\n+\n+class HttpSecurityFilterSuite extends SparkFunSuite {\n+\n+  test(\"filter bad user input\") {\n+    val badValues = Map(\n+      \"encoded\" -> \"Encoding:base64%0d%0a%0d%0aPGh0bWw%2bjcmlwdD48L2h0bWw%2b\",\n+      \"alert1\" -> \"\"\">\"'><script>alert(401)<%2Fscript>\"\"\",\n+      \"alert2\" -> \"\"\"app-20161208133404-0002<iframe+src%3Djavascript%3Aalert(1705)>\"\"\",\n+      \"alert3\" -> \"\"\"stdout'%2Balert(60)%2B'\"\"\",\n+      \"html\" -> \"\"\"stdout'\"><iframe+id%3D1131+src%3Dhttp%3A%2F%2Fdemo.test.net%2Fphishing.html>\"\"\"\n+    )\n+    val badKeys = badValues.map(_.swap)\n+    val goodInput = Map(\"goodKey\" -> \"goodValue\")\n+\n+    val conf = new SparkConf()\n+    val filter = new HttpSecurityFilter(conf, new SecurityManager(conf))\n+\n+    def newRequest(): HttpServletRequest = {\n+      val req = mock(classOf[HttpServletRequest])\n+      when(req.getParameterMap()).thenReturn(Map.empty[String, Array[String]].asJava)\n+      req\n+    }\n+\n+    def doRequest(k: String, v: String): HttpServletRequest = {\n+      val req = newRequest()\n+      when(req.getParameterMap()).thenReturn(Map(k -> Array(v)).asJava)\n+\n+      val chain = mock(classOf[FilterChain])\n+      val res = mock(classOf[HttpServletResponse])\n+      filter.doFilter(req, res, chain)\n+\n+      val captor = ArgumentCaptor.forClass(classOf[HttpServletRequest])\n+      verify(chain).doFilter(captor.capture(), any())\n+      captor.getValue()\n+    }\n+\n+    badKeys.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) === null)\n+      assert(req.getParameterValues(k) === null)\n+      assert(!req.getParameterMap().containsKey(k))\n+    }\n+\n+    badValues.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) != null)\n+      assert(req.getParameter(k) != v)\n+      assert(req.getParameterValues(k) != null)\n+      assert(req.getParameterValues(k) != Array(v))"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Really it's best to use these in tests, always; it generates better error messages like \"foo wasn't true or \"someComplexExpression was not less than 3\"",
    "commit": "d185e126a8f06cb3b577fd7622de5a87126e7f81",
    "createdAt": "2019-01-04T21:40:03Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ui\n+\n+import java.util.UUID\n+import javax.servlet.FilterChain\n+import javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.mockito.ArgumentCaptor\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.Mockito.{mock, never, times, verify, when}\n+\n+import org.apache.spark._\n+import org.apache.spark.internal.config._\n+\n+class HttpSecurityFilterSuite extends SparkFunSuite {\n+\n+  test(\"filter bad user input\") {\n+    val badValues = Map(\n+      \"encoded\" -> \"Encoding:base64%0d%0a%0d%0aPGh0bWw%2bjcmlwdD48L2h0bWw%2b\",\n+      \"alert1\" -> \"\"\">\"'><script>alert(401)<%2Fscript>\"\"\",\n+      \"alert2\" -> \"\"\"app-20161208133404-0002<iframe+src%3Djavascript%3Aalert(1705)>\"\"\",\n+      \"alert3\" -> \"\"\"stdout'%2Balert(60)%2B'\"\"\",\n+      \"html\" -> \"\"\"stdout'\"><iframe+id%3D1131+src%3Dhttp%3A%2F%2Fdemo.test.net%2Fphishing.html>\"\"\"\n+    )\n+    val badKeys = badValues.map(_.swap)\n+    val goodInput = Map(\"goodKey\" -> \"goodValue\")\n+\n+    val conf = new SparkConf()\n+    val filter = new HttpSecurityFilter(conf, new SecurityManager(conf))\n+\n+    def newRequest(): HttpServletRequest = {\n+      val req = mock(classOf[HttpServletRequest])\n+      when(req.getParameterMap()).thenReturn(Map.empty[String, Array[String]].asJava)\n+      req\n+    }\n+\n+    def doRequest(k: String, v: String): HttpServletRequest = {\n+      val req = newRequest()\n+      when(req.getParameterMap()).thenReturn(Map(k -> Array(v)).asJava)\n+\n+      val chain = mock(classOf[FilterChain])\n+      val res = mock(classOf[HttpServletResponse])\n+      filter.doFilter(req, res, chain)\n+\n+      val captor = ArgumentCaptor.forClass(classOf[HttpServletRequest])\n+      verify(chain).doFilter(captor.capture(), any())\n+      captor.getValue()\n+    }\n+\n+    badKeys.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) === null)\n+      assert(req.getParameterValues(k) === null)\n+      assert(!req.getParameterMap().containsKey(k))\n+    }\n+\n+    badValues.foreach { case (k, v) =>\n+      val req = doRequest(k, v)\n+      assert(req.getParameter(k) != null)\n+      assert(req.getParameter(k) != v)\n+      assert(req.getParameterValues(k) != null)\n+      assert(req.getParameterValues(k) != Array(v))"
  }],
  "prId": 23302
}]