[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Cool trick I learned the other day: we have `TaskContext.empty()` as a shorthand for this.\n",
    "commit": "9f964f26effd66af83acb44c1e531d0c0df09f6b",
    "createdAt": "2016-01-24T22:18:46Z",
    "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.scheduler.AccumulableInfo\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+class InternalAccumulatorSuite extends SparkFunSuite with LocalSparkContext {\n+  import InternalAccumulator._\n+  import AccumulatorParam._\n+\n+  test(\"get param\") {\n+    assert(getParam(EXECUTOR_DESERIALIZE_TIME) === LongAccumulatorParam)\n+    assert(getParam(EXECUTOR_RUN_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SIZE) === LongAccumulatorParam)\n+    assert(getParam(JVM_GC_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SERIALIZATION_TIME) === LongAccumulatorParam)\n+    assert(getParam(MEMORY_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(DISK_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(PEAK_EXECUTION_MEMORY) === LongAccumulatorParam)\n+    assert(getParam(UPDATED_BLOCK_STATUSES) === UpdatedBlockStatusesAccumulatorParam)\n+    assert(getParam(TEST_ACCUM) === LongAccumulatorParam)\n+    // shuffle read\n+    assert(getParam(shuffleRead.REMOTE_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.REMOTE_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.FETCH_WAIT_TIME) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.RECORDS_READ) === LongAccumulatorParam)\n+    // shuffle write\n+    assert(getParam(shuffleWrite.BYTES_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.WRITE_TIME) === LongAccumulatorParam)\n+    // input\n+    assert(getParam(input.READ_METHOD) === StringAccumulatorParam)\n+    assert(getParam(input.RECORDS_READ) === LongAccumulatorParam)\n+    assert(getParam(input.BYTES_READ) === LongAccumulatorParam)\n+    // output\n+    assert(getParam(output.WRITE_METHOD) === StringAccumulatorParam)\n+    assert(getParam(output.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(output.BYTES_WRITTEN) === LongAccumulatorParam)\n+    // default to Long\n+    assert(getParam(METRICS_PREFIX + \"anything\") === LongAccumulatorParam)\n+    intercept[AssertionError] {\n+      getParam(\"something that does not start with the right prefix\")\n+    }\n+  }\n+\n+  test(\"create by name\") {\n+    val executorRunTime = create(EXECUTOR_RUN_TIME)\n+    val updatedBlockStatuses = create(UPDATED_BLOCK_STATUSES)\n+    val shuffleRemoteBlocksRead = create(shuffleRead.REMOTE_BLOCKS_FETCHED)\n+    val inputReadMethod = create(input.READ_METHOD)\n+    assert(executorRunTime.name === Some(EXECUTOR_RUN_TIME))\n+    assert(updatedBlockStatuses.name === Some(UPDATED_BLOCK_STATUSES))\n+    assert(shuffleRemoteBlocksRead.name === Some(shuffleRead.REMOTE_BLOCKS_FETCHED))\n+    assert(inputReadMethod.name === Some(input.READ_METHOD))\n+    assert(executorRunTime.value.isInstanceOf[Long])\n+    assert(updatedBlockStatuses.value.isInstanceOf[Seq[_]])\n+    // We cannot assert the type of the value directly since the type parameter is erased.\n+    // Instead, try casting a `Seq` of expected type and see if it fails in run time.\n+    updatedBlockStatuses.setValueAny(Seq.empty[(BlockId, BlockStatus)])\n+    assert(shuffleRemoteBlocksRead.value.isInstanceOf[Int])\n+    assert(inputReadMethod.value.isInstanceOf[String])\n+    // default to Long\n+    val anything = create(METRICS_PREFIX + \"anything\")\n+    assert(anything.value.isInstanceOf[Long])\n+  }\n+\n+  test(\"create\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert they're all internal\n+    assert(accums.forall(_.isInternal))\n+    assert(shuffleReadAccums.forall(_.isInternal))\n+    assert(shuffleWriteAccums.forall(_.isInternal))\n+    assert(inputAccums.forall(_.isInternal))\n+    assert(outputAccums.forall(_.isInternal))\n+    // assert they all have names\n+    assert(accums.forall(_.name.isDefined))\n+    assert(shuffleReadAccums.forall(_.name.isDefined))\n+    assert(shuffleWriteAccums.forall(_.name.isDefined))\n+    assert(inputAccums.forall(_.name.isDefined))\n+    assert(outputAccums.forall(_.name.isDefined))\n+    // assert `accums` is a strict superset of the others\n+    val accumNames = accums.map(_.name.get).toSet\n+    val shuffleReadAccumNames = shuffleReadAccums.map(_.name.get).toSet\n+    val shuffleWriteAccumNames = shuffleWriteAccums.map(_.name.get).toSet\n+    val inputAccumNames = inputAccums.map(_.name.get).toSet\n+    val outputAccumNames = outputAccums.map(_.name.get).toSet\n+    assert(shuffleReadAccumNames.subsetOf(accumNames))\n+    assert(shuffleWriteAccumNames.subsetOf(accumNames))\n+    assert(inputAccumNames.subsetOf(accumNames))\n+    assert(outputAccumNames.subsetOf(accumNames))\n+  }\n+\n+  test(\"naming\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert that prefixes are properly namespaced\n+    assert(SHUFFLE_READ_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(SHUFFLE_WRITE_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(INPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(OUTPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(accums.forall(_.name.get.startsWith(METRICS_PREFIX)))\n+    // assert they all start with the expected prefixes\n+    assert(shuffleReadAccums.forall(_.name.get.startsWith(SHUFFLE_READ_METRICS_PREFIX)))\n+    assert(shuffleWriteAccums.forall(_.name.get.startsWith(SHUFFLE_WRITE_METRICS_PREFIX)))\n+    assert(inputAccums.forall(_.name.get.startsWith(INPUT_METRICS_PREFIX)))\n+    assert(outputAccums.forall(_.name.get.startsWith(OUTPUT_METRICS_PREFIX)))\n+  }\n+\n+  test(\"internal accumulators in TaskContext\") {\n+    sc = new SparkContext(\"local\", \"test\")\n+    val taskContext = new TaskContextImpl(0, 0, 0, 0, null, null)"
  }],
  "prId": 10835
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This test doesn't use `SparkContext`?\n",
    "commit": "9f964f26effd66af83acb44c1e531d0c0df09f6b",
    "createdAt": "2016-01-24T22:19:32Z",
    "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.scheduler.AccumulableInfo\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+class InternalAccumulatorSuite extends SparkFunSuite with LocalSparkContext {\n+  import InternalAccumulator._\n+  import AccumulatorParam._\n+\n+  test(\"get param\") {\n+    assert(getParam(EXECUTOR_DESERIALIZE_TIME) === LongAccumulatorParam)\n+    assert(getParam(EXECUTOR_RUN_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SIZE) === LongAccumulatorParam)\n+    assert(getParam(JVM_GC_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SERIALIZATION_TIME) === LongAccumulatorParam)\n+    assert(getParam(MEMORY_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(DISK_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(PEAK_EXECUTION_MEMORY) === LongAccumulatorParam)\n+    assert(getParam(UPDATED_BLOCK_STATUSES) === UpdatedBlockStatusesAccumulatorParam)\n+    assert(getParam(TEST_ACCUM) === LongAccumulatorParam)\n+    // shuffle read\n+    assert(getParam(shuffleRead.REMOTE_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.REMOTE_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.FETCH_WAIT_TIME) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.RECORDS_READ) === LongAccumulatorParam)\n+    // shuffle write\n+    assert(getParam(shuffleWrite.BYTES_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.WRITE_TIME) === LongAccumulatorParam)\n+    // input\n+    assert(getParam(input.READ_METHOD) === StringAccumulatorParam)\n+    assert(getParam(input.RECORDS_READ) === LongAccumulatorParam)\n+    assert(getParam(input.BYTES_READ) === LongAccumulatorParam)\n+    // output\n+    assert(getParam(output.WRITE_METHOD) === StringAccumulatorParam)\n+    assert(getParam(output.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(output.BYTES_WRITTEN) === LongAccumulatorParam)\n+    // default to Long\n+    assert(getParam(METRICS_PREFIX + \"anything\") === LongAccumulatorParam)\n+    intercept[AssertionError] {\n+      getParam(\"something that does not start with the right prefix\")\n+    }\n+  }\n+\n+  test(\"create by name\") {\n+    val executorRunTime = create(EXECUTOR_RUN_TIME)\n+    val updatedBlockStatuses = create(UPDATED_BLOCK_STATUSES)\n+    val shuffleRemoteBlocksRead = create(shuffleRead.REMOTE_BLOCKS_FETCHED)\n+    val inputReadMethod = create(input.READ_METHOD)\n+    assert(executorRunTime.name === Some(EXECUTOR_RUN_TIME))\n+    assert(updatedBlockStatuses.name === Some(UPDATED_BLOCK_STATUSES))\n+    assert(shuffleRemoteBlocksRead.name === Some(shuffleRead.REMOTE_BLOCKS_FETCHED))\n+    assert(inputReadMethod.name === Some(input.READ_METHOD))\n+    assert(executorRunTime.value.isInstanceOf[Long])\n+    assert(updatedBlockStatuses.value.isInstanceOf[Seq[_]])\n+    // We cannot assert the type of the value directly since the type parameter is erased.\n+    // Instead, try casting a `Seq` of expected type and see if it fails in run time.\n+    updatedBlockStatuses.setValueAny(Seq.empty[(BlockId, BlockStatus)])\n+    assert(shuffleRemoteBlocksRead.value.isInstanceOf[Int])\n+    assert(inputReadMethod.value.isInstanceOf[String])\n+    // default to Long\n+    val anything = create(METRICS_PREFIX + \"anything\")\n+    assert(anything.value.isInstanceOf[Long])\n+  }\n+\n+  test(\"create\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert they're all internal\n+    assert(accums.forall(_.isInternal))\n+    assert(shuffleReadAccums.forall(_.isInternal))\n+    assert(shuffleWriteAccums.forall(_.isInternal))\n+    assert(inputAccums.forall(_.isInternal))\n+    assert(outputAccums.forall(_.isInternal))\n+    // assert they all have names\n+    assert(accums.forall(_.name.isDefined))\n+    assert(shuffleReadAccums.forall(_.name.isDefined))\n+    assert(shuffleWriteAccums.forall(_.name.isDefined))\n+    assert(inputAccums.forall(_.name.isDefined))\n+    assert(outputAccums.forall(_.name.isDefined))\n+    // assert `accums` is a strict superset of the others\n+    val accumNames = accums.map(_.name.get).toSet\n+    val shuffleReadAccumNames = shuffleReadAccums.map(_.name.get).toSet\n+    val shuffleWriteAccumNames = shuffleWriteAccums.map(_.name.get).toSet\n+    val inputAccumNames = inputAccums.map(_.name.get).toSet\n+    val outputAccumNames = outputAccums.map(_.name.get).toSet\n+    assert(shuffleReadAccumNames.subsetOf(accumNames))\n+    assert(shuffleWriteAccumNames.subsetOf(accumNames))\n+    assert(inputAccumNames.subsetOf(accumNames))\n+    assert(outputAccumNames.subsetOf(accumNames))\n+  }\n+\n+  test(\"naming\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert that prefixes are properly namespaced\n+    assert(SHUFFLE_READ_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(SHUFFLE_WRITE_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(INPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(OUTPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(accums.forall(_.name.get.startsWith(METRICS_PREFIX)))\n+    // assert they all start with the expected prefixes\n+    assert(shuffleReadAccums.forall(_.name.get.startsWith(SHUFFLE_READ_METRICS_PREFIX)))\n+    assert(shuffleWriteAccums.forall(_.name.get.startsWith(SHUFFLE_WRITE_METRICS_PREFIX)))\n+    assert(inputAccums.forall(_.name.get.startsWith(INPUT_METRICS_PREFIX)))\n+    assert(outputAccums.forall(_.name.get.startsWith(OUTPUT_METRICS_PREFIX)))\n+  }\n+\n+  test(\"internal accumulators in TaskContext\") {\n+    sc = new SparkContext(\"local\", \"test\")"
  }],
  "prId": 10835
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Hmm, I guess this is a consequence of internal accumulators being scoped to individual stages? To double-check my understanding, if we _were_ to open up this internal accumulator \"count failures\" API to users, then I guess the user-created accumulator's lifecycle would be broader in scope (encompassing the entire job (or possibly multiple jobs), even including stage resubmissions) because it's not being created in DAGScheduler. Is that right?\n",
    "commit": "9f964f26effd66af83acb44c1e531d0c0df09f6b",
    "createdAt": "2016-01-26T07:52:51Z",
    "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.scheduler.AccumulableInfo\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+class InternalAccumulatorSuite extends SparkFunSuite with LocalSparkContext {\n+  import InternalAccumulator._\n+  import AccumulatorParam._\n+\n+  test(\"get param\") {\n+    assert(getParam(EXECUTOR_DESERIALIZE_TIME) === LongAccumulatorParam)\n+    assert(getParam(EXECUTOR_RUN_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SIZE) === LongAccumulatorParam)\n+    assert(getParam(JVM_GC_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SERIALIZATION_TIME) === LongAccumulatorParam)\n+    assert(getParam(MEMORY_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(DISK_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(PEAK_EXECUTION_MEMORY) === LongAccumulatorParam)\n+    assert(getParam(UPDATED_BLOCK_STATUSES) === UpdatedBlockStatusesAccumulatorParam)\n+    assert(getParam(TEST_ACCUM) === LongAccumulatorParam)\n+    // shuffle read\n+    assert(getParam(shuffleRead.REMOTE_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.REMOTE_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.FETCH_WAIT_TIME) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.RECORDS_READ) === LongAccumulatorParam)\n+    // shuffle write\n+    assert(getParam(shuffleWrite.BYTES_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.WRITE_TIME) === LongAccumulatorParam)\n+    // input\n+    assert(getParam(input.READ_METHOD) === StringAccumulatorParam)\n+    assert(getParam(input.RECORDS_READ) === LongAccumulatorParam)\n+    assert(getParam(input.BYTES_READ) === LongAccumulatorParam)\n+    // output\n+    assert(getParam(output.WRITE_METHOD) === StringAccumulatorParam)\n+    assert(getParam(output.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(output.BYTES_WRITTEN) === LongAccumulatorParam)\n+    // default to Long\n+    assert(getParam(METRICS_PREFIX + \"anything\") === LongAccumulatorParam)\n+    intercept[IllegalArgumentException] {\n+      getParam(\"something that does not start with the right prefix\")\n+    }\n+  }\n+\n+  test(\"create by name\") {\n+    val executorRunTime = create(EXECUTOR_RUN_TIME)\n+    val updatedBlockStatuses = create(UPDATED_BLOCK_STATUSES)\n+    val shuffleRemoteBlocksRead = create(shuffleRead.REMOTE_BLOCKS_FETCHED)\n+    val inputReadMethod = create(input.READ_METHOD)\n+    assert(executorRunTime.name === Some(EXECUTOR_RUN_TIME))\n+    assert(updatedBlockStatuses.name === Some(UPDATED_BLOCK_STATUSES))\n+    assert(shuffleRemoteBlocksRead.name === Some(shuffleRead.REMOTE_BLOCKS_FETCHED))\n+    assert(inputReadMethod.name === Some(input.READ_METHOD))\n+    assert(executorRunTime.value.isInstanceOf[Long])\n+    assert(updatedBlockStatuses.value.isInstanceOf[Seq[_]])\n+    // We cannot assert the type of the value directly since the type parameter is erased.\n+    // Instead, try casting a `Seq` of expected type and see if it fails in run time.\n+    updatedBlockStatuses.setValueAny(Seq.empty[(BlockId, BlockStatus)])\n+    assert(shuffleRemoteBlocksRead.value.isInstanceOf[Int])\n+    assert(inputReadMethod.value.isInstanceOf[String])\n+    // default to Long\n+    val anything = create(METRICS_PREFIX + \"anything\")\n+    assert(anything.value.isInstanceOf[Long])\n+  }\n+\n+  test(\"create\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert they're all internal\n+    assert(accums.forall(_.isInternal))\n+    assert(shuffleReadAccums.forall(_.isInternal))\n+    assert(shuffleWriteAccums.forall(_.isInternal))\n+    assert(inputAccums.forall(_.isInternal))\n+    assert(outputAccums.forall(_.isInternal))\n+    // assert they all count on failures\n+    assert(accums.forall(_.countFailedValues))\n+    assert(shuffleReadAccums.forall(_.countFailedValues))\n+    assert(shuffleWriteAccums.forall(_.countFailedValues))\n+    assert(inputAccums.forall(_.countFailedValues))\n+    assert(outputAccums.forall(_.countFailedValues))\n+    // assert they all have names\n+    assert(accums.forall(_.name.isDefined))\n+    assert(shuffleReadAccums.forall(_.name.isDefined))\n+    assert(shuffleWriteAccums.forall(_.name.isDefined))\n+    assert(inputAccums.forall(_.name.isDefined))\n+    assert(outputAccums.forall(_.name.isDefined))\n+    // assert `accums` is a strict superset of the others\n+    val accumNames = accums.map(_.name.get).toSet\n+    val shuffleReadAccumNames = shuffleReadAccums.map(_.name.get).toSet\n+    val shuffleWriteAccumNames = shuffleWriteAccums.map(_.name.get).toSet\n+    val inputAccumNames = inputAccums.map(_.name.get).toSet\n+    val outputAccumNames = outputAccums.map(_.name.get).toSet\n+    assert(shuffleReadAccumNames.subsetOf(accumNames))\n+    assert(shuffleWriteAccumNames.subsetOf(accumNames))\n+    assert(inputAccumNames.subsetOf(accumNames))\n+    assert(outputAccumNames.subsetOf(accumNames))\n+  }\n+\n+  test(\"naming\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert that prefixes are properly namespaced\n+    assert(SHUFFLE_READ_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(SHUFFLE_WRITE_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(INPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(OUTPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(accums.forall(_.name.get.startsWith(METRICS_PREFIX)))\n+    // assert they all start with the expected prefixes\n+    assert(shuffleReadAccums.forall(_.name.get.startsWith(SHUFFLE_READ_METRICS_PREFIX)))\n+    assert(shuffleWriteAccums.forall(_.name.get.startsWith(SHUFFLE_WRITE_METRICS_PREFIX)))\n+    assert(inputAccums.forall(_.name.get.startsWith(INPUT_METRICS_PREFIX)))\n+    assert(outputAccums.forall(_.name.get.startsWith(OUTPUT_METRICS_PREFIX)))\n+  }\n+\n+  test(\"internal accumulators in TaskContext\") {\n+    val taskContext = TaskContext.empty()\n+    val accumUpdates = taskContext.taskMetrics.accumulatorUpdates()\n+    assert(accumUpdates.size > 0)\n+    assert(accumUpdates.forall(_.internal))\n+    val testAccum = taskContext.taskMetrics.getAccum(TEST_ACCUM)\n+    assert(accumUpdates.exists(_.id == testAccum.id))\n+  }\n+\n+  test(\"internal accumulators in a stage\") {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    sc = new SparkContext(\"local\", \"test\")\n+    sc.addSparkListener(listener)\n+    // Have each task add 1 to the internal accumulator\n+    val rdd = sc.parallelize(1 to 100, numPartitions).mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 1\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+      val stageInfos = listener.getCompletedStageInfos\n+      val taskInfos = listener.getCompletedTaskInfos\n+      assert(stageInfos.size === 1)\n+      assert(taskInfos.size === numPartitions)\n+      // The accumulator values should be merged in the stage\n+      val stageAccum = findTestAccum(stageInfos.head.accumulables.values)\n+      assert(stageAccum.value.get.asInstanceOf[Long] === numPartitions)\n+      // The accumulator should be updated locally on each task\n+      val taskAccumValues = taskInfos.map { taskInfo =>\n+        val taskAccum = findTestAccum(taskInfo.accumulables)\n+        assert(taskAccum.update.isDefined)\n+        assert(taskAccum.update.get.asInstanceOf[Long] === 1L)\n+        taskAccum.value.get.asInstanceOf[Long]\n+      }\n+      // Each task should keep track of the partial value on the way, i.e. 1, 2, ... numPartitions\n+      assert(taskAccumValues.sorted === (1L to numPartitions).toSeq)\n+    }\n+    rdd.count()\n+  }\n+\n+  test(\"internal accumulators in multiple stages\") {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    sc = new SparkContext(\"local\", \"test\")\n+    sc.addSparkListener(listener)\n+    // Each stage creates its own set of internal accumulators so the\n+    // values for the same metric should not be mixed up across stages\n+    val rdd = sc.parallelize(1 to 100, numPartitions)\n+      .map { i => (i, i) }\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 1\n+      iter\n+    }\n+      .reduceByKey { case (x, y) => x + y }\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 10\n+      iter\n+    }\n+      .repartition(numPartitions * 2)\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 100\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+    // We ran 3 stages, and the accumulator values should be distinct\n+      val stageInfos = listener.getCompletedStageInfos\n+      assert(stageInfos.size === 3)\n+      val (firstStageAccum, secondStageAccum, thirdStageAccum) =\n+        (findTestAccum(stageInfos(0).accumulables.values),\n+          findTestAccum(stageInfos(1).accumulables.values),\n+          findTestAccum(stageInfos(2).accumulables.values))\n+      assert(firstStageAccum.value.get.asInstanceOf[Long] === numPartitions)\n+      assert(secondStageAccum.value.get.asInstanceOf[Long] === numPartitions * 10)\n+      assert(thirdStageAccum.value.get.asInstanceOf[Long] === numPartitions * 2 * 100)\n+    }\n+    rdd.count()\n+  }\n+\n+  test(\"internal accumulators in fully resubmitted stages\") {\n+    testInternalAccumulatorsWithFailedTasks((i: Int) => true) // fail all tasks\n+  }\n+\n+  test(\"internal accumulators in partially resubmitted stages\") {\n+    testInternalAccumulatorsWithFailedTasks((i: Int) => i % 2 == 0) // fail a subset\n+  }\n+\n+  test(\"internal accumulators are registered for cleanups\") {\n+    sc = new SparkContext(\"local\", \"test\") {\n+      private val myCleaner = new SaveAccumContextCleaner(this)\n+      override def cleaner: Option[ContextCleaner] = Some(myCleaner)\n+    }\n+    assert(Accumulators.originals.isEmpty)\n+    sc.parallelize(1 to 100).map { i => (i, i) }.reduceByKey { _ + _ }.count()\n+    val internalAccums = InternalAccumulator.create()\n+    // We ran 2 stages, so we should have 2 sets of internal accumulators, 1 for each stage\n+    assert(Accumulators.originals.size === internalAccums.size * 2)\n+    val accumsRegistered = sc.cleaner match {\n+      case Some(cleaner: SaveAccumContextCleaner) => cleaner.accumsRegisteredForCleanup\n+      case _ => Seq.empty[Long]\n+    }\n+    // Make sure the same set of accumulators is registered for cleanup\n+    assert(accumsRegistered.size === internalAccums.size * 2)\n+    assert(accumsRegistered.toSet === Accumulators.originals.keys.toSet)\n+  }\n+\n+  /**\n+   * Return the accumulable info that matches the specified name.\n+   */\n+  private def findTestAccum(accums: Iterable[AccumulableInfo]): AccumulableInfo = {\n+    accums.find { a => a.name == TEST_ACCUM }.getOrElse {\n+      fail(s\"unable to find internal accumulator called $TEST_ACCUM\")\n+    }\n+  }\n+\n+  /**\n+   * Test whether internal accumulators are merged properly if some tasks fail.\n+   */\n+  private def testInternalAccumulatorsWithFailedTasks(failCondition: (Int => Boolean)): Unit = {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    val numFailedPartitions = (0 until numPartitions).count(failCondition)\n+    // This says use 1 core and retry tasks up to 2 times\n+    sc = new SparkContext(\"local[1, 2]\", \"test\")\n+    sc.addSparkListener(listener)\n+    val rdd = sc.parallelize(1 to 100, numPartitions).mapPartitionsWithIndex { case (i, iter) =>\n+      val taskContext = TaskContext.get()\n+      taskContext.taskMetrics().getAccum(TEST_ACCUM) += 1\n+      // Fail the first attempts of a subset of the tasks\n+      if (failCondition(i) && taskContext.attemptNumber() == 0) {\n+        throw new Exception(\"Failing a task intentionally.\")\n+      }\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+      val stageInfos = listener.getCompletedStageInfos\n+      val taskInfos = listener.getCompletedTaskInfos\n+      assert(stageInfos.size === 1)\n+      assert(taskInfos.size === numPartitions + numFailedPartitions)\n+      val stageAccum = findTestAccum(stageInfos.head.accumulables.values)\n+      // If all partitions failed, then we would resubmit the whole stage again and create a",
    "line": 287
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "No problem here for this PR, just double-checking.\n",
    "commit": "9f964f26effd66af83acb44c1e531d0c0df09f6b",
    "createdAt": "2016-01-26T07:53:20Z",
    "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.scheduler.AccumulableInfo\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+class InternalAccumulatorSuite extends SparkFunSuite with LocalSparkContext {\n+  import InternalAccumulator._\n+  import AccumulatorParam._\n+\n+  test(\"get param\") {\n+    assert(getParam(EXECUTOR_DESERIALIZE_TIME) === LongAccumulatorParam)\n+    assert(getParam(EXECUTOR_RUN_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SIZE) === LongAccumulatorParam)\n+    assert(getParam(JVM_GC_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SERIALIZATION_TIME) === LongAccumulatorParam)\n+    assert(getParam(MEMORY_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(DISK_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(PEAK_EXECUTION_MEMORY) === LongAccumulatorParam)\n+    assert(getParam(UPDATED_BLOCK_STATUSES) === UpdatedBlockStatusesAccumulatorParam)\n+    assert(getParam(TEST_ACCUM) === LongAccumulatorParam)\n+    // shuffle read\n+    assert(getParam(shuffleRead.REMOTE_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.REMOTE_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.FETCH_WAIT_TIME) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.RECORDS_READ) === LongAccumulatorParam)\n+    // shuffle write\n+    assert(getParam(shuffleWrite.BYTES_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.WRITE_TIME) === LongAccumulatorParam)\n+    // input\n+    assert(getParam(input.READ_METHOD) === StringAccumulatorParam)\n+    assert(getParam(input.RECORDS_READ) === LongAccumulatorParam)\n+    assert(getParam(input.BYTES_READ) === LongAccumulatorParam)\n+    // output\n+    assert(getParam(output.WRITE_METHOD) === StringAccumulatorParam)\n+    assert(getParam(output.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(output.BYTES_WRITTEN) === LongAccumulatorParam)\n+    // default to Long\n+    assert(getParam(METRICS_PREFIX + \"anything\") === LongAccumulatorParam)\n+    intercept[IllegalArgumentException] {\n+      getParam(\"something that does not start with the right prefix\")\n+    }\n+  }\n+\n+  test(\"create by name\") {\n+    val executorRunTime = create(EXECUTOR_RUN_TIME)\n+    val updatedBlockStatuses = create(UPDATED_BLOCK_STATUSES)\n+    val shuffleRemoteBlocksRead = create(shuffleRead.REMOTE_BLOCKS_FETCHED)\n+    val inputReadMethod = create(input.READ_METHOD)\n+    assert(executorRunTime.name === Some(EXECUTOR_RUN_TIME))\n+    assert(updatedBlockStatuses.name === Some(UPDATED_BLOCK_STATUSES))\n+    assert(shuffleRemoteBlocksRead.name === Some(shuffleRead.REMOTE_BLOCKS_FETCHED))\n+    assert(inputReadMethod.name === Some(input.READ_METHOD))\n+    assert(executorRunTime.value.isInstanceOf[Long])\n+    assert(updatedBlockStatuses.value.isInstanceOf[Seq[_]])\n+    // We cannot assert the type of the value directly since the type parameter is erased.\n+    // Instead, try casting a `Seq` of expected type and see if it fails in run time.\n+    updatedBlockStatuses.setValueAny(Seq.empty[(BlockId, BlockStatus)])\n+    assert(shuffleRemoteBlocksRead.value.isInstanceOf[Int])\n+    assert(inputReadMethod.value.isInstanceOf[String])\n+    // default to Long\n+    val anything = create(METRICS_PREFIX + \"anything\")\n+    assert(anything.value.isInstanceOf[Long])\n+  }\n+\n+  test(\"create\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert they're all internal\n+    assert(accums.forall(_.isInternal))\n+    assert(shuffleReadAccums.forall(_.isInternal))\n+    assert(shuffleWriteAccums.forall(_.isInternal))\n+    assert(inputAccums.forall(_.isInternal))\n+    assert(outputAccums.forall(_.isInternal))\n+    // assert they all count on failures\n+    assert(accums.forall(_.countFailedValues))\n+    assert(shuffleReadAccums.forall(_.countFailedValues))\n+    assert(shuffleWriteAccums.forall(_.countFailedValues))\n+    assert(inputAccums.forall(_.countFailedValues))\n+    assert(outputAccums.forall(_.countFailedValues))\n+    // assert they all have names\n+    assert(accums.forall(_.name.isDefined))\n+    assert(shuffleReadAccums.forall(_.name.isDefined))\n+    assert(shuffleWriteAccums.forall(_.name.isDefined))\n+    assert(inputAccums.forall(_.name.isDefined))\n+    assert(outputAccums.forall(_.name.isDefined))\n+    // assert `accums` is a strict superset of the others\n+    val accumNames = accums.map(_.name.get).toSet\n+    val shuffleReadAccumNames = shuffleReadAccums.map(_.name.get).toSet\n+    val shuffleWriteAccumNames = shuffleWriteAccums.map(_.name.get).toSet\n+    val inputAccumNames = inputAccums.map(_.name.get).toSet\n+    val outputAccumNames = outputAccums.map(_.name.get).toSet\n+    assert(shuffleReadAccumNames.subsetOf(accumNames))\n+    assert(shuffleWriteAccumNames.subsetOf(accumNames))\n+    assert(inputAccumNames.subsetOf(accumNames))\n+    assert(outputAccumNames.subsetOf(accumNames))\n+  }\n+\n+  test(\"naming\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert that prefixes are properly namespaced\n+    assert(SHUFFLE_READ_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(SHUFFLE_WRITE_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(INPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(OUTPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(accums.forall(_.name.get.startsWith(METRICS_PREFIX)))\n+    // assert they all start with the expected prefixes\n+    assert(shuffleReadAccums.forall(_.name.get.startsWith(SHUFFLE_READ_METRICS_PREFIX)))\n+    assert(shuffleWriteAccums.forall(_.name.get.startsWith(SHUFFLE_WRITE_METRICS_PREFIX)))\n+    assert(inputAccums.forall(_.name.get.startsWith(INPUT_METRICS_PREFIX)))\n+    assert(outputAccums.forall(_.name.get.startsWith(OUTPUT_METRICS_PREFIX)))\n+  }\n+\n+  test(\"internal accumulators in TaskContext\") {\n+    val taskContext = TaskContext.empty()\n+    val accumUpdates = taskContext.taskMetrics.accumulatorUpdates()\n+    assert(accumUpdates.size > 0)\n+    assert(accumUpdates.forall(_.internal))\n+    val testAccum = taskContext.taskMetrics.getAccum(TEST_ACCUM)\n+    assert(accumUpdates.exists(_.id == testAccum.id))\n+  }\n+\n+  test(\"internal accumulators in a stage\") {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    sc = new SparkContext(\"local\", \"test\")\n+    sc.addSparkListener(listener)\n+    // Have each task add 1 to the internal accumulator\n+    val rdd = sc.parallelize(1 to 100, numPartitions).mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 1\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+      val stageInfos = listener.getCompletedStageInfos\n+      val taskInfos = listener.getCompletedTaskInfos\n+      assert(stageInfos.size === 1)\n+      assert(taskInfos.size === numPartitions)\n+      // The accumulator values should be merged in the stage\n+      val stageAccum = findTestAccum(stageInfos.head.accumulables.values)\n+      assert(stageAccum.value.get.asInstanceOf[Long] === numPartitions)\n+      // The accumulator should be updated locally on each task\n+      val taskAccumValues = taskInfos.map { taskInfo =>\n+        val taskAccum = findTestAccum(taskInfo.accumulables)\n+        assert(taskAccum.update.isDefined)\n+        assert(taskAccum.update.get.asInstanceOf[Long] === 1L)\n+        taskAccum.value.get.asInstanceOf[Long]\n+      }\n+      // Each task should keep track of the partial value on the way, i.e. 1, 2, ... numPartitions\n+      assert(taskAccumValues.sorted === (1L to numPartitions).toSeq)\n+    }\n+    rdd.count()\n+  }\n+\n+  test(\"internal accumulators in multiple stages\") {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    sc = new SparkContext(\"local\", \"test\")\n+    sc.addSparkListener(listener)\n+    // Each stage creates its own set of internal accumulators so the\n+    // values for the same metric should not be mixed up across stages\n+    val rdd = sc.parallelize(1 to 100, numPartitions)\n+      .map { i => (i, i) }\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 1\n+      iter\n+    }\n+      .reduceByKey { case (x, y) => x + y }\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 10\n+      iter\n+    }\n+      .repartition(numPartitions * 2)\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 100\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+    // We ran 3 stages, and the accumulator values should be distinct\n+      val stageInfos = listener.getCompletedStageInfos\n+      assert(stageInfos.size === 3)\n+      val (firstStageAccum, secondStageAccum, thirdStageAccum) =\n+        (findTestAccum(stageInfos(0).accumulables.values),\n+          findTestAccum(stageInfos(1).accumulables.values),\n+          findTestAccum(stageInfos(2).accumulables.values))\n+      assert(firstStageAccum.value.get.asInstanceOf[Long] === numPartitions)\n+      assert(secondStageAccum.value.get.asInstanceOf[Long] === numPartitions * 10)\n+      assert(thirdStageAccum.value.get.asInstanceOf[Long] === numPartitions * 2 * 100)\n+    }\n+    rdd.count()\n+  }\n+\n+  test(\"internal accumulators in fully resubmitted stages\") {\n+    testInternalAccumulatorsWithFailedTasks((i: Int) => true) // fail all tasks\n+  }\n+\n+  test(\"internal accumulators in partially resubmitted stages\") {\n+    testInternalAccumulatorsWithFailedTasks((i: Int) => i % 2 == 0) // fail a subset\n+  }\n+\n+  test(\"internal accumulators are registered for cleanups\") {\n+    sc = new SparkContext(\"local\", \"test\") {\n+      private val myCleaner = new SaveAccumContextCleaner(this)\n+      override def cleaner: Option[ContextCleaner] = Some(myCleaner)\n+    }\n+    assert(Accumulators.originals.isEmpty)\n+    sc.parallelize(1 to 100).map { i => (i, i) }.reduceByKey { _ + _ }.count()\n+    val internalAccums = InternalAccumulator.create()\n+    // We ran 2 stages, so we should have 2 sets of internal accumulators, 1 for each stage\n+    assert(Accumulators.originals.size === internalAccums.size * 2)\n+    val accumsRegistered = sc.cleaner match {\n+      case Some(cleaner: SaveAccumContextCleaner) => cleaner.accumsRegisteredForCleanup\n+      case _ => Seq.empty[Long]\n+    }\n+    // Make sure the same set of accumulators is registered for cleanup\n+    assert(accumsRegistered.size === internalAccums.size * 2)\n+    assert(accumsRegistered.toSet === Accumulators.originals.keys.toSet)\n+  }\n+\n+  /**\n+   * Return the accumulable info that matches the specified name.\n+   */\n+  private def findTestAccum(accums: Iterable[AccumulableInfo]): AccumulableInfo = {\n+    accums.find { a => a.name == TEST_ACCUM }.getOrElse {\n+      fail(s\"unable to find internal accumulator called $TEST_ACCUM\")\n+    }\n+  }\n+\n+  /**\n+   * Test whether internal accumulators are merged properly if some tasks fail.\n+   */\n+  private def testInternalAccumulatorsWithFailedTasks(failCondition: (Int => Boolean)): Unit = {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    val numFailedPartitions = (0 until numPartitions).count(failCondition)\n+    // This says use 1 core and retry tasks up to 2 times\n+    sc = new SparkContext(\"local[1, 2]\", \"test\")\n+    sc.addSparkListener(listener)\n+    val rdd = sc.parallelize(1 to 100, numPartitions).mapPartitionsWithIndex { case (i, iter) =>\n+      val taskContext = TaskContext.get()\n+      taskContext.taskMetrics().getAccum(TEST_ACCUM) += 1\n+      // Fail the first attempts of a subset of the tasks\n+      if (failCondition(i) && taskContext.attemptNumber() == 0) {\n+        throw new Exception(\"Failing a task intentionally.\")\n+      }\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+      val stageInfos = listener.getCompletedStageInfos\n+      val taskInfos = listener.getCompletedTaskInfos\n+      assert(stageInfos.size === 1)\n+      assert(taskInfos.size === numPartitions + numFailedPartitions)\n+      val stageAccum = findTestAccum(stageInfos.head.accumulables.values)\n+      // If all partitions failed, then we would resubmit the whole stage again and create a",
    "line": 287
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "correct\n",
    "commit": "9f964f26effd66af83acb44c1e531d0c0df09f6b",
    "createdAt": "2016-01-26T08:21:29Z",
    "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.scheduler.AccumulableInfo\n+import org.apache.spark.storage.{BlockId, BlockStatus}\n+\n+\n+class InternalAccumulatorSuite extends SparkFunSuite with LocalSparkContext {\n+  import InternalAccumulator._\n+  import AccumulatorParam._\n+\n+  test(\"get param\") {\n+    assert(getParam(EXECUTOR_DESERIALIZE_TIME) === LongAccumulatorParam)\n+    assert(getParam(EXECUTOR_RUN_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SIZE) === LongAccumulatorParam)\n+    assert(getParam(JVM_GC_TIME) === LongAccumulatorParam)\n+    assert(getParam(RESULT_SERIALIZATION_TIME) === LongAccumulatorParam)\n+    assert(getParam(MEMORY_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(DISK_BYTES_SPILLED) === LongAccumulatorParam)\n+    assert(getParam(PEAK_EXECUTION_MEMORY) === LongAccumulatorParam)\n+    assert(getParam(UPDATED_BLOCK_STATUSES) === UpdatedBlockStatusesAccumulatorParam)\n+    assert(getParam(TEST_ACCUM) === LongAccumulatorParam)\n+    // shuffle read\n+    assert(getParam(shuffleRead.REMOTE_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BLOCKS_FETCHED) === IntAccumulatorParam)\n+    assert(getParam(shuffleRead.REMOTE_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.LOCAL_BYTES_READ) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.FETCH_WAIT_TIME) === LongAccumulatorParam)\n+    assert(getParam(shuffleRead.RECORDS_READ) === LongAccumulatorParam)\n+    // shuffle write\n+    assert(getParam(shuffleWrite.BYTES_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(shuffleWrite.WRITE_TIME) === LongAccumulatorParam)\n+    // input\n+    assert(getParam(input.READ_METHOD) === StringAccumulatorParam)\n+    assert(getParam(input.RECORDS_READ) === LongAccumulatorParam)\n+    assert(getParam(input.BYTES_READ) === LongAccumulatorParam)\n+    // output\n+    assert(getParam(output.WRITE_METHOD) === StringAccumulatorParam)\n+    assert(getParam(output.RECORDS_WRITTEN) === LongAccumulatorParam)\n+    assert(getParam(output.BYTES_WRITTEN) === LongAccumulatorParam)\n+    // default to Long\n+    assert(getParam(METRICS_PREFIX + \"anything\") === LongAccumulatorParam)\n+    intercept[IllegalArgumentException] {\n+      getParam(\"something that does not start with the right prefix\")\n+    }\n+  }\n+\n+  test(\"create by name\") {\n+    val executorRunTime = create(EXECUTOR_RUN_TIME)\n+    val updatedBlockStatuses = create(UPDATED_BLOCK_STATUSES)\n+    val shuffleRemoteBlocksRead = create(shuffleRead.REMOTE_BLOCKS_FETCHED)\n+    val inputReadMethod = create(input.READ_METHOD)\n+    assert(executorRunTime.name === Some(EXECUTOR_RUN_TIME))\n+    assert(updatedBlockStatuses.name === Some(UPDATED_BLOCK_STATUSES))\n+    assert(shuffleRemoteBlocksRead.name === Some(shuffleRead.REMOTE_BLOCKS_FETCHED))\n+    assert(inputReadMethod.name === Some(input.READ_METHOD))\n+    assert(executorRunTime.value.isInstanceOf[Long])\n+    assert(updatedBlockStatuses.value.isInstanceOf[Seq[_]])\n+    // We cannot assert the type of the value directly since the type parameter is erased.\n+    // Instead, try casting a `Seq` of expected type and see if it fails in run time.\n+    updatedBlockStatuses.setValueAny(Seq.empty[(BlockId, BlockStatus)])\n+    assert(shuffleRemoteBlocksRead.value.isInstanceOf[Int])\n+    assert(inputReadMethod.value.isInstanceOf[String])\n+    // default to Long\n+    val anything = create(METRICS_PREFIX + \"anything\")\n+    assert(anything.value.isInstanceOf[Long])\n+  }\n+\n+  test(\"create\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert they're all internal\n+    assert(accums.forall(_.isInternal))\n+    assert(shuffleReadAccums.forall(_.isInternal))\n+    assert(shuffleWriteAccums.forall(_.isInternal))\n+    assert(inputAccums.forall(_.isInternal))\n+    assert(outputAccums.forall(_.isInternal))\n+    // assert they all count on failures\n+    assert(accums.forall(_.countFailedValues))\n+    assert(shuffleReadAccums.forall(_.countFailedValues))\n+    assert(shuffleWriteAccums.forall(_.countFailedValues))\n+    assert(inputAccums.forall(_.countFailedValues))\n+    assert(outputAccums.forall(_.countFailedValues))\n+    // assert they all have names\n+    assert(accums.forall(_.name.isDefined))\n+    assert(shuffleReadAccums.forall(_.name.isDefined))\n+    assert(shuffleWriteAccums.forall(_.name.isDefined))\n+    assert(inputAccums.forall(_.name.isDefined))\n+    assert(outputAccums.forall(_.name.isDefined))\n+    // assert `accums` is a strict superset of the others\n+    val accumNames = accums.map(_.name.get).toSet\n+    val shuffleReadAccumNames = shuffleReadAccums.map(_.name.get).toSet\n+    val shuffleWriteAccumNames = shuffleWriteAccums.map(_.name.get).toSet\n+    val inputAccumNames = inputAccums.map(_.name.get).toSet\n+    val outputAccumNames = outputAccums.map(_.name.get).toSet\n+    assert(shuffleReadAccumNames.subsetOf(accumNames))\n+    assert(shuffleWriteAccumNames.subsetOf(accumNames))\n+    assert(inputAccumNames.subsetOf(accumNames))\n+    assert(outputAccumNames.subsetOf(accumNames))\n+  }\n+\n+  test(\"naming\") {\n+    val accums = create()\n+    val shuffleReadAccums = createShuffleReadAccums()\n+    val shuffleWriteAccums = createShuffleWriteAccums()\n+    val inputAccums = createInputAccums()\n+    val outputAccums = createOutputAccums()\n+    // assert that prefixes are properly namespaced\n+    assert(SHUFFLE_READ_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(SHUFFLE_WRITE_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(INPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(OUTPUT_METRICS_PREFIX.startsWith(METRICS_PREFIX))\n+    assert(accums.forall(_.name.get.startsWith(METRICS_PREFIX)))\n+    // assert they all start with the expected prefixes\n+    assert(shuffleReadAccums.forall(_.name.get.startsWith(SHUFFLE_READ_METRICS_PREFIX)))\n+    assert(shuffleWriteAccums.forall(_.name.get.startsWith(SHUFFLE_WRITE_METRICS_PREFIX)))\n+    assert(inputAccums.forall(_.name.get.startsWith(INPUT_METRICS_PREFIX)))\n+    assert(outputAccums.forall(_.name.get.startsWith(OUTPUT_METRICS_PREFIX)))\n+  }\n+\n+  test(\"internal accumulators in TaskContext\") {\n+    val taskContext = TaskContext.empty()\n+    val accumUpdates = taskContext.taskMetrics.accumulatorUpdates()\n+    assert(accumUpdates.size > 0)\n+    assert(accumUpdates.forall(_.internal))\n+    val testAccum = taskContext.taskMetrics.getAccum(TEST_ACCUM)\n+    assert(accumUpdates.exists(_.id == testAccum.id))\n+  }\n+\n+  test(\"internal accumulators in a stage\") {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    sc = new SparkContext(\"local\", \"test\")\n+    sc.addSparkListener(listener)\n+    // Have each task add 1 to the internal accumulator\n+    val rdd = sc.parallelize(1 to 100, numPartitions).mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 1\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+      val stageInfos = listener.getCompletedStageInfos\n+      val taskInfos = listener.getCompletedTaskInfos\n+      assert(stageInfos.size === 1)\n+      assert(taskInfos.size === numPartitions)\n+      // The accumulator values should be merged in the stage\n+      val stageAccum = findTestAccum(stageInfos.head.accumulables.values)\n+      assert(stageAccum.value.get.asInstanceOf[Long] === numPartitions)\n+      // The accumulator should be updated locally on each task\n+      val taskAccumValues = taskInfos.map { taskInfo =>\n+        val taskAccum = findTestAccum(taskInfo.accumulables)\n+        assert(taskAccum.update.isDefined)\n+        assert(taskAccum.update.get.asInstanceOf[Long] === 1L)\n+        taskAccum.value.get.asInstanceOf[Long]\n+      }\n+      // Each task should keep track of the partial value on the way, i.e. 1, 2, ... numPartitions\n+      assert(taskAccumValues.sorted === (1L to numPartitions).toSeq)\n+    }\n+    rdd.count()\n+  }\n+\n+  test(\"internal accumulators in multiple stages\") {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    sc = new SparkContext(\"local\", \"test\")\n+    sc.addSparkListener(listener)\n+    // Each stage creates its own set of internal accumulators so the\n+    // values for the same metric should not be mixed up across stages\n+    val rdd = sc.parallelize(1 to 100, numPartitions)\n+      .map { i => (i, i) }\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 1\n+      iter\n+    }\n+      .reduceByKey { case (x, y) => x + y }\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 10\n+      iter\n+    }\n+      .repartition(numPartitions * 2)\n+      .mapPartitions { iter =>\n+      TaskContext.get().taskMetrics().getAccum(TEST_ACCUM) += 100\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+    // We ran 3 stages, and the accumulator values should be distinct\n+      val stageInfos = listener.getCompletedStageInfos\n+      assert(stageInfos.size === 3)\n+      val (firstStageAccum, secondStageAccum, thirdStageAccum) =\n+        (findTestAccum(stageInfos(0).accumulables.values),\n+          findTestAccum(stageInfos(1).accumulables.values),\n+          findTestAccum(stageInfos(2).accumulables.values))\n+      assert(firstStageAccum.value.get.asInstanceOf[Long] === numPartitions)\n+      assert(secondStageAccum.value.get.asInstanceOf[Long] === numPartitions * 10)\n+      assert(thirdStageAccum.value.get.asInstanceOf[Long] === numPartitions * 2 * 100)\n+    }\n+    rdd.count()\n+  }\n+\n+  test(\"internal accumulators in fully resubmitted stages\") {\n+    testInternalAccumulatorsWithFailedTasks((i: Int) => true) // fail all tasks\n+  }\n+\n+  test(\"internal accumulators in partially resubmitted stages\") {\n+    testInternalAccumulatorsWithFailedTasks((i: Int) => i % 2 == 0) // fail a subset\n+  }\n+\n+  test(\"internal accumulators are registered for cleanups\") {\n+    sc = new SparkContext(\"local\", \"test\") {\n+      private val myCleaner = new SaveAccumContextCleaner(this)\n+      override def cleaner: Option[ContextCleaner] = Some(myCleaner)\n+    }\n+    assert(Accumulators.originals.isEmpty)\n+    sc.parallelize(1 to 100).map { i => (i, i) }.reduceByKey { _ + _ }.count()\n+    val internalAccums = InternalAccumulator.create()\n+    // We ran 2 stages, so we should have 2 sets of internal accumulators, 1 for each stage\n+    assert(Accumulators.originals.size === internalAccums.size * 2)\n+    val accumsRegistered = sc.cleaner match {\n+      case Some(cleaner: SaveAccumContextCleaner) => cleaner.accumsRegisteredForCleanup\n+      case _ => Seq.empty[Long]\n+    }\n+    // Make sure the same set of accumulators is registered for cleanup\n+    assert(accumsRegistered.size === internalAccums.size * 2)\n+    assert(accumsRegistered.toSet === Accumulators.originals.keys.toSet)\n+  }\n+\n+  /**\n+   * Return the accumulable info that matches the specified name.\n+   */\n+  private def findTestAccum(accums: Iterable[AccumulableInfo]): AccumulableInfo = {\n+    accums.find { a => a.name == TEST_ACCUM }.getOrElse {\n+      fail(s\"unable to find internal accumulator called $TEST_ACCUM\")\n+    }\n+  }\n+\n+  /**\n+   * Test whether internal accumulators are merged properly if some tasks fail.\n+   */\n+  private def testInternalAccumulatorsWithFailedTasks(failCondition: (Int => Boolean)): Unit = {\n+    val listener = new SaveInfoListener\n+    val numPartitions = 10\n+    val numFailedPartitions = (0 until numPartitions).count(failCondition)\n+    // This says use 1 core and retry tasks up to 2 times\n+    sc = new SparkContext(\"local[1, 2]\", \"test\")\n+    sc.addSparkListener(listener)\n+    val rdd = sc.parallelize(1 to 100, numPartitions).mapPartitionsWithIndex { case (i, iter) =>\n+      val taskContext = TaskContext.get()\n+      taskContext.taskMetrics().getAccum(TEST_ACCUM) += 1\n+      // Fail the first attempts of a subset of the tasks\n+      if (failCondition(i) && taskContext.attemptNumber() == 0) {\n+        throw new Exception(\"Failing a task intentionally.\")\n+      }\n+      iter\n+    }\n+    // Register asserts in job completion callback to avoid flakiness\n+    listener.registerJobCompletionCallback { _ =>\n+      val stageInfos = listener.getCompletedStageInfos\n+      val taskInfos = listener.getCompletedTaskInfos\n+      assert(stageInfos.size === 1)\n+      assert(taskInfos.size === numPartitions + numFailedPartitions)\n+      val stageAccum = findTestAccum(stageInfos.head.accumulables.values)\n+      // If all partitions failed, then we would resubmit the whole stage again and create a",
    "line": 287
  }],
  "prId": 10835
}]