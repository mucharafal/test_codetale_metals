[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "You might be able to use a cleaner syntax now that we're using Scala 2.12 (e.g. https://github.com/apache/spark/pull/24817/files#diff-953bc000b425424aa2fe471ee12a6e57R409).",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:20:34Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space after `{`",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:21:50Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {\n+      def answer(invocationOnMock: InvocationOnMock): Void = {\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    }).when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `}`",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:22:02Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {\n+      def answer(invocationOnMock: InvocationOnMock): Void = {\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    }).when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i)}"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`===`",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:22:13Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {\n+      def answer(invocationOnMock: InvocationOnMock): Void = {\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    }).when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i)}\n+      stream.close()\n+      intercept[IllegalStateException] {\n+        stream.write(p)\n+      }\n+      assert(writer.getNumBytesWritten() == D_LEN)"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `{`",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:22:25Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {\n+      def answer(invocationOnMock: InvocationOnMock): Void = {\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    }).when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i)}\n+      stream.close()\n+      intercept[IllegalStateException] {\n+        stream.write(p)\n+      }\n+      assert(writer.getNumBytesWritten() == D_LEN)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => D_LEN.toDouble}.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(false))\n+  }\n+\n+  test(\"writing to a channel\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `}`",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:22:42Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {\n+      def answer(invocationOnMock: InvocationOnMock): Void = {\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    }).when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i)}\n+      stream.close()\n+      intercept[IllegalStateException] {\n+        stream.write(p)\n+      }\n+      assert(writer.getNumBytesWritten() == D_LEN)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => D_LEN.toDouble}.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(false))\n+  }\n+\n+  test(\"writing to a channel\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val channel = writer.asInstanceOf[SupportsTransferTo].openTransferrableChannel()\n+      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n+      val intBuffer = byteBuffer.asIntBuffer()\n+      intBuffer.put(data(p))\n+      val numBytes = byteBuffer.remaining()\n+      val outputTempFile = File.createTempFile(\"channelTemp\", \"\", tempDir)\n+      val outputTempFileStream = new FileOutputStream(outputTempFile)\n+      Utils.copyStream(\n+        new ByteBufferInputStream(byteBuffer),\n+        outputTempFileStream,\n+        closeStreams = true)\n+      val tempFileInput = new FileInputStream(outputTempFile)\n+      channel.transferFrom(tempFileInput.getChannel, 0L, numBytes)\n+      // Bytes require * 4\n+      channel.close()\n+      tempFileInput.close()\n+      assert(writer.getNumBytesWritten == D_LEN * 4)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => (D_LEN * 4).toDouble}.toArray"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `{`\r\n\r\nI think you get the gist.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-11T22:22:56Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.mockito.invocation.InvocationOnMock\n+import org.mockito.stubbing.Answer\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.shuffle.api.SupportsTransferTo\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer(new Answer[Void] {\n+      def answer(invocationOnMock: InvocationOnMock): Void = {\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    }).when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i)}\n+      stream.close()\n+      intercept[IllegalStateException] {\n+        stream.write(p)\n+      }\n+      assert(writer.getNumBytesWritten() == D_LEN)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => D_LEN.toDouble}.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(false))\n+  }\n+\n+  test(\"writing to a channel\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val channel = writer.asInstanceOf[SupportsTransferTo].openTransferrableChannel()\n+      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n+      val intBuffer = byteBuffer.asIntBuffer()\n+      intBuffer.put(data(p))\n+      val numBytes = byteBuffer.remaining()\n+      val outputTempFile = File.createTempFile(\"channelTemp\", \"\", tempDir)\n+      val outputTempFileStream = new FileOutputStream(outputTempFile)\n+      Utils.copyStream(\n+        new ByteBufferInputStream(byteBuffer),\n+        outputTempFileStream,\n+        closeStreams = true)\n+      val tempFileInput = new FileInputStream(outputTempFile)\n+      channel.transferFrom(tempFileInput.getChannel, 0L, numBytes)\n+      // Bytes require * 4\n+      channel.close()\n+      tempFileInput.close()\n+      assert(writer.getNumBytesWritten == D_LEN * 4)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => (D_LEN * 4).toDouble}.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(true))\n+  }\n+\n+  test(\"copyStreams with an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach{ p =>"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "just my own personal preference -- I find the mockito style which starts with `doFoo(x).when(y)` way more confusing than `when(y).thenAnswer(x)`.  I feel like I need to read the code backwards.  I see we already have a mix (even within one file, like BypassMergeSortShuffleWriterSuite!), so I guess its your call.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-18T14:35:04Z",
    "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer { invocationOnMock =>\n+      partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+      val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+      if (tmp != null) {\n+        mergedOutputFile.delete\n+        tmp.renameTo(mergedOutputFile)\n+      }\n+      null\n+    }.when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "The `doFoo().when()` syntax is needed when using spies. For normal mocks the `when(...).thenFoo()` syntax is recommended (since it's type-safe).",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T18:00:10Z",
    "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer { invocationOnMock =>\n+      partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+      val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+      if (tmp != null) {\n+        mergedOutputFile.delete\n+        tmp.renameTo(mergedOutputFile)\n+      }\n+      null\n+    }.when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "this method is super confusing to me.  I don't understand the point of `fromByte` -- seems like it would be a lot easier if you just consistently wrote out Ints to the file, and read them back.  Also I think everything becomes a lot simpler if you use DataInputStream",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-18T15:27:44Z",
    "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer { invocationOnMock =>\n+      partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+      val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+      if (tmp != null) {\n+        mergedOutputFile.delete\n+        tmp.renameTo(mergedOutputFile)\n+      }\n+      null\n+    }.when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I don't understand how this is testing something different from \"writing to a channel\".  Both write the test data to a file, get a channel from that file, and pass that FileChannel to `writer.OpenTransferrableChannel().transferFrom()`.\r\n\r\nI deleted it in my suggested cleanup, but should be straightforward to bring it back if its doing something different ...",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-18T15:31:12Z",
    "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer { invocationOnMock =>\n+      partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+      val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+      if (tmp != null) {\n+        mergedOutputFile.delete\n+        tmp.renameTo(mergedOutputFile)\n+      }\n+      null\n+    }.when(blockResolver)\n+      .writeIndexFileAndCommit(anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File]))\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  private def readRecordsFromFile(fromByte: Boolean): Array[Array[Int]] = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Int]](NUM_PARTITIONS)\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val partitionSize = partitionSizesInMergedFile(p).toInt\n+      lazy val inner = new Array[Int](partitionSize)\n+      lazy val innerBytebuffer = ByteBuffer.allocate(partitionSize)\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)\n+        var nonEmpty = true\n+        var count = 0\n+        while (nonEmpty) {\n+          try {\n+            val readBit = lin.read()\n+            if (fromByte) {\n+              innerBytebuffer.put(readBit.toByte)\n+            } else {\n+              inner(count) = readBit\n+            }\n+            count += 1\n+          } catch {\n+            case _: Exception =>\n+              nonEmpty = false\n+          }\n+        }\n+        in.close()\n+      }\n+      if (fromByte) {\n+        result(p) = innerBytebuffer.array().sliding(4, 4).map { b =>\n+          new BigInteger(b).intValue()\n+        }.toArray\n+      } else {\n+        result(p) = inner\n+      }\n+      startOffset += partitionSize\n+    }\n+    result\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i) }\n+      stream.close()\n+      intercept[IllegalStateException] {\n+        stream.write(p)\n+      }\n+      assert(writer.getNumBytesWritten === D_LEN)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => D_LEN.toDouble}.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(false))\n+  }\n+\n+  test(\"writing to a channel\") {\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val channel = writer.openTransferrableChannel()\n+      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n+      val intBuffer = byteBuffer.asIntBuffer()\n+      intBuffer.put(data(p))\n+      val numBytes = byteBuffer.remaining()\n+      val outputTempFile = File.createTempFile(\"channelTemp\", \"\", tempDir)\n+      val outputTempFileStream = new FileOutputStream(outputTempFile)\n+      Utils.copyStream(\n+        new ByteBufferInputStream(byteBuffer),\n+        outputTempFileStream,\n+        closeStreams = true)\n+      val tempFileInput = new FileInputStream(outputTempFile)\n+      channel.transferFrom(tempFileInput.getChannel, 0L, numBytes)\n+      // Bytes require * 4\n+      channel.close()\n+      tempFileInput.close()\n+      assert(writer.getNumBytesWritten === D_LEN * 4)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => (D_LEN * 4).toDouble }.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(true))\n+  }\n+\n+  test(\"copyStreams with an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n+      val intBuffer = byteBuffer.asIntBuffer()\n+      intBuffer.put(data(p))\n+      val in = new ByteArrayInputStream(byteBuffer.array())\n+      Utils.copyStream(in, stream, false, false)\n+      in.close()\n+      stream.close()\n+      assert(writer.getNumBytesWritten === D_LEN * 4)\n+    }\n+    mapOutputWriter.commitAllPartitions()\n+    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => (D_LEN * 4).toDouble}.toArray\n+    assert(partitionSizesInMergedFile === partitionLengths)\n+    assert(mergedOutputFile.length() === partitionLengths.sum)\n+    assert(data === readRecordsFromFile(true))\n+  }\n+\n+  test(\"copyStreamsWithNIO with a channel\") {"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "I think the test would be better if we had a mix of different sized partitions, including some empty ones.\r\n\r\nI have some big suggestions for cleaning up this whole test suite (a couple more comments below), but will leave it all here: https://github.com/squito/spark/commit/da79d7b3d1e19638a8574bbb29647009f2103d42",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-18T15:38:24Z",
    "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "I looked over the test class again and agreed that there were significant adjustments that could be made. I more or less completely revamped the test suite in my latest commit.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-18T22:53:10Z",
    "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{ByteArrayInputStream, File, FileInputStream, FileOutputStream}\n+import java.math.BigInteger\n+import java.nio.ByteBuffer\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.network.util.LimitedInputStream\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.ByteBufferInputStream\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS) private var blockResolver: IndexShuffleBlockResolver = _\n+  @Mock(answer = RETURNS_SMART_NULLS) private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val D_LEN = 10\n+  private val data: Array[Array[Int]] = (0 until NUM_PARTITIONS).map {\n+    p => (1 to D_LEN).map(_ + p).toArray }.toArray"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "these input streams aren't getting closed in a `finally`.\r\n\r\nI still think its easier to just open the file once.  Since you're reading bytes instead of ints now, you could do\r\n\r\n```scala\r\nUtils.tryWithResource(new FileInputStream(mergedOutputFile))) { in =>\r\n  (0 until NUM_PARTITIONS).foreach { p =>\r\n    val buffer = new Array[Byte](data(p).length)\r\n    org.apache.commons.io.IOUtils.readFully(in, buffer)\r\n    result(p) = buffer\r\n  }\r\n}\r\n```",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-19T20:08:24Z",
    "diffHunk": "@@ -142,82 +109,54 @@ class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndA\n       intercept[IllegalStateException] {\n         stream.write(p)\n       }\n-      assert(writer.getNumBytesWritten === D_LEN)\n+      assert(writer.getNumBytesWritten === data(p).length)\n     }\n-    mapOutputWriter.commitAllPartitions()\n-    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => D_LEN.toDouble}.toArray\n-    assert(partitionSizesInMergedFile === partitionLengths)\n-    assert(mergedOutputFile.length() === partitionLengths.sum)\n-    assert(data === readRecordsFromFile(false))\n+    verifyWrittenRecords()\n   }\n \n   test(\"writing to a channel\") {\n     (0 until NUM_PARTITIONS).foreach { p =>\n       val writer = mapOutputWriter.getPartitionWriter(p)\n-      val channel = writer.openTransferrableChannel()\n-      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n-      val intBuffer = byteBuffer.asIntBuffer()\n-      intBuffer.put(data(p))\n-      val numBytes = byteBuffer.remaining()\n       val outputTempFile = File.createTempFile(\"channelTemp\", \"\", tempDir)\n       val outputTempFileStream = new FileOutputStream(outputTempFile)\n-      Utils.copyStream(\n-        new ByteBufferInputStream(byteBuffer),\n-        outputTempFileStream,\n-        closeStreams = true)\n+      outputTempFileStream.write(data(p))\n+      outputTempFileStream.close()\n       val tempFileInput = new FileInputStream(outputTempFile)\n-      channel.transferFrom(tempFileInput.getChannel, 0L, numBytes)\n-      // Bytes require * 4\n-      channel.close()\n-      tempFileInput.close()\n-      assert(writer.getNumBytesWritten === D_LEN * 4)\n+      val channel = writer.openTransferrableChannel()\n+      Utils.tryWithResource(new FileInputStream(outputTempFile)) { tempFileInput =>\n+        Utils.tryWithResource(writer.openTransferrableChannel()) { channel =>\n+          channel.transferFrom(tempFileInput.getChannel, 0L, data(p).length)\n+        }\n+      }\n+      assert(writer.getNumBytesWritten === data(p).length)\n     }\n-    mapOutputWriter.commitAllPartitions()\n-    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => (D_LEN * 4).toDouble }.toArray\n-    assert(partitionSizesInMergedFile === partitionLengths)\n-    assert(mergedOutputFile.length() === partitionLengths.sum)\n-    assert(data === readRecordsFromFile(true))\n+    verifyWrittenRecords()\n   }\n \n-  test(\"copyStreams with an outputstream\") {\n+  private def readRecordsFromFile() = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Byte]](NUM_PARTITIONS)\n     (0 until NUM_PARTITIONS).foreach { p =>\n-      val writer = mapOutputWriter.getPartitionWriter(p)\n-      val stream = writer.openStream()\n-      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n-      val intBuffer = byteBuffer.asIntBuffer()\n-      intBuffer.put(data(p))\n-      val in = new ByteArrayInputStream(byteBuffer.array())\n-      Utils.copyStream(in, stream, false, false)\n-      in.close()\n-      stream.close()\n-      assert(writer.getNumBytesWritten === D_LEN * 4)\n+      val partitionSize = data(p).length\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "I tackled this a bit differently, but a similar spirit of the idea. Please see the updated logic.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-19T21:12:59Z",
    "diffHunk": "@@ -142,82 +109,54 @@ class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndA\n       intercept[IllegalStateException] {\n         stream.write(p)\n       }\n-      assert(writer.getNumBytesWritten === D_LEN)\n+      assert(writer.getNumBytesWritten === data(p).length)\n     }\n-    mapOutputWriter.commitAllPartitions()\n-    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => D_LEN.toDouble}.toArray\n-    assert(partitionSizesInMergedFile === partitionLengths)\n-    assert(mergedOutputFile.length() === partitionLengths.sum)\n-    assert(data === readRecordsFromFile(false))\n+    verifyWrittenRecords()\n   }\n \n   test(\"writing to a channel\") {\n     (0 until NUM_PARTITIONS).foreach { p =>\n       val writer = mapOutputWriter.getPartitionWriter(p)\n-      val channel = writer.openTransferrableChannel()\n-      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n-      val intBuffer = byteBuffer.asIntBuffer()\n-      intBuffer.put(data(p))\n-      val numBytes = byteBuffer.remaining()\n       val outputTempFile = File.createTempFile(\"channelTemp\", \"\", tempDir)\n       val outputTempFileStream = new FileOutputStream(outputTempFile)\n-      Utils.copyStream(\n-        new ByteBufferInputStream(byteBuffer),\n-        outputTempFileStream,\n-        closeStreams = true)\n+      outputTempFileStream.write(data(p))\n+      outputTempFileStream.close()\n       val tempFileInput = new FileInputStream(outputTempFile)\n-      channel.transferFrom(tempFileInput.getChannel, 0L, numBytes)\n-      // Bytes require * 4\n-      channel.close()\n-      tempFileInput.close()\n-      assert(writer.getNumBytesWritten === D_LEN * 4)\n+      val channel = writer.openTransferrableChannel()\n+      Utils.tryWithResource(new FileInputStream(outputTempFile)) { tempFileInput =>\n+        Utils.tryWithResource(writer.openTransferrableChannel()) { channel =>\n+          channel.transferFrom(tempFileInput.getChannel, 0L, data(p).length)\n+        }\n+      }\n+      assert(writer.getNumBytesWritten === data(p).length)\n     }\n-    mapOutputWriter.commitAllPartitions()\n-    val partitionLengths = (0 until NUM_PARTITIONS).map { _ => (D_LEN * 4).toDouble }.toArray\n-    assert(partitionSizesInMergedFile === partitionLengths)\n-    assert(mergedOutputFile.length() === partitionLengths.sum)\n-    assert(data === readRecordsFromFile(true))\n+    verifyWrittenRecords()\n   }\n \n-  test(\"copyStreams with an outputstream\") {\n+  private def readRecordsFromFile() = {\n+    var startOffset = 0L\n+    val result = new Array[Array[Byte]](NUM_PARTITIONS)\n     (0 until NUM_PARTITIONS).foreach { p =>\n-      val writer = mapOutputWriter.getPartitionWriter(p)\n-      val stream = writer.openStream()\n-      val byteBuffer = ByteBuffer.allocate(D_LEN * 4)\n-      val intBuffer = byteBuffer.asIntBuffer()\n-      intBuffer.put(data(p))\n-      val in = new ByteArrayInputStream(byteBuffer.array())\n-      Utils.copyStream(in, stream, false, false)\n-      in.close()\n-      stream.close()\n-      assert(writer.getNumBytesWritten === D_LEN * 4)\n+      val partitionSize = data(p).length\n+      if (partitionSize > 0) {\n+        val in = new FileInputStream(mergedOutputFile)\n+        in.getChannel.position(startOffset)\n+        val lin = new LimitedInputStream(in, partitionSize)"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "move `p =>` to previous line, avoid extra braces.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T17:54:32Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{File, FileInputStream, FileOutputStream}\n+import java.nio.file.Files\n+import java.util.Arrays\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var blockResolver: IndexShuffleBlockResolver = _\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val data: Array[Array[Byte]] = (0 until NUM_PARTITIONS).map {\n+    p => {"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Don't use `null`; if you want the default root, just use `namePrefix = \"test\"`.\r\n\r\nOr don't provide any args, which works just as well unless you require the directory to be named in a certain way (which you shouldn't).",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T17:55:56Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{File, FileInputStream, FileOutputStream}\n+import java.nio.file.Files\n+import java.util.Arrays\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var blockResolver: IndexShuffleBlockResolver = _\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val data: Array[Array[Byte]] = (0 until NUM_PARTITIONS).map {\n+    p => {\n+      if (p == 3) {\n+        Array.emptyByteArray\n+      } else {\n+        (0 to p * 10).map(_ + p).map(_.toByte).toArray\n+      }\n+    }\n+  }.toArray\n+\n+  private val partitionLengths = data.map(_.length)\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`delete()`",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-24T17:58:18Z",
    "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{File, FileInputStream, FileOutputStream}\n+import java.nio.file.Files\n+import java.util.Arrays\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt, anyLong}\n+import org.mockito.Mock\n+import org.mockito.Mockito.{doAnswer, doNothing, when}\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var blockResolver: IndexShuffleBlockResolver = _\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val data: Array[Array[Byte]] = (0 until NUM_PARTITIONS).map {\n+    p => {\n+      if (p == 3) {\n+        Array.emptyByteArray\n+      } else {\n+        (0 to p * 10).map(_ + p).map(_.toByte).toArray\n+      }\n+    }\n+  }.toArray\n+\n+  private val partitionLengths = data.map(_.length)\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir(null, \"test\")\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+\n+    doNothing().when(shuffleWriteMetrics).incWriteTime(anyLong)\n+\n+    doAnswer { invocationOnMock =>\n+      partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+      val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+      if (tmp != null) {\n+        mergedOutputFile.delete"
  }],
  "prId": 25007
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`Files.write(Path, byte[])` is basically a one-line version of these statements.",
    "commit": "7dceec971784049442ec3d4cb71ddaa225e1e21f",
    "createdAt": "2019-07-25T18:36:28Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.shuffle.sort.io\n+\n+import java.io.{File, FileInputStream, FileOutputStream}\n+import java.nio.channels.FileChannel\n+import java.nio.file.Files\n+import java.util.Arrays\n+\n+import org.mockito.Answers.RETURNS_SMART_NULLS\n+import org.mockito.ArgumentMatchers.{any, anyInt}\n+import org.mockito.Mock\n+import org.mockito.Mockito.when\n+import org.mockito.MockitoAnnotations\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.executor.ShuffleWriteMetrics\n+import org.apache.spark.shuffle.IndexShuffleBlockResolver\n+import org.apache.spark.util.Utils\n+\n+class LocalDiskShuffleMapOutputWriterSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var blockResolver: IndexShuffleBlockResolver = _\n+\n+  @Mock(answer = RETURNS_SMART_NULLS)\n+  private var shuffleWriteMetrics: ShuffleWriteMetrics = _\n+\n+  private val NUM_PARTITIONS = 4\n+  private val data: Array[Array[Byte]] = (0 until NUM_PARTITIONS).map { p =>\n+    if (p == 3) {\n+      Array.emptyByteArray\n+    } else {\n+      (0 to p * 10).map(_ + p).map(_.toByte).toArray\n+    }\n+  }.toArray\n+\n+  private val partitionLengths = data.map(_.length)\n+\n+  private var tempFile: File = _\n+  private var mergedOutputFile: File = _\n+  private var tempDir: File = _\n+  private var partitionSizesInMergedFile: Array[Long] = _\n+  private var conf: SparkConf = _\n+  private var mapOutputWriter: LocalDiskShuffleMapOutputWriter = _\n+\n+  override def afterEach(): Unit = {\n+    try {\n+      Utils.deleteRecursively(tempDir)\n+    } finally {\n+      super.afterEach()\n+    }\n+  }\n+\n+  override def beforeEach(): Unit = {\n+    MockitoAnnotations.initMocks(this)\n+    tempDir = Utils.createTempDir()\n+    mergedOutputFile = File.createTempFile(\"mergedoutput\", \"\", tempDir)\n+    tempFile = File.createTempFile(\"tempfile\", \"\", tempDir)\n+    partitionSizesInMergedFile = null\n+    conf = new SparkConf()\n+      .set(\"spark.app.id\", \"example.spark.app\")\n+      .set(\"spark.shuffle.unsafe.file.output.buffer\", \"16k\")\n+    when(blockResolver.getDataFile(anyInt, anyInt)).thenReturn(mergedOutputFile)\n+    when(blockResolver.writeIndexFileAndCommit(\n+      anyInt, anyInt, any(classOf[Array[Long]]), any(classOf[File])))\n+      .thenAnswer { invocationOnMock =>\n+        partitionSizesInMergedFile = invocationOnMock.getArguments()(2).asInstanceOf[Array[Long]]\n+        val tmp: File = invocationOnMock.getArguments()(3).asInstanceOf[File]\n+        if (tmp != null) {\n+          mergedOutputFile.delete()\n+          tmp.renameTo(mergedOutputFile)\n+        }\n+        null\n+      }\n+    mapOutputWriter = new LocalDiskShuffleMapOutputWriter(\n+      0,\n+      0,\n+      NUM_PARTITIONS,\n+      shuffleWriteMetrics,\n+      blockResolver,\n+      conf)\n+  }\n+\n+  test(\"writing to an outputstream\") {\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val stream = writer.openStream()\n+      data(p).foreach { i => stream.write(i) }\n+      stream.close()\n+      intercept[IllegalStateException] {\n+        stream.write(p)\n+      }\n+      assert(writer.getNumBytesWritten === data(p).length)\n+    }\n+    verifyWrittenRecords()\n+  }\n+\n+  test(\"writing to a channel\") {\n+    (0 until NUM_PARTITIONS).foreach { p =>\n+      val writer = mapOutputWriter.getPartitionWriter(p)\n+      val outputTempFile = File.createTempFile(\"channelTemp\", \"\", tempDir)\n+      val outputTempFileStream = new FileOutputStream(outputTempFile)"
  }],
  "prId": 25007
}]