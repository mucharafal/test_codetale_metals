[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "`reset` is usually considered an anti-pattern in Mockito, but I guess it's okay here because although it forgets interactions _and_ stubbing you haven't stubbed any methods on `mm`.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T19:54:48Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    // Acquire up to the max, not granted\n+    assert(mm.acquireStorageMemory(dummyBlock, 1000L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1000L)\n+    assert(mm.storageMemoryUsed === 110L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 890L, dummyBlocks) === 890L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 890L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    mm.releaseStorageMemory(800L)\n+    assert(mm.storageMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 201L)\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1L)\n+    // Release beyond what was acquired\n+    mm.releaseStorageMemory(100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  test(\"execution and storage isolation\") {\n+    val maxExecutionMem = 200L\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"ain't nobody love like you do\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(maxExecutionMem, maxStorageMem)\n+    // Only execution memory should increase\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 100L)\n+    assert(mm.acquireExecutionMemory(1000L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only storage memory should increase\n+    assert(mm.acquireStorageMemory(dummyBlock, 50L, dummyBlocks) === 50L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 50L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only execution memory should be released\n+    mm.releaseExecutionMemory(133L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 67L)\n+    // Only storage memory should be released\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 67L)\n+  }\n+\n+  test(\"unroll memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"lonely water\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    assert(mm.storageMemoryUsed === 100L)\n+    mm.releaseUnrollMemory(40L)\n+    assert(mm.storageMemoryUsed === 60L)\n+    when(ms.currentUnrollMemory).thenReturn(60L)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 500L, dummyBlocks) === 500L)\n+    // `spark.storage.unrollFraction` is 0.4, so the max unroll space is 400 bytes.\n+    // Since we already occupy 60 bytes, we will try to ensure only 400 - 60 = 340 bytes.\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 340L)\n+    assert(mm.storageMemoryUsed === 560L)\n+    when(ms.currentUnrollMemory).thenReturn(560L)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 800L, dummyBlocks) === 0L)\n+    assert(mm.storageMemoryUsed === 560L)\n+    // We already have 560 bytes > the max unroll space of 400 bytes, so no bytes are freed\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 0L)\n+    // Release beyond what was acquired\n+    mm.releaseUnrollMemory(maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  /**\n+   * Make a [[StaticMemoryManager]] and a [[MemoryStore]] with limited class dependencies.\n+   */\n+  private def makeThings(\n+      maxExecutionMem: Long,\n+      maxStorageMem: Long): (StaticMemoryManager, MemoryStore) = {\n+    val mm = new StaticMemoryManager(conf, maxExecutionMem, maxStorageMem)\n+    val ms = mock(classOf[MemoryStore])\n+    mm.setMemoryStore(ms)\n+    (mm, ms)\n+  }\n+\n+  /**\n+   * Assert that [[MemoryStore.ensureFreeSpace]] is called with the given parameters.\n+   */\n+  private def assertEnsureFreeSpaceCalled(\n+      ms: MemoryStore,\n+      blockId: BlockId,\n+      numBytes: Long): Unit = {\n+    verify(ms).ensureFreeSpace(meq(blockId), meq(numBytes: java.lang.Long), any())\n+    reset(ms)"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "yeah, it actually calls `ensureFreeSpace(1)` 3 times in total, but I need a way to assert that it's called exactly once after each acquire. I couldn't find another way to do this.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-09T00:51:58Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    // Acquire up to the max, not granted\n+    assert(mm.acquireStorageMemory(dummyBlock, 1000L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1000L)\n+    assert(mm.storageMemoryUsed === 110L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 890L, dummyBlocks) === 890L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 890L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    mm.releaseStorageMemory(800L)\n+    assert(mm.storageMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 201L)\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1L)\n+    // Release beyond what was acquired\n+    mm.releaseStorageMemory(100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  test(\"execution and storage isolation\") {\n+    val maxExecutionMem = 200L\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"ain't nobody love like you do\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(maxExecutionMem, maxStorageMem)\n+    // Only execution memory should increase\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 100L)\n+    assert(mm.acquireExecutionMemory(1000L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only storage memory should increase\n+    assert(mm.acquireStorageMemory(dummyBlock, 50L, dummyBlocks) === 50L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 50L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only execution memory should be released\n+    mm.releaseExecutionMemory(133L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 67L)\n+    // Only storage memory should be released\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 67L)\n+  }\n+\n+  test(\"unroll memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"lonely water\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    assert(mm.storageMemoryUsed === 100L)\n+    mm.releaseUnrollMemory(40L)\n+    assert(mm.storageMemoryUsed === 60L)\n+    when(ms.currentUnrollMemory).thenReturn(60L)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 500L, dummyBlocks) === 500L)\n+    // `spark.storage.unrollFraction` is 0.4, so the max unroll space is 400 bytes.\n+    // Since we already occupy 60 bytes, we will try to ensure only 400 - 60 = 340 bytes.\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 340L)\n+    assert(mm.storageMemoryUsed === 560L)\n+    when(ms.currentUnrollMemory).thenReturn(560L)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 800L, dummyBlocks) === 0L)\n+    assert(mm.storageMemoryUsed === 560L)\n+    // We already have 560 bytes > the max unroll space of 400 bytes, so no bytes are freed\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 0L)\n+    // Release beyond what was acquired\n+    mm.releaseUnrollMemory(maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  /**\n+   * Make a [[StaticMemoryManager]] and a [[MemoryStore]] with limited class dependencies.\n+   */\n+  private def makeThings(\n+      maxExecutionMem: Long,\n+      maxStorageMem: Long): (StaticMemoryManager, MemoryStore) = {\n+    val mm = new StaticMemoryManager(conf, maxExecutionMem, maxStorageMem)\n+    val ms = mock(classOf[MemoryStore])\n+    mm.setMemoryStore(ms)\n+    (mm, ms)\n+  }\n+\n+  /**\n+   * Assert that [[MemoryStore.ensureFreeSpace]] is called with the given parameters.\n+   */\n+  private def assertEnsureFreeSpaceCalled(\n+      ms: MemoryStore,\n+      blockId: BlockId,\n+      numBytes: Long): Unit = {\n+    verify(ms).ensureFreeSpace(meq(blockId), meq(numBytes: java.lang.Long), any())\n+    reset(ms)"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Do you think that releasing beyond what was acquired should throw an exception, since this may indicate an accounting error?\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T19:59:52Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "it logs a warning\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-09T00:51:14Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Could use \n\n```\nassert(mm.executionMemoryUsed === maxExecutionMem)\n```\n\nto make this marginally easier to read.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:06:29Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Could you rename this to `evictedBlocks`, since that's what it is?\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:09:21Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Also, I noticed that there's only one assert involving `dummyBlocks`. In order to test the case where it's non-empty, I guess we'd have to more realistically stub the MemoryStore.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:12:58Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "However, since you call reset() on the MemoryStore between test cases within this method I suppose that you could stub the ensureFreeSpace() method on MemoryStore to have it return some dummy evicted blocks, letting you assert that the plumbing of `dummyBlocks` is correct. This might be overkill, though.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:14:11Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "meh, let's not do that\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-09T00:50:02Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Could assert that 110 of storage memory is used here, prior to trying to acquire more in next call.\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:11:59Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "For completeness, want to also call the variant of `releaseStorageMemory` which takes a specific amount of memory to release?\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:16:12Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    // Acquire up to the max, not granted\n+    assert(mm.acquireStorageMemory(dummyBlock, 1000L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1000L)\n+    assert(mm.storageMemoryUsed === 110L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 890L, dummyBlocks) === 890L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 890L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    mm.releaseStorageMemory(800L)\n+    assert(mm.storageMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 201L)\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1L)\n+    // Release beyond what was acquired\n+    mm.releaseStorageMemory(100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  test(\"execution and storage isolation\") {\n+    val maxExecutionMem = 200L\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"ain't nobody love like you do\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(maxExecutionMem, maxStorageMem)\n+    // Only execution memory should increase\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 100L)\n+    assert(mm.acquireExecutionMemory(1000L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only storage memory should increase\n+    assert(mm.acquireStorageMemory(dummyBlock, 50L, dummyBlocks) === 50L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 50L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only execution memory should be released\n+    mm.releaseExecutionMemory(133L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 67L)\n+    // Only storage memory should be released\n+    mm.releaseStorageMemory()"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "this is tested in the previous test\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-09T00:48:55Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    // Acquire up to the max, not granted\n+    assert(mm.acquireStorageMemory(dummyBlock, 1000L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1000L)\n+    assert(mm.storageMemoryUsed === 110L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 890L, dummyBlocks) === 890L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 890L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    mm.releaseStorageMemory(800L)\n+    assert(mm.storageMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 201L)\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1L)\n+    // Release beyond what was acquired\n+    mm.releaseStorageMemory(100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  test(\"execution and storage isolation\") {\n+    val maxExecutionMem = 200L\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"ain't nobody love like you do\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(maxExecutionMem, maxStorageMem)\n+    // Only execution memory should increase\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 100L)\n+    assert(mm.acquireExecutionMemory(1000L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only storage memory should increase\n+    assert(mm.acquireStorageMemory(dummyBlock, 50L, dummyBlocks) === 50L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 50L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only execution memory should be released\n+    mm.releaseExecutionMemory(133L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 67L)\n+    // Only storage memory should be released\n+    mm.releaseStorageMemory()"
  }],
  "prId": 9000
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Is it possible to add an assertion for this on the following line?\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-08T20:19:50Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    // Acquire up to the max, not granted\n+    assert(mm.acquireStorageMemory(dummyBlock, 1000L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1000L)\n+    assert(mm.storageMemoryUsed === 110L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 890L, dummyBlocks) === 890L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 890L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    mm.releaseStorageMemory(800L)\n+    assert(mm.storageMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 201L)\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1L)\n+    // Release beyond what was acquired\n+    mm.releaseStorageMemory(100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  test(\"execution and storage isolation\") {\n+    val maxExecutionMem = 200L\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"ain't nobody love like you do\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(maxExecutionMem, maxStorageMem)\n+    // Only execution memory should increase\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 100L)\n+    assert(mm.acquireExecutionMemory(1000L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only storage memory should increase\n+    assert(mm.acquireStorageMemory(dummyBlock, 50L, dummyBlocks) === 50L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 50L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only execution memory should be released\n+    mm.releaseExecutionMemory(133L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 67L)\n+    // Only storage memory should be released\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 67L)\n+  }\n+\n+  test(\"unroll memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"lonely water\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    assert(mm.storageMemoryUsed === 100L)\n+    mm.releaseUnrollMemory(40L)\n+    assert(mm.storageMemoryUsed === 60L)\n+    when(ms.currentUnrollMemory).thenReturn(60L)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 500L, dummyBlocks) === 500L)\n+    // `spark.storage.unrollFraction` is 0.4, so the max unroll space is 400 bytes."
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "the max unroll space is private so we don't have access to it. I think it's OK to leave it out since the `340L` assert implies that it was `400L`\n",
    "commit": "fc7f9f519852c2b3ef3eebcbc8e3f0ba63fcb3dc",
    "createdAt": "2015-10-09T00:47:55Z",
    "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.mockito.Mockito.{mock, reset, verify, when}\n+import org.mockito.Matchers.{any, eq => meq}\n+\n+import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, TestBlockId}\n+\n+\n+class StaticMemoryManagerSuite extends SparkFunSuite {\n+  private val conf = new SparkConf().set(\"spark.storage.unrollFraction\", \"0.4\")\n+\n+  test(\"basic execution memory\") {\n+    val maxExecutionMem = 1000L\n+    val (mm, _) = makeThings(maxExecutionMem, Long.MaxValue)\n+    assert(mm.executionMemoryUsed === 0L)\n+    assert(mm.acquireExecutionMemory(10L) === 10L)\n+    assert(mm.executionMemoryUsed === 10L)\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    // Acquire up to the max\n+    assert(mm.acquireExecutionMemory(1000L) === 890L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    assert(mm.acquireExecutionMemory(1L) === 0L)\n+    assert(mm.executionMemoryUsed === 1000L)\n+    mm.releaseExecutionMemory(800L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireExecutionMemory(1L) === 1L)\n+    assert(mm.executionMemoryUsed === 201L)\n+    // Release beyond what was acquired\n+    mm.releaseExecutionMemory(maxExecutionMem)\n+    assert(mm.executionMemoryUsed === 0L)\n+  }\n+\n+  test(\"basic storage memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"you can see the world you brought to live\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 10L, dummyBlocks) === 10L)\n+    // `ensureFreeSpace` should be called with the number of bytes requested\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 10L)\n+    assert(mm.storageMemoryUsed === 10L)\n+    assert(dummyBlocks.isEmpty)\n+    assert(mm.acquireStorageMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    // Acquire up to the max, not granted\n+    assert(mm.acquireStorageMemory(dummyBlock, 1000L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1000L)\n+    assert(mm.storageMemoryUsed === 110L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 890L, dummyBlocks) === 890L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 890L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 0L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1000L)\n+    mm.releaseStorageMemory(800L)\n+    assert(mm.storageMemoryUsed === 200L)\n+    // Acquire after release\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 201L)\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.acquireStorageMemory(dummyBlock, 1L, dummyBlocks) === 1L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 1L)\n+    assert(mm.storageMemoryUsed === 1L)\n+    // Release beyond what was acquired\n+    mm.releaseStorageMemory(100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+  }\n+\n+  test(\"execution and storage isolation\") {\n+    val maxExecutionMem = 200L\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"ain't nobody love like you do\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(maxExecutionMem, maxStorageMem)\n+    // Only execution memory should increase\n+    assert(mm.acquireExecutionMemory(100L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 100L)\n+    assert(mm.acquireExecutionMemory(1000L) === 100L)\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only storage memory should increase\n+    assert(mm.acquireStorageMemory(dummyBlock, 50L, dummyBlocks) === 50L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 50L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 200L)\n+    // Only execution memory should be released\n+    mm.releaseExecutionMemory(133L)\n+    assert(mm.storageMemoryUsed === 50L)\n+    assert(mm.executionMemoryUsed === 67L)\n+    // Only storage memory should be released\n+    mm.releaseStorageMemory()\n+    assert(mm.storageMemoryUsed === 0L)\n+    assert(mm.executionMemoryUsed === 67L)\n+  }\n+\n+  test(\"unroll memory\") {\n+    val maxStorageMem = 1000L\n+    val dummyBlock = TestBlockId(\"lonely water\")\n+    val dummyBlocks = new ArrayBuffer[(BlockId, BlockStatus)]\n+    val (mm, ms) = makeThings(Long.MaxValue, maxStorageMem)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 100L, dummyBlocks) === 100L)\n+    assertEnsureFreeSpaceCalled(ms, dummyBlock, 100L)\n+    assert(mm.storageMemoryUsed === 100L)\n+    mm.releaseUnrollMemory(40L)\n+    assert(mm.storageMemoryUsed === 60L)\n+    when(ms.currentUnrollMemory).thenReturn(60L)\n+    assert(mm.acquireUnrollMemory(dummyBlock, 500L, dummyBlocks) === 500L)\n+    // `spark.storage.unrollFraction` is 0.4, so the max unroll space is 400 bytes."
  }],
  "prId": 9000
}]