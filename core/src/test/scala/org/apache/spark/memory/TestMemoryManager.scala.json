[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "nit: double ,",
    "commit": "cd8b6f321747be2c4c598ec9ef56a78b0ddc68f5",
    "createdAt": "2019-10-01T20:18:19Z",
    "diffHunk": "@@ -17,60 +17,110 @@\n \n package org.apache.spark.memory\n \n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n import org.apache.spark.SparkConf\n import org.apache.spark.storage.BlockId\n \n class TestMemoryManager(conf: SparkConf)\n   extends MemoryManager(conf, numCores = 1, Long.MaxValue, Long.MaxValue) {\n \n+  @GuardedBy(\"this\")\n+  private var consequentOOM = 0\n+  @GuardedBy(\"this\")\n+  private var available = Long.MaxValue\n+  @GuardedBy(\"this\")\n+  private val memoryForTask = mutable.HashMap[Long, Long]().withDefaultValue(0L)\n+\n   override private[memory] def acquireExecutionMemory(\n       numBytes: Long,\n       taskAttemptId: Long,\n-      memoryMode: MemoryMode): Long = {\n-    if (consequentOOM > 0) {\n-      consequentOOM -= 1\n-      0\n-    } else if (available >= numBytes) {\n-      available -= numBytes\n-      numBytes\n-    } else {\n-      val grant = available\n-      available = 0\n-      grant\n+      memoryMode: MemoryMode): Long = synchronized {\n+    require(numBytes >= 0)\n+    val acquired = {\n+      if (consequentOOM > 0) {\n+        consequentOOM -= 1\n+        0\n+      } else if (available >= numBytes) {\n+        available -= numBytes\n+        numBytes\n+      } else {\n+        val grant = available\n+        available = 0\n+        grant\n+      }\n     }\n+    memoryForTask(taskAttemptId) = memoryForTask.getOrElse(taskAttemptId, 0L) + acquired\n+    acquired\n+  }\n+\n+  override private[memory] def releaseExecutionMemory(\n+      numBytes: Long,\n+      taskAttemptId: Long,\n+      memoryMode: MemoryMode): Unit = synchronized {\n+    require(numBytes >= 0)\n+    available += numBytes\n+    val existingMemoryUsage = memoryForTask.getOrElse(taskAttemptId, 0L)\n+    val newMemoryUsage = existingMemoryUsage - numBytes\n+    require(\n+      newMemoryUsage >= 0,\n+      s\"Attempting to free $numBytes of memory for task attempt $taskAttemptId, but it only \" +\n+      s\"allocated $existingMemoryUsage bytes of memory\")\n+    memoryForTask(taskAttemptId) = newMemoryUsage\n+  }\n+\n+  override private[memory] def releaseAllExecutionMemoryForTask(taskAttemptId: Long): Long = {\n+    memoryForTask.remove(taskAttemptId).getOrElse(0L)\n+  }\n+\n+  override private[memory] def getExecutionMemoryUsageForTask(taskAttemptId: Long): Long = {\n+    memoryForTask.getOrElse(taskAttemptId, 0L)\n   }\n+\n   override def acquireStorageMemory(\n       blockId: BlockId,\n       numBytes: Long,\n-      memoryMode: MemoryMode): Boolean = true\n+      memoryMode: MemoryMode): Boolean = {\n+    require(numBytes >= 0)\n+    true\n+  }\n+\n   override def acquireUnrollMemory(\n       blockId: BlockId,\n       numBytes: Long,\n-     memoryMode: MemoryMode): Boolean = true\n-  override def releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode): Unit = {}\n-  override private[memory] def releaseExecutionMemory(\n-      numBytes: Long,\n-      taskAttemptId: Long,\n-      memoryMode: MemoryMode): Unit = {\n-    available += numBytes\n+      memoryMode: MemoryMode): Boolean = {\n+    require(numBytes >= 0)\n+    true\n   }\n+\n+  override def releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode): Unit = {\n+    require(numBytes >= 0)\n+  }\n+\n   override def maxOnHeapStorageMemory: Long = Long.MaxValue\n \n   override def maxOffHeapStorageMemory: Long = 0L\n \n-  private var consequentOOM = 0\n-  private var available = Long.MaxValue\n-\n+  /**\n+   * Causes the next call to [[acquireExecutionMemory()]] to fail to allocate\n+   * memory (returning `0`), , simulating low-on-memory / out-of-memory conditions."
  }],
  "prId": 25985
}, {
  "comments": [{
    "author": {
      "login": "databricks-david-lewis"
    },
    "body": "Shouldn't this (and `getExecutionMemoryUsageForTask` below) be synchronized?",
    "commit": "cd8b6f321747be2c4c598ec9ef56a78b0ddc68f5",
    "createdAt": "2019-10-15T15:48:41Z",
    "diffHunk": "@@ -17,60 +17,110 @@\n \n package org.apache.spark.memory\n \n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n import org.apache.spark.SparkConf\n import org.apache.spark.storage.BlockId\n \n class TestMemoryManager(conf: SparkConf)\n   extends MemoryManager(conf, numCores = 1, Long.MaxValue, Long.MaxValue) {\n \n+  @GuardedBy(\"this\")\n+  private var consequentOOM = 0\n+  @GuardedBy(\"this\")\n+  private var available = Long.MaxValue\n+  @GuardedBy(\"this\")\n+  private val memoryForTask = mutable.HashMap[Long, Long]().withDefaultValue(0L)\n+\n   override private[memory] def acquireExecutionMemory(\n       numBytes: Long,\n       taskAttemptId: Long,\n-      memoryMode: MemoryMode): Long = {\n-    if (consequentOOM > 0) {\n-      consequentOOM -= 1\n-      0\n-    } else if (available >= numBytes) {\n-      available -= numBytes\n-      numBytes\n-    } else {\n-      val grant = available\n-      available = 0\n-      grant\n+      memoryMode: MemoryMode): Long = synchronized {\n+    require(numBytes >= 0)\n+    val acquired = {\n+      if (consequentOOM > 0) {\n+        consequentOOM -= 1\n+        0\n+      } else if (available >= numBytes) {\n+        available -= numBytes\n+        numBytes\n+      } else {\n+        val grant = available\n+        available = 0\n+        grant\n+      }\n     }\n+    memoryForTask(taskAttemptId) = memoryForTask.getOrElse(taskAttemptId, 0L) + acquired\n+    acquired\n+  }\n+\n+  override private[memory] def releaseExecutionMemory(\n+      numBytes: Long,\n+      taskAttemptId: Long,\n+      memoryMode: MemoryMode): Unit = synchronized {\n+    require(numBytes >= 0)\n+    available += numBytes\n+    val existingMemoryUsage = memoryForTask.getOrElse(taskAttemptId, 0L)\n+    val newMemoryUsage = existingMemoryUsage - numBytes\n+    require(\n+      newMemoryUsage >= 0,\n+      s\"Attempting to free $numBytes of memory for task attempt $taskAttemptId, but it only \" +\n+      s\"allocated $existingMemoryUsage bytes of memory\")\n+    memoryForTask(taskAttemptId) = newMemoryUsage\n+  }\n+\n+  override private[memory] def releaseAllExecutionMemoryForTask(taskAttemptId: Long): Long = {",
    "line": 69
  }, {
    "author": {
      "login": "joshrosen-stripe"
    },
    "body": "Yes, good catch 👍 ",
    "commit": "cd8b6f321747be2c4c598ec9ef56a78b0ddc68f5",
    "createdAt": "2019-10-15T16:09:07Z",
    "diffHunk": "@@ -17,60 +17,110 @@\n \n package org.apache.spark.memory\n \n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n import org.apache.spark.SparkConf\n import org.apache.spark.storage.BlockId\n \n class TestMemoryManager(conf: SparkConf)\n   extends MemoryManager(conf, numCores = 1, Long.MaxValue, Long.MaxValue) {\n \n+  @GuardedBy(\"this\")\n+  private var consequentOOM = 0\n+  @GuardedBy(\"this\")\n+  private var available = Long.MaxValue\n+  @GuardedBy(\"this\")\n+  private val memoryForTask = mutable.HashMap[Long, Long]().withDefaultValue(0L)\n+\n   override private[memory] def acquireExecutionMemory(\n       numBytes: Long,\n       taskAttemptId: Long,\n-      memoryMode: MemoryMode): Long = {\n-    if (consequentOOM > 0) {\n-      consequentOOM -= 1\n-      0\n-    } else if (available >= numBytes) {\n-      available -= numBytes\n-      numBytes\n-    } else {\n-      val grant = available\n-      available = 0\n-      grant\n+      memoryMode: MemoryMode): Long = synchronized {\n+    require(numBytes >= 0)\n+    val acquired = {\n+      if (consequentOOM > 0) {\n+        consequentOOM -= 1\n+        0\n+      } else if (available >= numBytes) {\n+        available -= numBytes\n+        numBytes\n+      } else {\n+        val grant = available\n+        available = 0\n+        grant\n+      }\n     }\n+    memoryForTask(taskAttemptId) = memoryForTask.getOrElse(taskAttemptId, 0L) + acquired\n+    acquired\n+  }\n+\n+  override private[memory] def releaseExecutionMemory(\n+      numBytes: Long,\n+      taskAttemptId: Long,\n+      memoryMode: MemoryMode): Unit = synchronized {\n+    require(numBytes >= 0)\n+    available += numBytes\n+    val existingMemoryUsage = memoryForTask.getOrElse(taskAttemptId, 0L)\n+    val newMemoryUsage = existingMemoryUsage - numBytes\n+    require(\n+      newMemoryUsage >= 0,\n+      s\"Attempting to free $numBytes of memory for task attempt $taskAttemptId, but it only \" +\n+      s\"allocated $existingMemoryUsage bytes of memory\")\n+    memoryForTask(taskAttemptId) = newMemoryUsage\n+  }\n+\n+  override private[memory] def releaseAllExecutionMemoryForTask(taskAttemptId: Long): Long = {",
    "line": 69
  }, {
    "author": {
      "login": "databricks-david-lewis"
    },
    "body": ":) Anything you touch will forever be forwarded to serverless in the batch merge!",
    "commit": "cd8b6f321747be2c4c598ec9ef56a78b0ddc68f5",
    "createdAt": "2019-10-15T16:15:18Z",
    "diffHunk": "@@ -17,60 +17,110 @@\n \n package org.apache.spark.memory\n \n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n import org.apache.spark.SparkConf\n import org.apache.spark.storage.BlockId\n \n class TestMemoryManager(conf: SparkConf)\n   extends MemoryManager(conf, numCores = 1, Long.MaxValue, Long.MaxValue) {\n \n+  @GuardedBy(\"this\")\n+  private var consequentOOM = 0\n+  @GuardedBy(\"this\")\n+  private var available = Long.MaxValue\n+  @GuardedBy(\"this\")\n+  private val memoryForTask = mutable.HashMap[Long, Long]().withDefaultValue(0L)\n+\n   override private[memory] def acquireExecutionMemory(\n       numBytes: Long,\n       taskAttemptId: Long,\n-      memoryMode: MemoryMode): Long = {\n-    if (consequentOOM > 0) {\n-      consequentOOM -= 1\n-      0\n-    } else if (available >= numBytes) {\n-      available -= numBytes\n-      numBytes\n-    } else {\n-      val grant = available\n-      available = 0\n-      grant\n+      memoryMode: MemoryMode): Long = synchronized {\n+    require(numBytes >= 0)\n+    val acquired = {\n+      if (consequentOOM > 0) {\n+        consequentOOM -= 1\n+        0\n+      } else if (available >= numBytes) {\n+        available -= numBytes\n+        numBytes\n+      } else {\n+        val grant = available\n+        available = 0\n+        grant\n+      }\n     }\n+    memoryForTask(taskAttemptId) = memoryForTask.getOrElse(taskAttemptId, 0L) + acquired\n+    acquired\n+  }\n+\n+  override private[memory] def releaseExecutionMemory(\n+      numBytes: Long,\n+      taskAttemptId: Long,\n+      memoryMode: MemoryMode): Unit = synchronized {\n+    require(numBytes >= 0)\n+    available += numBytes\n+    val existingMemoryUsage = memoryForTask.getOrElse(taskAttemptId, 0L)\n+    val newMemoryUsage = existingMemoryUsage - numBytes\n+    require(\n+      newMemoryUsage >= 0,\n+      s\"Attempting to free $numBytes of memory for task attempt $taskAttemptId, but it only \" +\n+      s\"allocated $existingMemoryUsage bytes of memory\")\n+    memoryForTask(taskAttemptId) = newMemoryUsage\n+  }\n+\n+  override private[memory] def releaseAllExecutionMemoryForTask(taskAttemptId: Long): Long = {",
    "line": 69
  }],
  "prId": 25985
}]