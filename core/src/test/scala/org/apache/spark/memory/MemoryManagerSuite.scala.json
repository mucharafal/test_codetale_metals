[{
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "should this start at the `DEFAULT`?\n",
    "commit": "7e9e191c76992813d9a0bdbb1de590776c4875a1",
    "createdAt": "2015-12-08T20:57:54Z",
    "diffHunk": "@@ -36,105 +37,98 @@ import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, StorageLevel\n /**\n  * Helper trait for sharing code among [[MemoryManager]] tests.\n  */\n-private[memory] trait MemoryManagerSuite extends SparkFunSuite {\n+private[memory] trait MemoryManagerSuite extends SparkFunSuite with BeforeAndAfterEach {\n \n-  import MemoryManagerSuite.DEFAULT_ENSURE_FREE_SPACE_CALLED\n+  protected val evictedBlocks = new mutable.ArrayBuffer[(BlockId, BlockStatus)]\n+\n+  import MemoryManagerSuite.DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED\n \n   // Note: Mockito's verify mechanism does not provide a way to reset method call counts\n   // without also resetting stubbed methods. Since our test code relies on the latter,\n-  // we need to use our own variable to track invocations of `ensureFreeSpace`.\n+  // we need to use our own variable to track invocations of `evictBlocksToFreeSpace`.\n \n   /**\n-   * The amount of free space requested in the last call to [[MemoryStore.ensureFreeSpace]]\n+   * The amount of space requested in the last call to [[MemoryStore.evictBlocksToFreeSpace]].\n    *\n-   * This set whenever [[MemoryStore.ensureFreeSpace]] is called, and cleared when the test\n-   * code makes explicit assertions on this variable through [[assertEnsureFreeSpaceCalled]].\n+   * This set whenever [[MemoryStore.evictBlocksToFreeSpace]] is called, and cleared when the test\n+   * code makes explicit assertions on this variable through\n+   * [[assertEvictBlocksToFreeSpaceCalled]].\n    */\n-  private val ensureFreeSpaceCalled = new AtomicLong(DEFAULT_ENSURE_FREE_SPACE_CALLED)\n+  private val evictBlocksToFreeSpaceCalled = new AtomicLong(0)",
    "line": 40
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "I see, you do this in `beforeEach` anyway\n",
    "commit": "7e9e191c76992813d9a0bdbb1de590776c4875a1",
    "createdAt": "2015-12-08T20:58:15Z",
    "diffHunk": "@@ -36,105 +37,98 @@ import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, StorageLevel\n /**\n  * Helper trait for sharing code among [[MemoryManager]] tests.\n  */\n-private[memory] trait MemoryManagerSuite extends SparkFunSuite {\n+private[memory] trait MemoryManagerSuite extends SparkFunSuite with BeforeAndAfterEach {\n \n-  import MemoryManagerSuite.DEFAULT_ENSURE_FREE_SPACE_CALLED\n+  protected val evictedBlocks = new mutable.ArrayBuffer[(BlockId, BlockStatus)]\n+\n+  import MemoryManagerSuite.DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED\n \n   // Note: Mockito's verify mechanism does not provide a way to reset method call counts\n   // without also resetting stubbed methods. Since our test code relies on the latter,\n-  // we need to use our own variable to track invocations of `ensureFreeSpace`.\n+  // we need to use our own variable to track invocations of `evictBlocksToFreeSpace`.\n \n   /**\n-   * The amount of free space requested in the last call to [[MemoryStore.ensureFreeSpace]]\n+   * The amount of space requested in the last call to [[MemoryStore.evictBlocksToFreeSpace]].\n    *\n-   * This set whenever [[MemoryStore.ensureFreeSpace]] is called, and cleared when the test\n-   * code makes explicit assertions on this variable through [[assertEnsureFreeSpaceCalled]].\n+   * This set whenever [[MemoryStore.evictBlocksToFreeSpace]] is called, and cleared when the test\n+   * code makes explicit assertions on this variable through\n+   * [[assertEvictBlocksToFreeSpaceCalled]].\n    */\n-  private val ensureFreeSpaceCalled = new AtomicLong(DEFAULT_ENSURE_FREE_SPACE_CALLED)\n+  private val evictBlocksToFreeSpaceCalled = new AtomicLong(0)",
    "line": 40
  }],
  "prId": 10170
}, {
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "as mentioned offline, this will likely add the same block to `evictedBlocks` twice. We should probably just add it to the one in the invocation args\n",
    "commit": "7e9e191c76992813d9a0bdbb1de590776c4875a1",
    "createdAt": "2015-12-08T20:59:58Z",
    "diffHunk": "@@ -36,105 +37,98 @@ import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, StorageLevel\n /**\n  * Helper trait for sharing code among [[MemoryManager]] tests.\n  */\n-private[memory] trait MemoryManagerSuite extends SparkFunSuite {\n+private[memory] trait MemoryManagerSuite extends SparkFunSuite with BeforeAndAfterEach {\n \n-  import MemoryManagerSuite.DEFAULT_ENSURE_FREE_SPACE_CALLED\n+  protected val evictedBlocks = new mutable.ArrayBuffer[(BlockId, BlockStatus)]\n+\n+  import MemoryManagerSuite.DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED\n \n   // Note: Mockito's verify mechanism does not provide a way to reset method call counts\n   // without also resetting stubbed methods. Since our test code relies on the latter,\n-  // we need to use our own variable to track invocations of `ensureFreeSpace`.\n+  // we need to use our own variable to track invocations of `evictBlocksToFreeSpace`.\n \n   /**\n-   * The amount of free space requested in the last call to [[MemoryStore.ensureFreeSpace]]\n+   * The amount of space requested in the last call to [[MemoryStore.evictBlocksToFreeSpace]].\n    *\n-   * This set whenever [[MemoryStore.ensureFreeSpace]] is called, and cleared when the test\n-   * code makes explicit assertions on this variable through [[assertEnsureFreeSpaceCalled]].\n+   * This set whenever [[MemoryStore.evictBlocksToFreeSpace]] is called, and cleared when the test\n+   * code makes explicit assertions on this variable through\n+   * [[assertEvictBlocksToFreeSpaceCalled]].\n    */\n-  private val ensureFreeSpaceCalled = new AtomicLong(DEFAULT_ENSURE_FREE_SPACE_CALLED)\n+  private val evictBlocksToFreeSpaceCalled = new AtomicLong(0)\n+\n+  override def beforeEach(): Unit = {\n+    super.beforeEach()\n+    evictedBlocks.clear()\n+    evictBlocksToFreeSpaceCalled.set(DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED)\n+  }\n \n   /**\n-   * Make a mocked [[MemoryStore]] whose [[MemoryStore.ensureFreeSpace]] method is stubbed.\n+   * Make a mocked [[MemoryStore]] whose [[MemoryStore.evictBlocksToFreeSpace]] method is stubbed.\n    *\n-   * This allows our test code to release storage memory when [[MemoryStore.ensureFreeSpace]]\n-   * is called without relying on [[org.apache.spark.storage.BlockManager]] and all of its\n-   * dependencies.\n+   * This allows our test code to release storage memory when these methods are called\n+   * without relying on [[org.apache.spark.storage.BlockManager]] and all of its dependencies.\n    */\n   protected def makeMemoryStore(mm: MemoryManager): MemoryStore = {\n-    val ms = mock(classOf[MemoryStore])\n-    when(ms.ensureFreeSpace(anyLong(), any())).thenAnswer(ensureFreeSpaceAnswer(mm, 0))\n-    when(ms.ensureFreeSpace(any(), anyLong(), any())).thenAnswer(ensureFreeSpaceAnswer(mm, 1))\n+    val ms = mock(classOf[MemoryStore], RETURNS_SMART_NULLS)\n+    when(ms.evictBlocksToFreeSpace(any(), anyLong(), any()))\n+      .thenAnswer(evictBlocksToFreeSpaceAnswer(mm))\n     mm.setMemoryStore(ms)\n     ms\n   }\n \n   /**\n-   * Make an [[Answer]] that stubs [[MemoryStore.ensureFreeSpace]] with the right arguments.\n-   */\n-  private def ensureFreeSpaceAnswer(mm: MemoryManager, numBytesPos: Int): Answer[Boolean] = {\n+    * Simulate the part of [[MemoryStore.evictBlocksToFreeSpace]] that releases storage memory.\n+    *\n+    * This is a significant simplification of the real method, which actually drops existing\n+    * blocks based on the size of each block. Instead, here we simply release as many bytes\n+    * as needed to ensure the requested amount of free space. This allows us to set up the\n+    * test without relying on the [[org.apache.spark.storage.BlockManager]], which brings in\n+    * many other dependencies.\n+    *\n+    * Every call to this method will set a global variable, [[evictBlocksToFreeSpaceCalled]], that\n+    * records the number of bytes this is called with. This variable is expected to be cleared\n+    * by the test code later through [[assertEvictBlocksToFreeSpaceCalled]].\n+    */\n+  private def evictBlocksToFreeSpaceAnswer(mm: MemoryManager): Answer[Boolean] = {\n     new Answer[Boolean] {\n       override def answer(invocation: InvocationOnMock): Boolean = {\n         val args = invocation.getArguments\n-        require(args.size > numBytesPos, s\"bad test: expected >$numBytesPos arguments \" +\n-          s\"in ensureFreeSpace, found ${args.size}\")\n-        require(args(numBytesPos).isInstanceOf[Long], s\"bad test: expected ensureFreeSpace \" +\n-          s\"argument at index $numBytesPos to be a Long: ${args.mkString(\", \")}\")\n-        val numBytes = args(numBytesPos).asInstanceOf[Long]\n-        val success = mockEnsureFreeSpace(mm, numBytes)\n-        if (success) {\n+        val numBytesToFree = args(1).asInstanceOf[Long]\n+        assert(numBytesToFree > 0)\n+        require(evictBlocksToFreeSpaceCalled.get() === DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED,\n+          \"bad test: evictBlocksToFreeSpace() variable was not reset\")\n+        evictBlocksToFreeSpaceCalled.set(numBytesToFree)\n+        if (numBytesToFree <= mm.storageMemoryUsed) {\n+          // We can evict enough blocks to fulfill the request for space\n+          mm.releaseStorageMemory(numBytesToFree)\n           args.last.asInstanceOf[mutable.Buffer[(BlockId, BlockStatus)]].append(\n-            (null, BlockStatus(StorageLevel.MEMORY_ONLY, numBytes, 0L, 0L)))\n+            (null, BlockStatus(StorageLevel.MEMORY_ONLY, numBytesToFree, 0L, 0L)))\n+          evictedBlocks.append(\n+            (null, BlockStatus(StorageLevel.MEMORY_ONLY, numBytesToFree, 0L, 0L)))"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "If you just add it to the one in the invocation args, then you won't be able to assert that execution memory requests resulted in the eviction of blocks, since the execution request doesn't pass in the `evictedBlocks` from the suite.\n\nA simple fix is to only add if `!(args.last eq evictedBlocks)`.\n",
    "commit": "7e9e191c76992813d9a0bdbb1de590776c4875a1",
    "createdAt": "2015-12-09T00:35:07Z",
    "diffHunk": "@@ -36,105 +37,98 @@ import org.apache.spark.storage.{BlockId, BlockStatus, MemoryStore, StorageLevel\n /**\n  * Helper trait for sharing code among [[MemoryManager]] tests.\n  */\n-private[memory] trait MemoryManagerSuite extends SparkFunSuite {\n+private[memory] trait MemoryManagerSuite extends SparkFunSuite with BeforeAndAfterEach {\n \n-  import MemoryManagerSuite.DEFAULT_ENSURE_FREE_SPACE_CALLED\n+  protected val evictedBlocks = new mutable.ArrayBuffer[(BlockId, BlockStatus)]\n+\n+  import MemoryManagerSuite.DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED\n \n   // Note: Mockito's verify mechanism does not provide a way to reset method call counts\n   // without also resetting stubbed methods. Since our test code relies on the latter,\n-  // we need to use our own variable to track invocations of `ensureFreeSpace`.\n+  // we need to use our own variable to track invocations of `evictBlocksToFreeSpace`.\n \n   /**\n-   * The amount of free space requested in the last call to [[MemoryStore.ensureFreeSpace]]\n+   * The amount of space requested in the last call to [[MemoryStore.evictBlocksToFreeSpace]].\n    *\n-   * This set whenever [[MemoryStore.ensureFreeSpace]] is called, and cleared when the test\n-   * code makes explicit assertions on this variable through [[assertEnsureFreeSpaceCalled]].\n+   * This set whenever [[MemoryStore.evictBlocksToFreeSpace]] is called, and cleared when the test\n+   * code makes explicit assertions on this variable through\n+   * [[assertEvictBlocksToFreeSpaceCalled]].\n    */\n-  private val ensureFreeSpaceCalled = new AtomicLong(DEFAULT_ENSURE_FREE_SPACE_CALLED)\n+  private val evictBlocksToFreeSpaceCalled = new AtomicLong(0)\n+\n+  override def beforeEach(): Unit = {\n+    super.beforeEach()\n+    evictedBlocks.clear()\n+    evictBlocksToFreeSpaceCalled.set(DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED)\n+  }\n \n   /**\n-   * Make a mocked [[MemoryStore]] whose [[MemoryStore.ensureFreeSpace]] method is stubbed.\n+   * Make a mocked [[MemoryStore]] whose [[MemoryStore.evictBlocksToFreeSpace]] method is stubbed.\n    *\n-   * This allows our test code to release storage memory when [[MemoryStore.ensureFreeSpace]]\n-   * is called without relying on [[org.apache.spark.storage.BlockManager]] and all of its\n-   * dependencies.\n+   * This allows our test code to release storage memory when these methods are called\n+   * without relying on [[org.apache.spark.storage.BlockManager]] and all of its dependencies.\n    */\n   protected def makeMemoryStore(mm: MemoryManager): MemoryStore = {\n-    val ms = mock(classOf[MemoryStore])\n-    when(ms.ensureFreeSpace(anyLong(), any())).thenAnswer(ensureFreeSpaceAnswer(mm, 0))\n-    when(ms.ensureFreeSpace(any(), anyLong(), any())).thenAnswer(ensureFreeSpaceAnswer(mm, 1))\n+    val ms = mock(classOf[MemoryStore], RETURNS_SMART_NULLS)\n+    when(ms.evictBlocksToFreeSpace(any(), anyLong(), any()))\n+      .thenAnswer(evictBlocksToFreeSpaceAnswer(mm))\n     mm.setMemoryStore(ms)\n     ms\n   }\n \n   /**\n-   * Make an [[Answer]] that stubs [[MemoryStore.ensureFreeSpace]] with the right arguments.\n-   */\n-  private def ensureFreeSpaceAnswer(mm: MemoryManager, numBytesPos: Int): Answer[Boolean] = {\n+    * Simulate the part of [[MemoryStore.evictBlocksToFreeSpace]] that releases storage memory.\n+    *\n+    * This is a significant simplification of the real method, which actually drops existing\n+    * blocks based on the size of each block. Instead, here we simply release as many bytes\n+    * as needed to ensure the requested amount of free space. This allows us to set up the\n+    * test without relying on the [[org.apache.spark.storage.BlockManager]], which brings in\n+    * many other dependencies.\n+    *\n+    * Every call to this method will set a global variable, [[evictBlocksToFreeSpaceCalled]], that\n+    * records the number of bytes this is called with. This variable is expected to be cleared\n+    * by the test code later through [[assertEvictBlocksToFreeSpaceCalled]].\n+    */\n+  private def evictBlocksToFreeSpaceAnswer(mm: MemoryManager): Answer[Boolean] = {\n     new Answer[Boolean] {\n       override def answer(invocation: InvocationOnMock): Boolean = {\n         val args = invocation.getArguments\n-        require(args.size > numBytesPos, s\"bad test: expected >$numBytesPos arguments \" +\n-          s\"in ensureFreeSpace, found ${args.size}\")\n-        require(args(numBytesPos).isInstanceOf[Long], s\"bad test: expected ensureFreeSpace \" +\n-          s\"argument at index $numBytesPos to be a Long: ${args.mkString(\", \")}\")\n-        val numBytes = args(numBytesPos).asInstanceOf[Long]\n-        val success = mockEnsureFreeSpace(mm, numBytes)\n-        if (success) {\n+        val numBytesToFree = args(1).asInstanceOf[Long]\n+        assert(numBytesToFree > 0)\n+        require(evictBlocksToFreeSpaceCalled.get() === DEFAULT_EVICT_BLOCKS_TO_FREE_SPACE_CALLED,\n+          \"bad test: evictBlocksToFreeSpace() variable was not reset\")\n+        evictBlocksToFreeSpaceCalled.set(numBytesToFree)\n+        if (numBytesToFree <= mm.storageMemoryUsed) {\n+          // We can evict enough blocks to fulfill the request for space\n+          mm.releaseStorageMemory(numBytesToFree)\n           args.last.asInstanceOf[mutable.Buffer[(BlockId, BlockStatus)]].append(\n-            (null, BlockStatus(StorageLevel.MEMORY_ONLY, numBytes, 0L, 0L)))\n+            (null, BlockStatus(StorageLevel.MEMORY_ONLY, numBytesToFree, 0L, 0L)))\n+          evictedBlocks.append(\n+            (null, BlockStatus(StorageLevel.MEMORY_ONLY, numBytesToFree, 0L, 0L)))"
  }],
  "prId": 10170
}]