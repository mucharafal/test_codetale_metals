[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "A cool trick I used in YarnSparkHadoopUtilSuite is to do something like this:\n\n```\ndef spillingTest(name: String)(testFn: => Unit) = test(name) {\n    blah blah blah testFn() blah\n}\n```\n\nThen you can register like this:\n\n```\nspillingTest(\"spilling with null keys and values\") {\n   // body of testSpillingWithNullKeysAndValues\n}\n```\n\nWould look a little bit cleaner overall, but no biggie.\n",
    "commit": "1b54bdc5d66568129fd9d47eeb5811df12957377",
    "createdAt": "2014-08-28T23:38:54Z",
    "diffHunk": "@@ -200,77 +204,127 @@ class ExternalAppendOnlyMapSuite extends FunSuite with LocalSparkContext {\n \n     result.foreach { case (i, (seq1, seq2)) =>\n       i match {\n-        case 0 => assert(seq1.toSet == Set[Int]() && seq2.toSet == Set[Int](2, 4))\n-        case 1 => assert(seq1.toSet == Set[Int](1) && seq2.toSet == Set[Int](1, 3))\n-        case 2 => assert(seq1.toSet == Set[Int](2) && seq2.toSet == Set[Int]())\n-        case 3 => assert(seq1.toSet == Set[Int](3) && seq2.toSet == Set[Int]())\n-        case 4 => assert(seq1.toSet == Set[Int](4) && seq2.toSet == Set[Int]())\n+        case 0 => assert(seq1.toSet === Set[Int]() && seq2.toSet === Set[Int](2, 4))\n+        case 1 => assert(seq1.toSet === Set[Int](1) && seq2.toSet === Set[Int](1, 3))\n+        case 2 => assert(seq1.toSet === Set[Int](2) && seq2.toSet === Set[Int]())\n+        case 3 => assert(seq1.toSet === Set[Int](3) && seq2.toSet === Set[Int]())\n+        case 4 => assert(seq1.toSet === Set[Int](4) && seq2.toSet === Set[Int]())\n       }\n     }\n+    sc.stop()\n   }\n \n+  /**\n+   * For tests that involve spilling, run them multiple times with different compression settings.\n+   */\n+\n   test(\"spilling\") {\n-    val conf = createSparkConf(true)  // Load defaults, otherwise SPARK_HOME is not found\n+    runSpillingTest(testSpilling)\n+  }\n+\n+  test(\"spilling with hash collisions\") {\n+    runSpillingTest(testSpillingWithCollisions)\n+  }\n+\n+  test(\"spilling with many hash collisions\") {\n+    runSpillingTest(testSpillingWithManyCollisions)\n+  }\n+\n+  test(\"spilling with hash collisions using the Int.MaxValue key\") {\n+    runSpillingTest(testSpillingWithCollisionsMaxInt)\n+  }\n+\n+  test(\"spilling with null keys and values\") {\n+    runSpillingTest(testSpillingWithNullKeysAndValues)\n+  }\n+\n+  /* ------------------------------------ *\n+   * Actual test logic for spilling tests *\n+   * ------------------------------------ */\n+\n+  /**\n+   * Run a spilling test multiple times, with and without compression and using all codecs.\n+   */\n+  private def runSpillingTest(test: Option[String] => Unit): Unit = {"
  }],
  "prId": 2187
}]