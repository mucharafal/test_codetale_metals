[{
  "comments": [{
    "author": {
      "login": "kayousterhout"
    },
    "body": "Do you think it's better to just add a private[spark] method to check for read locks? I'm worried this test will still be brittle and it seems relatively easy to just add that method.",
    "commit": "bcc5a7c17a542fb7712f8b584cb0bb1eaa0589bf",
    "createdAt": "2017-03-24T01:45:07Z",
    "diffHunk": "@@ -481,27 +481,39 @@ class BlockManagerProactiveReplicationSuite extends BlockManagerReplicationBehav\n     assert(blockLocations.size === replicationFactor)\n \n     // remove a random blockManager\n-    val executorsToRemove = blockLocations.take(replicationFactor - 1)\n+    val executorsToRemove = blockLocations.take(replicationFactor - 1).toSet\n     logInfo(s\"Removing $executorsToRemove\")\n-    executorsToRemove.foreach{exec =>\n-      master.removeExecutor(exec.executorId)\n+    initialStores.filter(bm => executorsToRemove.contains(bm.blockManagerId)).foreach { bm =>\n+      master.removeExecutor(bm.blockManagerId.executorId)\n+      bm.stop()\n       // giving enough time for replication to happen and new block be reported to master\n-      Thread.sleep(200)\n+      eventually(timeout(5 seconds), interval(100 millis)) {\n+        val newLocations = master.getLocations(blockId).toSet\n+        assert(newLocations.size === replicationFactor)\n+      }\n     }\n \n-    val newLocations = eventually(timeout(5 seconds), interval(10 millis)) {\n+    val newLocations = eventually(timeout(5 seconds), interval(100 millis)) {\n       val _newLocations = master.getLocations(blockId).toSet\n       assert(_newLocations.size === replicationFactor)\n       _newLocations\n     }\n     logInfo(s\"New locations : $newLocations\")\n-    // there should only be one common block manager between initial and new locations\n-    assert(newLocations.intersect(blockLocations.toSet).size === 1)\n \n-    // check if all the read locks have been released\n+    // new locations should not contain stopped block managers\n+    assert(newLocations.forall(bmId => !executorsToRemove.contains(bmId)),\n+      \"New locations contain stopped block managers.\")\n+\n+    // this is to ensure the last read lock gets released before we try to\n+    // check for read-locks. The check for read-locks using the method below is not\n+    // idempotent, and therefore can't be used in an `eventually` block.\n+    Thread.sleep(500)"
  }, {
    "author": {
      "login": "shubhamchopra"
    },
    "body": "A blocking method that waits for read-locks to be unlocked? The way BlockManagerInfo handles resource contention, I don't think it might be a trivial change.",
    "commit": "bcc5a7c17a542fb7712f8b584cb0bb1eaa0589bf",
    "createdAt": "2017-03-27T15:22:47Z",
    "diffHunk": "@@ -481,27 +481,39 @@ class BlockManagerProactiveReplicationSuite extends BlockManagerReplicationBehav\n     assert(blockLocations.size === replicationFactor)\n \n     // remove a random blockManager\n-    val executorsToRemove = blockLocations.take(replicationFactor - 1)\n+    val executorsToRemove = blockLocations.take(replicationFactor - 1).toSet\n     logInfo(s\"Removing $executorsToRemove\")\n-    executorsToRemove.foreach{exec =>\n-      master.removeExecutor(exec.executorId)\n+    initialStores.filter(bm => executorsToRemove.contains(bm.blockManagerId)).foreach { bm =>\n+      master.removeExecutor(bm.blockManagerId.executorId)\n+      bm.stop()\n       // giving enough time for replication to happen and new block be reported to master\n-      Thread.sleep(200)\n+      eventually(timeout(5 seconds), interval(100 millis)) {\n+        val newLocations = master.getLocations(blockId).toSet\n+        assert(newLocations.size === replicationFactor)\n+      }\n     }\n \n-    val newLocations = eventually(timeout(5 seconds), interval(10 millis)) {\n+    val newLocations = eventually(timeout(5 seconds), interval(100 millis)) {\n       val _newLocations = master.getLocations(blockId).toSet\n       assert(_newLocations.size === replicationFactor)\n       _newLocations\n     }\n     logInfo(s\"New locations : $newLocations\")\n-    // there should only be one common block manager between initial and new locations\n-    assert(newLocations.intersect(blockLocations.toSet).size === 1)\n \n-    // check if all the read locks have been released\n+    // new locations should not contain stopped block managers\n+    assert(newLocations.forall(bmId => !executorsToRemove.contains(bmId)),\n+      \"New locations contain stopped block managers.\")\n+\n+    // this is to ensure the last read lock gets released before we try to\n+    // check for read-locks. The check for read-locks using the method below is not\n+    // idempotent, and therefore can't be used in an `eventually` block.\n+    Thread.sleep(500)"
  }, {
    "author": {
      "login": "kayousterhout"
    },
    "body": "scala test has an eventually primitive that you can use for this; I submitted a PR to your branch with what I was thinking here: https://github.com/shubhamchopra/spark/pull/1/commits/0c2eb9360c027e5d8bc8381e7e1bd56d7911527a\r\n\r\nIn general we should avoid sleeping in tests -- because it tends to lead to Jenkins failures when Jenkins is slow.",
    "commit": "bcc5a7c17a542fb7712f8b584cb0bb1eaa0589bf",
    "createdAt": "2017-03-27T19:11:02Z",
    "diffHunk": "@@ -481,27 +481,39 @@ class BlockManagerProactiveReplicationSuite extends BlockManagerReplicationBehav\n     assert(blockLocations.size === replicationFactor)\n \n     // remove a random blockManager\n-    val executorsToRemove = blockLocations.take(replicationFactor - 1)\n+    val executorsToRemove = blockLocations.take(replicationFactor - 1).toSet\n     logInfo(s\"Removing $executorsToRemove\")\n-    executorsToRemove.foreach{exec =>\n-      master.removeExecutor(exec.executorId)\n+    initialStores.filter(bm => executorsToRemove.contains(bm.blockManagerId)).foreach { bm =>\n+      master.removeExecutor(bm.blockManagerId.executorId)\n+      bm.stop()\n       // giving enough time for replication to happen and new block be reported to master\n-      Thread.sleep(200)\n+      eventually(timeout(5 seconds), interval(100 millis)) {\n+        val newLocations = master.getLocations(blockId).toSet\n+        assert(newLocations.size === replicationFactor)\n+      }\n     }\n \n-    val newLocations = eventually(timeout(5 seconds), interval(10 millis)) {\n+    val newLocations = eventually(timeout(5 seconds), interval(100 millis)) {\n       val _newLocations = master.getLocations(blockId).toSet\n       assert(_newLocations.size === replicationFactor)\n       _newLocations\n     }\n     logInfo(s\"New locations : $newLocations\")\n-    // there should only be one common block manager between initial and new locations\n-    assert(newLocations.intersect(blockLocations.toSet).size === 1)\n \n-    // check if all the read locks have been released\n+    // new locations should not contain stopped block managers\n+    assert(newLocations.forall(bmId => !executorsToRemove.contains(bmId)),\n+      \"New locations contain stopped block managers.\")\n+\n+    // this is to ensure the last read lock gets released before we try to\n+    // check for read-locks. The check for read-locks using the method below is not\n+    // idempotent, and therefore can't be used in an `eventually` block.\n+    Thread.sleep(500)"
  }, {
    "author": {
      "login": "shubhamchopra"
    },
    "body": "Got it. Apologize for the confusion. I have merged the PR. Thanks!",
    "commit": "bcc5a7c17a542fb7712f8b584cb0bb1eaa0589bf",
    "createdAt": "2017-03-27T19:43:38Z",
    "diffHunk": "@@ -481,27 +481,39 @@ class BlockManagerProactiveReplicationSuite extends BlockManagerReplicationBehav\n     assert(blockLocations.size === replicationFactor)\n \n     // remove a random blockManager\n-    val executorsToRemove = blockLocations.take(replicationFactor - 1)\n+    val executorsToRemove = blockLocations.take(replicationFactor - 1).toSet\n     logInfo(s\"Removing $executorsToRemove\")\n-    executorsToRemove.foreach{exec =>\n-      master.removeExecutor(exec.executorId)\n+    initialStores.filter(bm => executorsToRemove.contains(bm.blockManagerId)).foreach { bm =>\n+      master.removeExecutor(bm.blockManagerId.executorId)\n+      bm.stop()\n       // giving enough time for replication to happen and new block be reported to master\n-      Thread.sleep(200)\n+      eventually(timeout(5 seconds), interval(100 millis)) {\n+        val newLocations = master.getLocations(blockId).toSet\n+        assert(newLocations.size === replicationFactor)\n+      }\n     }\n \n-    val newLocations = eventually(timeout(5 seconds), interval(10 millis)) {\n+    val newLocations = eventually(timeout(5 seconds), interval(100 millis)) {\n       val _newLocations = master.getLocations(blockId).toSet\n       assert(_newLocations.size === replicationFactor)\n       _newLocations\n     }\n     logInfo(s\"New locations : $newLocations\")\n-    // there should only be one common block manager between initial and new locations\n-    assert(newLocations.intersect(blockLocations.toSet).size === 1)\n \n-    // check if all the read locks have been released\n+    // new locations should not contain stopped block managers\n+    assert(newLocations.forall(bmId => !executorsToRemove.contains(bmId)),\n+      \"New locations contain stopped block managers.\")\n+\n+    // this is to ensure the last read lock gets released before we try to\n+    // check for read-locks. The check for read-locks using the method below is not\n+    // idempotent, and therefore can't be used in an `eventually` block.\n+    Thread.sleep(500)"
  }],
  "prId": 17325
}]