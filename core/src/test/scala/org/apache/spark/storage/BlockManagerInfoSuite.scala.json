[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Indentation is weird. Probably fits in one line if you use shorter names (e.g. \"svcEnabled\", \"bmInfo\", etc). Same in other tests.",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-02T22:50:40Z",
    "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { shuffleServiceEnabled =>\n+      val blockManagerInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (shuffleServiceEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$shuffleServiceEnabled\") {\n+        f(shuffleServiceEnabled, blockManagerInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add broadcast block\") { (_, blockManagerInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    blockManagerInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.isEmpty()` instead of comparing `.asScala === Map()`?",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-02T22:52:07Z",
    "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { shuffleServiceEnabled =>\n+      val blockManagerInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (shuffleServiceEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$shuffleServiceEnabled\") {\n+        f(shuffleServiceEnabled, blockManagerInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add broadcast block\") { (_, blockManagerInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    blockManagerInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`isEmpty()`",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-02T22:54:38Z",
    "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { shuffleServiceEnabled =>\n+      val blockManagerInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (shuffleServiceEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$shuffleServiceEnabled\") {\n+        f(shuffleServiceEnabled, blockManagerInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add broadcast block\") { (_, blockManagerInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    blockManagerInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_AND_DISK\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with DISK_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"update RDD block from MEMORY_ONLY to DISK_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala == Map())"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: the operator usually stays in the previous line.",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-02T22:55:23Z",
    "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { shuffleServiceEnabled =>\n+      val blockManagerInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (shuffleServiceEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$shuffleServiceEnabled\") {\n+        f(shuffleServiceEnabled, blockManagerInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add broadcast block\") { (_, blockManagerInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    blockManagerInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.isEmpty()`",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-02T22:55:49Z",
    "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { shuffleServiceEnabled =>\n+      val blockManagerInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (shuffleServiceEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$shuffleServiceEnabled\") {\n+        f(shuffleServiceEnabled, blockManagerInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add broadcast block\") { (_, blockManagerInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    blockManagerInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_AND_DISK\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with DISK_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"update RDD block from MEMORY_ONLY to DISK_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala == Map())\n+    }\n+\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForNoMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForNoMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"using invalid StorageLevel\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.NONE, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala === Map())\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`.isEmpty()`",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-02T22:55:59Z",
    "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { shuffleServiceEnabled =>\n+      val blockManagerInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (shuffleServiceEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$shuffleServiceEnabled\") {\n+        f(shuffleServiceEnabled, blockManagerInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add broadcast block\") { (_, blockManagerInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    blockManagerInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with MEMORY_AND_DISK\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"add RDD block with DISK_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"update RDD block from MEMORY_ONLY to DISK_ONLY\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, 0)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(blockManagerInfo.remainingMem == 29800)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala == Map())\n+    }\n+\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForNoMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForNoMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"using invalid StorageLevel\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.NONE, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala === Map())\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"remove block\") {\n+    (shuffleServiceEnabled, blockManagerInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    blockManagerInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(blockManagerInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (shuffleServiceEnabled) Set() else Set(rddId)\n+    assert(blockManagerInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala\n+        === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+\n+    blockManagerInfo.removeBlock(rddId)\n+    assert(blockManagerInfo.blocks.asScala === Map())\n+    assert(blockManagerInfo.exclusiveCachedBlocks === Set())\n+    assert(blockManagerInfo.remainingMem == 30000)\n+    if (shuffleServiceEnabled) {\n+      assert(blockManagerInfo.externalShuffleServiceBlockStatus.get.asScala === Map())"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`===` (also in other places)",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-06T16:56:31Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem == 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (svcEnabled) Set() else Set(rddId)\n+    assert(bmInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(bmInfo.remainingMem == 29800)"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: operator in previous line (also in other places)",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-06T16:57:05Z",
    "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem == 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem == 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (svcEnabled) Set() else Set(rddId)\n+    assert(bmInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(bmInfo.remainingMem == 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.asScala ===\n+        Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with DISK_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (svcEnabled) Set() else Set(rddId)\n+    assert(bmInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(bmInfo.remainingMem == 30000)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.asScala ===\n+        Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"update from MEMORY_ONLY to DISK_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, 0)\n+    assert(bmInfo.blocks.asScala  === Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem == 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.asScala == Map())\n+    }\n+\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(bmInfo.blocks.asScala === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForNoMemoryOnly = if (svcEnabled) Set() else Set(rddId)\n+    assert(bmInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForNoMemoryOnly)\n+    assert(bmInfo.remainingMem == 30000)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.asScala ===\n+        Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"using invalid StorageLevel\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(bmInfo.blocks.asScala\n+      === Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "this is the effective storage level, not the requested level, right?  So this is testing that a block actually exists in both memory and disk -- not that the user called `rdd.persist(StorageLevel.MEMORY_AND_DISK)`, which usually only stores the data in one of memory or disk, but not both.\r\n\r\nAs both marcelo and I asked about it -- are there any tests for when the requested storage level is memory and disk, but you might get either one?  Your walk through of how it works in the code is good, just wondering if there are tests.",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-07T03:08:27Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)"
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "Yes this is the effective storage level.\r\n\r\nActually as I see an effective storage level can never ever be `StorageLevel.MEMORY_AND_DISK`. \r\nIn my walk through we reached the conclusion that always the `BlockManager#getCurrentBlockStatus` is used for computing the effective storage level (or it could also come from `BlockStatus#empty` which means `StorageLevel$#NONE` so that case is not relevant). So in `getCurrentBlockStatus` the level is calculated from the requested level which there referenced as `level`, and the related code:\r\n\r\nhttps://github.com/apache/spark/blob/3e7797aa02a48e653b3c167a62cba6512a1d3bcb/core/src/main/scala/org/apache/spark/storage/BlockManager.scala#L691-L701\r\n\r\nYou are right a block either can be found in the memory store or in the disk store (I have double checked it by focusing to  how `BlockManager#doPutIterator` uses the result of  `MemoryStore#putIteratorAsValues`). \r\n\r\nSo in the `getCurrentBlockStatus` either  `inMem` or `onDisk` is true:\r\n\r\n```scala\r\n   val inMem = level.useMemory && memoryStore.contains(blockId) \r\n   val onDisk = level.useDisk && diskStore.contains(blockId) \r\n```\r\n\r\nSo the highlighted storage levels cannot be effective just requested:\r\n\r\n![image](https://user-images.githubusercontent.com/2017933/57297201-446c4c00-70cf-11e9-99c2-76769c91c631.png)\r\n\r\n\r\nBased on the analysis above I would delete this test with with `MEMORY_AND_DISK`.",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-07T11:49:02Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "yes I was wondering the same thing -- I agree the effective storage level can't be both memory and disk on initial storage.  I hadn't confirmed whether it could never become both memory and disk eventually, though -- eg. there isn't space initially, so it gets written to disk, but then later on other RDDs are unpersisted, but the RDD is accessed again, so it gets promoted to being in memory, and the files on disk are still there.  See the `maybeCacheDiskBytesInMemory` / `maybeCacheDiskValuesInMemory`: https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/storage/BlockManager.scala#L774-L776\r\n\r\nso the test case may still be useful, but its not actually the more important part of a _requested_  MEMORY_AND_DISK storage level that marcelo and I were concerned about",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-07T15:12:53Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)"
  }, {
    "author": {
      "login": "attilapiros"
    },
    "body": "I see. And for example a reregister later on will lead to `BlockManager#reportAllBlocks` where `getCurrentBlockStatus` will see this block both in the memory store and in the disk store. Then I add this test back.",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-07T17:55:43Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(\n+      rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)"
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "probably worth a comment here on what situation this is testing -- eg. \"this is the effective storage level, not the requested storage level, but MEMORY_AND_DISK is still possible if its first in memory, purged to disk, and later promoted back to memory.\"",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-10T18:25:28Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)",
    "line": 70
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "also worth a brief comment here \"this happens if MEMORY_AND_DISK is the requested storage level, but the block gets purged to disk under memory pressure\"",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-10T18:26:03Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 400)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (svcEnabled) Set() else Set(rddId)\n+    assert(bmInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.asScala ===\n+        Map(rddId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 400)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with DISK_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.DISK_ONLY, memSize = 0, diskSize = 200)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    val exclusiveCachedBlocksForOneMemoryOnly = if (svcEnabled) Set() else Set(rddId)\n+    assert(bmInfo.exclusiveCachedBlocks === exclusiveCachedBlocksForOneMemoryOnly)\n+    assert(bmInfo.remainingMem === 30000)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.asScala ===\n+        Map(rddId -> BlockStatus(StorageLevel.DISK_ONLY, 0, 200)))\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"update from MEMORY_ONLY to DISK_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, 0)",
    "line": 100
  }],
  "prId": 24499
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "it's",
    "commit": "faa583f88b410fc7ededafe36bcb1ef878482d44",
    "createdAt": "2019-05-22T22:00:45Z",
    "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import java.util.{HashMap => JHashMap}\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkFunSuite\n+\n+class BlockManagerInfoSuite extends SparkFunSuite {\n+\n+  def testWithShuffleServiceOnOff(testName: String)\n+      (f: (Boolean, BlockManagerInfo) => Unit): Unit = {\n+    Seq(true, false).foreach { svcEnabled =>\n+      val bmInfo = new BlockManagerInfo(\n+        BlockManagerId(\"executor0\", \"host\", 1234, None),\n+        timeMs = 300,\n+        maxOnHeapMem = 10000,\n+        maxOffHeapMem = 20000,\n+        slaveEndpoint = null,\n+        if (svcEnabled) Some(new JHashMap[BlockId, BlockStatus]) else None)\n+      test(s\"$testName externalShuffleServiceEnabled=$svcEnabled\") {\n+        f(svcEnabled, bmInfo)\n+      }\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"broadcast block\") { (_, bmInfo) =>\n+    val broadcastId: BlockId = BroadcastBlockId(0, \"field1\")\n+    bmInfo.updateBlockInfo(\n+      broadcastId, StorageLevel.MEMORY_AND_DISK, memSize = 200, diskSize = 100)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(broadcastId -> BlockStatus(StorageLevel.MEMORY_AND_DISK, 0, 100)))\n+    assert(bmInfo.exclusiveCachedBlocks.isEmpty)\n+    assert(bmInfo.remainingMem === 29800)\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_ONLY\") { (svcEnabled, bmInfo) =>\n+    val rddId: BlockId = RDDBlockId(0, 0)\n+    bmInfo.updateBlockInfo(rddId, StorageLevel.MEMORY_ONLY, memSize = 200, diskSize = 0)\n+    assert(bmInfo.blocks.asScala ===\n+      Map(rddId -> BlockStatus(StorageLevel.MEMORY_ONLY, 200, 0)))\n+    assert(bmInfo.exclusiveCachedBlocks === Set(rddId))\n+    assert(bmInfo.remainingMem === 29800)\n+    if (svcEnabled) {\n+      assert(bmInfo.externalShuffleServiceBlockStatus.get.isEmpty)\n+    }\n+  }\n+\n+  testWithShuffleServiceOnOff(\"RDD block with MEMORY_AND_DISK\") { (svcEnabled, bmInfo) =>\n+    // This is the effective storage level, not the requested storage level, but MEMORY_AND_DISK\n+    // is still possible if its first in memory, purged to disk, and later promoted back to memory."
  }],
  "prId": 24499
}]