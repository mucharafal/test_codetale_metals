[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "<del>Let's also check if the `currentUnrollMemoryForThisTask` is the default size 4MB.</del>",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-14T04:58:08Z",
    "diffHunk": "@@ -303,6 +303,34 @@ class MemoryStoreSuite\n     assert(memoryStore.currentUnrollMemoryForThisTask === 0) // discard released the unroll memory\n   }\n \n+  test(\"set unrollMemoryThreshold a huge value larger than Int.MaxValue\") {\n+    val tmpConf = conf.clone.set(\"spark.storage.unrollMemoryThreshold\", s\"${1L + Int.MaxValue}\")\n+    val (memoryStore, blockInfoManager) = makeMemoryStore(12000L + Int.MaxValue, tmpConf)\n+    val smallList = List.fill(40)(new Array[Byte](100))\n+    def smallIterator: Iterator[Any] = smallList.iterator.asInstanceOf[Iterator[Any]]\n+    assert(memoryStore.currentUnrollMemoryForThisTask === 0)\n+\n+    def putIteratorAsBytes[T](\n+        blockId: BlockId,\n+        iter: Iterator[T],\n+        classTag: ClassTag[T]): Either[PartiallySerializedBlock[T], Long] = {\n+      assert(blockInfoManager.lockNewBlockForWriting(\n+        blockId,\n+        new BlockInfo(StorageLevel.MEMORY_ONLY_SER, classTag, tellMaster = false)))\n+      val res = memoryStore.putIteratorAsBytes(blockId, iter, classTag, MemoryMode.ON_HEAP)\n+      blockInfoManager.unlock(blockId)\n+      res\n+    }\n+\n+    // Unroll with plenty of space. This should succeed and cache both blocks.\n+    val result1 = putIteratorAsBytes(\"b1\", smallIterator, ClassTag.Any)\n+    val result2 = putIteratorAsBytes(\"b2\", smallIterator, ClassTag.Any)\n+    assert(memoryStore.contains(\"b1\"))\n+    assert(memoryStore.contains(\"b2\"))\n+    assert(result1.isRight) // unroll was successful\n+    assert(result2.isRight)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "nvm. It will be released once unrolling is successful.",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-14T05:10:00Z",
    "diffHunk": "@@ -303,6 +303,34 @@ class MemoryStoreSuite\n     assert(memoryStore.currentUnrollMemoryForThisTask === 0) // discard released the unroll memory\n   }\n \n+  test(\"set unrollMemoryThreshold a huge value larger than Int.MaxValue\") {\n+    val tmpConf = conf.clone.set(\"spark.storage.unrollMemoryThreshold\", s\"${1L + Int.MaxValue}\")\n+    val (memoryStore, blockInfoManager) = makeMemoryStore(12000L + Int.MaxValue, tmpConf)\n+    val smallList = List.fill(40)(new Array[Byte](100))\n+    def smallIterator: Iterator[Any] = smallList.iterator.asInstanceOf[Iterator[Any]]\n+    assert(memoryStore.currentUnrollMemoryForThisTask === 0)\n+\n+    def putIteratorAsBytes[T](\n+        blockId: BlockId,\n+        iter: Iterator[T],\n+        classTag: ClassTag[T]): Either[PartiallySerializedBlock[T], Long] = {\n+      assert(blockInfoManager.lockNewBlockForWriting(\n+        blockId,\n+        new BlockInfo(StorageLevel.MEMORY_ONLY_SER, classTag, tellMaster = false)))\n+      val res = memoryStore.putIteratorAsBytes(blockId, iter, classTag, MemoryMode.ON_HEAP)\n+      blockInfoManager.unlock(blockId)\n+      res\n+    }\n+\n+    // Unroll with plenty of space. This should succeed and cache both blocks.\n+    val result1 = putIteratorAsBytes(\"b1\", smallIterator, ClassTag.Any)\n+    val result2 = putIteratorAsBytes(\"b2\", smallIterator, ClassTag.Any)\n+    assert(memoryStore.contains(\"b1\"))\n+    assert(memoryStore.contains(\"b2\"))\n+    assert(result1.isRight) // unroll was successful\n+    assert(result2.isRight)"
  }],
  "prId": 15915
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Is this change needed?",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-15T13:47:40Z",
    "diffHunk": "@@ -60,7 +60,7 @@ class MemoryStoreSuite\n     SizeEstimator invokePrivate initialize()\n   }\n \n-  def makeMemoryStore(maxMem: Long): (MemoryStore, BlockInfoManager) = {\n+  def makeMemoryStore(maxMem: Long, conf: SparkConf = conf): (MemoryStore, BlockInfoManager) = {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I think it is for passing a SparkConf with modified `spark.storage.unrollMemoryThreshold`.",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-16T02:06:48Z",
    "diffHunk": "@@ -60,7 +60,7 @@ class MemoryStoreSuite\n     SizeEstimator invokePrivate initialize()\n   }\n \n-  def makeMemoryStore(maxMem: Long): (MemoryStore, BlockInfoManager) = {\n+  def makeMemoryStore(maxMem: Long, conf: SparkConf = conf): (MemoryStore, BlockInfoManager) = {"
  }, {
    "author": {
      "login": "uncleGen"
    },
    "body": "I changed this to pass a temp conf which set `spark.storage.unrollMemoryThreshold` a different value.\r\n\r\n```\r\n+    val tmpConf = conf.clone.set(\"spark.storage.unrollMemoryThreshold\", s\"${1L + Int.MaxValue}\")\r\n+    val (memoryStore, blockInfoManager) = makeMemoryStore(12000L + Int.MaxValue, tmpConf)\r\n```",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-16T02:09:48Z",
    "diffHunk": "@@ -60,7 +60,7 @@ class MemoryStoreSuite\n     SizeEstimator invokePrivate initialize()\n   }\n \n-  def makeMemoryStore(maxMem: Long): (MemoryStore, BlockInfoManager) = {\n+  def makeMemoryStore(maxMem: Long, conf: SparkConf = conf): (MemoryStore, BlockInfoManager) = {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Oh, that's confusing because of the shadowing. The arg and member have the same name. Please name this arg differently if you do this.",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-16T08:59:51Z",
    "diffHunk": "@@ -60,7 +60,7 @@ class MemoryStoreSuite\n     SizeEstimator invokePrivate initialize()\n   }\n \n-  def makeMemoryStore(maxMem: Long): (MemoryStore, BlockInfoManager) = {\n+  def makeMemoryStore(maxMem: Long, conf: SparkConf = conf): (MemoryStore, BlockInfoManager) = {"
  }, {
    "author": {
      "login": "uncleGen"
    },
    "body": "get it",
    "commit": "6b892af78c0ce47352d8f2be1bb765aafaff363a",
    "createdAt": "2016-12-16T10:17:22Z",
    "diffHunk": "@@ -60,7 +60,7 @@ class MemoryStoreSuite\n     SizeEstimator invokePrivate initialize()\n   }\n \n-  def makeMemoryStore(maxMem: Long): (MemoryStore, BlockInfoManager) = {\n+  def makeMemoryStore(maxMem: Long, conf: SparkConf = conf): (MemoryStore, BlockInfoManager) = {"
  }],
  "prId": 15915
}]