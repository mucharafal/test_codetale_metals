[{
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Put a space after the \"be\" if you use this syntax. FYI it's also okay to do `assert(iterator.hasNext === true)`, or, for booleans, `assert(iterator.hasNext, \"iterator did not have next\")` (for a nicer error message).\n",
    "commit": "85c89380b499702a6fee119e5f45a7a0685f149e",
    "createdAt": "2014-07-30T21:55:36Z",
    "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.storage\n+\n+import org.scalatest.{FunSuite, Matchers}\n+import org.scalatest.PrivateMethodTester._\n+\n+import org.mockito.Mockito._\n+import org.mockito.Matchers.{any, eq => meq}\n+import org.mockito.stubbing.Answer\n+import org.mockito.invocation.InvocationOnMock\n+\n+import org.apache.spark._\n+import org.apache.spark.storage.BlockFetcherIterator._\n+import org.apache.spark.network.{ConnectionManager, ConnectionManagerId,\n+                                 Message}\n+\n+class BlockFetcherIteratorSuite extends FunSuite with Matchers {\n+\n+  test(\"block fetch from local fails using BasicBlockFetcherIterator\") {\n+    val blockManager = mock(classOf[BlockManager])\n+    val connManager = mock(classOf[ConnectionManager])\n+    doReturn(connManager).when(blockManager).connectionManager\n+    doReturn(BlockManagerId(\"test-client\", \"test-client\", 1, 0)).when(blockManager).blockManagerId\n+\n+    doReturn((48 * 1024 * 1024).asInstanceOf[Long]).when(blockManager).maxBytesInFlight\n+\n+    val blIds = Array[BlockId](\n+      ShuffleBlockId(0,0,0),\n+      ShuffleBlockId(0,1,0),\n+      ShuffleBlockId(0,2,0),\n+      ShuffleBlockId(0,3,0),\n+      ShuffleBlockId(0,4,0))\n+\n+    val optItr = mock(classOf[Option[Iterator[Any]]])\n+    val answer = new Answer[Option[Iterator[Any]]] {\n+      override def answer(invocation: InvocationOnMock) = Option[Iterator[Any]] {\n+        throw new Exception\n+      }\n+    }\n+\n+    // 3rd block is going to fail\n+    doReturn(optItr).when(blockManager).getLocalFromDisk(meq(blIds(0)), any())\n+    doReturn(optItr).when(blockManager).getLocalFromDisk(meq(blIds(1)), any())\n+    doAnswer(answer).when(blockManager).getLocalFromDisk(meq(blIds(2)), any())\n+    doReturn(optItr).when(blockManager).getLocalFromDisk(meq(blIds(3)), any())\n+    doReturn(optItr).when(blockManager).getLocalFromDisk(meq(blIds(4)), any())\n+\n+    val bmId = BlockManagerId(\"test-client\", \"test-client\",1 , 0)\n+    val blocksByAddress = Seq[(BlockManagerId, Seq[(BlockId, Long)])](\n+      (bmId, blIds.map(blId => (blId, 1.asInstanceOf[Long])).toSeq)\n+    )\n+\n+    val iterator = new BasicBlockFetcherIterator(blockManager,\n+      blocksByAddress, null)\n+\n+    iterator.initialize()\n+\n+    // 3rd getLocalFromDisk invocation should be failed\n+    verify(blockManager, times(3)).getLocalFromDisk(any(), any())\n+\n+    (iterator.hasNext) should be(true)"
  }],
  "prId": 1578
}]