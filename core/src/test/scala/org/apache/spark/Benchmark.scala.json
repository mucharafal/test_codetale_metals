[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "How about calling System.nanoTime() for short-running benchmarks instead of System.currentTimeMillis()?\n",
    "commit": "e0f427f9d4083068fefaed6a29719f0a7eeb22b3",
    "createdAt": "2016-01-06T02:05:09Z",
    "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.commons.lang3.SystemUtils\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Utility class to benchmark components. An example of how to use this is:\n+ *  val benchmark = new Benchmark(\"My Benchmark\", valuesPerIteration)\n+ *   benchmark.addCase(\"V1\", <function>\")\n+ *   benchmark.addCase(\"V2\", <function>\")\n+ *   benchmark.run\n+ * This will output the average time to run each function and the rate of each function.\n+ *\n+ * The benchmark function takes one argument that is the iteration that's being run\n+ */\n+class Benchmark(name: String, valuesPerIteration: Long, iters: Int = 5) {\n+  val benchmarks = mutable.ArrayBuffer.empty[Benchmark.Case]\n+\n+  def addCase(name: String, f: Int => Unit): Unit = {\n+    benchmarks += Benchmark.Case(name, f)\n+  }\n+\n+  /**\n+   * Runs the benchmark and outputs the results to stdout. This should be copied and added as\n+   * a comment with the benchmark. Although the results vary from machine to machine, it should\n+   * provide some baseline.\n+   */\n+  def run(): Unit = {\n+    require(benchmarks.nonEmpty)\n+    val results = benchmarks.map { c =>\n+      Benchmark.measure(valuesPerIteration, c.fn, iters)\n+    }\n+    val firstRate = results.head.avgRate\n+    // scalastyle:off\n+    // The results are going to be processor specific so it is useful to include that.\n+    println(Benchmark.getProcessorName())\n+    printf(\"%-30s %16s %16s %14s\\n\", name + \":\", \"Avg Time(ms)\", \"Avg Rate(M/s)\", \"Relative Rate\")\n+    println(\"-------------------------------------------------------------------------------\")\n+    results.zip(benchmarks).foreach { r =>\n+      printf(\"%-30s %16s %16s %14s\\n\", r._2.name, r._1.avgMs.toString, \"%10.2f\" format r._1.avgRate,\n+        \"%6.2f X\" format (r._1.avgRate / firstRate))\n+    }\n+    println\n+    // scalastyle:on\n+  }\n+}\n+\n+object Benchmark {\n+  case class Case(name: String, fn: Int => Unit)\n+  case class Result(avgMs: Double, avgRate: Double)\n+\n+  /**\n+   * This should return a user helpful processor information. Getting at this depends on the OS.\n+   * This should return something like \"Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\"\n+   */\n+  def getProcessorName(): String = {\n+    if (SystemUtils.IS_OS_MAC_OSX) {\n+      Utils.executeAndGetOutput(Seq(\"/usr/sbin/sysctl\", \"-n\", \"machdep.cpu.brand_string\"))\n+    } else if (SystemUtils.IS_OS_LINUX) {\n+      Utils.executeAndGetOutput(Seq(\"/usr/bin/grep\", \"-m\", \"1\", \"\\\"model name\\\"\", \"/proc/cpuinfo\"))\n+    } else {\n+      System.getenv(\"PROCESSOR_IDENTIFIER\")\n+    }\n+  }\n+\n+  /**\n+   * Runs a single function `f` for iters, returning the average time the function took and\n+   * the rate of the function.\n+   */\n+  def measure(num: Long, f: Int => Unit, iters: Int): Result = {\n+    var totalTime = 0L\n+    for (i <- 0 until iters + 1) {\n+      val start = System.currentTimeMillis()"
  }, {
    "author": {
      "login": "velvia"
    },
    "body": "Or use JMH (see sbt-jmh), which takes care of a lot of common issues like JVM warmups and environment isolation when running benchmarks.\n",
    "commit": "e0f427f9d4083068fefaed6a29719f0a7eeb22b3",
    "createdAt": "2016-01-06T18:33:24Z",
    "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.commons.lang3.SystemUtils\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Utility class to benchmark components. An example of how to use this is:\n+ *  val benchmark = new Benchmark(\"My Benchmark\", valuesPerIteration)\n+ *   benchmark.addCase(\"V1\", <function>\")\n+ *   benchmark.addCase(\"V2\", <function>\")\n+ *   benchmark.run\n+ * This will output the average time to run each function and the rate of each function.\n+ *\n+ * The benchmark function takes one argument that is the iteration that's being run\n+ */\n+class Benchmark(name: String, valuesPerIteration: Long, iters: Int = 5) {\n+  val benchmarks = mutable.ArrayBuffer.empty[Benchmark.Case]\n+\n+  def addCase(name: String, f: Int => Unit): Unit = {\n+    benchmarks += Benchmark.Case(name, f)\n+  }\n+\n+  /**\n+   * Runs the benchmark and outputs the results to stdout. This should be copied and added as\n+   * a comment with the benchmark. Although the results vary from machine to machine, it should\n+   * provide some baseline.\n+   */\n+  def run(): Unit = {\n+    require(benchmarks.nonEmpty)\n+    val results = benchmarks.map { c =>\n+      Benchmark.measure(valuesPerIteration, c.fn, iters)\n+    }\n+    val firstRate = results.head.avgRate\n+    // scalastyle:off\n+    // The results are going to be processor specific so it is useful to include that.\n+    println(Benchmark.getProcessorName())\n+    printf(\"%-30s %16s %16s %14s\\n\", name + \":\", \"Avg Time(ms)\", \"Avg Rate(M/s)\", \"Relative Rate\")\n+    println(\"-------------------------------------------------------------------------------\")\n+    results.zip(benchmarks).foreach { r =>\n+      printf(\"%-30s %16s %16s %14s\\n\", r._2.name, r._1.avgMs.toString, \"%10.2f\" format r._1.avgRate,\n+        \"%6.2f X\" format (r._1.avgRate / firstRate))\n+    }\n+    println\n+    // scalastyle:on\n+  }\n+}\n+\n+object Benchmark {\n+  case class Case(name: String, fn: Int => Unit)\n+  case class Result(avgMs: Double, avgRate: Double)\n+\n+  /**\n+   * This should return a user helpful processor information. Getting at this depends on the OS.\n+   * This should return something like \"Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\"\n+   */\n+  def getProcessorName(): String = {\n+    if (SystemUtils.IS_OS_MAC_OSX) {\n+      Utils.executeAndGetOutput(Seq(\"/usr/sbin/sysctl\", \"-n\", \"machdep.cpu.brand_string\"))\n+    } else if (SystemUtils.IS_OS_LINUX) {\n+      Utils.executeAndGetOutput(Seq(\"/usr/bin/grep\", \"-m\", \"1\", \"\\\"model name\\\"\", \"/proc/cpuinfo\"))\n+    } else {\n+      System.getenv(\"PROCESSOR_IDENTIFIER\")\n+    }\n+  }\n+\n+  /**\n+   * Runs a single function `f` for iters, returning the average time the function took and\n+   * the rate of the function.\n+   */\n+  def measure(num: Long, f: Int => Unit, iters: Int): Result = {\n+    var totalTime = 0L\n+    for (i <- 0 until iters + 1) {\n+      val start = System.currentTimeMillis()"
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "JMH looks great and it would be good to add. The utility I added is super simple and gets us going and I don't think it's worth blocking other work items. It would be great if someone added JMH to spark and deleted this benchmarking harness.\n",
    "commit": "e0f427f9d4083068fefaed6a29719f0a7eeb22b3",
    "createdAt": "2016-01-07T02:23:11Z",
    "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark\n+\n+import scala.collection.mutable\n+\n+import org.apache.commons.lang3.SystemUtils\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Utility class to benchmark components. An example of how to use this is:\n+ *  val benchmark = new Benchmark(\"My Benchmark\", valuesPerIteration)\n+ *   benchmark.addCase(\"V1\", <function>\")\n+ *   benchmark.addCase(\"V2\", <function>\")\n+ *   benchmark.run\n+ * This will output the average time to run each function and the rate of each function.\n+ *\n+ * The benchmark function takes one argument that is the iteration that's being run\n+ */\n+class Benchmark(name: String, valuesPerIteration: Long, iters: Int = 5) {\n+  val benchmarks = mutable.ArrayBuffer.empty[Benchmark.Case]\n+\n+  def addCase(name: String, f: Int => Unit): Unit = {\n+    benchmarks += Benchmark.Case(name, f)\n+  }\n+\n+  /**\n+   * Runs the benchmark and outputs the results to stdout. This should be copied and added as\n+   * a comment with the benchmark. Although the results vary from machine to machine, it should\n+   * provide some baseline.\n+   */\n+  def run(): Unit = {\n+    require(benchmarks.nonEmpty)\n+    val results = benchmarks.map { c =>\n+      Benchmark.measure(valuesPerIteration, c.fn, iters)\n+    }\n+    val firstRate = results.head.avgRate\n+    // scalastyle:off\n+    // The results are going to be processor specific so it is useful to include that.\n+    println(Benchmark.getProcessorName())\n+    printf(\"%-30s %16s %16s %14s\\n\", name + \":\", \"Avg Time(ms)\", \"Avg Rate(M/s)\", \"Relative Rate\")\n+    println(\"-------------------------------------------------------------------------------\")\n+    results.zip(benchmarks).foreach { r =>\n+      printf(\"%-30s %16s %16s %14s\\n\", r._2.name, r._1.avgMs.toString, \"%10.2f\" format r._1.avgRate,\n+        \"%6.2f X\" format (r._1.avgRate / firstRate))\n+    }\n+    println\n+    // scalastyle:on\n+  }\n+}\n+\n+object Benchmark {\n+  case class Case(name: String, fn: Int => Unit)\n+  case class Result(avgMs: Double, avgRate: Double)\n+\n+  /**\n+   * This should return a user helpful processor information. Getting at this depends on the OS.\n+   * This should return something like \"Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\"\n+   */\n+  def getProcessorName(): String = {\n+    if (SystemUtils.IS_OS_MAC_OSX) {\n+      Utils.executeAndGetOutput(Seq(\"/usr/sbin/sysctl\", \"-n\", \"machdep.cpu.brand_string\"))\n+    } else if (SystemUtils.IS_OS_LINUX) {\n+      Utils.executeAndGetOutput(Seq(\"/usr/bin/grep\", \"-m\", \"1\", \"\\\"model name\\\"\", \"/proc/cpuinfo\"))\n+    } else {\n+      System.getenv(\"PROCESSOR_IDENTIFIER\")\n+    }\n+  }\n+\n+  /**\n+   * Runs a single function `f` for iters, returning the average time the function took and\n+   * the rate of the function.\n+   */\n+  def measure(num: Long, f: Int => Unit, iters: Int): Result = {\n+    var totalTime = 0L\n+    for (i <- 0 until iters + 1) {\n+      val start = System.currentTimeMillis()"
  }],
  "prId": 10593
}]