[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about commenting out unsupported syntaxes instead of removing? I feel its better to keep the original ones as much as possible.",
    "commit": "092bba95543c861146bafbd6a529913e353a4d51",
    "createdAt": "2019-07-11T06:24:23Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT\n+-- Test int8 64-bit integers.\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select.sql\n+--\n+create or replace temporary view onek2 as select * from onek;\n+create or replace temporary view INT8_TBL as select * from values\n+  (cast(trim('  123   ') as bigint), cast(trim('  456') as bigint)),\n+  (cast(trim('123   ') as bigint),cast('4567890123456789' as bigint)),\n+  (cast('4567890123456789' as bigint),cast('123' as bigint)),\n+  (cast(+4567890123456789 as bigint),cast('4567890123456789' as bigint)),\n+  (cast('+4567890123456789' as bigint),cast('-4567890123456789' as bigint))\n+  as INT8_TBL(q1, q2);\n+\n+-- btree index\n+-- awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1\n+--\n+SELECT * FROM onek\n+   WHERE onek.unique1 < 10\n+   ORDER BY onek.unique1;\n+\n+-- [SPARK-28010] Support ORDER BY ... USING syntax\n+--\n+-- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1\n+--\n+SELECT onek.unique1, onek.stringu1 FROM onek\n+   WHERE onek.unique1 < 20\n+   ORDER BY unique1 DESC;\n+\n+--\n+-- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2\n+--\n+SELECT onek.unique1, onek.stringu1 FROM onek\n+   WHERE onek.unique1 > 980\n+   ORDER BY stringu1 ASC;\n+\n+--\n+-- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |\n+-- sort +1d -2 +0nr -1\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 > 980\n+   ORDER BY string4 ASC, unique1 DESC;\n+\n+--\n+-- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |\n+-- sort +1dr -2 +0n -1\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 > 980\n+   ORDER BY string4 DESC, unique1 ASC;\n+\n+--\n+-- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |\n+-- sort +0nr -1 +1d -2\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 < 20\n+   ORDER BY unique1 DESC, string4 ASC;\n+\n+--\n+-- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |\n+-- sort +0n -1 +1dr -2\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 < 20\n+   ORDER BY unique1 ASC, string4 DESC;\n+\n+--\n+-- test partial btree indexes\n+--\n+-- As of 7.2, planner probably won't pick an indexscan without stats,\n+-- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan\n+-- followed by sort, because that could hide index ordering problems.\n+--\n+-- ANALYZE onek2;\n+\n+-- SET enable_seqscan TO off;\n+-- SET enable_bitmapscan TO off;\n+-- SET enable_sort TO off;\n+\n+--\n+-- awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1\n+--\n+SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;\n+\n+--\n+-- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1\n+--\n+SELECT onek2.unique1, onek2.stringu1 FROM onek2\n+    WHERE onek2.unique1 < 20\n+    ORDER BY unique1 DESC;\n+\n+--\n+-- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2\n+--\n+SELECT onek2.unique1, onek2.stringu1 FROM onek2\n+   WHERE onek2.unique1 > 980;\n+\n+-- RESET enable_seqscan;\n+-- RESET enable_bitmapscan;\n+-- RESET enable_sort;\n+\n+-- [SPARK-28329] SELECT INTO syntax\n+CREATE TABLE tmp USING parquet AS",
    "line": 111
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "OK. commented it out.",
    "commit": "092bba95543c861146bafbd6a529913e353a4d51",
    "createdAt": "2019-07-11T10:46:59Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT\n+-- Test int8 64-bit integers.\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select.sql\n+--\n+create or replace temporary view onek2 as select * from onek;\n+create or replace temporary view INT8_TBL as select * from values\n+  (cast(trim('  123   ') as bigint), cast(trim('  456') as bigint)),\n+  (cast(trim('123   ') as bigint),cast('4567890123456789' as bigint)),\n+  (cast('4567890123456789' as bigint),cast('123' as bigint)),\n+  (cast(+4567890123456789 as bigint),cast('4567890123456789' as bigint)),\n+  (cast('+4567890123456789' as bigint),cast('-4567890123456789' as bigint))\n+  as INT8_TBL(q1, q2);\n+\n+-- btree index\n+-- awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1\n+--\n+SELECT * FROM onek\n+   WHERE onek.unique1 < 10\n+   ORDER BY onek.unique1;\n+\n+-- [SPARK-28010] Support ORDER BY ... USING syntax\n+--\n+-- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1\n+--\n+SELECT onek.unique1, onek.stringu1 FROM onek\n+   WHERE onek.unique1 < 20\n+   ORDER BY unique1 DESC;\n+\n+--\n+-- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2\n+--\n+SELECT onek.unique1, onek.stringu1 FROM onek\n+   WHERE onek.unique1 > 980\n+   ORDER BY stringu1 ASC;\n+\n+--\n+-- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |\n+-- sort +1d -2 +0nr -1\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 > 980\n+   ORDER BY string4 ASC, unique1 DESC;\n+\n+--\n+-- awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |\n+-- sort +1dr -2 +0n -1\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 > 980\n+   ORDER BY string4 DESC, unique1 ASC;\n+\n+--\n+-- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |\n+-- sort +0nr -1 +1d -2\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 < 20\n+   ORDER BY unique1 DESC, string4 ASC;\n+\n+--\n+-- awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |\n+-- sort +0n -1 +1dr -2\n+--\n+SELECT onek.unique1, onek.string4 FROM onek\n+   WHERE onek.unique1 < 20\n+   ORDER BY unique1 ASC, string4 DESC;\n+\n+--\n+-- test partial btree indexes\n+--\n+-- As of 7.2, planner probably won't pick an indexscan without stats,\n+-- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan\n+-- followed by sort, because that could hide index ordering problems.\n+--\n+-- ANALYZE onek2;\n+\n+-- SET enable_seqscan TO off;\n+-- SET enable_bitmapscan TO off;\n+-- SET enable_sort TO off;\n+\n+--\n+-- awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1\n+--\n+SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;\n+\n+--\n+-- awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1\n+--\n+SELECT onek2.unique1, onek2.stringu1 FROM onek2\n+    WHERE onek2.unique1 < 20\n+    ORDER BY unique1 DESC;\n+\n+--\n+-- awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2\n+--\n+SELECT onek2.unique1, onek2.stringu1 FROM onek2\n+   WHERE onek2.unique1 > 980;\n+\n+-- RESET enable_seqscan;\n+-- RESET enable_bitmapscan;\n+-- RESET enable_sort;\n+\n+-- [SPARK-28329] SELECT INTO syntax\n+CREATE TABLE tmp USING parquet AS",
    "line": 111
  }],
  "prId": 25096
}]