[{
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Do we need  to adapt `aggf_trans`, `aggfns_trans`, `aggfstr` and `aggfns` from [PostgreSQL](https://github.com/postgres/postgres/blob/01bde4fa4c24f4eea0a634d8fcad0b376efda6b1/src/test/regress/sql/create_aggregate.sql#L54-L73)?\r\n",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-06-10T05:08:01Z",
    "diffHunk": "@@ -0,0 +1,284 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+select aggfstr(a,b,c)"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Personally, I think we do not need them unless the community is asking for them. ",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-06-11T08:01:46Z",
    "diffHunk": "@@ -0,0 +1,284 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+select aggfstr(a,b,c)"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "OK.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-06-12T05:20:58Z",
    "diffHunk": "@@ -0,0 +1,284 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+select aggfstr(a,b,c)"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about keeping the original queries here?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T00:56:00Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T05:21:25Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "I personally think this title name is a bit confusing cuz this is a general term for aggregates in Spark? https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/aggregate/HashAggregateExec.scala#L49",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T01:07:50Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+select concat_ws('AB', collect_list(a)) from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- The result is different: collect_list returns an empty list, but string_agg results NULL\n+select concat_ws(',', collect_list(a)) from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+select concat_ws(',', sort_array(array_distinct(collect_list(f1)))) from varchar_tbl;\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Renamed it to `Support Aggregate Expressions with filter`.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T05:21:04Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+select concat_ws('AB', collect_list(a)) from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- The result is different: collect_list returns an empty list, but string_agg results NULL\n+select concat_ws(',', collect_list(a)) from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+select concat_ws(',', sort_array(array_distinct(collect_list(f1)))) from varchar_tbl;\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about keeping the original queries, too?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T01:11:36Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+select concat_ws('AB', collect_list(a)) from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- The result is different: collect_list returns an empty list, but string_agg results NULL\n+select concat_ws(',', collect_list(a)) from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+select concat_ws(',', sort_array(array_distinct(collect_list(f1)))) from varchar_tbl;\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions\n+-- FILTER tests\n+\n+select min(CASE WHEN unique1> 100 THEN unique1 END) from tenk1;"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T05:20:37Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+select concat_ws('AB', collect_list(a)) from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- The result is different: collect_list returns an empty list, but string_agg results NULL\n+select concat_ws(',', collect_list(a)) from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+select concat_ws(',', sort_array(array_distinct(collect_list(f1)))) from varchar_tbl;\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions\n+-- FILTER tests\n+\n+select min(CASE WHEN unique1> 100 THEN unique1 END) from tenk1;"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "The `COLLATE` clause is defined in the standard?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T01:17:26Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+select concat_ws('AB', collect_list(a)) from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- The result is different: collect_list returns an empty list, but string_agg results NULL\n+select concat_ws(',', collect_list(a)) from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+select concat_ws(',', sort_array(array_distinct(collect_list(f1)))) from varchar_tbl;\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions\n+-- FILTER tests\n+\n+select min(CASE WHEN unique1> 100 THEN unique1 END) from tenk1;\n+\n+-- The result is different: we added cast here because [SPARK-2659]\n+select sum(CASE WHEN ten > 0 THEN cast(1/ten as integer) END) from tenk1;\n+\n+-- [SPARK-27987] Support POSIX Regular Expressions\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+select ten, sum(distinct CASE WHEN four > 10 THEN four END)  from onek a\n+group by ten\n+having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- Rewrite this SQL by removing COLLATE"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Yes. SPARK-28682: ANSI SQL: Collation Support",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-10T05:19:45Z",
    "diffHunk": "@@ -0,0 +1,287 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+create temporary view varchar_tbl as select * from values\n+  ('a'),\n+  ('A'),\n+  ('1'),\n+  ('2'),\n+  ('3'),\n+  (''),\n+  -- ('cd'),\n+  ('c')\n+  as varchar_tbl(f1);\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] We use concat_ws(delimiter, collect_list(expression)) to rewrite string_agg\n+-- string_agg tests\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+select concat_ws(',', collect_list(a)) from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+select concat_ws('AB', collect_list(a)) from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- The result is different: collect_list returns an empty list, but string_agg results NULL\n+select concat_ws(',', collect_list(a)) from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+select concat_ws(',', sort_array(array_distinct(collect_list(f1)))) from varchar_tbl;\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions\n+-- FILTER tests\n+\n+select min(CASE WHEN unique1> 100 THEN unique1 END) from tenk1;\n+\n+-- The result is different: we added cast here because [SPARK-2659]\n+select sum(CASE WHEN ten > 0 THEN cast(1/ten as integer) END) from tenk1;\n+\n+-- [SPARK-27987] Support POSIX Regular Expressions\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+select ten, sum(distinct CASE WHEN four > 10 THEN four END)  from onek a\n+group by ten\n+having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- Rewrite this SQL by removing COLLATE"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`REL_12_BETA1` -> `REL_12_BETA2`?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:06:21Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Please check the line numbers too if the file is changed. I hope it's unchanged.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:07:21Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "AGGREGATES [Part 3] unchanged, AGGREGATES [Part 4] changed:\r\nhttps://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/aggregates.sql#L992\r\nWe has added it: https://github.com/apache/spark/blob/2a2b2029622746c0e08a8b12a38bd6b1171a6396/sql/core/src/test/resources/sql-tests/inputs/pgSQL/aggregates_part4.sql#L414-L419",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:07:59Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Instead of adding `SPARK-9830`, can we check the actual error? The original PostgreSQL test is also for ensuring the error.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:11:49Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors",
    "line": 35
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "It's a correct behaviour, `aggregate function calls cannot be nested`\r\nhttps://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/expected/aggregates.out#L1078-L1085",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-17T03:13:26Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors",
    "line": 35
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ya. I know. My suggestion is to check the error message like PostgreSQL.\r\nIf it doesn't throw exceptions later, we can detect a regression at that time.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-17T04:29:02Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors",
    "line": 35
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Sorry, but this looks insufficient to ignore the followings.\r\nWe can register these functions like we did for tables `tenk1 `, cann't we?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:17:57Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "UDF is easy, UDAF seems need to implement `UserDefinedFunction`.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:10:49Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Got it. Never mind.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-17T04:29:43Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Did you mean that Spark doesn't support UDF invocation syntax like this `udfName(distinct a,b,c order by b)`?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:24:54Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)",
    "line": 109
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "I think this is UDF behaviour:\r\n![image](https://user-images.githubusercontent.com/5399861/63167123-edc5c500-c062-11e9-84db-d449c9f1359c.png)\r\n",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:18:04Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)",
    "line": 109
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Do we have a JIRA for that? Then, please add the ID as a comment here.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-17T04:30:47Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)",
    "line": 109
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "```sql\r\npostgres=# select max(distinct a) from (values('a'), ('b')) v(a);\r\n max\r\n-----\r\n b\r\n(1 row)\r\n\r\nspark-sql> select max(distinct a) from (values('a'), ('b')) v(a);\r\nb\r\nspark-sql>\r\n```\r\n\r\n```sql\r\npostgres=# select upper(distinct a) from (values('a'), ('b')) v(a);\r\nERROR:  DISTINCT specified, but upper is not an aggregate function\r\nLINE 1: select upper(distinct a) from (values('a'), ('b')) v(a);\r\n\r\nspark-sql> select upper(distinct a) from (values('a'), ('b')) v(a);\r\nError in query: upper does not support the modifier DISTINCT; line 1 pos 7\r\nspark-sql>\r\n```\r\nDo we need to add an ID? It seems that only the error message is different.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-18T11:09:28Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)",
    "line": 109
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "https://github.com/apache/spark/pull/25486",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-18T12:00:14Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)",
    "line": 109
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "It seems that we need to mention the existing JIRA issue for `distinct a,a,c order by c using ~<~,a`?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:25:38Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)",
    "line": 119
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "SPARK-28010 or a new one for `USING` syntax.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:26:48Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)",
    "line": 119
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "@maropu These are operators?\r\n```\r\npostgres=# \\do ~*~\r\n                                     List of operators\r\n   Schema   | Name | Left arg type | Right arg type | Result type |       Description\r\n------------+------+---------------+----------------+-------------+-------------------------\r\n pg_catalog | ~<=~ | character     | character      | boolean     | less than or equal\r\n pg_catalog | ~<=~ | text          | text           | boolean     | less than or equal\r\n pg_catalog | ~<~  | character     | character      | boolean     | less than\r\n pg_catalog | ~<~  | text          | text           | boolean     | less than\r\n pg_catalog | ~>=~ | character     | character      | boolean     | greater than or equal\r\n pg_catalog | ~>=~ | text          | text           | boolean     | greater than or equal\r\n pg_catalog | ~>~  | character     | character      | boolean     | greater than\r\n pg_catalog | ~>~  | text          | text           | boolean     | greater than\r\n pg_catalog | ~~   | bytea         | bytea          | boolean     | matches LIKE expression\r\n pg_catalog | ~~   | character     | text           | boolean     | matches LIKE expression\r\n pg_catalog | ~~   | name          | text           | boolean     | matches LIKE expression\r\n pg_catalog | ~~   | text          | text           | boolean     | matches LIKE expression\r\n(12 rows)\r\n```",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:25:00Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)",
    "line": 119
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "https://issues.apache.org/jira/browse/SPARK-28768",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-18T10:59:11Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)",
    "line": 119
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "@wangyum and @maropu .\r\n\r\nShall we use `BINARY` as we did at [strings.sql](https://github.com/apache/spark/pull/24923)?\r\n```\r\ncreate table bytea_test_table(v BINARY);\r\n```\r\n\r\nAfter that, we are able to remove line 212 and focus on our next steps.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:39:59Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Ur, right. I missed it. bytea is binary.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T03:18:13Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Maybe, something like the following? And, do we have a JIRA for `decode`?\r\n```\r\ninsert into bytea_test_table values(decode('aa', 'utf-8'));\r\n```",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:42:16Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));",
    "line": 218
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "It's https://issues.apache.org/jira/browse/SPARK-28121",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:26:49Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));",
    "line": 218
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "File a JIRA issue?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:47:15Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions with filter\n+-- FILTER tests\n+\n+-- select min(unique1) filter (where unique1 > 100) from tenk1;\n+\n+-- select sum(1/ten) filter (where ten > 0) from tenk1;\n+\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+-- select ten, sum(distinct four) filter (where four > 10) from onek a\n+-- group by ten\n+-- having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- [SPARK-28682] ANSI SQL: Collation Support\n+-- select max(foo COLLATE \"C\") filter (where (bar collate \"POSIX\") > '0')\n+-- from (values ('a', 'b')) AS v(foo,bar);\n+\n+-- outer reference in FILTER (PostgreSQL extension)\n+select (select count(*)\n+        from (values (1)) t0(inner_c))\n+from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "I think we should revert it to original query. We can not support Aggregate Expressions with filter.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:28:45Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions with filter\n+-- FILTER tests\n+\n+-- select min(unique1) filter (where unique1 > 100) from tenk1;\n+\n+-- select sum(1/ten) filter (where ten > 0) from tenk1;\n+\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+-- select ten, sum(distinct four) filter (where four > 10) from onek a\n+-- group by ten\n+-- having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- [SPARK-28682] ANSI SQL: Collation Support\n+-- select max(foo COLLATE \"C\") filter (where (bar collate \"POSIX\") > '0')\n+-- from (values ('a', 'b')) AS v(foo,bar);\n+\n+-- outer reference in FILTER (PostgreSQL extension)\n+select (select count(*)\n+        from (values (1)) t0(inner_c))\n+from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "File a JIRA issue?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:47:27Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions with filter\n+-- FILTER tests\n+\n+-- select min(unique1) filter (where unique1 > 100) from tenk1;\n+\n+-- select sum(1/ten) filter (where ten > 0) from tenk1;\n+\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+-- select ten, sum(distinct four) filter (where four > 10) from onek a\n+-- group by ten\n+-- having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- [SPARK-28682] ANSI SQL: Collation Support\n+-- select max(foo COLLATE \"C\") filter (where (bar collate \"POSIX\") > '0')\n+-- from (values ('a', 'b')) AS v(foo,bar);\n+\n+-- outer reference in FILTER (PostgreSQL extension)\n+select (select count(*)\n+        from (values (1)) t0(inner_c))\n+from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses\n+-- select (select count(*) filter (where outer_c <> 0)\n+--         from (values (1)) t0(inner_c))\n+-- from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Found an aggregate expression in a correlated predicate that has both outer and local references"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "I think we should revert it to original query. We can not support Aggregate Expressions with filter.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:28:55Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions with filter\n+-- FILTER tests\n+\n+-- select min(unique1) filter (where unique1 > 100) from tenk1;\n+\n+-- select sum(1/ten) filter (where ten > 0) from tenk1;\n+\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+-- select ten, sum(distinct four) filter (where four > 10) from onek a\n+-- group by ten\n+-- having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- [SPARK-28682] ANSI SQL: Collation Support\n+-- select max(foo COLLATE \"C\") filter (where (bar collate \"POSIX\") > '0')\n+-- from (values ('a', 'b')) AS v(foo,bar);\n+\n+-- outer reference in FILTER (PostgreSQL extension)\n+select (select count(*)\n+        from (values (1)) t0(inner_c))\n+from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses\n+-- select (select count(*) filter (where outer_c <> 0)\n+--         from (values (1)) t0(inner_c))\n+-- from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Found an aggregate expression in a correlated predicate that has both outer and local references"
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "From line 252 ~ 268, I understand the reason why you add comments like `Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clause`. But, let's have an explicit JIRA ID. Otherwise, let's not add the comment here.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-11T00:50:50Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions with filter\n+-- FILTER tests\n+\n+-- select min(unique1) filter (where unique1 > 100) from tenk1;\n+\n+-- select sum(1/ten) filter (where ten > 0) from tenk1;\n+\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+-- select ten, sum(distinct four) filter (where four > 10) from onek a\n+-- group by ten\n+-- having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- [SPARK-28682] ANSI SQL: Collation Support\n+-- select max(foo COLLATE \"C\") filter (where (bar collate \"POSIX\") > '0')\n+-- from (values ('a', 'b')) AS v(foo,bar);\n+\n+-- outer reference in FILTER (PostgreSQL extension)\n+select (select count(*)\n+        from (values (1)) t0(inner_c))\n+from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses\n+-- select (select count(*) filter (where outer_c <> 0)\n+--         from (values (1)) t0(inner_c))\n+-- from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Found an aggregate expression in a correlated predicate that has both outer and local references\n+-- select (select count(inner_c) filter (where outer_c <> 0)\n+--         from (values (1)) t0(inner_c))\n+-- from (values (2),(3)) t1(outer_c); -- inner query is aggregation query\n+-- Can not rewrite this pattern: aggregate_name(sub-query) filter()\n+-- select\n+--   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))\n+--      filter (where o.unique1 < 10))\n+-- from tenk1 o;\t\t\t\t\t-- outer query is aggregation query\n+-- subquery in FILTER clause (PostgreSQL extension)\n+-- Rewriting to CASE WHEN will hit: IN/EXISTS predicate sub-queries can only be used in a Filter\n+-- select sum(unique1) FILTER (WHERE\n+--  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;",
    "line": 265
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Yes. We should revert it to original query.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-16T12:29:45Z",
    "diffHunk": "@@ -0,0 +1,273 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- [SPARK-9830] It is not allowed to use an aggregate function in the argument of another aggregate function\n+-- check for correct detection of nested-aggregate errors\n+-- select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns\n+-- multi-arg aggs, strict/nonstrict, distinct/order by\n+\n+-- select aggfstr(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+-- select aggfns(a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select aggfstr(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- select aggfstr(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+-- select aggfns(distinct a,b,c order by b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,3) i;\n+\n+-- test specific code paths\n+\n+-- select aggfns(distinct a,a,c order by c using ~<~,a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by c using ~<~)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--        generate_series(1,2) i;\n+\n+-- check node I/O via view creation and usage, also deparsing logic\n+\n+-- create view agg_view1 as\n+--   select aggfns(a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,3) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by b+1)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,a,c order by b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(a,b,c order by c using ~<~)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- create or replace view agg_view1 as\n+--   select aggfns(distinct a,b,c order by a,c using ~<~,b)\n+--     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),\n+--          generate_series(1,2) i;\n+\n+-- select * from agg_view1;\n+-- select pg_get_viewdef('agg_view1'::regclass);\n+\n+-- drop view agg_view1;\n+\n+-- incorrect DISTINCT usage errors\n+\n+-- select aggfns(distinct a,b,c order by i)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b+1)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,b,c order by a,b,i,c)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+-- select aggfns(distinct a,a,c order by a,b)\n+--   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;\n+\n+-- [SPARK-27978] Add built-in Aggregate Functions: string_agg\n+-- string_agg tests\n+-- select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);\n+-- select string_agg(a,',') from (values(null),(null)) g(a);\n+\n+-- check some implicit casting cases, as per bug #5564\n+-- select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok\n+-- select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok\n+-- select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok\n+\n+-- Skip these tests because we do not have a bytea type\n+-- string_agg bytea tests\n+-- create table bytea_test_table(v bytea);\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('ff','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+\n+-- insert into bytea_test_table values(decode('aa','hex'));\n+\n+-- select string_agg(v, '') from bytea_test_table;\n+-- select string_agg(v, NULL) from bytea_test_table;\n+-- select string_agg(v, decode('ee', 'hex')) from bytea_test_table;\n+\n+-- drop table bytea_test_table;\n+\n+-- [SPARK-27986] Support Aggregate Expressions with filter\n+-- FILTER tests\n+\n+-- select min(unique1) filter (where unique1 > 100) from tenk1;\n+\n+-- select sum(1/ten) filter (where ten > 0) from tenk1;\n+\n+-- select ten, sum(distinct four) filter (where four::text ~ '123') from onek a\n+-- group by ten;\n+\n+-- select ten, sum(distinct four) filter (where four > 10) from onek a\n+-- group by ten\n+-- having exists (select 1 from onek b where sum(distinct a.four) = b.four);\n+\n+-- [SPARK-28682] ANSI SQL: Collation Support\n+-- select max(foo COLLATE \"C\") filter (where (bar collate \"POSIX\") > '0')\n+-- from (values ('a', 'b')) AS v(foo,bar);\n+\n+-- outer reference in FILTER (PostgreSQL extension)\n+select (select count(*)\n+        from (values (1)) t0(inner_c))\n+from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses\n+-- select (select count(*) filter (where outer_c <> 0)\n+--         from (values (1)) t0(inner_c))\n+-- from (values (2),(3)) t1(outer_c);\n+-- Rewriting to CASE WHEN will hit: Found an aggregate expression in a correlated predicate that has both outer and local references\n+-- select (select count(inner_c) filter (where outer_c <> 0)\n+--         from (values (1)) t0(inner_c))\n+-- from (values (2),(3)) t1(outer_c); -- inner query is aggregation query\n+-- Can not rewrite this pattern: aggregate_name(sub-query) filter()\n+-- select\n+--   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))\n+--      filter (where o.unique1 < 10))\n+-- from tenk1 o;\t\t\t\t\t-- outer query is aggregation query\n+-- subquery in FILTER clause (PostgreSQL extension)\n+-- Rewriting to CASE WHEN will hit: IN/EXISTS predicate sub-queries can only be used in a Filter\n+-- select sum(unique1) FILTER (WHERE\n+--  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;",
    "line": 265
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Out of curiosity, why didn't we file a JIRA here? Even if we explicitly don't support, it's better to file a JIRA and resolve it as `Won't Fix`.",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-25T02:04:30Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests."
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-25T10:00:58Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests."
  }],
  "prId": 24829
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Then should it be \"Skip the test below because it requires 4 UDAFs:\"?",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-25T02:07:00Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- check for correct detection of nested-aggregate errors\n+select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "33650461aa18b66f5d69c032113efd264ebb4bea",
    "createdAt": "2019-08-25T10:00:52Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 3]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/aggregates.sql#L352-L605\n+\n+-- We do not support inheritance tree, skip related tests.\n+-- try it on an inheritance tree\n+-- create table minmaxtest(f1 int);\n+-- create table minmaxtest1() inherits (minmaxtest);\n+-- create table minmaxtest2() inherits (minmaxtest);\n+-- create table minmaxtest3() inherits (minmaxtest);\n+-- create index minmaxtesti on minmaxtest(f1);\n+-- create index minmaxtest1i on minmaxtest1(f1);\n+-- create index minmaxtest2i on minmaxtest2(f1 desc);\n+-- create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;\n+\n+-- insert into minmaxtest values(11), (12);\n+-- insert into minmaxtest1 values(13), (14);\n+-- insert into minmaxtest2 values(15), (16);\n+-- insert into minmaxtest3 values(17), (18);\n+\n+-- explain (costs off)\n+--   select min(f1), max(f1) from minmaxtest;\n+-- select min(f1), max(f1) from minmaxtest;\n+\n+-- DISTINCT doesn't do anything useful here, but it shouldn't fail\n+-- explain (costs off)\n+--   select distinct min(f1), max(f1) from minmaxtest;\n+-- select distinct min(f1), max(f1) from minmaxtest;\n+\n+-- drop table minmaxtest cascade;\n+\n+-- check for correct detection of nested-aggregate errors\n+select max(min(unique1)) from tenk1;\n+-- select (select max(min(unique1)) from int8_tbl) from tenk1;\n+\n+-- These tests only test the explain. Skip these tests.\n+--\n+-- Test removal of redundant GROUP BY columns\n+--\n+\n+-- create temp table t1 (a int, b int, c int, d int, primary key (a, b));\n+-- create temp table t2 (x int, y int, z int, primary key (x, y));\n+-- create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);\n+\n+-- Non-primary-key columns can be removed from GROUP BY\n+-- explain (costs off) select * from t1 group by a,b,c,d;\n+\n+-- No removal can happen if the complete PK is not present in GROUP BY\n+-- explain (costs off) select a,c from t1 group by a,c,d;\n+\n+-- Test removal across multiple relations\n+-- explain (costs off) select *\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;\n+\n+-- Test case where t1 can be optimized but not t2\n+-- explain (costs off) select t1.*,t2.x,t2.z\n+-- from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y\n+-- group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;\n+\n+-- Cannot optimize when PK is deferrable\n+-- explain (costs off) select * from t3 group by a,b,c;\n+\n+-- drop table t1;\n+-- drop table t2;\n+-- drop table t3;\n+\n+-- [SPARK-27974] Add built-in Aggregate Function: array_agg\n+--\n+-- Test combinations of DISTINCT and/or ORDER BY\n+--\n+\n+-- select array_agg(a order by b)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(a order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+-- select array_agg(b order by a desc)\n+--   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);\n+\n+-- select array_agg(distinct a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+-- select array_agg(distinct a order by a desc nulls last)\n+--   from (values (1),(2),(1),(3),(null),(2)) v(a);\n+\n+-- Skip the test below because it requires 4 UDFs: aggf_trans, aggfns_trans, aggfstr, and aggfns"
  }],
  "prId": 24829
}]