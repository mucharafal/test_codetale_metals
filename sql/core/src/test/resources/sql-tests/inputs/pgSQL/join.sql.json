[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Shall we use `upper case` like `CREATE OR ...`?",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:11:29Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from"
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "nit. The JIRA title seems to be just an error message.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:34:00Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated",
    "line": 874
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Yes. I do not know the root cause.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-29T14:25:36Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated",
    "line": 874
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "JIRA ID?",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:36:11Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Do we need to support this?\r\nhttps://www.postgresql.org/docs/11/infoschema-schema.html",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-29T14:19:22Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "No. There is a JIRA about `information_schema` and we need to reference them explicitly.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-29T15:54:05Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`SPARK-16452` might be the one.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-30T00:37:20Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Added it.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-30T02:32:02Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type"
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's comment out the above three since we didn't create them.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:49:58Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type\n+-- select ss1.d1 from\n+--   tenk1 as t1\n+--   inner join tenk1 as t2\n+--   on t1.tenthous = t2.ten\n+--   inner join\n+--     int8_tbl as i8\n+--     left join int4_tbl as i4\n+--       inner join (select 64::information_schema.cardinal_number as d1\n+--                   from tenk1 t3,\n+--                        lateral (select abs(t3.unique1) + random()) ss0(x)\n+--                   where t3.fivethous < 0) as ss1\n+--       on i4.f1 = ss1.d1\n+--     on i8.q1 = i4.f1\n+--   on t1.tenthous = ss1.d1\n+-- where t1.unique1 < i4.f1;\n+\n+-- this variant is foldable by the remove-useless-RESULT-RTEs code\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+--\n+-- test extraction of restriction OR clauses from join OR clause\n+-- (we used to only do this for indexable clauses)\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or\n+--   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);\n+\n+--\n+-- test placement of movable quals in a parameterized join tree\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+--   join int4_tbl on b.thousand = f1;\n+\n+select count(*) from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+  join int4_tbl on b.thousand = f1;\n+\n+-- explain (costs off)\n+-- select b.unique1 from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+--   join int4_tbl i1 on b.thousand = f1\n+--   right join int4_tbl i2 on i2.f1 = b.tenthous\n+--   order by 1;\n+\n+select b.unique1 from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+  join int4_tbl i1 on b.thousand = f1\n+  right join int4_tbl i2 on i2.f1 = b.tenthous\n+  order by 1;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (\n+--   select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+--   from int8_tbl left join tenk1 on (q2 = unique2)\n+-- ) ss\n+-- where fault = 122\n+-- order by fault;\n+\n+select * from\n+(\n+  select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+  from int8_tbl left join tenk1 on (q2 = unique2)\n+) ss\n+where fault = 122\n+order by fault;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+-- [SPARK-28382] Array Functions: unnest\n+-- select * from\n+-- (values (1, array(10,20)), (2, array(20,30))) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+--\n+-- test handling of potential equivalence clauses above outer joins\n+--\n+\n+-- explain (costs off)\n+-- select q1, unique2, thousand, hundred\n+--   from int8_tbl a left join tenk1 b on q1 = unique2\n+--   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+select q1, unique2, thousand, hundred\n+  from int8_tbl a left join tenk1 b on q1 = unique2\n+  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+-- explain (costs off)\n+-- select f1, unique2, case when unique2 is null then f1 else 0 end\n+--   from int4_tbl a left join tenk1 b on f1 = unique2\n+--   where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+select f1, unique2, case when unique2 is null then f1 else 0 end\n+  from int4_tbl a left join tenk1 b on f1 = unique2\n+  where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+--\n+-- another case with equivalence clauses above outer joins (bug #8591)\n+--\n+\n+-- explain (costs off)\n+-- select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+--   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+--   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+--\n+-- check handling of join aliases when flattening multiple levels of subquery\n+--\n+\n+-- explain (verbose, costs off)\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+-- [SPARK-20856] Support statement using nested joins\n+--\n+-- test successful handling of nested outer joins with degenerate join quals\n+--\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   inner join int8_tbl i8\n+--   on i8.q2 = 456\n+--   right join text_tbl t2\n+--   on t1.f1 = 'doh!'\n+--   left join int4_tbl i4\n+--   on i8.q1 = i4.f1;\n+\n+select * from\n+  text_tbl t1\n+  inner join int8_tbl i8\n+  on i8.q2 = 456\n+  right join text_tbl t2\n+  on t1.f1 = 'doh!'\n+  left join int4_tbl i4\n+  on i8.q1 = i4.f1;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- test for appropriate join order in the presence of lateral references\n+--\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- explain (verbose, costs off)\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+--\n+-- check a case in which a PlaceHolderVar forces join order\n+--\n+\n+-- explain (verbose, costs off)\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+--\n+-- test successful handling of full join underneath left join (bug #14105)\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   (select 1 as id) as xx\n+--   left join\n+--     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+--   on (xx.id = coalesce(yy.id));\n+\n+select * from\n+  (select 1 as id) as xx\n+  left join\n+    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+  on (xx.id = coalesce(yy.id));\n+\n+--\n+-- test ability to push constants through outer join clauses\n+--\n+\n+-- explain (costs off)\n+--   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;\n+\n+-- explain (costs off)\n+--   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;\n+\n+--\n+-- test that quals attached to an outer join have correct semantics,\n+-- specifically that they don't re-use expressions computed below the join;\n+-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input\n+--\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- explain (verbose, costs off)\n+--   select a.q2, b.q1\n+--     from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+--     where coalesce(b.q1, 1) > 0;\n+select a.q2, b.q1\n+  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+  where coalesce(b.q1, 1) > 0;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test join removal\n+--\n+\n+-- begin;\n+\n+-- CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);\n+-- CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);\n+-- CREATE TEMP TABLE c (id int PRIMARY KEY);\n+-- CREATE TEMP TABLE d (a int, b int);\n+-- INSERT INTO a VALUES (0, 0), (1, NULL);\n+-- INSERT INTO b VALUES (0, 0), (1, NULL);\n+-- INSERT INTO c VALUES (0), (1);\n+-- INSERT INTO d VALUES (1,3), (2,2), (3,1);\n+\n+-- all three cases should be optimizable into a simple seqscan\n+-- explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;\n+-- explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;\n+-- explain (costs off)\n+--   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)\n+--   ON (a.b_id = b.id);\n+\n+-- check optimization of outer join within another special join\n+-- explain (costs off)\n+-- select id from a where id in (\n+-- \tselect b.id from b left join c on b.id = c.id\n+-- );\n+\n+-- check that join removal works for a left join when joining a subquery\n+-- that is guaranteed to be unique by its GROUP BY clause\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- join removal is not possible when the GROUP BY contains a column that is\n+-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a\n+-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;\n+-- but this happens too late for join removal in the outer plan level.)\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal works when uniqueness of the join condition is enforced\n+-- by a UNION\n+-- explain (costs off)\n+-- select d.* from d left join (select id from a union select id from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal with a cross-type comparison operator\n+-- explain (costs off)\n+-- select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4\n+--   on i8.q1 = i4.f1;\n+\n+-- check join removal with lateral references\n+-- explain (costs off)\n+-- select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,\n+-- \t\t\t  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;\n+\n+-- rollback;\n+\n+create or replace temporary view parent as select * from\n+  (values (1, 10), (2, 20), (3, 30))\n+  as v(k, pd);\n+create or replace temporary view child as select * from\n+  (values (1, 100), (4, 400))\n+  as v(k, cd);\n+\n+-- this case is optimizable\n+select p.* from parent p left join child c on (p.k = c.k);\n+-- explain (costs off)\n+--   select p.* from parent p left join child c on (p.k = c.k);\n+\n+-- this case is not\n+select p.*, linked from parent p\n+  left join (select c.*, true as linked from child c) as ss\n+  on (p.k = ss.k);\n+-- explain (costs off)\n+--   select p.*, linked from parent p\n+--     left join (select c.*, true as linked from child c) as ss\n+--     on (p.k = ss.k);\n+\n+-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling\n+select p.* from\n+  parent p left join child c on (p.k = c.k)\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   parent p left join child c on (p.k = c.k)\n+--   where p.k = 1 and p.k = 2;\n+\n+select p.* from\n+  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+--   where p.k = 1 and p.k = 2;\n+\n+-- bug 5255: this is not optimizable by join removal\n+-- begin;\n+\n+create or replace temporary view a as select * from\n+  (values (0), (1))\n+  as v(id);\n+create or replace temporary view b as select * from\n+  (values (0, 0), (1, NULL))\n+  as v(id, a_id);\n+\n+SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+\n+-- rollback;\n+\n+-- another join removal bug: this is not optimizable, either\n+-- begin;\n+\n+create or replace temporary view innertab as select * from\n+  (values (123L, 42L))\n+  as v(id, dat1);\n+\n+SELECT * FROM\n+    (SELECT 1 AS x) ss1\n+  LEFT JOIN\n+    (SELECT q1, q2, COALESCE(dat1, q1) AS y\n+     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2\n+  ON true;\n+\n+-- rollback;\n+\n+-- another join removal bug: we must clean up correctly when removing a PHV\n+-- begin;\n+\n+-- create temp table uniquetbl (f1 text unique);\n+\n+-- explain (costs off)\n+-- select t1.* from\n+--   uniquetbl as t1\n+--   left join (select *, '***'::text as d1 from uniquetbl) t2\n+--   on t1.f1 = t2.f1\n+--   left join uniquetbl t3\n+--   on t2.d1 = t3.f1;\n+\n+-- explain (costs off)\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- [SPARK-27987] Support POSIX Regular Expressions\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- rollback;\n+\n+-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs\n+\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok\n+\n+--\n+-- Test hints given on incorrect column references are useful\n+--\n+\n+select t1.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t1\" suggestion\n+select t2.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t2\" suggestion\n+select uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once\n+\n+-- Skip this test because it is a PostgreSQL specific case\n+--\n+-- Take care to reference the correct RTE\n+--\n+\n+-- -- select atts.relid::regclass, s.* from pg_stats s join\n+-- --     pg_attribute a on s.attname = a.attname and s.tablename =\n+-- --     a.attrelid::regclass::text join (select unnest(indkey) attnum,\n+-- --     indexrelid from pg_index i) atts on atts.attnum = a.attnum where\n+--     schemaname != 'pg_catalog';\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- Test LATERAL\n+--\n+\n+-- select unique2, x.*\n+-- from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- select unique2, x.*\n+-- from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- select unique2, x.*\n+-- from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+-- check scoping of lateral versus parent references\n+-- the first of these should return int8_tbl.q2, the second int8_tbl.q1\n+-- select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;\n+-- select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;\n+\n+-- lateral with function in FROM\n+-- select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;\n+-- don't need the explicit LATERAL keyword for functions\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, generate_series(1,two) g;\n+\n+-- lateral with UNION ALL subselect\n+-- explain (costs off)\n+--   select * from generate_series(100,200) g,\n+--     lateral (select * from int8_tbl a where g = q1 union all\n+--              select * from int8_tbl b where g = q2) ss;\n+-- select * from generate_series(100,200) g,\n+--   lateral (select * from int8_tbl a where g = q1 union all\n+--            select * from int8_tbl b where g = q2) ss;\n+\n+-- lateral with VALUES\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral with VALUES, no flattening possible\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral injecting a strange outer join condition\n+-- explain (costs off)\n+--   select * from int8_tbl a,\n+--     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--       on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+-- select * from int8_tbl a,\n+--   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--     on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+\n+-- lateral reference to a join alias variable\n+-- select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (select x) ss2(y);\n+-- select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (values(x)) ss2(y);\n+-- select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,\n+--   lateral (select x) ss2(y);\n+\n+-- lateral references requiring pullup\n+-- select * from (values(1)) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (select f1/1000000000 from int4_tbl) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (values(1)) x(lb),\n+--   lateral (values(lb)) y(lbcopy);\n+-- select * from (values(1)) x(lb),\n+--   lateral (select lb from int4_tbl) y(lbcopy);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select x.* from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+\n+-- lateral can result in join conditions appearing below their\n+-- real semantic level\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+\n+-- lateral reference in a PlaceHolderVar evaluated at join level\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+\n+-- case requiring nested PlaceHolderVars\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select ss2.y offset 0) ss3;\n+\n+-- case that breaks the old ph_may_need optimization\n+-- explain (verbose, costs off)\n+-- select c.*,a.*,ss1.q1,ss2.q1,ss3.* from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join\n+--       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2\n+--        where q1 < f1) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select * from int4_tbl i where ss2.y > f1) ss3;\n+\n+-- check processing of postponed quals (bug #9041)\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (select 1 as x offset 0) x cross join (select 2 as y offset 0) y\n+--   left join lateral (\n+--     select * from (select 3 as z offset 0) z where z.z = x.x\n+--   ) zz on zz.z = y.y;\n+\n+-- check dummy rels with lateral references (bug #15694)\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl where false) ss on true;\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;\n+\n+-- check handling of nested appendrels inside LATERAL\n+-- select * from\n+--   ((select 2 as v) union all (select 3 as v)) as q1\n+--   cross join lateral\n+--   ((select * from\n+--       ((select 4 as v) union all (select 5 as v)) as q3)\n+--    union all\n+--    (select q1.v)\n+--   ) as q2;\n+\n+-- check we don't try to do a unique-ified semijoin with LATERAL\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+\n+-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,\n+-- but we can make the test case much more compact with LATERAL)\n+-- explain (verbose, costs off)\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- test some error cases where LATERAL should have been used but wasn't\n+select f1,g from int4_tbl a, (select f1 as g) ss;\n+select f1,g from int4_tbl a, (select a.f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select a.f1 as g) ss;\n+-- SQL:2008 says the left table is in scope but illegal to access here\n+-- select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;\n+-- select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;\n+-- check we complain about ambiguous table references\n+-- select * from\n+--   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);\n+-- LATERAL can be used to put an aggregate into the FROM clause of its query\n+-- select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;\n+\n+-- check behavior of LATERAL in UPDATE/DELETE\n+\n+-- create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;\n+\n+-- error, can't do this:\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- can't do it even with LATERAL:\n+-- update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;\n+-- we might in future allow something like this, but for now it's an error:\n+-- update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- also errors:\n+-- delete from xx1 using (select * from int4_tbl where f1 = x1) ss;\n+-- delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- [SPARK-25411] Implement range partition in Spark\n+--\n+-- test LATERAL reference propagation down a multi-level inheritance hierarchy\n+-- produced for a multi-level partitioned table hierarchy.\n+--\n+-- create table join_pt1 (a int, b int, c varchar) partition by range(a);\n+-- create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);\n+-- create table join_pt1p2 partition of join_pt1 for values from (100) to (200);\n+-- create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);\n+-- insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');\n+-- create table join_ut1 (a int, b int, c varchar);\n+-- insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');\n+-- explain (verbose, costs off)\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+--\n+-- drop table join_pt1;\n+-- drop table join_ut1;\n+--\n+-- test that foreign key join estimation performs sanely for outer joins\n+--\n+\n+-- begin;\n+\n+-- create table fkest (a int, b int, c int unique, primary key(a,b));\n+-- create table fkest1 (a int, b int, primary key(a,b));\n+\n+-- insert into fkest select x/10, x%10, x from generate_series(1,1000) x;\n+-- insert into fkest1 select x/10, x%10 from generate_series(1,1000) x;\n+\n+-- alter table fkest1\n+--   add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;\n+\n+-- analyze fkest;\n+-- analyze fkest1;\n+\n+-- explain (costs off)\n+-- select *\n+-- from fkest f\n+--   left join fkest1 f1 on f.a = f1.a and f.b = f1.b\n+--   left join fkest1 f2 on f.a = f2.a and f.b = f2.b\n+--   left join fkest1 f3 on f.a = f3.a and f.b = f3.b\n+-- where f.c = 1;\n+\n+-- rollback;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test planner's ability to mark joins as unique\n+--\n+\n+-- create table j1 (id int primary key);\n+-- create table j2 (id int primary key);\n+-- create table j3 (id int);\n+\n+-- insert into j1 values(1),(2),(3);\n+-- insert into j2 values(1),(2),(3);\n+-- insert into j3 values(1),(1);\n+\n+-- analyze j1;\n+-- analyze j2;\n+-- analyze j3;\n+\n+-- ensure join is properly marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id = j2.id;\n+\n+-- ensure join is not unique when not an equi-join\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id > j2.id;\n+\n+-- ensure non-unique rel is not chosen as inner\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j3 on j1.id = j3.id;\n+\n+-- ensure left join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 left join j2 on j1.id = j2.id;\n+\n+-- ensure right join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 right join j2 on j1.id = j2.id;\n+\n+-- ensure full join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 full join j2 on j1.id = j2.id;\n+\n+-- a clauseless (cross) join can't be unique\n+-- explain (verbose, costs off)\n+-- select * from j1 cross join j2;\n+\n+-- ensure a natural join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 natural join j2;\n+\n+-- ensure a distinct clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select distinct id from j3) j3 on j1.id = j3.id;\n+\n+-- ensure group by clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select id from j3 group by id) j3 on j1.id = j3.id;\n+\n+drop table if exists j1;\n+drop table if exists j2;\n+drop table if exists j3;"
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's comment out `j3` since we are not going to use it.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:50:27Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type\n+-- select ss1.d1 from\n+--   tenk1 as t1\n+--   inner join tenk1 as t2\n+--   on t1.tenthous = t2.ten\n+--   inner join\n+--     int8_tbl as i8\n+--     left join int4_tbl as i4\n+--       inner join (select 64::information_schema.cardinal_number as d1\n+--                   from tenk1 t3,\n+--                        lateral (select abs(t3.unique1) + random()) ss0(x)\n+--                   where t3.fivethous < 0) as ss1\n+--       on i4.f1 = ss1.d1\n+--     on i8.q1 = i4.f1\n+--   on t1.tenthous = ss1.d1\n+-- where t1.unique1 < i4.f1;\n+\n+-- this variant is foldable by the remove-useless-RESULT-RTEs code\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+--\n+-- test extraction of restriction OR clauses from join OR clause\n+-- (we used to only do this for indexable clauses)\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or\n+--   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);\n+\n+--\n+-- test placement of movable quals in a parameterized join tree\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+--   join int4_tbl on b.thousand = f1;\n+\n+select count(*) from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+  join int4_tbl on b.thousand = f1;\n+\n+-- explain (costs off)\n+-- select b.unique1 from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+--   join int4_tbl i1 on b.thousand = f1\n+--   right join int4_tbl i2 on i2.f1 = b.tenthous\n+--   order by 1;\n+\n+select b.unique1 from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+  join int4_tbl i1 on b.thousand = f1\n+  right join int4_tbl i2 on i2.f1 = b.tenthous\n+  order by 1;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (\n+--   select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+--   from int8_tbl left join tenk1 on (q2 = unique2)\n+-- ) ss\n+-- where fault = 122\n+-- order by fault;\n+\n+select * from\n+(\n+  select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+  from int8_tbl left join tenk1 on (q2 = unique2)\n+) ss\n+where fault = 122\n+order by fault;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+-- [SPARK-28382] Array Functions: unnest\n+-- select * from\n+-- (values (1, array(10,20)), (2, array(20,30))) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+--\n+-- test handling of potential equivalence clauses above outer joins\n+--\n+\n+-- explain (costs off)\n+-- select q1, unique2, thousand, hundred\n+--   from int8_tbl a left join tenk1 b on q1 = unique2\n+--   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+select q1, unique2, thousand, hundred\n+  from int8_tbl a left join tenk1 b on q1 = unique2\n+  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+-- explain (costs off)\n+-- select f1, unique2, case when unique2 is null then f1 else 0 end\n+--   from int4_tbl a left join tenk1 b on f1 = unique2\n+--   where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+select f1, unique2, case when unique2 is null then f1 else 0 end\n+  from int4_tbl a left join tenk1 b on f1 = unique2\n+  where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+--\n+-- another case with equivalence clauses above outer joins (bug #8591)\n+--\n+\n+-- explain (costs off)\n+-- select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+--   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+--   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+--\n+-- check handling of join aliases when flattening multiple levels of subquery\n+--\n+\n+-- explain (verbose, costs off)\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+-- [SPARK-20856] Support statement using nested joins\n+--\n+-- test successful handling of nested outer joins with degenerate join quals\n+--\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   inner join int8_tbl i8\n+--   on i8.q2 = 456\n+--   right join text_tbl t2\n+--   on t1.f1 = 'doh!'\n+--   left join int4_tbl i4\n+--   on i8.q1 = i4.f1;\n+\n+select * from\n+  text_tbl t1\n+  inner join int8_tbl i8\n+  on i8.q2 = 456\n+  right join text_tbl t2\n+  on t1.f1 = 'doh!'\n+  left join int4_tbl i4\n+  on i8.q1 = i4.f1;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- test for appropriate join order in the presence of lateral references\n+--\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- explain (verbose, costs off)\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+--\n+-- check a case in which a PlaceHolderVar forces join order\n+--\n+\n+-- explain (verbose, costs off)\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+--\n+-- test successful handling of full join underneath left join (bug #14105)\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   (select 1 as id) as xx\n+--   left join\n+--     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+--   on (xx.id = coalesce(yy.id));\n+\n+select * from\n+  (select 1 as id) as xx\n+  left join\n+    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+  on (xx.id = coalesce(yy.id));\n+\n+--\n+-- test ability to push constants through outer join clauses\n+--\n+\n+-- explain (costs off)\n+--   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;\n+\n+-- explain (costs off)\n+--   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;\n+\n+--\n+-- test that quals attached to an outer join have correct semantics,\n+-- specifically that they don't re-use expressions computed below the join;\n+-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input\n+--\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- explain (verbose, costs off)\n+--   select a.q2, b.q1\n+--     from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+--     where coalesce(b.q1, 1) > 0;\n+select a.q2, b.q1\n+  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+  where coalesce(b.q1, 1) > 0;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test join removal\n+--\n+\n+-- begin;\n+\n+-- CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);\n+-- CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);\n+-- CREATE TEMP TABLE c (id int PRIMARY KEY);\n+-- CREATE TEMP TABLE d (a int, b int);\n+-- INSERT INTO a VALUES (0, 0), (1, NULL);\n+-- INSERT INTO b VALUES (0, 0), (1, NULL);\n+-- INSERT INTO c VALUES (0), (1);\n+-- INSERT INTO d VALUES (1,3), (2,2), (3,1);\n+\n+-- all three cases should be optimizable into a simple seqscan\n+-- explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;\n+-- explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;\n+-- explain (costs off)\n+--   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)\n+--   ON (a.b_id = b.id);\n+\n+-- check optimization of outer join within another special join\n+-- explain (costs off)\n+-- select id from a where id in (\n+-- \tselect b.id from b left join c on b.id = c.id\n+-- );\n+\n+-- check that join removal works for a left join when joining a subquery\n+-- that is guaranteed to be unique by its GROUP BY clause\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- join removal is not possible when the GROUP BY contains a column that is\n+-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a\n+-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;\n+-- but this happens too late for join removal in the outer plan level.)\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal works when uniqueness of the join condition is enforced\n+-- by a UNION\n+-- explain (costs off)\n+-- select d.* from d left join (select id from a union select id from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal with a cross-type comparison operator\n+-- explain (costs off)\n+-- select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4\n+--   on i8.q1 = i4.f1;\n+\n+-- check join removal with lateral references\n+-- explain (costs off)\n+-- select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,\n+-- \t\t\t  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;\n+\n+-- rollback;\n+\n+create or replace temporary view parent as select * from\n+  (values (1, 10), (2, 20), (3, 30))\n+  as v(k, pd);\n+create or replace temporary view child as select * from\n+  (values (1, 100), (4, 400))\n+  as v(k, cd);\n+\n+-- this case is optimizable\n+select p.* from parent p left join child c on (p.k = c.k);\n+-- explain (costs off)\n+--   select p.* from parent p left join child c on (p.k = c.k);\n+\n+-- this case is not\n+select p.*, linked from parent p\n+  left join (select c.*, true as linked from child c) as ss\n+  on (p.k = ss.k);\n+-- explain (costs off)\n+--   select p.*, linked from parent p\n+--     left join (select c.*, true as linked from child c) as ss\n+--     on (p.k = ss.k);\n+\n+-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling\n+select p.* from\n+  parent p left join child c on (p.k = c.k)\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   parent p left join child c on (p.k = c.k)\n+--   where p.k = 1 and p.k = 2;\n+\n+select p.* from\n+  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+--   where p.k = 1 and p.k = 2;\n+\n+-- bug 5255: this is not optimizable by join removal\n+-- begin;\n+\n+create or replace temporary view a as select * from\n+  (values (0), (1))\n+  as v(id);\n+create or replace temporary view b as select * from\n+  (values (0, 0), (1, NULL))\n+  as v(id, a_id);\n+\n+SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+\n+-- rollback;\n+\n+-- another join removal bug: this is not optimizable, either\n+-- begin;\n+\n+create or replace temporary view innertab as select * from\n+  (values (123L, 42L))\n+  as v(id, dat1);\n+\n+SELECT * FROM\n+    (SELECT 1 AS x) ss1\n+  LEFT JOIN\n+    (SELECT q1, q2, COALESCE(dat1, q1) AS y\n+     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2\n+  ON true;\n+\n+-- rollback;\n+\n+-- another join removal bug: we must clean up correctly when removing a PHV\n+-- begin;\n+\n+-- create temp table uniquetbl (f1 text unique);\n+\n+-- explain (costs off)\n+-- select t1.* from\n+--   uniquetbl as t1\n+--   left join (select *, '***'::text as d1 from uniquetbl) t2\n+--   on t1.f1 = t2.f1\n+--   left join uniquetbl t3\n+--   on t2.d1 = t3.f1;\n+\n+-- explain (costs off)\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- [SPARK-27987] Support POSIX Regular Expressions\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- rollback;\n+\n+-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs\n+\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok\n+\n+--\n+-- Test hints given on incorrect column references are useful\n+--\n+\n+select t1.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t1\" suggestion\n+select t2.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t2\" suggestion\n+select uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once\n+\n+-- Skip this test because it is a PostgreSQL specific case\n+--\n+-- Take care to reference the correct RTE\n+--\n+\n+-- -- select atts.relid::regclass, s.* from pg_stats s join\n+-- --     pg_attribute a on s.attname = a.attname and s.tablename =\n+-- --     a.attrelid::regclass::text join (select unnest(indkey) attnum,\n+-- --     indexrelid from pg_index i) atts on atts.attnum = a.attnum where\n+--     schemaname != 'pg_catalog';\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- Test LATERAL\n+--\n+\n+-- select unique2, x.*\n+-- from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- select unique2, x.*\n+-- from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- select unique2, x.*\n+-- from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+-- check scoping of lateral versus parent references\n+-- the first of these should return int8_tbl.q2, the second int8_tbl.q1\n+-- select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;\n+-- select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;\n+\n+-- lateral with function in FROM\n+-- select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;\n+-- don't need the explicit LATERAL keyword for functions\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, generate_series(1,two) g;\n+\n+-- lateral with UNION ALL subselect\n+-- explain (costs off)\n+--   select * from generate_series(100,200) g,\n+--     lateral (select * from int8_tbl a where g = q1 union all\n+--              select * from int8_tbl b where g = q2) ss;\n+-- select * from generate_series(100,200) g,\n+--   lateral (select * from int8_tbl a where g = q1 union all\n+--            select * from int8_tbl b where g = q2) ss;\n+\n+-- lateral with VALUES\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral with VALUES, no flattening possible\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral injecting a strange outer join condition\n+-- explain (costs off)\n+--   select * from int8_tbl a,\n+--     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--       on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+-- select * from int8_tbl a,\n+--   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--     on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+\n+-- lateral reference to a join alias variable\n+-- select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (select x) ss2(y);\n+-- select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (values(x)) ss2(y);\n+-- select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,\n+--   lateral (select x) ss2(y);\n+\n+-- lateral references requiring pullup\n+-- select * from (values(1)) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (select f1/1000000000 from int4_tbl) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (values(1)) x(lb),\n+--   lateral (values(lb)) y(lbcopy);\n+-- select * from (values(1)) x(lb),\n+--   lateral (select lb from int4_tbl) y(lbcopy);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select x.* from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+\n+-- lateral can result in join conditions appearing below their\n+-- real semantic level\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+\n+-- lateral reference in a PlaceHolderVar evaluated at join level\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+\n+-- case requiring nested PlaceHolderVars\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select ss2.y offset 0) ss3;\n+\n+-- case that breaks the old ph_may_need optimization\n+-- explain (verbose, costs off)\n+-- select c.*,a.*,ss1.q1,ss2.q1,ss3.* from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join\n+--       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2\n+--        where q1 < f1) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select * from int4_tbl i where ss2.y > f1) ss3;\n+\n+-- check processing of postponed quals (bug #9041)\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (select 1 as x offset 0) x cross join (select 2 as y offset 0) y\n+--   left join lateral (\n+--     select * from (select 3 as z offset 0) z where z.z = x.x\n+--   ) zz on zz.z = y.y;\n+\n+-- check dummy rels with lateral references (bug #15694)\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl where false) ss on true;\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;\n+\n+-- check handling of nested appendrels inside LATERAL\n+-- select * from\n+--   ((select 2 as v) union all (select 3 as v)) as q1\n+--   cross join lateral\n+--   ((select * from\n+--       ((select 4 as v) union all (select 5 as v)) as q3)\n+--    union all\n+--    (select q1.v)\n+--   ) as q2;\n+\n+-- check we don't try to do a unique-ified semijoin with LATERAL\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+\n+-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,\n+-- but we can make the test case much more compact with LATERAL)\n+-- explain (verbose, costs off)\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- test some error cases where LATERAL should have been used but wasn't\n+select f1,g from int4_tbl a, (select f1 as g) ss;\n+select f1,g from int4_tbl a, (select a.f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select a.f1 as g) ss;\n+-- SQL:2008 says the left table is in scope but illegal to access here\n+-- select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;\n+-- select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;\n+-- check we complain about ambiguous table references\n+-- select * from\n+--   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);\n+-- LATERAL can be used to put an aggregate into the FROM clause of its query\n+-- select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;\n+\n+-- check behavior of LATERAL in UPDATE/DELETE\n+\n+-- create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;\n+\n+-- error, can't do this:\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- can't do it even with LATERAL:\n+-- update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;\n+-- we might in future allow something like this, but for now it's an error:\n+-- update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- also errors:\n+-- delete from xx1 using (select * from int4_tbl where f1 = x1) ss;\n+-- delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- [SPARK-25411] Implement range partition in Spark\n+--\n+-- test LATERAL reference propagation down a multi-level inheritance hierarchy\n+-- produced for a multi-level partitioned table hierarchy.\n+--\n+-- create table join_pt1 (a int, b int, c varchar) partition by range(a);\n+-- create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);\n+-- create table join_pt1p2 partition of join_pt1 for values from (100) to (200);\n+-- create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);\n+-- insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');\n+-- create table join_ut1 (a int, b int, c varchar);\n+-- insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');\n+-- explain (verbose, costs off)\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+--\n+-- drop table join_pt1;\n+-- drop table join_ut1;\n+--\n+-- test that foreign key join estimation performs sanely for outer joins\n+--\n+\n+-- begin;\n+\n+-- create table fkest (a int, b int, c int unique, primary key(a,b));\n+-- create table fkest1 (a int, b int, primary key(a,b));\n+\n+-- insert into fkest select x/10, x%10, x from generate_series(1,1000) x;\n+-- insert into fkest1 select x/10, x%10 from generate_series(1,1000) x;\n+\n+-- alter table fkest1\n+--   add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;\n+\n+-- analyze fkest;\n+-- analyze fkest1;\n+\n+-- explain (costs off)\n+-- select *\n+-- from fkest f\n+--   left join fkest1 f1 on f.a = f1.a and f.b = f1.b\n+--   left join fkest1 f2 on f.a = f2.a and f.b = f2.b\n+--   left join fkest1 f3 on f.a = f3.a and f.b = f3.b\n+-- where f.c = 1;\n+\n+-- rollback;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test planner's ability to mark joins as unique\n+--\n+\n+-- create table j1 (id int primary key);\n+-- create table j2 (id int primary key);\n+-- create table j3 (id int);\n+\n+-- insert into j1 values(1),(2),(3);\n+-- insert into j2 values(1),(2),(3);\n+-- insert into j3 values(1),(1);\n+\n+-- analyze j1;\n+-- analyze j2;\n+-- analyze j3;\n+\n+-- ensure join is properly marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id = j2.id;\n+\n+-- ensure join is not unique when not an equi-join\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id > j2.id;\n+\n+-- ensure non-unique rel is not chosen as inner\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j3 on j1.id = j3.id;\n+\n+-- ensure left join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 left join j2 on j1.id = j2.id;\n+\n+-- ensure right join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 right join j2 on j1.id = j2.id;\n+\n+-- ensure full join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 full join j2 on j1.id = j2.id;\n+\n+-- a clauseless (cross) join can't be unique\n+-- explain (verbose, costs off)\n+-- select * from j1 cross join j2;\n+\n+-- ensure a natural join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 natural join j2;\n+\n+-- ensure a distinct clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select distinct id from j3) j3 on j1.id = j3.id;\n+\n+-- ensure group by clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select id from j3 group by id) j3 on j1.id = j3.id;\n+\n+drop table if exists j1;\n+drop table if exists j2;\n+drop table if exists j3;\n+\n+-- test more complex permutations of unique joins\n+\n+create table j1 (id1 int, id2 int) using parquet;\n+create table j2 (id1 int, id2 int) using parquet;\n+create table j3 (id1 int, id2 int) using parquet;"
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's comment out j3 insertion, too.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:50:55Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type\n+-- select ss1.d1 from\n+--   tenk1 as t1\n+--   inner join tenk1 as t2\n+--   on t1.tenthous = t2.ten\n+--   inner join\n+--     int8_tbl as i8\n+--     left join int4_tbl as i4\n+--       inner join (select 64::information_schema.cardinal_number as d1\n+--                   from tenk1 t3,\n+--                        lateral (select abs(t3.unique1) + random()) ss0(x)\n+--                   where t3.fivethous < 0) as ss1\n+--       on i4.f1 = ss1.d1\n+--     on i8.q1 = i4.f1\n+--   on t1.tenthous = ss1.d1\n+-- where t1.unique1 < i4.f1;\n+\n+-- this variant is foldable by the remove-useless-RESULT-RTEs code\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+--\n+-- test extraction of restriction OR clauses from join OR clause\n+-- (we used to only do this for indexable clauses)\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or\n+--   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);\n+\n+--\n+-- test placement of movable quals in a parameterized join tree\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+--   join int4_tbl on b.thousand = f1;\n+\n+select count(*) from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+  join int4_tbl on b.thousand = f1;\n+\n+-- explain (costs off)\n+-- select b.unique1 from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+--   join int4_tbl i1 on b.thousand = f1\n+--   right join int4_tbl i2 on i2.f1 = b.tenthous\n+--   order by 1;\n+\n+select b.unique1 from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+  join int4_tbl i1 on b.thousand = f1\n+  right join int4_tbl i2 on i2.f1 = b.tenthous\n+  order by 1;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (\n+--   select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+--   from int8_tbl left join tenk1 on (q2 = unique2)\n+-- ) ss\n+-- where fault = 122\n+-- order by fault;\n+\n+select * from\n+(\n+  select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+  from int8_tbl left join tenk1 on (q2 = unique2)\n+) ss\n+where fault = 122\n+order by fault;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+-- [SPARK-28382] Array Functions: unnest\n+-- select * from\n+-- (values (1, array(10,20)), (2, array(20,30))) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+--\n+-- test handling of potential equivalence clauses above outer joins\n+--\n+\n+-- explain (costs off)\n+-- select q1, unique2, thousand, hundred\n+--   from int8_tbl a left join tenk1 b on q1 = unique2\n+--   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+select q1, unique2, thousand, hundred\n+  from int8_tbl a left join tenk1 b on q1 = unique2\n+  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+-- explain (costs off)\n+-- select f1, unique2, case when unique2 is null then f1 else 0 end\n+--   from int4_tbl a left join tenk1 b on f1 = unique2\n+--   where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+select f1, unique2, case when unique2 is null then f1 else 0 end\n+  from int4_tbl a left join tenk1 b on f1 = unique2\n+  where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+--\n+-- another case with equivalence clauses above outer joins (bug #8591)\n+--\n+\n+-- explain (costs off)\n+-- select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+--   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+--   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+--\n+-- check handling of join aliases when flattening multiple levels of subquery\n+--\n+\n+-- explain (verbose, costs off)\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+-- [SPARK-20856] Support statement using nested joins\n+--\n+-- test successful handling of nested outer joins with degenerate join quals\n+--\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   inner join int8_tbl i8\n+--   on i8.q2 = 456\n+--   right join text_tbl t2\n+--   on t1.f1 = 'doh!'\n+--   left join int4_tbl i4\n+--   on i8.q1 = i4.f1;\n+\n+select * from\n+  text_tbl t1\n+  inner join int8_tbl i8\n+  on i8.q2 = 456\n+  right join text_tbl t2\n+  on t1.f1 = 'doh!'\n+  left join int4_tbl i4\n+  on i8.q1 = i4.f1;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- test for appropriate join order in the presence of lateral references\n+--\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- explain (verbose, costs off)\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+--\n+-- check a case in which a PlaceHolderVar forces join order\n+--\n+\n+-- explain (verbose, costs off)\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+--\n+-- test successful handling of full join underneath left join (bug #14105)\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   (select 1 as id) as xx\n+--   left join\n+--     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+--   on (xx.id = coalesce(yy.id));\n+\n+select * from\n+  (select 1 as id) as xx\n+  left join\n+    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+  on (xx.id = coalesce(yy.id));\n+\n+--\n+-- test ability to push constants through outer join clauses\n+--\n+\n+-- explain (costs off)\n+--   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;\n+\n+-- explain (costs off)\n+--   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;\n+\n+--\n+-- test that quals attached to an outer join have correct semantics,\n+-- specifically that they don't re-use expressions computed below the join;\n+-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input\n+--\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- explain (verbose, costs off)\n+--   select a.q2, b.q1\n+--     from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+--     where coalesce(b.q1, 1) > 0;\n+select a.q2, b.q1\n+  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+  where coalesce(b.q1, 1) > 0;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test join removal\n+--\n+\n+-- begin;\n+\n+-- CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);\n+-- CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);\n+-- CREATE TEMP TABLE c (id int PRIMARY KEY);\n+-- CREATE TEMP TABLE d (a int, b int);\n+-- INSERT INTO a VALUES (0, 0), (1, NULL);\n+-- INSERT INTO b VALUES (0, 0), (1, NULL);\n+-- INSERT INTO c VALUES (0), (1);\n+-- INSERT INTO d VALUES (1,3), (2,2), (3,1);\n+\n+-- all three cases should be optimizable into a simple seqscan\n+-- explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;\n+-- explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;\n+-- explain (costs off)\n+--   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)\n+--   ON (a.b_id = b.id);\n+\n+-- check optimization of outer join within another special join\n+-- explain (costs off)\n+-- select id from a where id in (\n+-- \tselect b.id from b left join c on b.id = c.id\n+-- );\n+\n+-- check that join removal works for a left join when joining a subquery\n+-- that is guaranteed to be unique by its GROUP BY clause\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- join removal is not possible when the GROUP BY contains a column that is\n+-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a\n+-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;\n+-- but this happens too late for join removal in the outer plan level.)\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal works when uniqueness of the join condition is enforced\n+-- by a UNION\n+-- explain (costs off)\n+-- select d.* from d left join (select id from a union select id from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal with a cross-type comparison operator\n+-- explain (costs off)\n+-- select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4\n+--   on i8.q1 = i4.f1;\n+\n+-- check join removal with lateral references\n+-- explain (costs off)\n+-- select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,\n+-- \t\t\t  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;\n+\n+-- rollback;\n+\n+create or replace temporary view parent as select * from\n+  (values (1, 10), (2, 20), (3, 30))\n+  as v(k, pd);\n+create or replace temporary view child as select * from\n+  (values (1, 100), (4, 400))\n+  as v(k, cd);\n+\n+-- this case is optimizable\n+select p.* from parent p left join child c on (p.k = c.k);\n+-- explain (costs off)\n+--   select p.* from parent p left join child c on (p.k = c.k);\n+\n+-- this case is not\n+select p.*, linked from parent p\n+  left join (select c.*, true as linked from child c) as ss\n+  on (p.k = ss.k);\n+-- explain (costs off)\n+--   select p.*, linked from parent p\n+--     left join (select c.*, true as linked from child c) as ss\n+--     on (p.k = ss.k);\n+\n+-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling\n+select p.* from\n+  parent p left join child c on (p.k = c.k)\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   parent p left join child c on (p.k = c.k)\n+--   where p.k = 1 and p.k = 2;\n+\n+select p.* from\n+  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+--   where p.k = 1 and p.k = 2;\n+\n+-- bug 5255: this is not optimizable by join removal\n+-- begin;\n+\n+create or replace temporary view a as select * from\n+  (values (0), (1))\n+  as v(id);\n+create or replace temporary view b as select * from\n+  (values (0, 0), (1, NULL))\n+  as v(id, a_id);\n+\n+SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+\n+-- rollback;\n+\n+-- another join removal bug: this is not optimizable, either\n+-- begin;\n+\n+create or replace temporary view innertab as select * from\n+  (values (123L, 42L))\n+  as v(id, dat1);\n+\n+SELECT * FROM\n+    (SELECT 1 AS x) ss1\n+  LEFT JOIN\n+    (SELECT q1, q2, COALESCE(dat1, q1) AS y\n+     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2\n+  ON true;\n+\n+-- rollback;\n+\n+-- another join removal bug: we must clean up correctly when removing a PHV\n+-- begin;\n+\n+-- create temp table uniquetbl (f1 text unique);\n+\n+-- explain (costs off)\n+-- select t1.* from\n+--   uniquetbl as t1\n+--   left join (select *, '***'::text as d1 from uniquetbl) t2\n+--   on t1.f1 = t2.f1\n+--   left join uniquetbl t3\n+--   on t2.d1 = t3.f1;\n+\n+-- explain (costs off)\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- [SPARK-27987] Support POSIX Regular Expressions\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- rollback;\n+\n+-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs\n+\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok\n+\n+--\n+-- Test hints given on incorrect column references are useful\n+--\n+\n+select t1.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t1\" suggestion\n+select t2.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t2\" suggestion\n+select uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once\n+\n+-- Skip this test because it is a PostgreSQL specific case\n+--\n+-- Take care to reference the correct RTE\n+--\n+\n+-- -- select atts.relid::regclass, s.* from pg_stats s join\n+-- --     pg_attribute a on s.attname = a.attname and s.tablename =\n+-- --     a.attrelid::regclass::text join (select unnest(indkey) attnum,\n+-- --     indexrelid from pg_index i) atts on atts.attnum = a.attnum where\n+--     schemaname != 'pg_catalog';\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- Test LATERAL\n+--\n+\n+-- select unique2, x.*\n+-- from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- select unique2, x.*\n+-- from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- select unique2, x.*\n+-- from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+-- check scoping of lateral versus parent references\n+-- the first of these should return int8_tbl.q2, the second int8_tbl.q1\n+-- select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;\n+-- select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;\n+\n+-- lateral with function in FROM\n+-- select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;\n+-- don't need the explicit LATERAL keyword for functions\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, generate_series(1,two) g;\n+\n+-- lateral with UNION ALL subselect\n+-- explain (costs off)\n+--   select * from generate_series(100,200) g,\n+--     lateral (select * from int8_tbl a where g = q1 union all\n+--              select * from int8_tbl b where g = q2) ss;\n+-- select * from generate_series(100,200) g,\n+--   lateral (select * from int8_tbl a where g = q1 union all\n+--            select * from int8_tbl b where g = q2) ss;\n+\n+-- lateral with VALUES\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral with VALUES, no flattening possible\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral injecting a strange outer join condition\n+-- explain (costs off)\n+--   select * from int8_tbl a,\n+--     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--       on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+-- select * from int8_tbl a,\n+--   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--     on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+\n+-- lateral reference to a join alias variable\n+-- select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (select x) ss2(y);\n+-- select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (values(x)) ss2(y);\n+-- select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,\n+--   lateral (select x) ss2(y);\n+\n+-- lateral references requiring pullup\n+-- select * from (values(1)) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (select f1/1000000000 from int4_tbl) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (values(1)) x(lb),\n+--   lateral (values(lb)) y(lbcopy);\n+-- select * from (values(1)) x(lb),\n+--   lateral (select lb from int4_tbl) y(lbcopy);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select x.* from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+\n+-- lateral can result in join conditions appearing below their\n+-- real semantic level\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+\n+-- lateral reference in a PlaceHolderVar evaluated at join level\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+\n+-- case requiring nested PlaceHolderVars\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select ss2.y offset 0) ss3;\n+\n+-- case that breaks the old ph_may_need optimization\n+-- explain (verbose, costs off)\n+-- select c.*,a.*,ss1.q1,ss2.q1,ss3.* from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join\n+--       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2\n+--        where q1 < f1) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select * from int4_tbl i where ss2.y > f1) ss3;\n+\n+-- check processing of postponed quals (bug #9041)\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (select 1 as x offset 0) x cross join (select 2 as y offset 0) y\n+--   left join lateral (\n+--     select * from (select 3 as z offset 0) z where z.z = x.x\n+--   ) zz on zz.z = y.y;\n+\n+-- check dummy rels with lateral references (bug #15694)\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl where false) ss on true;\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;\n+\n+-- check handling of nested appendrels inside LATERAL\n+-- select * from\n+--   ((select 2 as v) union all (select 3 as v)) as q1\n+--   cross join lateral\n+--   ((select * from\n+--       ((select 4 as v) union all (select 5 as v)) as q3)\n+--    union all\n+--    (select q1.v)\n+--   ) as q2;\n+\n+-- check we don't try to do a unique-ified semijoin with LATERAL\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+\n+-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,\n+-- but we can make the test case much more compact with LATERAL)\n+-- explain (verbose, costs off)\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- test some error cases where LATERAL should have been used but wasn't\n+select f1,g from int4_tbl a, (select f1 as g) ss;\n+select f1,g from int4_tbl a, (select a.f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select a.f1 as g) ss;\n+-- SQL:2008 says the left table is in scope but illegal to access here\n+-- select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;\n+-- select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;\n+-- check we complain about ambiguous table references\n+-- select * from\n+--   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);\n+-- LATERAL can be used to put an aggregate into the FROM clause of its query\n+-- select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;\n+\n+-- check behavior of LATERAL in UPDATE/DELETE\n+\n+-- create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;\n+\n+-- error, can't do this:\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- can't do it even with LATERAL:\n+-- update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;\n+-- we might in future allow something like this, but for now it's an error:\n+-- update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- also errors:\n+-- delete from xx1 using (select * from int4_tbl where f1 = x1) ss;\n+-- delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- [SPARK-25411] Implement range partition in Spark\n+--\n+-- test LATERAL reference propagation down a multi-level inheritance hierarchy\n+-- produced for a multi-level partitioned table hierarchy.\n+--\n+-- create table join_pt1 (a int, b int, c varchar) partition by range(a);\n+-- create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);\n+-- create table join_pt1p2 partition of join_pt1 for values from (100) to (200);\n+-- create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);\n+-- insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');\n+-- create table join_ut1 (a int, b int, c varchar);\n+-- insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');\n+-- explain (verbose, costs off)\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+--\n+-- drop table join_pt1;\n+-- drop table join_ut1;\n+--\n+-- test that foreign key join estimation performs sanely for outer joins\n+--\n+\n+-- begin;\n+\n+-- create table fkest (a int, b int, c int unique, primary key(a,b));\n+-- create table fkest1 (a int, b int, primary key(a,b));\n+\n+-- insert into fkest select x/10, x%10, x from generate_series(1,1000) x;\n+-- insert into fkest1 select x/10, x%10 from generate_series(1,1000) x;\n+\n+-- alter table fkest1\n+--   add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;\n+\n+-- analyze fkest;\n+-- analyze fkest1;\n+\n+-- explain (costs off)\n+-- select *\n+-- from fkest f\n+--   left join fkest1 f1 on f.a = f1.a and f.b = f1.b\n+--   left join fkest1 f2 on f.a = f2.a and f.b = f2.b\n+--   left join fkest1 f3 on f.a = f3.a and f.b = f3.b\n+-- where f.c = 1;\n+\n+-- rollback;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test planner's ability to mark joins as unique\n+--\n+\n+-- create table j1 (id int primary key);\n+-- create table j2 (id int primary key);\n+-- create table j3 (id int);\n+\n+-- insert into j1 values(1),(2),(3);\n+-- insert into j2 values(1),(2),(3);\n+-- insert into j3 values(1),(1);\n+\n+-- analyze j1;\n+-- analyze j2;\n+-- analyze j3;\n+\n+-- ensure join is properly marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id = j2.id;\n+\n+-- ensure join is not unique when not an equi-join\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id > j2.id;\n+\n+-- ensure non-unique rel is not chosen as inner\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j3 on j1.id = j3.id;\n+\n+-- ensure left join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 left join j2 on j1.id = j2.id;\n+\n+-- ensure right join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 right join j2 on j1.id = j2.id;\n+\n+-- ensure full join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 full join j2 on j1.id = j2.id;\n+\n+-- a clauseless (cross) join can't be unique\n+-- explain (verbose, costs off)\n+-- select * from j1 cross join j2;\n+\n+-- ensure a natural join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 natural join j2;\n+\n+-- ensure a distinct clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select distinct id from j3) j3 on j1.id = j3.id;\n+\n+-- ensure group by clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select id from j3 group by id) j3 on j1.id = j3.id;\n+\n+drop table if exists j1;\n+drop table if exists j2;\n+drop table if exists j3;\n+\n+-- test more complex permutations of unique joins\n+\n+create table j1 (id1 int, id2 int) using parquet;\n+create table j2 (id1 int, id2 int) using parquet;\n+create table j3 (id1 int, id2 int) using parquet;\n+\n+insert into j1 values(1,1),(1,2);\n+insert into j2 values(1,1);\n+insert into j3 values(1,1);"
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "ditto. Comment out `j3`.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-28T20:51:35Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  as v(f1);\n+create or replace temporary view TEXT_TBL as select * from\n+  (values ('doh!'), ('hi de ho neighbor'))\n+  as v(f1);\n+create or replace temporary view tenk2 as select * from tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+drop table if exists tt3;\n+create table tt3(f1 int, f2 string) using parquet;\n+insert into tt3 select x.id, repeat('xyzzy', 100) from range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+drop table if exists tt4;\n+create table tt4(f1 int) using parquet;\n+insert into tt4 values (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type\n+-- select ss1.d1 from\n+--   tenk1 as t1\n+--   inner join tenk1 as t2\n+--   on t1.tenthous = t2.ten\n+--   inner join\n+--     int8_tbl as i8\n+--     left join int4_tbl as i4\n+--       inner join (select 64::information_schema.cardinal_number as d1\n+--                   from tenk1 t3,\n+--                        lateral (select abs(t3.unique1) + random()) ss0(x)\n+--                   where t3.fivethous < 0) as ss1\n+--       on i4.f1 = ss1.d1\n+--     on i8.q1 = i4.f1\n+--   on t1.tenthous = ss1.d1\n+-- where t1.unique1 < i4.f1;\n+\n+-- this variant is foldable by the remove-useless-RESULT-RTEs code\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+--\n+-- test extraction of restriction OR clauses from join OR clause\n+-- (we used to only do this for indexable clauses)\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or\n+--   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);\n+\n+--\n+-- test placement of movable quals in a parameterized join tree\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+--   join int4_tbl on b.thousand = f1;\n+\n+select count(*) from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+  join int4_tbl on b.thousand = f1;\n+\n+-- explain (costs off)\n+-- select b.unique1 from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+--   join int4_tbl i1 on b.thousand = f1\n+--   right join int4_tbl i2 on i2.f1 = b.tenthous\n+--   order by 1;\n+\n+select b.unique1 from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+  join int4_tbl i1 on b.thousand = f1\n+  right join int4_tbl i2 on i2.f1 = b.tenthous\n+  order by 1;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (\n+--   select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+--   from int8_tbl left join tenk1 on (q2 = unique2)\n+-- ) ss\n+-- where fault = 122\n+-- order by fault;\n+\n+select * from\n+(\n+  select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+  from int8_tbl left join tenk1 on (q2 = unique2)\n+) ss\n+where fault = 122\n+order by fault;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+-- [SPARK-28382] Array Functions: unnest\n+-- select * from\n+-- (values (1, array(10,20)), (2, array(20,30))) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+--\n+-- test handling of potential equivalence clauses above outer joins\n+--\n+\n+-- explain (costs off)\n+-- select q1, unique2, thousand, hundred\n+--   from int8_tbl a left join tenk1 b on q1 = unique2\n+--   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+select q1, unique2, thousand, hundred\n+  from int8_tbl a left join tenk1 b on q1 = unique2\n+  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+-- explain (costs off)\n+-- select f1, unique2, case when unique2 is null then f1 else 0 end\n+--   from int4_tbl a left join tenk1 b on f1 = unique2\n+--   where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+select f1, unique2, case when unique2 is null then f1 else 0 end\n+  from int4_tbl a left join tenk1 b on f1 = unique2\n+  where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+--\n+-- another case with equivalence clauses above outer joins (bug #8591)\n+--\n+\n+-- explain (costs off)\n+-- select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+--   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+--   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+--\n+-- check handling of join aliases when flattening multiple levels of subquery\n+--\n+\n+-- explain (verbose, costs off)\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+-- [SPARK-20856] Support statement using nested joins\n+--\n+-- test successful handling of nested outer joins with degenerate join quals\n+--\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, string('***') as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, int(null) as d2 from int8_tbl i8b2, int4_tbl i4b2\n+--                  where q1 = f1) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   inner join int8_tbl i8\n+--   on i8.q2 = 456\n+--   right join text_tbl t2\n+--   on t1.f1 = 'doh!'\n+--   left join int4_tbl i4\n+--   on i8.q1 = i4.f1;\n+\n+select * from\n+  text_tbl t1\n+  inner join int8_tbl i8\n+  on i8.q2 = 456\n+  right join text_tbl t2\n+  on t1.f1 = 'doh!'\n+  left join int4_tbl i4\n+  on i8.q1 = i4.f1;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- test for appropriate join order in the presence of lateral references\n+--\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss\n+-- where t1.f1 = ss.f1;\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- select * from\n+--   text_tbl t1\n+--   left join int8_tbl i8\n+--   on i8.q2 = 123,\n+--   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,\n+--   lateral (select ss1.* from text_tbl t3 limit 1) as ss2\n+-- where t1.f1 = ss2.f1;\n+\n+-- explain (verbose, costs off)\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+-- select 1 from\n+--   text_tbl as tt1\n+--   inner join text_tbl as tt2 on (tt1.f1 = 'foo')\n+--   left join text_tbl as tt3 on (tt3.f1 = 'foo')\n+--   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),\n+--   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1\n+-- where tt1.f1 = ss1.c0;\n+\n+--\n+-- check a case in which a PlaceHolderVar forces join order\n+--\n+\n+-- explain (verbose, costs off)\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+-- select ss2.* from\n+--   int4_tbl i41\n+--   left join int8_tbl i8\n+--     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3\n+--           from int4_tbl i42, int4_tbl i43) ss1\n+--     on i8.q1 = ss1.c2\n+--   on i41.f1 = ss1.c1,\n+--   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2\n+-- where ss1.c2 = 0;\n+\n+--\n+-- test successful handling of full join underneath left join (bug #14105)\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   (select 1 as id) as xx\n+--   left join\n+--     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+--   on (xx.id = coalesce(yy.id));\n+\n+select * from\n+  (select 1 as id) as xx\n+  left join\n+    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))\n+  on (xx.id = coalesce(yy.id));\n+\n+--\n+-- test ability to push constants through outer join clauses\n+--\n+\n+-- explain (costs off)\n+--   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;\n+\n+-- explain (costs off)\n+--   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;\n+\n+--\n+-- test that quals attached to an outer join have correct semantics,\n+-- specifically that they don't re-use expressions computed below the join;\n+-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input\n+--\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- explain (verbose, costs off)\n+--   select a.q2, b.q1\n+--     from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+--     where coalesce(b.q1, 1) > 0;\n+select a.q2, b.q1\n+  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)\n+  where coalesce(b.q1, 1) > 0;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test join removal\n+--\n+\n+-- begin;\n+\n+-- CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);\n+-- CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);\n+-- CREATE TEMP TABLE c (id int PRIMARY KEY);\n+-- CREATE TEMP TABLE d (a int, b int);\n+-- INSERT INTO a VALUES (0, 0), (1, NULL);\n+-- INSERT INTO b VALUES (0, 0), (1, NULL);\n+-- INSERT INTO c VALUES (0), (1);\n+-- INSERT INTO d VALUES (1,3), (2,2), (3,1);\n+\n+-- all three cases should be optimizable into a simple seqscan\n+-- explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;\n+-- explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;\n+-- explain (costs off)\n+--   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)\n+--   ON (a.b_id = b.id);\n+\n+-- check optimization of outer join within another special join\n+-- explain (costs off)\n+-- select id from a where id in (\n+-- \tselect b.id from b left join c on b.id = c.id\n+-- );\n+\n+-- check that join removal works for a left join when joining a subquery\n+-- that is guaranteed to be unique by its GROUP BY clause\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id and d.b = s.c_id;\n+\n+-- join removal is not possible when the GROUP BY contains a column that is\n+-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a\n+-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;\n+-- but this happens too late for join removal in the outer plan level.)\n+-- explain (costs off)\n+-- select d.* from d left join (select * from b group by b.id, b.c_id) s\n+--   on d.a = s.id;\n+\n+-- similarly, but keying off a DISTINCT clause\n+-- explain (costs off)\n+-- select d.* from d left join (select distinct * from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal works when uniqueness of the join condition is enforced\n+-- by a UNION\n+-- explain (costs off)\n+-- select d.* from d left join (select id from a union select id from b) s\n+--   on d.a = s.id;\n+\n+-- check join removal with a cross-type comparison operator\n+-- explain (costs off)\n+-- select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4\n+--   on i8.q1 = i4.f1;\n+\n+-- check join removal with lateral references\n+-- explain (costs off)\n+-- select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,\n+-- \t\t\t  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;\n+\n+-- rollback;\n+\n+create or replace temporary view parent as select * from\n+  (values (1, 10), (2, 20), (3, 30))\n+  as v(k, pd);\n+create or replace temporary view child as select * from\n+  (values (1, 100), (4, 400))\n+  as v(k, cd);\n+\n+-- this case is optimizable\n+select p.* from parent p left join child c on (p.k = c.k);\n+-- explain (costs off)\n+--   select p.* from parent p left join child c on (p.k = c.k);\n+\n+-- this case is not\n+select p.*, linked from parent p\n+  left join (select c.*, true as linked from child c) as ss\n+  on (p.k = ss.k);\n+-- explain (costs off)\n+--   select p.*, linked from parent p\n+--     left join (select c.*, true as linked from child c) as ss\n+--     on (p.k = ss.k);\n+\n+-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling\n+select p.* from\n+  parent p left join child c on (p.k = c.k)\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   parent p left join child c on (p.k = c.k)\n+--   where p.k = 1 and p.k = 2;\n+\n+select p.* from\n+  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+  where p.k = 1 and p.k = 2;\n+-- explain (costs off)\n+-- select p.* from\n+--   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k\n+--   where p.k = 1 and p.k = 2;\n+\n+-- bug 5255: this is not optimizable by join removal\n+-- begin;\n+\n+create or replace temporary view a as select * from\n+  (values (0), (1))\n+  as v(id);\n+create or replace temporary view b as select * from\n+  (values (0, 0), (1, NULL))\n+  as v(id, a_id);\n+\n+SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);\n+\n+-- rollback;\n+\n+-- another join removal bug: this is not optimizable, either\n+-- begin;\n+\n+create or replace temporary view innertab as select * from\n+  (values (123L, 42L))\n+  as v(id, dat1);\n+\n+SELECT * FROM\n+    (SELECT 1 AS x) ss1\n+  LEFT JOIN\n+    (SELECT q1, q2, COALESCE(dat1, q1) AS y\n+     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2\n+  ON true;\n+\n+-- rollback;\n+\n+-- another join removal bug: we must clean up correctly when removing a PHV\n+-- begin;\n+\n+-- create temp table uniquetbl (f1 text unique);\n+\n+-- explain (costs off)\n+-- select t1.* from\n+--   uniquetbl as t1\n+--   left join (select *, '***'::text as d1 from uniquetbl) t2\n+--   on t1.f1 = t2.f1\n+--   left join uniquetbl t3\n+--   on t2.d1 = t3.f1;\n+\n+-- explain (costs off)\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- [SPARK-27987] Support POSIX Regular Expressions\n+-- select t0.*\n+-- from\n+--  text_tbl t0\n+--  left join\n+--    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,\n+--            t1.stringu2\n+--      from tenk1 t1\n+--      join int4_tbl i4 ON i4.f1 = t1.unique2\n+--      left join uniquetbl u1 ON u1.f1 = t1.string4) ss\n+--   on t0.f1 = ss.case1\n+-- where ss.stringu2 !~* ss.case1;\n+\n+-- rollback;\n+\n+-- bug #8444: we've historically allowed duplicate aliases within aliased JOINs\n+\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1; -- error\n+select * from\n+  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1; -- ok\n+\n+--\n+-- Test hints given on incorrect column references are useful\n+--\n+\n+select t1.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t1\" suggestion\n+select t2.uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, prefer \"t2\" suggestion\n+select uunique1 from\n+  tenk1 t1 join tenk2 t2 on t1.two = t2.two; -- error, suggest both at once\n+\n+-- Skip this test because it is a PostgreSQL specific case\n+--\n+-- Take care to reference the correct RTE\n+--\n+\n+-- -- select atts.relid::regclass, s.* from pg_stats s join\n+-- --     pg_attribute a on s.attname = a.attname and s.tablename =\n+-- --     a.attrelid::regclass::text join (select unnest(indkey) attnum,\n+-- --     indexrelid from pg_index i) atts on atts.attnum = a.attnum where\n+--     schemaname != 'pg_catalog';\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+--\n+-- Test LATERAL\n+--\n+\n+-- select unique2, x.*\n+-- from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;\n+-- select unique2, x.*\n+-- from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;\n+-- select unique2, x.*\n+-- from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+-- explain (costs off)\n+--   select unique2, x.*\n+--   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n+\n+-- [SPARK-27877] ANSI SQL: LATERAL derived table(T491)\n+-- check scoping of lateral versus parent references\n+-- the first of these should return int8_tbl.q2, the second int8_tbl.q1\n+-- select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;\n+-- select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;\n+\n+-- lateral with function in FROM\n+-- select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, lateral generate_series(1,two) g;\n+-- explain (costs off)\n+--   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;\n+-- don't need the explicit LATERAL keyword for functions\n+-- explain (costs off)\n+--   select count(*) from tenk1 a, generate_series(1,two) g;\n+\n+-- lateral with UNION ALL subselect\n+-- explain (costs off)\n+--   select * from generate_series(100,200) g,\n+--     lateral (select * from int8_tbl a where g = q1 union all\n+--              select * from int8_tbl b where g = q2) ss;\n+-- select * from generate_series(100,200) g,\n+--   lateral (select * from int8_tbl a where g = q1 union all\n+--            select * from int8_tbl b where g = q2) ss;\n+\n+-- lateral with VALUES\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral with VALUES, no flattening possible\n+-- explain (costs off)\n+--   select count(*) from tenk1 a,\n+--     tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+-- select count(*) from tenk1 a,\n+--   tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;\n+\n+-- lateral injecting a strange outer join condition\n+-- explain (costs off)\n+--   select * from int8_tbl a,\n+--     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--       on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+-- select * from int8_tbl a,\n+--   int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)\n+--     on x.q2 = ss.z\n+--   order by a.q1, a.q2, x.q1, x.q2, ss.z;\n+\n+-- lateral reference to a join alias variable\n+-- select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (select x) ss2(y);\n+-- select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,\n+--   lateral (values(x)) ss2(y);\n+-- select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,\n+--   lateral (select x) ss2(y);\n+\n+-- lateral references requiring pullup\n+-- select * from (values(1)) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (select f1/1000000000 from int4_tbl) x(lb),\n+--   lateral generate_series(lb,4) x4;\n+-- select * from (values(1)) x(lb),\n+--   lateral (values(lb)) y(lbcopy);\n+-- select * from (values(1)) x(lb),\n+--   lateral (select lb from int4_tbl) y(lbcopy);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);\n+-- select * from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select x.* from\n+--   int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,\n+--   lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);\n+-- select v.* from\n+--   (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)\n+--   left join int4_tbl z on z.f1 = x.q2,\n+--   lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);\n+\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+-- select * from\n+--   int8_tbl a left join\n+--   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;\n+\n+-- lateral can result in join conditions appearing below their\n+-- real semantic level\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- select * from int4_tbl i left join\n+--   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;\n+-- explain (verbose, costs off)\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+-- select * from int4_tbl a,\n+--   lateral (\n+--     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)\n+--   ) ss;\n+\n+-- lateral reference in a PlaceHolderVar evaluated at join level\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+-- select * from\n+--   int8_tbl a left join lateral\n+--   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from\n+--    int8_tbl b cross join int8_tbl c) ss\n+--   on a.q2 = ss.bq1;\n+\n+-- case requiring nested PlaceHolderVars\n+-- explain (verbose, costs off)\n+-- select * from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select ss2.y offset 0) ss3;\n+\n+-- case that breaks the old ph_may_need optimization\n+-- explain (verbose, costs off)\n+-- select c.*,a.*,ss1.q1,ss2.q1,ss3.* from\n+--   int8_tbl c left join (\n+--     int8_tbl a left join\n+--       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2\n+--        where q1 < f1) ss1\n+--       on a.q2 = ss1.q1\n+--     cross join\n+--     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2\n+--   ) on c.q2 = ss2.q1,\n+--   lateral (select * from int4_tbl i where ss2.y > f1) ss3;\n+\n+-- check processing of postponed quals (bug #9041)\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (select 1 as x offset 0) x cross join (select 2 as y offset 0) y\n+--   left join lateral (\n+--     select * from (select 3 as z offset 0) z where z.z = x.x\n+--   ) zz on zz.z = y.y;\n+\n+-- check dummy rels with lateral references (bug #15694)\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl where false) ss on true;\n+-- explain (verbose, costs off)\n+-- select * from int8_tbl i8 left join lateral\n+--   (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;\n+\n+-- check handling of nested appendrels inside LATERAL\n+-- select * from\n+--   ((select 2 as v) union all (select 3 as v)) as q1\n+--   cross join lateral\n+--   ((select * from\n+--       ((select 4 as v) union all (select 5 as v)) as q3)\n+--    union all\n+--    (select q1.v)\n+--   ) as q2;\n+\n+-- check we don't try to do a unique-ified semijoin with LATERAL\n+-- explain (verbose, costs off)\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+-- select * from\n+--   (values (0,9998), (1,1000)) v(id,x),\n+--   lateral (select f1 from int4_tbl\n+--            where f1 = any (select unique1 from tenk1\n+--                            where unique2 = v.x offset 0)) ss;\n+\n+-- check proper extParam/allParam handling (this isn't exactly a LATERAL issue,\n+-- but we can make the test case much more compact with LATERAL)\n+-- explain (verbose, costs off)\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- select * from (values (0), (1)) v(id),\n+-- lateral (select * from int8_tbl t1,\n+--          lateral (select * from\n+--                     (select * from int8_tbl t2\n+--                      where q1 = any (select q2 from int8_tbl t3\n+--                                      where q2 = (select greatest(t1.q1,t2.q2))\n+--                                        and (select v.id=0)) offset 0) ss2) ss\n+--          where t1.q1 = ss.q2) ss0;\n+\n+-- test some error cases where LATERAL should have been used but wasn't\n+select f1,g from int4_tbl a, (select f1 as g) ss;\n+select f1,g from int4_tbl a, (select a.f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select f1 as g) ss;\n+select f1,g from int4_tbl a cross join (select a.f1 as g) ss;\n+-- SQL:2008 says the left table is in scope but illegal to access here\n+-- select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;\n+-- select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;\n+-- check we complain about ambiguous table references\n+-- select * from\n+--   int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);\n+-- LATERAL can be used to put an aggregate into the FROM clause of its query\n+-- select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;\n+\n+-- check behavior of LATERAL in UPDATE/DELETE\n+\n+-- create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;\n+\n+-- error, can't do this:\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;\n+-- update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- can't do it even with LATERAL:\n+-- update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;\n+-- we might in future allow something like this, but for now it's an error:\n+-- update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- also errors:\n+-- delete from xx1 using (select * from int4_tbl where f1 = x1) ss;\n+-- delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;\n+-- delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;\n+\n+-- [SPARK-25411] Implement range partition in Spark\n+--\n+-- test LATERAL reference propagation down a multi-level inheritance hierarchy\n+-- produced for a multi-level partitioned table hierarchy.\n+--\n+-- create table join_pt1 (a int, b int, c varchar) partition by range(a);\n+-- create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);\n+-- create table join_pt1p2 partition of join_pt1 for values from (100) to (200);\n+-- create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);\n+-- insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');\n+-- create table join_ut1 (a int, b int, c varchar);\n+-- insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');\n+-- explain (verbose, costs off)\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+-- select t1.b, ss.phv from join_ut1 t1 left join lateral\n+--               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv\n+-- \t\t\t\t\t  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss\n+--               on t1.a = ss.t2a order by t1.a;\n+--\n+-- drop table join_pt1;\n+-- drop table join_ut1;\n+--\n+-- test that foreign key join estimation performs sanely for outer joins\n+--\n+\n+-- begin;\n+\n+-- create table fkest (a int, b int, c int unique, primary key(a,b));\n+-- create table fkest1 (a int, b int, primary key(a,b));\n+\n+-- insert into fkest select x/10, x%10, x from generate_series(1,1000) x;\n+-- insert into fkest1 select x/10, x%10 from generate_series(1,1000) x;\n+\n+-- alter table fkest1\n+--   add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;\n+\n+-- analyze fkest;\n+-- analyze fkest1;\n+\n+-- explain (costs off)\n+-- select *\n+-- from fkest f\n+--   left join fkest1 f1 on f.a = f1.a and f.b = f1.b\n+--   left join fkest1 f2 on f.a = f2.a and f.b = f2.b\n+--   left join fkest1 f3 on f.a = f3.a and f.b = f3.b\n+-- where f.c = 1;\n+\n+-- rollback;\n+\n+-- Skip these test because it only test explain\n+--\n+-- test planner's ability to mark joins as unique\n+--\n+\n+-- create table j1 (id int primary key);\n+-- create table j2 (id int primary key);\n+-- create table j3 (id int);\n+\n+-- insert into j1 values(1),(2),(3);\n+-- insert into j2 values(1),(2),(3);\n+-- insert into j3 values(1),(1);\n+\n+-- analyze j1;\n+-- analyze j2;\n+-- analyze j3;\n+\n+-- ensure join is properly marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id = j2.id;\n+\n+-- ensure join is not unique when not an equi-join\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j2 on j1.id > j2.id;\n+\n+-- ensure non-unique rel is not chosen as inner\n+-- explain (verbose, costs off)\n+-- select * from j1 inner join j3 on j1.id = j3.id;\n+\n+-- ensure left join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 left join j2 on j1.id = j2.id;\n+\n+-- ensure right join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 right join j2 on j1.id = j2.id;\n+\n+-- ensure full join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 full join j2 on j1.id = j2.id;\n+\n+-- a clauseless (cross) join can't be unique\n+-- explain (verbose, costs off)\n+-- select * from j1 cross join j2;\n+\n+-- ensure a natural join is marked as unique\n+-- explain (verbose, costs off)\n+-- select * from j1 natural join j2;\n+\n+-- ensure a distinct clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select distinct id from j3) j3 on j1.id = j3.id;\n+\n+-- ensure group by clause allows the inner to become unique\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join (select id from j3 group by id) j3 on j1.id = j3.id;\n+\n+drop table if exists j1;\n+drop table if exists j2;\n+drop table if exists j3;\n+\n+-- test more complex permutations of unique joins\n+\n+create table j1 (id1 int, id2 int) using parquet;\n+create table j2 (id1 int, id2 int) using parquet;\n+create table j3 (id1 int, id2 int) using parquet;\n+\n+insert into j1 values(1,1),(1,2);\n+insert into j2 values(1,1);\n+insert into j3 values(1,1);\n+\n+-- analyze j1;\n+-- analyze j2;\n+-- analyze j3;\n+\n+-- ensure there's no unique join when not all columns which are part of the\n+-- unique index are seen in the join clause\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join j2 on j1.id1 = j2.id1;\n+\n+-- ensure proper unique detection with multiple join quals\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;\n+\n+-- ensure we don't detect the join to be unique when quals are not part of the\n+-- join condition\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;\n+\n+-- as above, but for left joins.\n+-- explain (verbose, costs off)\n+-- select * from j1\n+-- left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;\n+\n+-- validate logic in merge joins which skips mark and restore.\n+-- it should only do this if all "
  }],
  "prId": 25148
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "skip this case for correlation names, too?",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-30T03:19:22Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+DROP TABLE IF EXISTS tt3;\n+CREATE TABLE tt3(f1 int, f2 string) USING parquet;\n+INSERT INTO tt3 SELECT x.id, repeat('xyzzy', 100) FROM range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+DROP TABLE IF EXISTS tt4;\n+CREATE TABLE tt4(f1 int) USING parquet;\n+INSERT INTO tt4 VALUES (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type\n+-- select ss1.d1 from\n+--   tenk1 as t1\n+--   inner join tenk1 as t2\n+--   on t1.tenthous = t2.ten\n+--   inner join\n+--     int8_tbl as i8\n+--     left join int4_tbl as i4\n+--       inner join (select 64::information_schema.cardinal_number as d1\n+--                   from tenk1 t3,\n+--                        lateral (select abs(t3.unique1) + random()) ss0(x)\n+--                   where t3.fivethous < 0) as ss1\n+--       on i4.f1 = ss1.d1\n+--     on i8.q1 = i4.f1\n+--   on t1.tenthous = ss1.d1\n+-- where t1.unique1 < i4.f1;\n+\n+-- this variant is foldable by the remove-useless-RESULT-RTEs code\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+--\n+-- test extraction of restriction OR clauses from join OR clause\n+-- (we used to only do this for indexable clauses)\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or\n+--   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);\n+\n+--\n+-- test placement of movable quals in a parameterized join tree\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+--   join int4_tbl on b.thousand = f1;\n+\n+select count(*) from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+  join int4_tbl on b.thousand = f1;\n+\n+-- explain (costs off)\n+-- select b.unique1 from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+--   join int4_tbl i1 on b.thousand = f1\n+--   right join int4_tbl i2 on i2.f1 = b.tenthous\n+--   order by 1;\n+\n+select b.unique1 from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+  join int4_tbl i1 on b.thousand = f1\n+  right join int4_tbl i2 on i2.f1 = b.tenthous\n+  order by 1;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (\n+--   select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+--   from int8_tbl left join tenk1 on (q2 = unique2)\n+-- ) ss\n+-- where fault = 122\n+-- order by fault;\n+\n+select * from\n+(\n+  select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+  from int8_tbl left join tenk1 on (q2 = unique2)\n+) ss\n+where fault = 122\n+order by fault;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+-- [SPARK-28382] Array Functions: unnest\n+-- select * from\n+-- (values (1, array(10,20)), (2, array(20,30))) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+--\n+-- test handling of potential equivalence clauses above outer joins\n+--\n+\n+-- explain (costs off)\n+-- select q1, unique2, thousand, hundred\n+--   from int8_tbl a left join tenk1 b on q1 = unique2\n+--   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+select q1, unique2, thousand, hundred\n+  from int8_tbl a left join tenk1 b on q1 = unique2\n+  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+-- explain (costs off)\n+-- select f1, unique2, case when unique2 is null then f1 else 0 end\n+--   from int4_tbl a left join tenk1 b on f1 = unique2\n+--   where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+select f1, unique2, case when unique2 is null then f1 else 0 end\n+  from int4_tbl a left join tenk1 b on f1 = unique2\n+  where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+--\n+-- another case with equivalence clauses above outer joins (bug #8591)\n+--\n+\n+-- explain (costs off)\n+-- select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+--   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+--   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+--\n+-- check handling of join aliases when flattening multiple levels of subquery\n+--\n+\n+-- explain (verbose, costs off)\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+-- [SPARK-20856] Support statement using nested joins\n+--\n+-- test successful handling of nested outer joins with degenerate join quals\n+--\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from",
    "line": 1182
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "No. for nested joins.",
    "commit": "6261c875fbfa8af50bf7c3982e6f1489b7852745",
    "createdAt": "2019-07-30T04:53:51Z",
    "diffHunk": "@@ -0,0 +1,2079 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL tx;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT '' AS `xxx`, i, k, t\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT '' AS `xxx`, t1.i, k, t\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT '' AS `xxx`, ii, tt, kk\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY a, d;\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY i, k, t;\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);\n+\n+SELECT '' AS `xxx`, *\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+INNER JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+LEFT JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, n as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT * FROM\n+  (SELECT name, n as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, 2 as s2_n FROM t2) as s2\n+ON (s1_n = s2_n);\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select * from x;\n+select * from y;\n+\n+select * from x left join y on (x1 = y1 and x2 is not null);\n+select * from x left join y on (x1 = y1 and y2 is not null);\n+\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1 and xx2 is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (x2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (y2 is not null);\n+select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)\n+on (x1 = xx1) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select count(*) from tenk1 a where unique1 in\n+  (select unique1 from tenk1 b join tenk1 c using (unique1)\n+   where b.unique2 = 42);\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select count(*) from tenk1 x where\n+  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and\n+  x.unique1 = 0 and\n+  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+order by 1, 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select count(*)\n+from\n+  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on t1.unique1 = t2.unique1\n+   join tenk1 t3 on t1.unique2 = t3.unique2) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select a.f1, b.f1, t.thousand, t.tenthous from\n+  tenk1 t,\n+  (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+  (select sum(f1) as f1 from int4_tbl i4b) b\n+where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select count(*) from\n+  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by y.unique2) y\n+  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select count(*) from tenk1 a, tenk1 b\n+  where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+DROP TABLE IF EXISTS tt3;\n+CREATE TABLE tt3(f1 int, f2 string) USING parquet;\n+INSERT INTO tt3 SELECT x.id, repeat('xyzzy', 100) FROM range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+DROP TABLE IF EXISTS tt4;\n+CREATE TABLE tt4(f1 int) USING parquet;\n+INSERT INTO tt4 VALUES (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT a.f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)\n+        WHERE c.f1 IS NULL\n+) AS d ON (a.f1 = d.f1)\n+WHERE d.f1 IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,\n+       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy\n+     left join xx xxa on yya.pkxx = xxa.pkxx\n+     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zt1 on (f3 = f1)\n+where f2 = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = f3)\n+      left join zv1 on (f3 = f1)\n+where f2 = 53;\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred\n+from tenk1 a left join tenk1 b on a.unique2 = b.tenthous\n+where a.unique1 = 42 and\n+      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on i = x and i = y and x = i;\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select t1.q2, count(t2.*)\n+from int8_tbl t1 left join\n+  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (t1.q2 = t2.q1)\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select c.name, ss.code, ss.b_cnt, ss.const\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select count(1) as cnt, b.a from b group by b.a) as b_grp\n+     on a.code = b_grp.a\n+  ) as ss\n+  on (c.a = ss.code)\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = sub2.key3;\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)\n+-- SELECT qq, unique1\n+--   FROM\n+--   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+--   FULL OUTER JOIN\n+--   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+--   USING (qq)\n+--   INNER JOIN tenk1 c ON qq = unique2;\n+\n+SELECT qq, unique1\n+  FROM\n+  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1\n+  FULL OUTER JOIN\n+  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2\n+  USING (qq)\n+  INNER JOIN tenk1 c ON qq = unique2;\n+\n+--\n+-- nested nestloops can require nested PlaceHolderVars\n+--\n+\n+create or replace temporary view nt1 as select * from\n+  (values(1,true,true), (2,true,false), (3,false,false))\n+  as v(id, a1, a2);\n+create or replace temporary view nt2 as select * from\n+  (values(1,1,true,true), (2,2,true,false), (3,3,false,false))\n+  as v(id, nt1_id, b1, b2);\n+create or replace temporary view nt3 as select * from\n+  (values(1,1,true), (2,2,false), (3,3,true))\n+  as v(id, nt2_id, c1);\n+-- explain (costs off)\n+-- select nt3.id\n+-- from nt3 as nt3\n+--   left join\n+--     (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+--      from nt2 as nt2\n+--        left join\n+--          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+--          on ss1.id = nt2.nt1_id\n+--     ) as ss2\n+--     on ss2.id = nt3.nt2_id\n+-- where nt3.id = 1 and ss2.b3;\n+\n+select nt3.id\n+from nt3 as nt3\n+  left join\n+    (select nt2.*, (nt2.b1 and ss1.a3) AS b3\n+     from nt2 as nt2\n+       left join\n+         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1\n+         on ss1.id = nt2.nt1_id\n+    ) as ss2\n+    on ss2.id = nt3.nt2_id\n+where nt3.id = 1 and ss2.b3;\n+\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+--\n+-- test case where a PlaceHolderVar is propagated into a subquery\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+-- select * from\n+--   int8_tbl t1 left join\n+--   (select q1 as x, 42 as y from int8_tbl t2) ss\n+--   on t1.q2 = ss.x\n+-- where\n+--   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)\n+-- order by 1,2;\n+\n+--\n+-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE\n+--\n+select * from int4_tbl a full join int4_tbl b on true;\n+select * from int4_tbl a full join int4_tbl b on false;\n+\n+--\n+-- test for ability to use a cartesian join when necessary\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where q1 = thousand or q2 = thousand;\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1 join int4_tbl on f1 = twothousand,\n+--   int4(sin(1)) q1,\n+--   int4(sin(0)) q2\n+-- where thousand = (q1 + q2);\n+\n+--\n+-- test ability to generate a suitable plan for a star-schema query\n+--\n+\n+-- explain (costs off)\n+-- select * from\n+--   tenk1, int8_tbl a, int8_tbl b\n+-- where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;\n+\n+--\n+-- test a corner case in which we shouldn't apply the star-schema optimization\n+--\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (select 1,0 from onerow) v1(x1,x2)\n+--                left join (select 3,1 from onerow) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- variant that isn't quite a star-schema case\n+\n+-- Spark SQL do not support information_schema.cardinal_number type\n+-- select ss1.d1 from\n+--   tenk1 as t1\n+--   inner join tenk1 as t2\n+--   on t1.tenthous = t2.ten\n+--   inner join\n+--     int8_tbl as i8\n+--     left join int4_tbl as i4\n+--       inner join (select 64::information_schema.cardinal_number as d1\n+--                   from tenk1 t3,\n+--                        lateral (select abs(t3.unique1) + random()) ss0(x)\n+--                   where t3.fivethous < 0) as ss1\n+--       on i4.f1 = ss1.d1\n+--     on i8.q1 = i4.f1\n+--   on t1.tenthous = ss1.d1\n+-- where t1.unique1 < i4.f1;\n+\n+-- this variant is foldable by the remove-useless-RESULT-RTEs code\n+\n+-- explain (costs off)\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+-- [SPARK-20856] support statement using nested joins\n+-- select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from\n+--   tenk1 t1\n+--   inner join int4_tbl i1\n+--     left join (select v1.x2, v2.y1, 11 AS d1\n+--                from (values(1,0)) v1(x1,x2)\n+--                left join (values(3,1)) v2(y1,y2)\n+--                on v1.x1 = v2.y2) subq1\n+--     on (i1.f1 = subq1.x2)\n+--   on (t1.unique2 = subq1.d1)\n+--   left join tenk1 t2\n+--   on (subq1.y1 = t2.unique1)\n+-- where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;\n+\n+--\n+-- test extraction of restriction OR clauses from join OR clause\n+-- (we used to only do this for indexable clauses)\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);\n+-- explain (costs off)\n+-- select * from tenk1 a join tenk1 b on\n+--   (a.unique1 = 1 and b.unique1 = 2) or\n+--   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);\n+\n+--\n+-- test placement of movable quals in a parameterized join tree\n+--\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select * from tenk1 t1 left join\n+--   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)\n+--   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten\n+-- where t1.unique1 = 1;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+--   join int4_tbl on b.thousand = f1;\n+\n+select count(*) from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand\n+  join int4_tbl on b.thousand = f1;\n+\n+-- explain (costs off)\n+-- select b.unique1 from\n+--   tenk1 a join tenk1 b on a.unique1 = b.unique2\n+--   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+--   join int4_tbl i1 on b.thousand = f1\n+--   right join int4_tbl i2 on i2.f1 = b.tenthous\n+--   order by 1;\n+\n+select b.unique1 from\n+  tenk1 a join tenk1 b on a.unique1 = b.unique2\n+  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand\n+  join int4_tbl i1 on b.thousand = f1\n+  right join int4_tbl i2 on i2.f1 = b.tenthous\n+  order by 1;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (\n+--   select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+--   from int8_tbl left join tenk1 on (q2 = unique2)\n+-- ) ss\n+-- where fault = 122\n+-- order by fault;\n+\n+select * from\n+(\n+  select unique1, q1, coalesce(unique1, -1) + q1 as fault\n+  from int8_tbl left join tenk1 on (q2 = unique2)\n+) ss\n+where fault = 122\n+order by fault;\n+\n+-- explain (costs off)\n+-- select * from\n+-- (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+-- [SPARK-28382] Array Functions: unnest\n+-- select * from\n+-- (values (1, array(10,20)), (2, array(20,30))) as v1(v1x,v1ys)\n+-- left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x\n+-- left join unnest(v1ys) as u1(u1y) on u1y = v2y;\n+\n+--\n+-- test handling of potential equivalence clauses above outer joins\n+--\n+\n+-- explain (costs off)\n+-- select q1, unique2, thousand, hundred\n+--   from int8_tbl a left join tenk1 b on q1 = unique2\n+--   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+select q1, unique2, thousand, hundred\n+  from int8_tbl a left join tenk1 b on q1 = unique2\n+  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);\n+\n+-- explain (costs off)\n+-- select f1, unique2, case when unique2 is null then f1 else 0 end\n+--   from int4_tbl a left join tenk1 b on f1 = unique2\n+--   where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+select f1, unique2, case when unique2 is null then f1 else 0 end\n+  from int4_tbl a left join tenk1 b on f1 = unique2\n+  where (case when unique2 is null then f1 else 0 end) = 0;\n+\n+--\n+-- another case with equivalence clauses above outer joins (bug #8591)\n+--\n+\n+-- explain (costs off)\n+-- select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+--   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+--   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)\n+  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)\n+  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;\n+\n+--\n+-- check handling of join aliases when flattening multiple levels of subquery\n+--\n+\n+-- explain (verbose, costs off)\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from\n+--   (values (0),(1)) foo1(join_key)\n+-- left join\n+--   (select join_key, bug_field from\n+--     (select ss1.join_key, ss1.bug_field from\n+--       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1\n+--     ) foo2\n+--    left join\n+--     (select unique2 as join_key from tenk1 i2) ss2\n+--    using (join_key)\n+--   ) foo3\n+-- using (join_key);\n+\n+-- [SPARK-20856] Support statement using nested joins\n+--\n+-- test successful handling of nested outer joins with degenerate join quals\n+--\n+\n+-- explain (verbose, costs off)\n+-- select t1.* from\n+--   text_tbl t1\n+--   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1\n+--     left join int8_tbl i8\n+--       left join (select *, null::int as d2 from int8_tbl i8b2) b2\n+--       on (i8.q1 = b2.q1)\n+--     on (b2.d2 = b1.q2)\n+--   on (t1.f1 = b1.d1)\n+--   left join int4_tbl i4\n+--   on (i8.q2 = i4.f1);\n+\n+-- select t1.* from",
    "line": 1182
  }],
  "prId": 25148
}]