[{
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Skip these tests?\r\nIt seem `select from` is very strange syntax.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-15T15:53:32Z",
    "diffHunk": "@@ -0,0 +1,470 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);",
    "line": 231
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's file a JIRA for `SELECT FROM` first and use `SELECT * FROM` for these queries here.\r\nI believe we will make that JIRA 'Won't Fix', but we need a record.\r\n\r\ncc @gatorsmile ",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-15T15:57:14Z",
    "diffHunk": "@@ -0,0 +1,470 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);",
    "line": 231
  }],
  "prId": 25163
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Please add a reference to the existing JIRA.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-29T03:48:18Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types."
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "IIRC, there is a related JIRA because this is the difference from Hive, too.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-29T03:48:38Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types."
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Yes. It's https://issues.apache.org/jira/browse/SPARK-28298.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-30T02:43:59Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types."
  }],
  "prId": 25163
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's file a new JIRA about `empty select` and add a comment before line 219.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-29T03:51:34Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;",
    "line": 222
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "This is different from SPARK-28409.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-29T03:51:55Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;",
    "line": 222
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-30T03:01:46Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;",
    "line": 222
  }],
  "prId": 25163
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Shall we add `SPARK-27767` before this line, too?",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-29T03:57:29Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+-- [SPARK-28409] SELECT FROM syntax\n+select * from range(1,5) union select * from range(1,3);",
    "line": 235
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-30T03:01:40Z",
    "diffHunk": "@@ -0,0 +1,471 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+create or replace temporary view INT4_TBL as select * from\n+  (values (0), (123456), (-123456), (2147483647), (-2147483647))\n+  as v(f1);\n+create or replace temporary view INT8_TBL as select * from\n+  (values\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  as v(q1, q2);\n+create or replace temporary view FLOAT8_TBL as select * from\n+  (values (0.0), (-34.84), (-1004.30),\n+    (cast('-1.2345678901234e+200' as double)), (cast('-1.2345678901234e-200' as double)))\n+  as v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- Skip these tests because Spark SQL can not fully support char and varchar types.\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+-- [SPARK-28409] SELECT FROM syntax\n+select * from range(1,5) union select * from range(1,3);",
    "line": 235
  }],
  "prId": 25163
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Any reason for commenting out this?",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-30T04:20:26Z",
    "diffHunk": "@@ -0,0 +1,472 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (-34.84), (-1004.30),\n+    (CAST('-1.2345678901234e+200' AS DOUBLE)), (CAST('-1.2345678901234e-200' AS DOUBLE)))\n+  AS v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- [SPARK-28298] Fully support char and varchar types\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+-- [SPARK-28557] Support empty select list\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+-- [SPARK-28409] SELECT FROM syntax\n+-- [SPARK-27767] Built-in function: generate_series\n+select * from range(1,5) union select * from range(1,3);\n+select * from range(1,6) union all select * from range(1,4);\n+select * from range(1,6) intersect select * from range(1,4);\n+select * from range(1,6) intersect all select * from range(1,4);\n+select * from range(1,6) except select * from range(1,4);\n+select * from range(1,6) except all select * from range(1,4);\n+\n+-- check sorted implementation\n+-- set enable_hashagg = false;\n+-- set enable_sort = true;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+select * from range(1,6) union select * from range(1,4);\n+select * from range(1,6) union all select * from range(1,4);\n+select * from range(1,6) intersect select * from range(1,4);\n+select * from range(1,6) intersect all select * from range(1,4);\n+select * from range(1,6) except select * from range(1,4);\n+select * from range(1,6) except all select * from range(1,4);\n+\n+-- reset enable_hashagg;\n+-- reset enable_sort;\n+\n+--\n+-- Check handling of a case with unknown constants.  We don't guarantee\n+-- an undecorated constant will work in all cases, but historically this\n+-- usage has worked, so test we don't break it.\n+--\n+\n+-- SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a",
    "line": 267
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "We can not fully support char and varchar types.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-30T04:58:36Z",
    "diffHunk": "@@ -0,0 +1,472 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (-34.84), (-1004.30),\n+    (CAST('-1.2345678901234e+200' AS DOUBLE)), (CAST('-1.2345678901234e-200' AS DOUBLE)))\n+  AS v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- [SPARK-28298] Fully support char and varchar types\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+-- [SPARK-28557] Support empty select list\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+-- [SPARK-28409] SELECT FROM syntax\n+-- [SPARK-27767] Built-in function: generate_series\n+select * from range(1,5) union select * from range(1,3);\n+select * from range(1,6) union all select * from range(1,4);\n+select * from range(1,6) intersect select * from range(1,4);\n+select * from range(1,6) intersect all select * from range(1,4);\n+select * from range(1,6) except select * from range(1,4);\n+select * from range(1,6) except all select * from range(1,4);\n+\n+-- check sorted implementation\n+-- set enable_hashagg = false;\n+-- set enable_sort = true;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+select * from range(1,6) union select * from range(1,4);\n+select * from range(1,6) union all select * from range(1,4);\n+select * from range(1,6) intersect select * from range(1,4);\n+select * from range(1,6) intersect all select * from range(1,4);\n+select * from range(1,6) except select * from range(1,4);\n+select * from range(1,6) except all select * from range(1,4);\n+\n+-- reset enable_hashagg;\n+-- reset enable_sort;\n+\n+--\n+-- Check handling of a case with unknown constants.  We don't guarantee\n+-- an undecorated constant will work in all cases, but historically this\n+-- usage has worked, so test we don't break it.\n+--\n+\n+-- SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a",
    "line": 267
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Ur, I see.",
    "commit": "3e0dce328998fe4e29d633c662819674e230e228",
    "createdAt": "2019-07-30T05:15:03Z",
    "diffHunk": "@@ -0,0 +1,472 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- UNION (also INTERSECT, EXCEPT)\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/union.sql\n+--\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (-34.84), (-1004.30),\n+    (CAST('-1.2345678901234e+200' AS DOUBLE)), (CAST('-1.2345678901234e-200' AS DOUBLE)))\n+  AS v(f1);\n+\n+-- Simple UNION constructs\n+\n+SELECT 1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT 1 ORDER BY 1;\n+\n+SELECT 1 AS two UNION ALL SELECT 2;\n+\n+SELECT 1 AS two UNION ALL SELECT 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2 UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+-- Mixed types\n+\n+SELECT 1.1 AS two UNION SELECT 2 ORDER BY 1;\n+\n+SELECT 1 AS two UNION SELECT 2.2 ORDER BY 1;\n+\n+SELECT 1 AS one UNION SELECT double(1.0) ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT double(1.0) AS two UNION ALL SELECT 1 ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION SELECT 3 ORDER BY 1;\n+\n+SELECT double(1.1) AS two UNION SELECT 2 UNION SELECT double(2.0) ORDER BY 1;\n+\n+SELECT 1.1 AS three UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1;\n+\n+SELECT 1.1 AS two UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1;\n+\n+--\n+-- Try testing from tables...\n+--\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM FLOAT8_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM FLOAT8_TBL;\n+\n+SELECT f1 AS nine FROM FLOAT8_TBL\n+UNION\n+SELECT f1 FROM INT4_TBL\n+ORDER BY 1;\n+\n+SELECT f1 AS ten FROM FLOAT8_TBL\n+UNION ALL\n+SELECT f1 FROM INT4_TBL;\n+\n+SELECT f1 AS five FROM FLOAT8_TBL\n+  WHERE f1 BETWEEN -1e6 AND 1e6\n+UNION\n+SELECT f1 FROM INT4_TBL\n+  WHERE f1 BETWEEN 0 AND 1000000\n+ORDER BY 1;\n+\n+-- [SPARK-28298] Fully support char and varchar types\n+-- SELECT CAST(f1 AS char(4)) AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT f1 FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS three FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT CAST(f1 AS varchar) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+-- SELECT f1 AS eight FROM VARCHAR_TBL\n+-- UNION ALL\n+-- SELECT f1 FROM CHAR_TBL;\n+\n+-- SELECT f1 AS five FROM TEXT_TBL\n+-- UNION\n+-- SELECT f1 FROM VARCHAR_TBL\n+-- UNION\n+-- SELECT TRIM(TRAILING FROM f1) FROM CHAR_TBL\n+-- ORDER BY 1;\n+\n+--\n+-- INTERSECT and EXCEPT\n+--\n+\n+SELECT q2 FROM int8_tbl INTERSECT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl INTERSECT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q2 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q2 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl EXCEPT ALL SELECT DISTINCT q2 FROM int8_tbl ORDER BY 1;\n+\n+-- Spark SQL do not support update\n+-- SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;\n+\n+-- nested cases\n+(SELECT 1,2,3 UNION SELECT 4,5,6) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) INTERSECT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6) EXCEPT SELECT 4,5,6;\n+(SELECT 1,2,3 UNION SELECT 4,5,6 ORDER BY 1,2) EXCEPT SELECT 4,5,6;\n+\n+-- exercise both hashed and sorted implementations of INTERSECT/EXCEPT\n+\n+-- set enable_hashagg to on;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- set enable_hashagg to off;\n+\n+-- explain (costs off)\n+-- select count(*) from\n+--   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+select count(*) from\n+  ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;\n+\n+-- explain (costs off)\n+-- select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;\n+\n+-- reset enable_hashagg;\n+\n+--\n+-- Mixed types\n+--\n+\n+SELECT f1 FROM float8_tbl INTERSECT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+SELECT f1 FROM float8_tbl EXCEPT SELECT f1 FROM int4_tbl ORDER BY 1;\n+\n+--\n+-- Operator precedence and (((((extra))))) parentheses\n+--\n+\n+SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl  ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl INTERSECT (((SELECT q2 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) ORDER BY 1;\n+\n+(((SELECT q1 FROM int8_tbl INTERSECT SELECT q2 FROM int8_tbl ORDER BY 1))) UNION ALL SELECT q2 FROM int8_tbl;\n+\n+SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+SELECT q1 FROM int8_tbl UNION ALL (((SELECT q2 FROM int8_tbl EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1)));\n+\n+(((SELECT q1 FROM int8_tbl UNION ALL SELECT q2 FROM int8_tbl))) EXCEPT SELECT q1 FROM int8_tbl ORDER BY 1;\n+\n+--\n+-- Subqueries with ORDER BY & LIMIT clauses\n+--\n+\n+-- In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT\n+SELECT q1,q2 FROM int8_tbl EXCEPT SELECT q2,q1 FROM int8_tbl\n+ORDER BY q2,q1;\n+\n+-- This should fail, because q2 isn't a name of an EXCEPT output column\n+SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;\n+\n+-- But this should work:\n+SELECT q1 FROM int8_tbl EXCEPT (((SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1))) ORDER BY 1;\n+\n+--\n+-- New syntaxes (7.1) permit new tests\n+--\n+\n+(((((select * from int8_tbl)))));\n+\n+-- [SPARK-28557] Support empty select list\n+--\n+-- Check behavior with empty select list (allowed since 9.4)\n+--\n+\n+-- select union select;\n+-- select intersect select;\n+-- select except select;\n+\n+-- check hashed implementation\n+-- set enable_hashagg = true;\n+-- set enable_sort = false;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+-- [SPARK-28409] SELECT FROM syntax\n+-- [SPARK-27767] Built-in function: generate_series\n+select * from range(1,5) union select * from range(1,3);\n+select * from range(1,6) union all select * from range(1,4);\n+select * from range(1,6) intersect select * from range(1,4);\n+select * from range(1,6) intersect all select * from range(1,4);\n+select * from range(1,6) except select * from range(1,4);\n+select * from range(1,6) except all select * from range(1,4);\n+\n+-- check sorted implementation\n+-- set enable_hashagg = false;\n+-- set enable_sort = true;\n+\n+-- explain (costs off)\n+-- select from generate_series(1,5) union select from generate_series(1,3);\n+-- explain (costs off)\n+-- select from generate_series(1,5) intersect select from generate_series(1,3);\n+\n+select * from range(1,6) union select * from range(1,4);\n+select * from range(1,6) union all select * from range(1,4);\n+select * from range(1,6) intersect select * from range(1,4);\n+select * from range(1,6) intersect all select * from range(1,4);\n+select * from range(1,6) except select * from range(1,4);\n+select * from range(1,6) except all select * from range(1,4);\n+\n+-- reset enable_hashagg;\n+-- reset enable_sort;\n+\n+--\n+-- Check handling of a case with unknown constants.  We don't guarantee\n+-- an undecorated constant will work in all cases, but historically this\n+-- usage has worked, so test we don't break it.\n+--\n+\n+-- SELECT a.f1 FROM (SELECT 'test' AS f1 FROM varchar_tbl) a",
    "line": 267
  }],
  "prId": 25163
}]