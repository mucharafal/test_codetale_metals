[{
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "How to create `int4_tbl`? `int4_tbl` is not created by [copy.source](https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/input/copy.source), via [int4.sql#L5-L18](https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/int4.sql#L5-L18)?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-30T14:38:55Z",
    "diffHunk": "@@ -0,0 +1,217 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+explain\n+  select min(unique1) from tenk1;\n+select min(unique1) from tenk1;\n+explain\n+  select max(unique1) from tenk1;\n+select max(unique1) from tenk1;\n+explain\n+  select max(unique1) from tenk1 where unique1 < 42;\n+select max(unique1) from tenk1 where unique1 < 42;\n+explain\n+  select max(unique1) from tenk1 where unique1 > 42;\n+select max(unique1) from tenk1 where unique1 > 42;\n+\n+-- the planner may choose a generic aggregate here if parallel query is\n+-- enabled, since that plan will be parallel safe and the \"optimized\"\n+-- plan, which has almost identical cost, will not be.  we want to test\n+-- the optimized plan, so temporarily disable parallel query.\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+explain\n+  select max(unique1) from tenk1 where unique1 > 42000;\n+select max(unique1) from tenk1 where unique1 > 42000;\n+-- rollback;\n+\n+-- multi-column index (uses tenk1_thous_tenthous)\n+explain\n+  select max(tenthous) from tenk1 where thousand = 33;\n+select max(tenthous) from tenk1 where thousand = 33;\n+explain\n+  select min(tenthous) from tenk1 where thousand = 33;\n+select min(tenthous) from tenk1 where thousand = 33;\n+\n+-- check parameter propagation into an indexscan subquery\n+explain\n+  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+    from int4_tbl;"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "You can try to create a table at the beginning of this test suite and compare the results. If that matched, I think that is the right source. \r\n\r\nYou also can create a temp view for that \r\n```\r\ncreate temporary view int4_tbl as select * from values\r\n  (...),\r\n...\r\n  (...)\r\n  as int4_tbl(f1);\r\n```\r\n\r\n",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-31T06:44:35Z",
    "diffHunk": "@@ -0,0 +1,217 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+explain\n+  select min(unique1) from tenk1;\n+select min(unique1) from tenk1;\n+explain\n+  select max(unique1) from tenk1;\n+select max(unique1) from tenk1;\n+explain\n+  select max(unique1) from tenk1 where unique1 < 42;\n+select max(unique1) from tenk1 where unique1 < 42;\n+explain\n+  select max(unique1) from tenk1 where unique1 > 42;\n+select max(unique1) from tenk1 where unique1 > 42;\n+\n+-- the planner may choose a generic aggregate here if parallel query is\n+-- enabled, since that plan will be parallel safe and the \"optimized\"\n+-- plan, which has almost identical cost, will not be.  we want to test\n+-- the optimized plan, so temporarily disable parallel query.\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+explain\n+  select max(unique1) from tenk1 where unique1 > 42000;\n+select max(unique1) from tenk1 where unique1 > 42000;\n+-- rollback;\n+\n+-- multi-column index (uses tenk1_thous_tenthous)\n+explain\n+  select max(tenthous) from tenk1 where thousand = 33;\n+select max(tenthous) from tenk1 where thousand = 33;\n+explain\n+  select min(tenthous) from tenk1 where thousand = 33;\n+select min(tenthous) from tenk1 where thousand = 33;\n+\n+-- check parameter propagation into an indexscan subquery\n+explain\n+  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+    from int4_tbl;"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-01T09:52:02Z",
    "diffHunk": "@@ -0,0 +1,217 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+explain\n+  select min(unique1) from tenk1;\n+select min(unique1) from tenk1;\n+explain\n+  select max(unique1) from tenk1;\n+select max(unique1) from tenk1;\n+explain\n+  select max(unique1) from tenk1 where unique1 < 42;\n+select max(unique1) from tenk1 where unique1 < 42;\n+explain\n+  select max(unique1) from tenk1 where unique1 > 42;\n+select max(unique1) from tenk1 where unique1 > 42;\n+\n+-- the planner may choose a generic aggregate here if parallel query is\n+-- enabled, since that plan will be parallel safe and the \"optimized\"\n+-- plan, which has almost identical cost, will not be.  we want to test\n+-- the optimized plan, so temporarily disable parallel query.\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+explain\n+  select max(unique1) from tenk1 where unique1 > 42000;\n+select max(unique1) from tenk1 where unique1 > 42000;\n+-- rollback;\n+\n+-- multi-column index (uses tenk1_thous_tenthous)\n+explain\n+  select max(tenthous) from tenk1 where thousand = 33;\n+select max(tenthous) from tenk1 where thousand = 33;\n+explain\n+  select min(tenthous) from tenk1 where thousand = 33;\n+select min(tenthous) from tenk1 where thousand = 33;\n+\n+-- check parameter propagation into an indexscan subquery\n+explain\n+  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+    from int4_tbl;"
  }],
  "prId": 24743
}, {
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Do we need to deal with `booland_statefunc` and `boolor_statefunc`? These 2 functions are not exist in doc: https://www.postgresql.org/docs/12/functions-aggregate.html",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-30T14:52:48Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "```\r\n  288  * Function for standard EVERY aggregate conforming to SQL 2003.\r\n  289  * The aggregate is also named bool_and for consistency.\r\n  290  *\r\n  291  * Note: this is only used in plain aggregate mode, not moving-aggregate mode.\r\n```\r\n\r\nSee: https://doxygen.postgresql.org/bool_8c_source.html",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-31T06:46:43Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "`BooleanType and BooleanType` is equivalent to `bool bool_and bool`?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-31T06:50:03Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Yes. it's equivalent. BOOL_AND and booland_statefunc, BOOL_OR and boolor_statefunc.",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-01T09:50:51Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Can we rewrite the queries by using AND on the columns with boolean data types?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-02T17:45:28Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Do you mean:\r\n```sql\r\nselect NULL and NULL is null AS \"t\"\r\n```\r\n?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-03T06:05:36Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "yes. ",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-05T01:07:56Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "The behaviour different:\r\n\r\n1. Spark SQL:\r\n```sql\r\nSELECT\r\n  -- boolean and transitions\r\n  -- null because strict\r\n  NULL and NULL IS NULL AS `t`,\r\n  TRUE and NULL IS NULL AS `t`,\r\n  FALSE and NULL IS NULL AS `t`,\r\n  NULL and TRUE IS NULL AS `t`,\r\n  NULL and FALSE IS NULL AS `t`,\r\n  -- and actual computations\r\n  TRUE and TRUE AS `t`,\r\n  NOT TRUE and FALSE AS `t`,\r\n  NOT FALSE and TRUE AS `t`,\r\n  NOT FALSE and FALSE AS `t`\r\n-- !query 1 schema\r\nstruct<t:boolean,t:boolean,t:boolean,t:boolean,t:boolean,t:boolean,t:boolean,t:boolean,t:boolean>\r\n-- !query 1 output\r\nNULL\ttrue\tfalse\tfalse\tfalse\ttrue\tfalse\ttrue\tfalse\r\n``` \r\n\r\nPostgreSQL:\r\n```sql\r\nSELECT\r\n  -- boolean and transitions\r\n  -- null because strict\r\n  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\r\n  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\r\n  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\r\n  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\r\n  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\r\n  -- and actual computations\r\n  booland_statefunc(TRUE, TRUE) AS \"t\",\r\n  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\r\n  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\r\n  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\r\n t | t | t | t | t | t | t | t | t \r\n---+---+---+---+---+---+---+---+---\r\n t | t | t | t | t | t | t | t | t\r\n(1 row)\r\n```",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-05T13:12:08Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "You need to add parenthesis. \r\n\r\n```\r\n%sql\r\nSELECT\r\n  -- boolean and transitions\r\n  -- null because strict\r\n  (NULL and NULL) IS NULL AS `t`,\r\n  (TRUE and NULL) IS NULL AS `t`,\r\n  (FALSE and NULL) IS NULL AS `t`,\r\n  (NULL and TRUE) IS NULL AS `t`,\r\n  (NULL and FALSE) IS NULL AS `t`,\r\n  -- and actual computations\r\n  TRUE and TRUE AS `t`,\r\n  NOT (TRUE and FALSE) AS `t`,\r\n  NOT (FALSE and TRUE) AS `t`,\r\n  NOT (FALSE and FALSE) AS `t`\r\n```\r\n\r\nYou will still see the difference. That is because of the strict mode.\r\n\r\nBased on the doc of postgreSQL https://www.postgresql.org/docs/9.5/sql-createfunction.html\r\n, for strict mode, \r\n> STRICT indicates that the function always returns null whenever any of its arguments are null. If this parameter is specified, the function is not executed when there are null arguments; instead a null result is assumed automatically.\r\n\r\nOur AND does not have a strict mode. It is fine to have a behavior difference, but you need to update the comment to explain it.\r\n\r\n",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-05T16:04:56Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Thank you, I see.",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-06T07:15:11Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT"
  }],
  "prId": 24743
}, {
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Our `range(1,3)` can not replace `generate_series(1,3)` here.  How to deal with this case?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-30T15:15:03Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n \n -- empty case\n-SELECT\n-  BOOL_AND(b1)   AS \"n\",\n-  BOOL_OR(b3)    AS \"n\"\n-FROM bool_test;\n-\n-COPY bool_test FROM STDIN NULL 'null';\n-TRUE\tnull\tFALSE\tnull\n-FALSE\tTRUE\tnull\tnull\n-null\tTRUE\tFALSE\tnull\n-\\.\n-\n-SELECT\n-  BOOL_AND(b1)     AS \"f\",\n-  BOOL_AND(b2)     AS \"t\",\n-  BOOL_AND(b3)     AS \"f\",\n-  BOOL_AND(b4)     AS \"n\",\n-  BOOL_AND(NOT b2) AS \"f\",\n-  BOOL_AND(NOT b3) AS \"t\"\n-FROM bool_test;\n-\n-SELECT\n-  EVERY(b1)     AS \"f\",\n-  EVERY(b2)     AS \"t\",\n-  EVERY(b3)     AS \"f\",\n-  EVERY(b4)     AS \"n\",\n-  EVERY(NOT b2) AS \"f\",\n-  EVERY(NOT b3) AS \"t\"\n-FROM bool_test;\n-\n-SELECT\n-  BOOL_OR(b1)      AS \"t\",\n-  BOOL_OR(b2)      AS \"t\",\n-  BOOL_OR(b3)      AS \"f\",\n-  BOOL_OR(b4)      AS \"n\",\n-  BOOL_OR(NOT b2)  AS \"f\",\n-  BOOL_OR(NOT b3)  AS \"t\"\n-FROM bool_test;\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n \n --\n -- Test cases that should be optimized into indexscans instead of\n -- the generic aggregate implementation.\n --\n \n -- Basic cases\n-explain (costs off)\n+explain\n   select min(unique1) from tenk1;\n select min(unique1) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1;\n select max(unique1) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1 where unique1 < 42;\n select max(unique1) from tenk1 where unique1 < 42;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1 where unique1 > 42;\n select max(unique1) from tenk1 where unique1 > 42;\n \n -- the planner may choose a generic aggregate here if parallel query is\n -- enabled, since that plan will be parallel safe and the \"optimized\"\n -- plan, which has almost identical cost, will not be.  we want to test\n -- the optimized plan, so temporarily disable parallel query.\n-begin;\n-set local max_parallel_workers_per_gather = 0;\n-explain (costs off)\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+explain\n   select max(unique1) from tenk1 where unique1 > 42000;\n select max(unique1) from tenk1 where unique1 > 42000;\n-rollback;\n+-- rollback;\n \n -- multi-column index (uses tenk1_thous_tenthous)\n-explain (costs off)\n+explain\n   select max(tenthous) from tenk1 where thousand = 33;\n select max(tenthous) from tenk1 where thousand = 33;\n-explain (costs off)\n+explain\n   select min(tenthous) from tenk1 where thousand = 33;\n select min(tenthous) from tenk1 where thousand = 33;\n \n -- check parameter propagation into an indexscan subquery\n-explain (costs off)\n+explain\n   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n     from int4_tbl;\n select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n   from int4_tbl;\n \n -- check some cases that were handled incorrectly in 8.3.0\n-explain (costs off)\n+explain\n   select distinct max(unique2) from tenk1;\n select distinct max(unique2) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by 1;\n select max(unique2) from tenk1 order by 1;\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by max(unique2);\n select max(unique2) from tenk1 order by max(unique2);\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by max(unique2)+1;\n select max(unique2) from tenk1 order by max(unique2)+1;\n-explain (costs off)\n+explain\n   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "rewrite the query?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-31T07:01:41Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n \n -- empty case\n-SELECT\n-  BOOL_AND(b1)   AS \"n\",\n-  BOOL_OR(b3)    AS \"n\"\n-FROM bool_test;\n-\n-COPY bool_test FROM STDIN NULL 'null';\n-TRUE\tnull\tFALSE\tnull\n-FALSE\tTRUE\tnull\tnull\n-null\tTRUE\tFALSE\tnull\n-\\.\n-\n-SELECT\n-  BOOL_AND(b1)     AS \"f\",\n-  BOOL_AND(b2)     AS \"t\",\n-  BOOL_AND(b3)     AS \"f\",\n-  BOOL_AND(b4)     AS \"n\",\n-  BOOL_AND(NOT b2) AS \"f\",\n-  BOOL_AND(NOT b3) AS \"t\"\n-FROM bool_test;\n-\n-SELECT\n-  EVERY(b1)     AS \"f\",\n-  EVERY(b2)     AS \"t\",\n-  EVERY(b3)     AS \"f\",\n-  EVERY(b4)     AS \"n\",\n-  EVERY(NOT b2) AS \"f\",\n-  EVERY(NOT b3) AS \"t\"\n-FROM bool_test;\n-\n-SELECT\n-  BOOL_OR(b1)      AS \"t\",\n-  BOOL_OR(b2)      AS \"t\",\n-  BOOL_OR(b3)      AS \"f\",\n-  BOOL_OR(b4)      AS \"n\",\n-  BOOL_OR(NOT b2)  AS \"f\",\n-  BOOL_OR(NOT b3)  AS \"t\"\n-FROM bool_test;\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n \n --\n -- Test cases that should be optimized into indexscans instead of\n -- the generic aggregate implementation.\n --\n \n -- Basic cases\n-explain (costs off)\n+explain\n   select min(unique1) from tenk1;\n select min(unique1) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1;\n select max(unique1) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1 where unique1 < 42;\n select max(unique1) from tenk1 where unique1 < 42;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1 where unique1 > 42;\n select max(unique1) from tenk1 where unique1 > 42;\n \n -- the planner may choose a generic aggregate here if parallel query is\n -- enabled, since that plan will be parallel safe and the \"optimized\"\n -- plan, which has almost identical cost, will not be.  we want to test\n -- the optimized plan, so temporarily disable parallel query.\n-begin;\n-set local max_parallel_workers_per_gather = 0;\n-explain (costs off)\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+explain\n   select max(unique1) from tenk1 where unique1 > 42000;\n select max(unique1) from tenk1 where unique1 > 42000;\n-rollback;\n+-- rollback;\n \n -- multi-column index (uses tenk1_thous_tenthous)\n-explain (costs off)\n+explain\n   select max(tenthous) from tenk1 where thousand = 33;\n select max(tenthous) from tenk1 where thousand = 33;\n-explain (costs off)\n+explain\n   select min(tenthous) from tenk1 where thousand = 33;\n select min(tenthous) from tenk1 where thousand = 33;\n \n -- check parameter propagation into an indexscan subquery\n-explain (costs off)\n+explain\n   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n     from int4_tbl;\n select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n   from int4_tbl;\n \n -- check some cases that were handled incorrectly in 8.3.0\n-explain (costs off)\n+explain\n   select distinct max(unique2) from tenk1;\n select distinct max(unique2) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by 1;\n select max(unique2) from tenk1 order by 1;\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by max(unique2);\n select max(unique2) from tenk1 order by max(unique2);\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by max(unique2)+1;\n select max(unique2) from tenk1 order by max(unique2)+1;\n-explain (costs off)\n+explain\n   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-01T09:52:11Z",
    "diffHunk": "@@ -7,207 +7,211 @@\n \n -- Test handling of Params within aggregate arguments in hashed aggregation.\n -- Per bug report from Jeevan Chalke.\n-explain (verbose, costs off)\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-select s1, s2, sm\n-from generate_series(1, 3) s1,\n-     lateral (select s2, sum(s1 + s2) sm\n-              from generate_series(1, 3) s2 group by s2) ss\n-order by 1, 2;\n-\n-explain (verbose, costs off)\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-select array(select sum(x+y) s\n-            from generate_series(1,3) y group by y order by s)\n-  from generate_series(1,3) x;\n-\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n --\n -- test for bitwise integer aggregates\n --\n-CREATE TEMPORARY TABLE bitwise_test(\n-  i2 INT2,\n-  i4 INT4,\n-  i8 INT8,\n-  i INTEGER,\n-  x INT2,\n-  y BIT(4)\n-);\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n \n -- empty case\n-SELECT\n-  BIT_AND(i2) AS \"?\",\n-  BIT_OR(i4)  AS \"?\"\n-FROM bitwise_test;\n-\n-COPY bitwise_test FROM STDIN NULL 'null';\n-1\t1\t1\t1\t1\tB0101\n-3\t3\t3\tnull\t2\tB0100\n-7\t7\t7\t3\t4\tB1100\n-\\.\n-\n-SELECT\n-  BIT_AND(i2) AS \"1\",\n-  BIT_AND(i4) AS \"1\",\n-  BIT_AND(i8) AS \"1\",\n-  BIT_AND(i)  AS \"?\",\n-  BIT_AND(x)  AS \"0\",\n-  BIT_AND(y)  AS \"0100\",\n-\n-  BIT_OR(i2)  AS \"7\",\n-  BIT_OR(i4)  AS \"7\",\n-  BIT_OR(i8)  AS \"7\",\n-  BIT_OR(i)   AS \"?\",\n-  BIT_OR(x)   AS \"7\",\n-  BIT_OR(y)   AS \"1101\"\n-FROM bitwise_test;\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n \n --\n -- test boolean aggregates\n --\n -- first test all possible transition and final states\n \n-SELECT\n-  -- boolean and transitions\n-  -- null because strict\n-  booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- and actual computations\n-  booland_statefunc(TRUE, TRUE) AS \"t\",\n-  NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n-  NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n-\n-SELECT\n-  -- boolean or transitions\n-  -- null because strict\n-  boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n-  boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n-  boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n-  boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n-  -- actual computations\n-  boolor_statefunc(TRUE, TRUE) AS \"t\",\n-  boolor_statefunc(TRUE, FALSE) AS \"t\",\n-  boolor_statefunc(FALSE, TRUE) AS \"t\",\n-  NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n-\n-CREATE TEMPORARY TABLE bool_test(\n-  b1 BOOL,\n-  b2 BOOL,\n-  b3 BOOL,\n-  b4 BOOL);\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n \n -- empty case\n-SELECT\n-  BOOL_AND(b1)   AS \"n\",\n-  BOOL_OR(b3)    AS \"n\"\n-FROM bool_test;\n-\n-COPY bool_test FROM STDIN NULL 'null';\n-TRUE\tnull\tFALSE\tnull\n-FALSE\tTRUE\tnull\tnull\n-null\tTRUE\tFALSE\tnull\n-\\.\n-\n-SELECT\n-  BOOL_AND(b1)     AS \"f\",\n-  BOOL_AND(b2)     AS \"t\",\n-  BOOL_AND(b3)     AS \"f\",\n-  BOOL_AND(b4)     AS \"n\",\n-  BOOL_AND(NOT b2) AS \"f\",\n-  BOOL_AND(NOT b3) AS \"t\"\n-FROM bool_test;\n-\n-SELECT\n-  EVERY(b1)     AS \"f\",\n-  EVERY(b2)     AS \"t\",\n-  EVERY(b3)     AS \"f\",\n-  EVERY(b4)     AS \"n\",\n-  EVERY(NOT b2) AS \"f\",\n-  EVERY(NOT b3) AS \"t\"\n-FROM bool_test;\n-\n-SELECT\n-  BOOL_OR(b1)      AS \"t\",\n-  BOOL_OR(b2)      AS \"t\",\n-  BOOL_OR(b3)      AS \"f\",\n-  BOOL_OR(b4)      AS \"n\",\n-  BOOL_OR(NOT b2)  AS \"f\",\n-  BOOL_OR(NOT b3)  AS \"t\"\n-FROM bool_test;\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n \n --\n -- Test cases that should be optimized into indexscans instead of\n -- the generic aggregate implementation.\n --\n \n -- Basic cases\n-explain (costs off)\n+explain\n   select min(unique1) from tenk1;\n select min(unique1) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1;\n select max(unique1) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1 where unique1 < 42;\n select max(unique1) from tenk1 where unique1 < 42;\n-explain (costs off)\n+explain\n   select max(unique1) from tenk1 where unique1 > 42;\n select max(unique1) from tenk1 where unique1 > 42;\n \n -- the planner may choose a generic aggregate here if parallel query is\n -- enabled, since that plan will be parallel safe and the \"optimized\"\n -- plan, which has almost identical cost, will not be.  we want to test\n -- the optimized plan, so temporarily disable parallel query.\n-begin;\n-set local max_parallel_workers_per_gather = 0;\n-explain (costs off)\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+explain\n   select max(unique1) from tenk1 where unique1 > 42000;\n select max(unique1) from tenk1 where unique1 > 42000;\n-rollback;\n+-- rollback;\n \n -- multi-column index (uses tenk1_thous_tenthous)\n-explain (costs off)\n+explain\n   select max(tenthous) from tenk1 where thousand = 33;\n select max(tenthous) from tenk1 where thousand = 33;\n-explain (costs off)\n+explain\n   select min(tenthous) from tenk1 where thousand = 33;\n select min(tenthous) from tenk1 where thousand = 33;\n \n -- check parameter propagation into an indexscan subquery\n-explain (costs off)\n+explain\n   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n     from int4_tbl;\n select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n   from int4_tbl;\n \n -- check some cases that were handled incorrectly in 8.3.0\n-explain (costs off)\n+explain\n   select distinct max(unique2) from tenk1;\n select distinct max(unique2) from tenk1;\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by 1;\n select max(unique2) from tenk1 order by 1;\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by max(unique2);\n select max(unique2) from tenk1 order by max(unique2);\n-explain (costs off)\n+explain\n   select max(unique2) from tenk1 order by max(unique2)+1;\n select max(unique2) from tenk1 order by max(unique2)+1;\n-explain (costs off)\n+explain\n   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;"
  }],
  "prId": 24743
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "These plans are not useful for us. Can we skip them?",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-05-31T07:01:10Z",
    "diffHunk": "@@ -0,0 +1,217 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+explain"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Done",
    "commit": "41d4e0a4babb29e89532b411c742e481ad632e61",
    "createdAt": "2019-06-01T09:52:24Z",
    "diffHunk": "@@ -0,0 +1,217 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- SELECT\n+     -- boolean and transitions\n+     -- null because strict\n+--   booland_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   booland_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   booland_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   booland_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- and actual computations\n+--   booland_statefunc(TRUE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(TRUE, FALSE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT booland_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- SELECT\n+     -- boolean or transitions\n+     -- null because strict\n+--   boolor_statefunc(NULL, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(TRUE, NULL)  IS NULL AS \"t\",\n+--   boolor_statefunc(FALSE, NULL) IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, TRUE)  IS NULL AS \"t\",\n+--   boolor_statefunc(NULL, FALSE) IS NULL AS \"t\",\n+     -- actual computations\n+--   boolor_statefunc(TRUE, TRUE) AS \"t\",\n+--   boolor_statefunc(TRUE, FALSE) AS \"t\",\n+--   boolor_statefunc(FALSE, TRUE) AS \"t\",\n+--   NOT boolor_statefunc(FALSE, FALSE) AS \"t\";\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+explain"
  }],
  "prId": 24743
}]