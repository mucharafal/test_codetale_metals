[{
  "comments": [{
    "author": {
      "login": "peter-toth"
    },
    "body": "Is there a way to show the DDL of a view in Spark?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-06-25T14:18:18Z",
    "diffHunk": "@@ -0,0 +1,1216 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+-- [ORIGINAL SQL]\n+--WITH q1(x,y) AS (SELECT 1,2)\n+--SELECT * FROM q1, q1 AS q2;\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1 CROSS JOIN q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);",
    "line": 249
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "@dongjoon-hyun can you please advise what shall I do with this?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T19:21:12Z",
    "diffHunk": "@@ -0,0 +1,1216 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+-- [ORIGINAL SQL]\n+--WITH q1(x,y) AS (SELECT 1,2)\n+--SELECT * FROM q1, q1 AS q2;\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1 CROSS JOIN q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);",
    "line": 249
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "According to the `case.sql`, it seems that we prefer to use `crossJoin.enabled` at the beginning and at the end.\r\n```\r\nset spark.sql.crossJoin.enabled=true;\r\n...\r\nset spark.sql.crossJoin.enabled=false;\r\n```",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-06-26T20:42:53Z",
    "diffHunk": "@@ -0,0 +1,1216 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+-- [ORIGINAL SQL]\n+--WITH q1(x,y) AS (SELECT 1,2)\n+--SELECT * FROM q1, q1 AS q2;\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1 CROSS JOIN q1 AS q2;"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Thanks @dongjoon-hyun, I've changed it.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-06-28T13:43:00Z",
    "diffHunk": "@@ -0,0 +1,1216 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+-- [ORIGINAL SQL]\n+--WITH q1(x,y) AS (SELECT 1,2)\n+--SELECT * FROM q1, q1 AS q2;\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1 CROSS JOIN q1 AS q2;"
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "PostgresSQL 12 Beta2 was released on 20th June.\r\n- https://www.postgresql.org/about/news/1949/\r\n\r\nCould you check `https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql`?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-04T03:13:14Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Sure, https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql and https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql are identical.\r\nI've updated the comment.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-04T06:12:28Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thank you!",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-04T19:38:12Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/with.sql"
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "This seems to be a supported SQL statement. Did I miss something?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-06T01:21:21Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ah, it seems to be `USING parquet;` is a typo here because it's Spark SQL syntax.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-06T01:22:55Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Yes I messed this up, will fix this in the next commit.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T19:00:11Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thanks!",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T20:14:56Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Ok, fixed.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-08T12:59:52Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;"
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Do we have a JIRA for `generate_series`?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-06T01:23:41Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))",
    "line": 26
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Actually there is a JIRA: https://issues.apache.org/jira/browse/SPARK-27767, but is is closed as don't fix so I didn't mention it here. Shall I mention it?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T19:02:05Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))",
    "line": 26
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Got it. In that case, could you mention `SPARK-27767` from the beginning of this file as a `Won't Do` issue?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T20:16:14Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))",
    "line": 26
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Ok, done.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-08T12:59:17Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))",
    "line": 26
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "BTW, please keep `TEMPORARY` like the original SQL statement. Then, you can remove `DROP TABLE` at line 477.\r\n```\r\nspark-sql> CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\r\nTime taken: 1.144 seconds\r\n```",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-06T01:25:59Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\n+CREATE TABLE y (a INTEGER) USING parquet;",
    "line": 451
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "I will recheck all `CREATE TABLE`s but the reason I dropped `TEMPORARY` is that `INSERT INTO` follows most of these tables so they can't be temporary.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T19:03:21Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\n+CREATE TABLE y (a INTEGER) USING parquet;",
    "line": 451
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Done.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-08T13:00:12Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\n+CREATE TABLE y (a INTEGER) USING parquet;",
    "line": 451
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Please keep `TEMPORARY`.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-06T01:26:13Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\n+CREATE TABLE y (a INTEGER) USING parquet;\n+-- [ORIGINAL SQL]\n+--INSERT INTO y SELECT generate_series(1, 10);\n+INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10));\n+\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH t AS (\n+--\tSELECT a FROM y\n+--)\n+--INSERT INTO y\n+--SELECT a+20 FROM t RETURNING *;\n+--\n+--SELECT * FROM y;\n+\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+----WITH t AS (\n+----\tSELECT a FROM y\n+----)\n+----UPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;\n+--\n+--SELECT * FROM y;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH RECURSIVE t(a) AS (\n+--\tSELECT 11\n+--\tUNION ALL\n+--\tSELECT a+1 FROM t WHERE a < 50\n+--)\n+--DELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;\n+--\n+--SELECT * FROM y;\n+\n+DROP TABLE y;\n+\n+--\n+-- error cases\n+--\n+\n+-- INTERSECT\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- EXCEPT\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- no non-recursive term\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT n FROM x)\n+--\tSELECT * FROM x;\n+\n+-- recursive term in the left hand side (strictly speaking, should allow this)\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)\n+--\tSELECT * FROM x;\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER);\n+CREATE TABLE y (a INTEGER) USING parquet;",
    "line": 519
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "I think `INSERT INTO` follows this one too.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-07T19:04:41Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\n+CREATE TABLE y (a INTEGER) USING parquet;\n+-- [ORIGINAL SQL]\n+--INSERT INTO y SELECT generate_series(1, 10);\n+INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10));\n+\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH t AS (\n+--\tSELECT a FROM y\n+--)\n+--INSERT INTO y\n+--SELECT a+20 FROM t RETURNING *;\n+--\n+--SELECT * FROM y;\n+\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+----WITH t AS (\n+----\tSELECT a FROM y\n+----)\n+----UPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;\n+--\n+--SELECT * FROM y;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH RECURSIVE t(a) AS (\n+--\tSELECT 11\n+--\tUNION ALL\n+--\tSELECT a+1 FROM t WHERE a < 50\n+--)\n+--DELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;\n+--\n+--SELECT * FROM y;\n+\n+DROP TABLE y;\n+\n+--\n+-- error cases\n+--\n+\n+-- INTERSECT\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- EXCEPT\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- no non-recursive term\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT n FROM x)\n+--\tSELECT * FROM x;\n+\n+-- recursive term in the left hand side (strictly speaking, should allow this)\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)\n+--\tSELECT * FROM x;\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER);\n+CREATE TABLE y (a INTEGER) USING parquet;",
    "line": 519
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "~ditto. `create temp table test`.~ Oops. Please ignore this. This table is used for `insert into`.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-06T01:27:20Z",
    "diffHunk": "@@ -0,0 +1,1222 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;\n+\n+--\n+-- Tests for common table expressions (WITH query, ... SELECT ...)\n+--\n+\n+-- Basic WITH\n+WITH q1(x,y) AS (SELECT 1,2)\n+SELECT * FROM q1, q1 AS q2;\n+\n+-- Multiple uses are evaluated only once\n+-- [SPARK-19799] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n+--    SELECT * FROM q1\n+--  UNION\n+--    SELECT * FROM q1\n+--) ss;\n+\n+-- WITH RECURSIVE\n+\n+-- sum of 1..100\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT (VALUES(1))\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 5\n+--)\n+--SELECT * FROM t;\n+\n+-- recursive view\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 5;\n+--\n+--SELECT * FROM nums;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM nums WHERE n < 6;\n+--\n+--SELECT * FROM nums;\n+\n+-- This is an infinite loop with UNION ALL, but not with UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT 10-n FROM t)\n+--SELECT * FROM t;\n+\n+-- This'd be an infinite loop, but outside query reads only as much as needed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- UNION case should have same property\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 1\n+--UNION\n+--    SELECT n+1 FROM t)\n+--SELECT * FROM t LIMIT 10;\n+\n+-- Test behavior with an unknown-type literal in the WITH\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH q AS (SELECT 'foo' AS x)\n+--SELECT x, x IS OF (text) AS is_text FROM q;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT 'foo'\n+--UNION ALL\n+--    SELECT n || ' bar' FROM t WHERE length(n) < 20\n+--)\n+--SELECT n, n IS OF (text) AS is_text FROM t;\n+\n+-- In a perfect world, this would work and resolve the literal as int ...\n+-- but for now, we have to be content with resolving to text too soon.\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28146] Support IS OF type predicate\n+--WITH RECURSIVE t(n) AS (\n+--    SELECT '7'\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 10\n+--)\n+--SELECT n, n IS OF (int) AS is_int FROM t;\n+\n+--\n+-- Some examples with a tree\n+--\n+-- department structure represented here is as follows:\n+--\n+-- ROOT-+->A-+->B-+->C\n+--      |         |\n+--      |         +->D-+->F\n+--      +->E-+->G\n+\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE department (\n+--\tid INTEGER PRIMARY KEY,  -- department ID\n+--\tparent_department INTEGER REFERENCES department, -- upper department ID\n+--\tname string -- department name\n+--);\n+CREATE TABLE department (\n+\tid INTEGER,  -- department ID\n+\tparent_department INTEGER, -- upper department ID\n+\tname string -- department name\n+) USING parquet;\n+\n+INSERT INTO department VALUES (0, NULL, 'ROOT');\n+INSERT INTO department VALUES (1, 0, 'A');\n+INSERT INTO department VALUES (2, 1, 'B');\n+INSERT INTO department VALUES (3, 2, 'C');\n+INSERT INTO department VALUES (4, 2, 'D');\n+INSERT INTO department VALUES (5, 0, 'E');\n+INSERT INTO department VALUES (6, 4, 'F');\n+INSERT INTO department VALUES (7, 5, 'G');\n+\n+\n+-- extract all departments under 'A'. Result should be A, B, C, D and F\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT name as root_name, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- extract all departments under 'A' with \"level\" number.\n+-- Only shows level 2 or more\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n+--(\n+--\t-- non recursive term\n+--\tSELECT 1, * FROM department WHERE name = 'A'\n+--\n+--\tUNION ALL\n+--\n+--\t-- recursive term\n+--\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n+--\t\tWHERE d.parent_department = sd.id\n+--)\n+--SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n+\n+-- \"RECURSIVE\" is ignored if the query has no self-reference\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE subdepartment AS\n+--(\n+--\t-- note lack of recursive UNION structure\n+--\tSELECT * FROM department WHERE name = 'A'\n+--)\n+--SELECT * FROM subdepartment ORDER BY name;\n+\n+-- inside subqueries\n+-- [SPARK-19799] Support WITH clause in subqueries\n+-- [SPARK-24497] Support recursive SQL query\n+--SELECT count(*) FROM (\n+--    WITH RECURSIVE t(n) AS (\n+--        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n+--    )\n+--    SELECT * FROM t) AS t WHERE n < (\n+--        SELECT count(*) FROM (\n+--            WITH RECURSIVE t(n) AS (\n+--                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n+--                )\n+--            SELECT * FROM t WHERE n < 50000\n+--         ) AS t WHERE n < 100);\n+\n+-- use same CTE twice at different subquery levels\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH q1(x,y) AS (\n+--    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n+--  )\n+--SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n+\n+-- via a VIEW\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE TEMPORARY VIEW vsubdepartment AS\n+--\tWITH RECURSIVE subdepartment AS\n+--\t(\n+--\t\t -- non recursive term\n+--\t\tSELECT * FROM department WHERE name = 'A'\n+--\t\tUNION ALL\n+--\t\t-- recursive term\n+--\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n+--\t\t\tWHERE d.parent_department = sd.id\n+--\t)\n+--\tSELECT * FROM subdepartment;\n+--\n+--SELECT * FROM vsubdepartment ORDER BY name;\n+\n+-- Check reverse listing\n+-- [TODO] is there a way to show DDL of a view?\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass);\n+--SELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n+\n+-- Another reverse-listing example\n+-- [SPARK-24497] Support recursive SQL query\n+--CREATE VIEW sums_1_100 AS\n+--WITH RECURSIVE t(n) AS (\n+--    VALUES (1)\n+--UNION ALL\n+--    SELECT n+1 FROM t WHERE n < 100\n+--)\n+--SELECT sum(n) FROM t;\n+\n+-- [TODO] is there a way to show DDL of a view?\n+--\\d+ sums_1_100\n+\n+-- corner case in which sub-WITH gets initialized first\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with x as (select * from q)\n+--       select * from x)\n+--    )\n+--select * from q limit 24;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive q as (\n+--      select * from department\n+--    union all\n+--      (with recursive x as (\n+--           select * from department\n+--         union all\n+--           (select * from q union all select * from x)\n+--        )\n+--       select * from x)\n+--    )\n+--select * from q limit 32;\n+\n+-- recursive term has sub-UNION\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(i,j) AS (\n+--\tVALUES (1,2)\n+--\tUNION ALL\n+--\tSELECT t2.i, t.j+1 FROM\n+--\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n+--\t\tJOIN t ON (t2.i = t.i+1))\n+--\n+--\tSELECT * FROM t;\n+\n+--\n+-- different tree example\n+--\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE tree(\n+--    id INTEGER PRIMARY KEY,\n+--    parent_id INTEGER REFERENCES tree(id)\n+--);\n+CREATE TABLE tree(\n+    id INTEGER,\n+    parent_id INTEGER\n+) USING parquet;\n+\n+INSERT INTO tree\n+VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n+       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n+\n+--\n+-- get all paths from \"second level\" nodes to leaf nodes\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tORDER BY t1.id, t2.id;\n+\n+-- just count 'em\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n+--\t(t1.path[1] = t2.path[1] AND\n+--\tarray_upper(t1.path,1) = 1 AND\n+--\tarray_upper(t2.path,1) > 1)\n+--\tGROUP BY t1.id\n+--\tORDER BY t1.id;\n+\n+-- this variant tickled a whole-row-variable bug in 8.4devel\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(id, path) AS (\n+--    VALUES(1,ARRAY[]::integer[])\n+--UNION ALL\n+--    SELECT tree.id, t.path || tree.id\n+--    FROM tree JOIN t ON (tree.parent_id = t.id)\n+--)\n+--SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n+--(t1.id=t2.id);\n+\n+--\n+-- test cycle detection\n+--\n+-- [ORIGINAL SQL]\n+--create temp table graph( f int, t int, label text );\n+create table graph( f int, t int, label string ) USING parquet;\n+\n+insert into graph values\n+\t(1, 2, 'arc 1 -> 2'),\n+\t(1, 3, 'arc 1 -> 3'),\n+\t(2, 3, 'arc 2 -> 3'),\n+\t(1, 4, 'arc 1 -> 4'),\n+\t(4, 5, 'arc 4 -> 5'),\n+\t(5, 1, 'arc 5 -> 1');\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph;\n+\n+-- ordering by the path column has same effect as SEARCH DEPTH FIRST\n+-- [SPARK-24497] Support recursive SQL query\n+--with recursive search_graph(f, t, label, path, cycle) as (\n+--\tselect *, array[row(g.f, g.t)], false from graph g\n+--\tunion all\n+--\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n+--\tfrom graph g, search_graph sg\n+--\twhere g.f = sg.t and not cycle\n+--)\n+--select * from search_graph order by path;\n+\n+--\n+-- test multiple WITH queries\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  y (id) AS (VALUES (1)),\n+--  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- forward reference OK\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--    y(id) AS (values (1))\n+-- SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n+--   y(id) AS\n+--     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n+-- SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--   x(id) AS\n+--     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n+--   y(id) AS\n+--     (SELECT * FROM x UNION ALL SELECT * FROM x),\n+--   z(id) AS\n+--     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n+-- SELECT * FROM z;\n+\n+--\n+-- Test WITH attached to a data-modifying statement\n+--\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER) USING parquet;\n+CREATE TABLE y (a INTEGER) USING parquet;\n+-- [ORIGINAL SQL]\n+--INSERT INTO y SELECT generate_series(1, 10);\n+INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10));\n+\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH t AS (\n+--\tSELECT a FROM y\n+--)\n+--INSERT INTO y\n+--SELECT a+20 FROM t RETURNING *;\n+--\n+--SELECT * FROM y;\n+\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+----WITH t AS (\n+----\tSELECT a FROM y\n+----)\n+----UPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;\n+--\n+--SELECT * FROM y;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH RECURSIVE t(a) AS (\n+--\tSELECT 11\n+--\tUNION ALL\n+--\tSELECT a+1 FROM t WHERE a < 50\n+--)\n+--DELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;\n+--\n+--SELECT * FROM y;\n+\n+DROP TABLE y;\n+\n+--\n+-- error cases\n+--\n+\n+-- INTERSECT\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- EXCEPT\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)\n+--\tSELECT * FROM x;\n+\n+-- no non-recursive term\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT n FROM x)\n+--\tSELECT * FROM x;\n+\n+-- recursive term in the left hand side (strictly speaking, should allow this)\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)\n+--\tSELECT * FROM x;\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE y (a INTEGER);\n+CREATE TABLE y (a INTEGER) USING parquet;\n+-- [ORIGINAL SQL]\n+--INSERT INTO y SELECT generate_series(1, 10);\n+INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10));\n+\n+-- LEFT JOIN\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1\n+--\tUNION ALL\n+--\tSELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)\n+--SELECT * FROM x;\n+\n+-- RIGHT JOIN\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1\n+--\tUNION ALL\n+--\tSELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)\n+--SELECT * FROM x;\n+\n+-- FULL JOIN\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1\n+--\tUNION ALL\n+--\tSELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)\n+--SELECT * FROM x;\n+\n+-- subquery\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x\n+--                          WHERE n IN (SELECT * FROM x))\n+--  SELECT * FROM x;\n+\n+-- aggregate functions\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) FROM x)\n+--  SELECT * FROM x;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FROM x)\n+--  SELECT * FROM x;\n+\n+-- ORDER BY\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)\n+--  SELECT * FROM x;\n+\n+-- LIMIT/OFFSET\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)\n+--  SELECT * FROM x;\n+\n+-- FOR UPDATE\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x FOR UPDATE)\n+--  SELECT * FROM x;\n+\n+-- target list has a recursive query name\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE x(id) AS (values (1)\n+--    UNION ALL\n+--    SELECT (SELECT * FROM x) FROM x WHERE id < 5\n+--) SELECT * FROM x;\n+\n+-- mutual recursive query (not implemented)\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),\n+--  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)\n+--SELECT * FROM x;\n+\n+-- non-linear recursion is not allowed\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE foo(i) AS\n+--    (values (1)\n+--    UNION ALL\n+--       (SELECT i+1 FROM foo WHERE i < 10\n+--          UNION ALL\n+--       SELECT i+1 FROM foo WHERE i < 5)\n+--) SELECT * FROM foo;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE foo(i) AS\n+--    (values (1)\n+--    UNION ALL\n+--\t   SELECT * FROM\n+--       (SELECT i+1 FROM foo WHERE i < 10\n+--          UNION ALL\n+--       SELECT i+1 FROM foo WHERE i < 5) AS t\n+--) SELECT * FROM foo;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE foo(i) AS\n+--    (values (1)\n+--    UNION ALL\n+--       (SELECT i+1 FROM foo WHERE i < 10\n+--          EXCEPT\n+--       SELECT i+1 FROM foo WHERE i < 5)\n+--) SELECT * FROM foo;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE foo(i) AS\n+--    (values (1)\n+--    UNION ALL\n+--       (SELECT i+1 FROM foo WHERE i < 10\n+--          INTERSECT\n+--       SELECT i+1 FROM foo WHERE i < 5)\n+--) SELECT * FROM foo;\n+\n+-- Wrong type induced from non-recursive term\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE foo(i) AS\n+--   (SELECT i FROM (VALUES(1),(2)) t(i)\n+--   UNION ALL\n+--   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)\n+--SELECT * FROM foo;\n+\n+-- rejects different typmod, too (should we allow this?)\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE foo(i) AS\n+--   (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)\n+--   UNION ALL\n+--   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)\n+--SELECT * FROM foo;\n+\n+-- [NOTE] Spark SQL doesn't support RULEs\n+-- disallow OLD/NEW reference in CTE\n+--CREATE TABLE x (n integer) USING parquet;\n+--CREATE RULE r2 AS ON UPDATE TO x DO INSTEAD\n+--    WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;\n+\n+--\n+-- test for bug #4902\n+--\n+-- [SPARK-19799] Support recursive SQL query\n+--with cte(foo) as ( values(42) ) values((select foo from cte));\n+with cte(foo) as ( select 42 ) select * from ((select foo from cte)) q;\n+\n+-- test CTE referencing an outer-level variable (to see that changed-parameter\n+-- signaling still works properly after fixing this bug)\n+-- [SPARK-19799] Support WITH clause in subqueries\n+--select ( with cte(foo) as ( values(f1) )\n+--         select (select foo from cte) )\n+--from int4_tbl;\n+\n+-- [SPARK-19799] Support WITH clause in subqueries\n+--select ( with cte(foo) as ( values(f1) )\n+--          values((select foo from cte)) )\n+--from int4_tbl;\n+\n+--\n+-- test for nested-recursive-WITH bug\n+--\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(j) AS (\n+--    WITH RECURSIVE s(i) AS (\n+--        VALUES (1)\n+--        UNION ALL\n+--        SELECT i+1 FROM s WHERE i < 10\n+--    )\n+--    SELECT i FROM s\n+--    UNION ALL\n+--    SELECT j+1 FROM t WHERE j < 10\n+--)\n+--SELECT * FROM t;\n+\n+--\n+-- test WITH attached to intermediate-level set operation\n+--\n+\n+-- [SPARK-19799] Support recursive SQL query\n+--WITH outermost(x) AS (\n+--  SELECT 1\n+--  UNION (WITH innermost as (SELECT 2)\n+--         SELECT * FROM innermost\n+--         UNION SELECT 3)\n+--)\n+--SELECT * FROM outermost ORDER BY 1;\n+\n+-- [SPARK-19799] Support recursive SQL query\n+--WITH outermost(x) AS (\n+--  SELECT 1\n+--  UNION (WITH innermost as (SELECT 2)\n+--         SELECT * FROM outermost  -- fail\n+--         UNION SELECT * FROM innermost)\n+--)\n+--SELECT * FROM outermost ORDER BY 1;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE outermost(x) AS (\n+--  SELECT 1\n+--  UNION (WITH innermost as (SELECT 2)\n+--         SELECT * FROM outermost\n+--         UNION SELECT * FROM innermost)\n+--)\n+--SELECT * FROM outermost ORDER BY 1;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE outermost(x) AS (\n+--  WITH innermost as (SELECT 2 FROM outermost) -- fail\n+--    SELECT * FROM innermost\n+--    UNION SELECT * from outermost\n+--)\n+--SELECT * FROM outermost ORDER BY 1;\n+\n+--\n+-- This test will fail with the old implementation of PARAM_EXEC parameter\n+-- assignment, because the \"q1\" Var passed down to A's targetlist subselect\n+-- looks exactly like the \"A.id\" Var passed down to C's subselect, causing\n+-- the old code to give them the same runtime PARAM_EXEC slot.  But the\n+-- lifespans of the two parameters overlap, thanks to B also reading A.\n+--\n+\n+-- [NOTE] INT8_TBL is created in int8.sql originally\n+--CREATE TABLE INT8_TBL(q1 bigint, q2 bigint) USING parquet;\n+--INSERT INTO INT8_TBL VALUES(trim('  123   '),trim('  456'));\n+--INSERT INTO INT8_TBL VALUES(trim('123   '),'4567890123456789');\n+--INSERT INTO INT8_TBL VALUES('4567890123456789','123');\n+--INSERT INTO INT8_TBL VALUES(+4567890123456789,'4567890123456789');\n+--INSERT INTO INT8_TBL VALUES('+4567890123456789','-4567890123456789');\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+--with\n+--A as ( select q2 as id, (select q1) as x from int8_tbl ),\n+--B as ( select id, row_number() over (partition by id) as r from A ),\n+--C as ( select A.id, array(select B.id from B where B.id = A.id) from A )\n+--select * from C;\n+\n+--DROP TABLE INT8_TBL;\n+\n+--\n+-- Test CTEs read in non-initialization orders\n+--\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),\n+--  iter (id_key, row_type, link) AS (\n+--      SELECT 0, 'base', 17\n+--    UNION ALL (\n+--      WITH remaining(id_key, row_type, link, min) AS (\n+--        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()\n+--        FROM tab INNER JOIN iter USING (link)\n+--        WHERE tab.id_key > iter.id_key\n+--      ),\n+--      first_remaining AS (\n+--        SELECT id_key, row_type, link\n+--        FROM remaining\n+--        WHERE id_key=min\n+--      ),\n+--      effect AS (\n+--        SELECT tab.id_key, 'new'::text, tab.link\n+--        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key\n+--        WHERE e.row_type = 'false'\n+--      )\n+--      SELECT * FROM first_remaining\n+--      UNION ALL SELECT * FROM effect\n+--    )\n+--  )\n+--SELECT * FROM iter;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE\n+--  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),\n+--  iter (id_key, row_type, link) AS (\n+--      SELECT 0, 'base', 17\n+--    UNION (\n+--      WITH remaining(id_key, row_type, link, min) AS (\n+--        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()\n+--        FROM tab INNER JOIN iter USING (link)\n+--        WHERE tab.id_key > iter.id_key\n+--      ),\n+--      first_remaining AS (\n+--        SELECT id_key, row_type, link\n+--        FROM remaining\n+--        WHERE id_key=min\n+--      ),\n+--      effect AS (\n+--        SELECT tab.id_key, 'new'::text, tab.link\n+--        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key\n+--        WHERE e.row_type = 'false'\n+--      )\n+--      SELECT * FROM first_remaining\n+--      UNION ALL SELECT * FROM effect\n+--    )\n+--  )\n+--SELECT * FROM iter;\n+\n+--\n+-- Data-modifying statements in WITH\n+--\n+\n+-- INSERT ... RETURNING\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH t AS (\n+--    INSERT INTO y\n+--    VALUES\n+--        (11),\n+--        (12),\n+--        (13),\n+--        (14),\n+--        (15),\n+--        (16),\n+--        (17),\n+--        (18),\n+--        (19),\n+--        (20)\n+--    RETURNING *\n+--)\n+--SELECT * FROM t;\n+--\n+--SELECT * FROM y;\n+\n+-- UPDATE ... RETURNING\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+--WITH t AS (\n+--    UPDATE y\n+--    SET a=a+1\n+--    RETURNING *\n+--)\n+--SELECT * FROM t;\n+--\n+--SELECT * FROM y;\n+\n+-- DELETE ... RETURNING\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH t AS (\n+--    DELETE FROM y\n+--    WHERE a <= 10\n+--    RETURNING *\n+--)\n+--SELECT * FROM t;\n+--\n+--SELECT * FROM y;\n+\n+-- forward reference\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+--WITH RECURSIVE t AS (\n+--\tINSERT INTO y\n+--\t\tSELECT a+5 FROM t2 WHERE a > 5\n+--\tRETURNING *\n+--), t2 AS (\n+--\tUPDATE y SET a=a-11 RETURNING *\n+--)\n+--SELECT * FROM t\n+--UNION ALL\n+--SELECT * FROM t2;\n+--\n+--SELECT * FROM y;\n+\n+-- unconditional DO INSTEAD rule\n+-- [NOTE] Spark SQL doesn't support RULEs\n+--CREATE RULE y_rule AS ON DELETE TO y DO INSTEAD\n+--  INSERT INTO y VALUES(42) RETURNING *;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH t AS (\n+--\tDELETE FROM y RETURNING *\n+--)\n+--SELECT * FROM t;\n+--\n+--SELECT * FROM y;\n+\n+--DROP RULE y_rule ON y;\n+\n+-- check merging of outer CTE with CTE in a rule action\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE bug6051 AS\n+--  select i from generate_series(1,3) as t(i);\n+CREATE TABLE bug6051 USING parquet AS\n+  SELECT EXPLODE(SEQUENCE(1,3)) AS i;\n+\n+SELECT * FROM bug6051;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH t1 AS ( DELETE FROM bug6051 RETURNING * )\n+--INSERT INTO bug6051 SELECT * FROM t1;\n+--\n+--SELECT * FROM bug6051;\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE bug6051_2 (i int);\n+CREATE TABLE bug6051_2 (i int) USING parquet;\n+\n+--CREATE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD\n+-- INSERT INTO bug6051_2\n+-- SELECT NEW.i;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH t1 AS ( DELETE FROM bug6051 RETURNING * )\n+--INSERT INTO bug6051 SELECT * FROM t1;\n+--\n+--SELECT * FROM bug6051;\n+--SELECT * FROM bug6051_2;\n+\n+-- a truly recursive CTE in the same list\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t(a) AS (\n+--\tSELECT 0\n+--\t\tUNION ALL\n+--\tSELECT a+1 FROM t WHERE a+1 < 5\n+--), t2 as (\n+--\tINSERT INTO y\n+--\t\tSELECT * FROM t RETURNING *\n+--)\n+--SELECT * FROM t2 JOIN y USING (a) ORDER BY a;\n+--\n+--SELECT * FROM y;\n+\n+-- data-modifying WITH in a modifying statement\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH t AS (\n+--    DELETE FROM y\n+--    WHERE a <= 10\n+--    RETURNING *\n+--)\n+--INSERT INTO y SELECT -a FROM t RETURNING *;\n+--\n+--SELECT * FROM y;\n+\n+-- check that WITH query is run to completion even if outer query isn't\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+--WITH t AS (\n+--    UPDATE y SET a = a * 100 RETURNING *\n+--)\n+--SELECT * FROM t LIMIT 10;\n+--\n+--SELECT * FROM y;\n+\n+-- data-modifying WITH containing INSERT...ON CONFLICT DO UPDATE\n+-- [ORIGINAL SQL]\n+--CREATE TABLE withz AS SELECT i AS k, (i || ' v')::text v FROM generate_series(1, 16, 3) i;\n+CREATE TABLE withz USING parquet AS SELECT i AS k, CAST(i || ' v' AS string) v FROM (SELECT EXPLODE(SEQUENCE(1, 16, 3)) i);\n+-- [NOTE] Spark SQL doesn't support UNIQUE constraints\n+--ALTER TABLE withz ADD UNIQUE (k);\n+\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+--WITH t AS (\n+--    INSERT INTO withz SELECT i, 'insert'\n+--    FROM generate_series(0, 16) i\n+--    ON CONFLICT (k) DO UPDATE SET v = withz.v || ', now update'\n+--    RETURNING *\n+--)\n+--SELECT * FROM t JOIN y ON t.k = y.a ORDER BY a, k;\n+\n+-- Test EXCLUDED.* reference within CTE\n+-- [NOTE] Spark SQL doesn't support ON CONFLICT clause\n+--WITH aa AS (\n+--    INSERT INTO withz VALUES(1, 5) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v\n+--    WHERE withz.k != EXCLUDED.k\n+--    RETURNING *\n+--)\n+--SELECT * FROM aa;\n+\n+-- New query/snapshot demonstrates side-effects of previous query.\n+SELECT * FROM withz ORDER BY k;\n+\n+--\n+-- Ensure subqueries within the update clause work, even if they\n+-- reference outside values\n+--\n+-- [NOTE] Spark SQL doesn't support ON CONFLICT clause\n+--WITH aa AS (SELECT 1 a, 2 b)\n+--INSERT INTO withz VALUES(1, 'insert')\n+--ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);\n+--WITH aa AS (SELECT 1 a, 2 b)\n+--INSERT INTO withz VALUES(1, 'insert')\n+--ON CONFLICT (k) DO UPDATE SET v = ' update' WHERE withz.k = (SELECT a FROM aa);\n+--WITH aa AS (SELECT 1 a, 2 b)\n+--INSERT INTO withz VALUES(1, 'insert')\n+--ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);\n+--WITH aa AS (SELECT 'a' a, 'b' b UNION ALL SELECT 'a' a, 'b' b)\n+--INSERT INTO withz VALUES(1, 'insert')\n+--ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 'a' LIMIT 1);\n+--WITH aa AS (SELECT 1 a, 2 b)\n+--INSERT INTO withz VALUES(1, (SELECT b || ' insert' FROM aa WHERE a = 1 ))\n+--ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);\n+\n+-- Update a row more than once, in different parts of a wCTE. That is\n+-- an allowed, presumably very rare, edge case, but since it was\n+-- broken in the past, having a test seems worthwhile.\n+-- [NOTE] Spark SQL doesn't support ON CONFLICT clause\n+--WITH simpletup AS (\n+--  SELECT 2 k, 'Green' v),\n+--upsert_cte AS (\n+--  INSERT INTO withz VALUES(2, 'Blue') ON CONFLICT (k) DO\n+--    UPDATE SET (k, v) = (SELECT k, v FROM simpletup WHERE simpletup.k = withz.k)\n+--    RETURNING k, v)\n+--INSERT INTO withz VALUES(2, 'Red') ON CONFLICT (k) DO\n+--UPDATE SET (k, v) = (SELECT k, v FROM upsert_cte WHERE upsert_cte.k = withz.k)\n+--RETURNING k, v;\n+\n+DROP TABLE withz;\n+\n+-- check that run to completion happens in proper ordering\n+\n+TRUNCATE TABLE y;\n+-- [ORIGINAL SQL]\n+--INSERT INTO y SELECT generate_series(1, 3);\n+INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 3));\n+-- [ORIGINAL SQL]\n+--CREATE TEMPORARY TABLE yy (a INTEGER);\n+CREATE TABLE yy (a INTEGER) USING parquet;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH RECURSIVE t1 AS (\n+--  INSERT INTO y SELECT * FROM y RETURNING *\n+--), t2 AS (\n+--  INSERT INTO yy SELECT * FROM t1 RETURNING *\n+--)\n+--SELECT 1;\n+\n+SELECT * FROM y;\n+SELECT * FROM yy;\n+\n+-- [SPARK-24497] Support recursive SQL query\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH RECURSIVE t1 AS (\n+--  INSERT INTO yy SELECT * FROM t2 RETURNING *\n+--), t2 AS (\n+--  INSERT INTO y SELECT * FROM y RETURNING *\n+--)\n+--SELECT 1;\n+\n+SELECT * FROM y;\n+SELECT * FROM yy;\n+\n+-- [NOTE] Spark SQL doesn't support TRIGGERs\n+-- triggers\n+--\n+--TRUNCATE TABLE y;\n+--INSERT INTO y SELECT generate_series(1, 10);\n+--\n+--CREATE FUNCTION y_trigger() RETURNS trigger AS $$\n+--begin\n+--  raise notice 'y_trigger: a = %', new.a;\n+--  return new;\n+--end;\n+--$$ LANGUAGE plpgsql;\n+--\n+--\n+--CREATE TRIGGER y_trig BEFORE INSERT ON y FOR EACH ROW\n+--    EXECUTE PROCEDURE y_trigger();\n+--\n+--WITH t AS (\n+--    INSERT INTO y\n+--    VALUES\n+--        (21),\n+--        (22),\n+--        (23)\n+--    RETURNING *\n+--)\n+--SELECT * FROM t;\n+--\n+--SELECT * FROM y;\n+--\n+--DROP TRIGGER y_trig ON y;\n+--\n+--CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH ROW\n+--    EXECUTE PROCEDURE y_trigger();\n+--\n+--WITH t AS (\n+--    INSERT INTO y\n+--    VALUES\n+--        (31),\n+--        (32),\n+--        (33)\n+--    RETURNING *\n+--)\n+--SELECT * FROM t LIMIT 1;\n+--\n+--SELECT * FROM y;\n+--\n+--DROP TRIGGER y_trig ON y;\n+--\n+--CREATE OR REPLACE FUNCTION y_trigger() RETURNS trigger AS $$\n+--begin\n+--  raise notice 'y_trigger';\n+--  return null;\n+--end;\n+--$$ LANGUAGE plpgsql;\n+--\n+--CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH STATEMENT\n+--    EXECUTE PROCEDURE y_trigger();\n+--\n+--WITH t AS (\n+--    INSERT INTO y\n+--    VALUES\n+--        (41),\n+--        (42),\n+--        (43)\n+--    RETURNING *\n+--)\n+--SELECT * FROM t;\n+--\n+--SELECT * FROM y;\n+--\n+--DROP TRIGGER y_trig ON y;\n+--DROP FUNCTION y_trigger();\n+\n+-- WITH attached to inherited UPDATE or DELETE\n+\n+-- [ORIGINAL SQL]\n+--CREATE TEMP TABLE parent ( id int, val text );\n+CREATE TABLE parent ( id int, val string ) USING parquet;\n+-- [NOTE] Spark SQL doesn't support INHERITS clause\n+--CREATE TEMP TABLE child1 ( ) INHERITS ( parent );\n+-- [NOTE] Spark SQL doesn't support INHERITS clause\n+--CREATE TEMP TABLE child2 ( ) INHERITS ( parent );\n+\n+INSERT INTO parent VALUES ( 1, 'p1' );\n+--INSERT INTO child1 VALUES ( 11, 'c11' ),( 12, 'c12' );\n+--INSERT INTO child2 VALUES ( 23, 'c21' ),( 24, 'c22' );\n+\n+-- [NOTE] Spark SQL doesn't support UPDATE statement\n+--WITH rcte AS ( SELECT sum(id) AS totalid FROM parent )\n+--UPDATE parent SET id = id + totalid FROM rcte;\n+\n+SELECT * FROM parent;\n+\n+-- [SPARK-28147] Support RETURNING clause\n+--WITH wcte AS ( INSERT INTO child1 VALUES ( 42, 'new' ) RETURNING id AS newid )\n+--UPDATE parent SET id = id + newid FROM wcte;\n+--\n+--SELECT * FROM parent;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH rcte AS ( SELECT max(id) AS maxid FROM parent )\n+--DELETE FROM parent USING rcte WHERE id = maxid;\n+\n+SELECT * FROM parent;\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--WITH wcte AS ( INSERT INTO child2 VALUES ( 42, 'new2' ) RETURNING id AS newid )\n+--DELETE FROM parent USING wcte WHERE id = newid;\n+--\n+--SELECT * FROM parent;\n+\n+-- check EXPLAIN VERBOSE for a wCTE with RETURNING\n+\n+-- [NOTE] Spark SQL doesn't support DELETE statement\n+--EXPLAIN (VERBOSE, COSTS OFF)\n+--WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )\n+--DELETE FROM a USING wcte WHERE aa = q2;\n+\n+-- error cases\n+\n+-- data-modifying WITH tries to use its own output\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH RECURSIVE t AS (\n+--\tINSERT INTO y\n+--\t\tSELECT * FROM t\n+--)\n+--VALUES(FALSE);\n+\n+-- no RETURNING in a referenced data-modifying WITH\n+-- [SPARK-24497] Support recursive SQL query\n+--WITH t AS (\n+--\tINSERT INTO y VALUES(0)\n+--)\n+--SELECT * FROM t;\n+\n+-- data-modifying WITH allowed only at the top level\n+-- [SPARK-28147] Support RETURNING clause\n+--SELECT * FROM (\n+--\tWITH t AS (UPDATE y SET a=a+1 RETURNING *)\n+--\tSELECT * FROM t\n+--) ss;\n+\n+-- most variants of rules aren't allowed\n+-- [NOTE] Spark SQL doesn't support RULEs\n+--CREATE RULE y_rule AS ON INSERT TO y WHERE a=0 DO INSTEAD DELETE FROM y;\n+--WITH t AS (\n+--\tINSERT INTO y VALUES(0)\n+--)\n+--VALUES(FALSE);\n+--DROP RULE y_rule ON y;\n+\n+-- check that parser lookahead for WITH doesn't cause any odd behavior\n+create table foo (with baz);  -- fail, WITH is a reserved word\n+create table foo (with ordinality);  -- fail, WITH is a reserved word\n+with ordinality as (select 1 as x) select * from ordinality;\n+\n+-- check sane response to attempt to modify CTE relation\n+WITH test AS (SELECT 42) INSERT INTO test VALUES (1);\n+\n+-- check response to attempt to modify table with same name as a CTE (perhaps\n+-- surprisingly it works, because CTEs don't hide tables from data-modifying\n+-- statements)\n+-- [ORIGINAL SQL]\n+--create temp table test (i int);\n+create table test (i int) USING parquet;",
    "line": 1199
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Hi, @maropu . \r\nCould you give us some advice on this?",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-08T14:57:22Z",
    "diffHunk": "@@ -1190,7 +1183,9 @@ SELECT * FROM parent;\n --DROP RULE y_rule ON y;\n \n -- check that parser lookahead for WITH doesn't cause any odd behavior\n+-- [TODO] WITH should be a reserved keyword?"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "yea, already reaserved in spark (ansi=true). https://github.com/apache/spark/blob/master/docs/sql-keywords.md",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-11T01:20:15Z",
    "diffHunk": "@@ -1190,7 +1183,9 @@ SELECT * FROM parent;\n --DROP RULE y_rule ON y;\n \n -- check that parser lookahead for WITH doesn't cause any odd behavior\n+-- [TODO] WITH should be a reserved keyword?"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Probably, we can always set ansi=true for these PostgreSQL ported tests by set ansi=true in SQLQueryTestSuite.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-11T01:22:28Z",
    "diffHunk": "@@ -1190,7 +1183,9 @@ SELECT * FROM parent;\n --DROP RULE y_rule ON y;\n \n -- check that parser lookahead for WITH doesn't cause any odd behavior\n+-- [TODO] WITH should be a reserved keyword?"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "+1 for that.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-11T02:09:29Z",
    "diffHunk": "@@ -1190,7 +1183,9 @@ SELECT * FROM parent;\n --DROP RULE y_rule ON y;\n \n -- check that parser lookahead for WITH doesn't cause any odd behavior\n+-- [TODO] WITH should be a reserved keyword?"
  }],
  "prId": 24860
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "This related to my comment there: https://github.com/apache/spark/pull/25092#discussion_r302319639 cc: @wangyum",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-11T01:24:18Z",
    "diffHunk": "@@ -0,0 +1,1215 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;",
    "line": 10
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "@dongjoon-hyun @maropu I filed a JIRA:\r\nhttps://issues.apache.org/jira/browse/SPARK-28343",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-11T02:21:41Z",
    "diffHunk": "@@ -0,0 +1,1215 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;",
    "line": 10
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Great. Thanks, @wangyum .\r\n@maropu . Please update that JIRA if we need more.",
    "commit": "615f59273f2ddd1d167627f3e6c62249adca684d",
    "createdAt": "2019-07-11T02:24:17Z",
    "diffHunk": "@@ -0,0 +1,1215 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- WITH\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/with.sql\n+--\n+-- This test suite contains two Cartesian products without using explicit CROSS JOIN syntax.\n+-- Thus, we set spark.sql.crossJoin.enabled to true.\n+set spark.sql.crossJoin.enabled=true;",
    "line": 10
  }],
  "prId": 24860
}]