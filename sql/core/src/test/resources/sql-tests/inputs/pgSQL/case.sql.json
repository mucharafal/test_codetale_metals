[{
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Need to `set spark.sql.crossJoin.enabled=true`. otherwise:\r\n```\r\n-- !query 30\r\nSELECT '' AS Five, NULLIF(a.i,b.i) AS `NULLIF(a.i,b.i)`,\r\n  NULLIF(b.i, 4) AS `NULLIF(b.i,4)`\r\n  FROM CASE_TBL a, CASE2_TBL b\r\n-- !query 30 schema\r\nstruct<>\r\n-- !query 30 output\r\norg.apache.spark.sql.AnalysisException\r\nDetected implicit cartesian product for INNER join between logical plans\r\nProject [i#x]\r\n+- Relation[i#x,f#x] parquet\r\nand\r\nProject [i#x]\r\n+- Relation[i#x,j#x] parquet\r\nJoin condition is missing or trivial.\r\nEither: use the CROSS JOIN syntax to allow cartesian products between these\r\nrelations, or: enable implicit cartesian products by setting the configuration\r\nvariable spark.sql.crossJoin.enabled=true;\r\n```",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-03T14:12:22Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;",
    "line": 11
  }],
  "prId": 24782
}, {
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Skip `UPDATE` cases? I add a comment here.",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-03T14:20:29Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1\n+--   END AS `NULL on no matches`;\n+\n+-- Constant-expression folding shouldn't evaluate unreachable subexpressions\n+SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;\n+SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;\n+\n+-- [SPARK-27923] PostgreSQL throws an exception but Spark SQL is NULL\n+-- However we do not currently suppress folding of potentially\n+-- reachable subexpressions\n+SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;\n+\n+-- Test for cases involving untyped literals in test expression\n+SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;\n+\n+--\n+-- Examples of targets involving tables\n+--\n+\n+SELECT '' AS `Five`,\n+  CASE\n+    WHEN i >= 3 THEN i\n+  END AS `>= 3 or Null`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN i >= 3 THEN (i + i)\n+       ELSE i\n+  END AS `Simplest Math`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`, i AS `Value`,\n+  CASE WHEN (i < 0) THEN 'small'\n+       WHEN (i = 0) THEN 'zero'\n+       WHEN (i = 1) THEN 'one'\n+       WHEN (i = 2) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN ((i < 0) or (i < 0)) THEN 'small'\n+       WHEN ((i = 0) or (i = 0)) THEN 'zero'\n+       WHEN ((i = 1) or (i = 1)) THEN 'one'\n+       WHEN ((i = 2) or (i = 2)) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+--\n+-- Examples of qualifications involving tables\n+--\n+\n+--\n+-- NULLIF() and COALESCE()\n+-- Shorthand forms for typical CASE constructs\n+--  defined in the SQL standard.\n+--\n+\n+SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;\n+\n+SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;\n+\n+SELECT COALESCE(a.f, b.i, b.j)\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(a.f, b.i, b.j) = 2;\n+\n+SELECT '' AS Five, NULLIF(a.i,b.i) AS `NULLIF(a.i,b.i)`,\n+  NULLIF(b.i, 4) AS `NULLIF(b.i,4)`\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT '' AS `Two`, *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(f,b.i) = 2;\n+\n+-- We don't support update now.",
    "line": 146
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Hi, @gatorsmile and @wangyum . The half of the file is `comment` which is irrelevant to Apache Spark. Do we need to keep all the invalid comments? In fact, the original will be changed time to time, too. For the simply invalid one (which has no SPARK JIRA), shall we skip adding comments?",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-09T02:39:02Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1\n+--   END AS `NULL on no matches`;\n+\n+-- Constant-expression folding shouldn't evaluate unreachable subexpressions\n+SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;\n+SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;\n+\n+-- [SPARK-27923] PostgreSQL throws an exception but Spark SQL is NULL\n+-- However we do not currently suppress folding of potentially\n+-- reachable subexpressions\n+SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;\n+\n+-- Test for cases involving untyped literals in test expression\n+SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;\n+\n+--\n+-- Examples of targets involving tables\n+--\n+\n+SELECT '' AS `Five`,\n+  CASE\n+    WHEN i >= 3 THEN i\n+  END AS `>= 3 or Null`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN i >= 3 THEN (i + i)\n+       ELSE i\n+  END AS `Simplest Math`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`, i AS `Value`,\n+  CASE WHEN (i < 0) THEN 'small'\n+       WHEN (i = 0) THEN 'zero'\n+       WHEN (i = 1) THEN 'one'\n+       WHEN (i = 2) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN ((i < 0) or (i < 0)) THEN 'small'\n+       WHEN ((i = 0) or (i = 0)) THEN 'zero'\n+       WHEN ((i = 1) or (i = 1)) THEN 'one'\n+       WHEN ((i = 2) or (i = 2)) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+--\n+-- Examples of qualifications involving tables\n+--\n+\n+--\n+-- NULLIF() and COALESCE()\n+-- Shorthand forms for typical CASE constructs\n+--  defined in the SQL standard.\n+--\n+\n+SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;\n+\n+SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;\n+\n+SELECT COALESCE(a.f, b.i, b.j)\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(a.f, b.i, b.j) = 2;\n+\n+SELECT '' AS Five, NULLIF(a.i,b.i) AS `NULLIF(a.i,b.i)`,\n+  NULLIF(b.i, 4) AS `NULLIF(b.i,4)`\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT '' AS `Two`, *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(f,b.i) = 2;\n+\n+-- We don't support update now.",
    "line": 146
  }],
  "prId": 24782
}, {
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Skip these cases? I add a comment here.",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-03T14:20:51Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1\n+--   END AS `NULL on no matches`;\n+\n+-- Constant-expression folding shouldn't evaluate unreachable subexpressions\n+SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;\n+SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;\n+\n+-- [SPARK-27923] PostgreSQL throws an exception but Spark SQL is NULL\n+-- However we do not currently suppress folding of potentially\n+-- reachable subexpressions\n+SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;\n+\n+-- Test for cases involving untyped literals in test expression\n+SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;\n+\n+--\n+-- Examples of targets involving tables\n+--\n+\n+SELECT '' AS `Five`,\n+  CASE\n+    WHEN i >= 3 THEN i\n+  END AS `>= 3 or Null`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN i >= 3 THEN (i + i)\n+       ELSE i\n+  END AS `Simplest Math`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`, i AS `Value`,\n+  CASE WHEN (i < 0) THEN 'small'\n+       WHEN (i = 0) THEN 'zero'\n+       WHEN (i = 1) THEN 'one'\n+       WHEN (i = 2) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN ((i < 0) or (i < 0)) THEN 'small'\n+       WHEN ((i = 0) or (i = 0)) THEN 'zero'\n+       WHEN ((i = 1) or (i = 1)) THEN 'one'\n+       WHEN ((i = 2) or (i = 2)) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+--\n+-- Examples of qualifications involving tables\n+--\n+\n+--\n+-- NULLIF() and COALESCE()\n+-- Shorthand forms for typical CASE constructs\n+--  defined in the SQL standard.\n+--\n+\n+SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;\n+\n+SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;\n+\n+SELECT COALESCE(a.f, b.i, b.j)\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(a.f, b.i, b.j) = 2;\n+\n+SELECT '' AS Five, NULLIF(a.i,b.i) AS `NULLIF(a.i,b.i)`,\n+  NULLIF(b.i, 4) AS `NULLIF(b.i,4)`\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT '' AS `Two`, *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(f,b.i) = 2;\n+\n+-- We don't support update now.\n+--\n+-- Examples of updates involving tables\n+--\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN i >= 3 THEN (- i)\n+--                 ELSE (2 * i) END;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN i >= 2 THEN (2 * i)\n+--                 ELSE (3 * i) END;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN b.i >= 2 THEN (2 * j)\n+--                 ELSE (3 * j) END\n+--   FROM CASE2_TBL b\n+--   WHERE j = -CASE_TBL.i;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- We don't support the features below:"
  }],
  "prId": 24782
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "- `is missing` -> `which is missing` or `missed`?\r\n- `we set` -> `We set`.\r\n\r\nBTW, it's not clear about the relation between the missed one and `crossJoin`.",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-09T02:29:25Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true."
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "How about rewriting it to the following text?\r\n> This test suite contains two Cartesian products without using explicit CROSS JOIN syntax. Thus, we set spark.sql.crossJoin.enabled to true.",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-10T09:10:39Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true."
  }],
  "prId": 24782
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I know this is copied from the original, but for readability, `the case statement` -> `the CASE statement`",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-09T02:29:51Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement"
  }],
  "prId": 24782
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Can we first use rand()?",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-10T09:51:02Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "OK. Rewrite it to `rand()`.",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-10T16:09:22Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1"
  }],
  "prId": 24782
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "This test case is pretty useful. Could we use a udf here?",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-10T09:56:05Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1\n+--   END AS `NULL on no matches`;\n+\n+-- Constant-expression folding shouldn't evaluate unreachable subexpressions\n+SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;\n+SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;\n+\n+-- [SPARK-27923] PostgreSQL throws an exception but Spark SQL is NULL\n+-- However we do not currently suppress folding of potentially\n+-- reachable subexpressions\n+SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;\n+\n+-- Test for cases involving untyped literals in test expression\n+SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;\n+\n+--\n+-- Examples of targets involving tables\n+--\n+\n+SELECT '' AS `Five`,\n+  CASE\n+    WHEN i >= 3 THEN i\n+  END AS `>= 3 or Null`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN i >= 3 THEN (i + i)\n+       ELSE i\n+  END AS `Simplest Math`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`, i AS `Value`,\n+  CASE WHEN (i < 0) THEN 'small'\n+       WHEN (i = 0) THEN 'zero'\n+       WHEN (i = 1) THEN 'one'\n+       WHEN (i = 2) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN ((i < 0) or (i < 0)) THEN 'small'\n+       WHEN ((i = 0) or (i = 0)) THEN 'zero'\n+       WHEN ((i = 1) or (i = 1)) THEN 'one'\n+       WHEN ((i = 2) or (i = 2)) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+--\n+-- Examples of qualifications involving tables\n+--\n+\n+--\n+-- NULLIF() and COALESCE()\n+-- Shorthand forms for typical CASE constructs\n+--  defined in the SQL standard.\n+--\n+\n+SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;\n+\n+SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;\n+\n+SELECT COALESCE(a.f, b.i, b.j)\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(a.f, b.i, b.j) = 2;\n+\n+SELECT '' AS Five, NULLIF(a.i,b.i) AS `NULLIF(a.i,b.i)`,\n+  NULLIF(b.i, 4) AS `NULLIF(b.i,4)`\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT '' AS `Two`, *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(f,b.i) = 2;\n+\n+-- We don't support update now.\n+--\n+-- Examples of updates involving tables\n+--\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN i >= 3 THEN (- i)\n+--                 ELSE (2 * i) END;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN i >= 2 THEN (2 * i)\n+--                 ELSE (3 * i) END;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN b.i >= 2 THEN (2 * j)\n+--                 ELSE (3 * j) END\n+--   FROM CASE2_TBL b\n+--   WHERE j = -CASE_TBL.i;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- We don't support the features below:\n+-- 1. CREATE FUNCTION ... returns ... as ...\n+-- 2. CREATE DOMAIN ...\n+-- 3. CREATE OPERATOR ...\n+-- 4. CREATE TYPE ...\n+--\n+-- Nested CASE expressions\n+--\n+\n+-- This test exercises a bug caused by aliasing econtext->caseValue_isNull\n+-- with the isNull argument of the inner CASE's CaseExpr evaluation.  After\n+-- evaluating the vol(null) expression in the inner CASE's second WHEN-clause,\n+-- the isNull flag for the case test value incorrectly became true, causing\n+-- the third WHEN-clause not to match.  The volatile function calls are needed\n+-- to prevent constant-folding in the planner, which would hide the bug.\n+\n+-- Wrap this in a single transaction so the transient '=' operator doesn't\n+-- cause problems in concurrent sessions\n+-- BEGIN;\n+\n+-- CREATE FUNCTION vol(text) returns text as\n+--   'begin return $1; end' language plpgsql volatile;\n+\n+-- SELECT CASE\n+--   (CASE vol('bar')"
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "Yes. Add `vol` to  `SQLQueryTestSuite`.",
    "commit": "89e3a9e935279fcc1cd3f8555057ff66ff40192b",
    "createdAt": "2019-06-10T16:08:47Z",
    "diffHunk": "@@ -0,0 +1,267 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- CASE\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/case.sql\n+-- Test the case statement\n+--\n+-- There are 2 join condition is missing in this test case. we set spark.sql.crossJoin.enabled=true.\n+set spark.sql.crossJoin.enabled=true;\n+CREATE TABLE CASE_TBL (\n+  i integer,\n+  f double\n+) USING parquet;\n+\n+CREATE TABLE CASE2_TBL (\n+  i integer,\n+  j integer\n+) USING parquet;\n+\n+INSERT INTO CASE_TBL VALUES (1, 10.1);\n+INSERT INTO CASE_TBL VALUES (2, 20.2);\n+INSERT INTO CASE_TBL VALUES (3, -30.3);\n+INSERT INTO CASE_TBL VALUES (4, NULL);\n+\n+INSERT INTO CASE2_TBL VALUES (1, -1);\n+INSERT INTO CASE2_TBL VALUES (2, -2);\n+INSERT INTO CASE2_TBL VALUES (3, -3);\n+INSERT INTO CASE2_TBL VALUES (2, -4);\n+INSERT INTO CASE2_TBL VALUES (1, NULL);\n+INSERT INTO CASE2_TBL VALUES (NULL, -6);\n+\n+--\n+-- Simplest examples without tables\n+--\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+  END AS `Simple WHEN`;\n+\n+SELECT '<NULL>' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+  END AS `Simple default`;\n+\n+SELECT '3' AS `One`,\n+  CASE\n+    WHEN 1 < 2 THEN 3\n+    ELSE 4\n+  END AS `Simple ELSE`;\n+\n+SELECT '4' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    ELSE 4\n+  END AS `ELSE default`;\n+\n+SELECT '6' AS `One`,\n+  CASE\n+    WHEN 1 > 2 THEN 3\n+    WHEN 4 < 5 THEN 6\n+    ELSE 7\n+  END AS `Two WHEN with default`;\n+\n+-- [SPARK-27930] Add built-in Math Function: RANDOM\n+-- SELECT '7' AS `None`,\n+--   CASE WHEN random() < 0 THEN 1\n+--   END AS `NULL on no matches`;\n+\n+-- Constant-expression folding shouldn't evaluate unreachable subexpressions\n+SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;\n+SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;\n+\n+-- [SPARK-27923] PostgreSQL throws an exception but Spark SQL is NULL\n+-- However we do not currently suppress folding of potentially\n+-- reachable subexpressions\n+SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;\n+\n+-- Test for cases involving untyped literals in test expression\n+SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;\n+\n+--\n+-- Examples of targets involving tables\n+--\n+\n+SELECT '' AS `Five`,\n+  CASE\n+    WHEN i >= 3 THEN i\n+  END AS `>= 3 or Null`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN i >= 3 THEN (i + i)\n+       ELSE i\n+  END AS `Simplest Math`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`, i AS `Value`,\n+  CASE WHEN (i < 0) THEN 'small'\n+       WHEN (i = 0) THEN 'zero'\n+       WHEN (i = 1) THEN 'one'\n+       WHEN (i = 2) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+SELECT '' AS `Five`,\n+  CASE WHEN ((i < 0) or (i < 0)) THEN 'small'\n+       WHEN ((i = 0) or (i = 0)) THEN 'zero'\n+       WHEN ((i = 1) or (i = 1)) THEN 'one'\n+       WHEN ((i = 2) or (i = 2)) THEN 'two'\n+       ELSE 'big'\n+  END AS `Category`\n+  FROM CASE_TBL;\n+\n+--\n+-- Examples of qualifications involving tables\n+--\n+\n+--\n+-- NULLIF() and COALESCE()\n+-- Shorthand forms for typical CASE constructs\n+--  defined in the SQL standard.\n+--\n+\n+SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;\n+\n+SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;\n+\n+SELECT COALESCE(a.f, b.i, b.j)\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(a.f, b.i, b.j) = 2;\n+\n+SELECT '' AS Five, NULLIF(a.i,b.i) AS `NULLIF(a.i,b.i)`,\n+  NULLIF(b.i, 4) AS `NULLIF(b.i,4)`\n+  FROM CASE_TBL a, CASE2_TBL b;\n+\n+SELECT '' AS `Two`, *\n+  FROM CASE_TBL a, CASE2_TBL b\n+  WHERE COALESCE(f,b.i) = 2;\n+\n+-- We don't support update now.\n+--\n+-- Examples of updates involving tables\n+--\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN i >= 3 THEN (- i)\n+--                 ELSE (2 * i) END;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN i >= 2 THEN (2 * i)\n+--                 ELSE (3 * i) END;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- UPDATE CASE_TBL\n+--   SET i = CASE WHEN b.i >= 2 THEN (2 * j)\n+--                 ELSE (3 * j) END\n+--   FROM CASE2_TBL b\n+--   WHERE j = -CASE_TBL.i;\n+\n+-- SELECT * FROM CASE_TBL;\n+\n+-- We don't support the features below:\n+-- 1. CREATE FUNCTION ... returns ... as ...\n+-- 2. CREATE DOMAIN ...\n+-- 3. CREATE OPERATOR ...\n+-- 4. CREATE TYPE ...\n+--\n+-- Nested CASE expressions\n+--\n+\n+-- This test exercises a bug caused by aliasing econtext->caseValue_isNull\n+-- with the isNull argument of the inner CASE's CaseExpr evaluation.  After\n+-- evaluating the vol(null) expression in the inner CASE's second WHEN-clause,\n+-- the isNull flag for the case test value incorrectly became true, causing\n+-- the third WHEN-clause not to match.  The volatile function calls are needed\n+-- to prevent constant-folding in the planner, which would hide the bug.\n+\n+-- Wrap this in a single transaction so the transient '=' operator doesn't\n+-- cause problems in concurrent sessions\n+-- BEGIN;\n+\n+-- CREATE FUNCTION vol(text) returns text as\n+--   'begin return $1; end' language plpgsql volatile;\n+\n+-- SELECT CASE\n+--   (CASE vol('bar')"
  }],
  "prId": 24782
}]