[{
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "I'd like to add a flag to control whether to use integral division with the `/` operator:\r\nhttps://github.com/apache/spark/pull/25158",
    "commit": "c00b9d84e02bb6bd2f3d6bfa04649478ae370f0f",
    "createdAt": "2019-07-14T15:43:18Z",
    "diffHunk": "@@ -0,0 +1,160 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_IMPLICIT\n+-- Test cases for queries with ordering terms missing from the target list.\n+-- This used to be called \"junkfilter.sql\".\n+-- The parser uses the term \"resjunk\" to handle these cases.\n+-- - thomas 1998-07-09\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_implicit.sql\n+--\n+\n+-- load test data\n+CREATE TABLE test_missing_target (a int, b int, c string, d string) using parquet;\n+INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');\n+INSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');\n+INSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');\n+\n+\n+--   w/ existing GROUP BY target\n+SELECT c, count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;\n+\n+--   w/o existing GROUP BY target using a relation name in GROUP BY clause\n+SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;\n+\n+--   w/o existing GROUP BY target and w/o existing a different ORDER BY target\n+--   failure expected\n+SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;\n+\n+--   w/o existing GROUP BY target and w/o existing same ORDER BY target\n+SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;\n+\n+--   w/ existing GROUP BY target using a relation name in target\n+SELECT test_missing_target.b, count(*)\n+  FROM test_missing_target GROUP BY b ORDER BY b;\n+\n+--   w/o existing GROUP BY target\n+SELECT c FROM test_missing_target ORDER BY a;\n+\n+--   w/o existing ORDER BY target\n+SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b desc;\n+\n+--   group using reference number\n+SELECT count(*) FROM test_missing_target ORDER BY 1 desc;\n+\n+--   order using reference number\n+SELECT c, count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;\n+\n+--   group using reference number out of range\n+--   failure expected\n+SELECT c, count(*) FROM test_missing_target GROUP BY 3;\n+\n+--   group w/o existing GROUP BY and ORDER BY target under ambiguous condition\n+--   failure expected\n+SELECT count(*) FROM test_missing_target x, test_missing_target y\n+\tWHERE x.a = y.a\n+\tGROUP BY b ORDER BY b;\n+\n+--   order w/ target under ambiguous condition\n+--   failure NOT expected\n+SELECT a, a FROM test_missing_target\n+\tORDER BY a;\n+\n+--   order expression w/ target under ambiguous condition\n+--   failure NOT expected\n+SELECT a/2, a/2 FROM test_missing_target",
    "line": 73
  }],
  "prId": 25152
}]