[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Can you add line numbers?: https://github.com/apache/spark/blob/a6a663c4379390217443bc5b6f75873fb1c38c73/sql/core/src/test/resources/sql-tests/inputs/pgSQL/aggregates_part1.sql#L6",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-19T04:23:42Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Unfortunately,`REL_12_BETA4` is released.\r\n> https://github.com/postgres/postgres/blob/REL_12_BETA4/src/test/regress/sql/window.sql",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-21T02:51:11Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql"
  }, {
    "author": {
      "login": "DylanGuedes"
    },
    "body": "I can update to match Beta4, but:\r\n- If the PgSQL version is *that* relevant, then we will add a new JIRA for every new PgSQL release for every .sql migration (i.e:  strings.sql, union.sql, date.sql, aggregates.sql, etc). But we didn't.\r\n- If the PgSQL is not that relevant, then there's no need to change PRs to match the latest release candidate version (although it matches a stable version).\r\n\r\nWhat you think?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-25T23:21:28Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Have you checked the last discussion? https://github.com/apache/spark/pull/24850#discussion_r300215383\r\nI think we don't need to stick to the single snapshot, so its ok to update it to `REL_12_BETA4` in this port. Actually, no difference between `BETA2` and `BETA4` in `window.sql`?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-26T04:21:05Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql"
  }, {
    "author": {
      "login": "DylanGuedes"
    },
    "body": "No, I didn't get noticed that you guys were already discussing about updating other tests.\r\nI checked last week and there are some major differences between BETA2 and BETA4 for `window.sql`, I just can't remember if lines L1-L319 are impacted by them. So, it's ok to keep at REL2 or should I updated to REL3?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-29T11:19:07Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql"
  }],
  "prId": 25816
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Can you describe which keyword?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-19T04:42:53Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql\n+\n+CREATE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE empsalary (\n+    depname string,\n+    empno integer,\n+    salary int,\n+    enroll_date date\n+) USING parquet;\n+\n+INSERT INTO empsalary VALUES\n+('develop', 10, 5200, '2007-08-01'),\n+('sales', 1, 5000, '2006-10-01'),\n+('personnel', 5, 3500, '2007-12-10'),\n+('sales', 4, 4800, '2007-08-08'),\n+('personnel', 2, 3900, '2006-12-23'),\n+('develop', 7, 4200, '2008-01-01'),\n+('develop', 9, 4500, '2008-01-01'),\n+('sales', 3, 4800, '2007-08-01'),\n+('develop', 8, 6000, '2006-10-01'),\n+('develop', 11, 5200, '2007-08-15');\n+\n+SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;\n+\n+SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;\n+\n+-- with GROUP BY\n+SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1\n+GROUP BY four, ten ORDER BY four, ten;\n+\n+SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);\n+\n+-- [SPARK-28064] Order by does not accept a call to rank()\n+-- SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;\n+\n+-- empty window specification\n+SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();\n+\n+-- no window operation\n+SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);\n+\n+-- cumulative aggregate\n+SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28065] ntile does not accept NULL as input\n+-- SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;\n+\n+SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT first(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- last returns the last row of the frame, which is CURRENT ROW in ORDER BY window.\n+SELECT last(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT last(ten) OVER (PARTITION BY four), ten, four FROM\n+(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s\n+ORDER BY four, ten;\n+\n+-- [SPARK-27951] ANSI SQL: NTH_VALUE function\n+-- SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four\n+-- FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum\n+FROM tenk1 GROUP BY ten, two;\n+\n+SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;\n+\n+SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +\n+  sum(hundred) OVER (PARTITION BY four ORDER BY ten)) AS cntsum\n+  FROM tenk1 WHERE unique2 < 10;\n+\n+-- opexpr with different windows evaluation.\n+SELECT * FROM(\n+  SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,\n+    count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum\n+    FROM tenk1\n+)sub WHERE total <> fourcount + twosum;\n+\n+SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum\n+FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);\n+\n+-- more than one window with GROUP BY\n+SELECT sum(salary),\n+  row_number() OVER (ORDER BY depname),\n+  sum(sum(salary)) OVER (ORDER BY depname DESC)\n+FROM empsalary GROUP BY depname;\n+\n+-- identical windows with different names\n+SELECT sum(salary) OVER w1, count(*) OVER w2\n+FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);\n+\n+-- subplan\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+-- SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)\n+-- FROM tenk1 s WHERE unique2 < 10;\n+\n+-- empty table\n+SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;\n+\n+-- mixture of agg/wfunc in the same window\n+SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n+\n+-- strict aggs\n+-- Temporarily turns off the ANSI mode because of compatibility issues between keywords"
  }],
  "prId": 25816
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Why didn't you comment out this statement? You did the other statements, though?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-19T04:49:30Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql\n+\n+CREATE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE empsalary (\n+    depname string,\n+    empno integer,\n+    salary int,\n+    enroll_date date\n+) USING parquet;\n+\n+INSERT INTO empsalary VALUES\n+('develop', 10, 5200, '2007-08-01'),\n+('sales', 1, 5000, '2006-10-01'),\n+('personnel', 5, 3500, '2007-12-10'),\n+('sales', 4, 4800, '2007-08-08'),\n+('personnel', 2, 3900, '2006-12-23'),\n+('develop', 7, 4200, '2008-01-01'),\n+('develop', 9, 4500, '2008-01-01'),\n+('sales', 3, 4800, '2007-08-01'),\n+('develop', 8, 6000, '2006-10-01'),\n+('develop', 11, 5200, '2007-08-15');\n+\n+SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;\n+\n+SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;\n+\n+-- with GROUP BY\n+SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1\n+GROUP BY four, ten ORDER BY four, ten;\n+\n+SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);\n+\n+-- [SPARK-28064] Order by does not accept a call to rank()\n+-- SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;\n+\n+-- empty window specification\n+SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();\n+\n+-- no window operation\n+SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);\n+\n+-- cumulative aggregate\n+SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28065] ntile does not accept NULL as input\n+-- SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;\n+\n+SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT first(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- last returns the last row of the frame, which is CURRENT ROW in ORDER BY window.\n+SELECT last(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT last(ten) OVER (PARTITION BY four), ten, four FROM\n+(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s\n+ORDER BY four, ten;\n+\n+-- [SPARK-27951] ANSI SQL: NTH_VALUE function\n+-- SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four\n+-- FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum\n+FROM tenk1 GROUP BY ten, two;\n+\n+SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;\n+\n+SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +\n+  sum(hundred) OVER (PARTITION BY four ORDER BY ten)) AS cntsum\n+  FROM tenk1 WHERE unique2 < 10;\n+\n+-- opexpr with different windows evaluation.\n+SELECT * FROM(\n+  SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,\n+    count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum\n+    FROM tenk1\n+)sub WHERE total <> fourcount + twosum;\n+\n+SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum\n+FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);\n+\n+-- more than one window with GROUP BY\n+SELECT sum(salary),\n+  row_number() OVER (ORDER BY depname),\n+  sum(sum(salary)) OVER (ORDER BY depname DESC)\n+FROM empsalary GROUP BY depname;\n+\n+-- identical windows with different names\n+SELECT sum(salary) OVER w1, count(*) OVER w2\n+FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);\n+\n+-- subplan\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+-- SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)\n+-- FROM tenk1 s WHERE unique2 < 10;\n+\n+-- empty table\n+SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;\n+\n+-- mixture of agg/wfunc in the same window\n+SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n+\n+-- strict aggs\n+-- Temporarily turns off the ANSI mode because of compatibility issues between keywords\n+SET spark.sql.parser.ansi.enabled=false;\n+SELECT empno, depname, salary, bonus, depadj, MIN(bonus) OVER (ORDER BY empno), MAX(depadj) OVER () FROM(\n+SELECT *,\n+  CASE WHEN enroll_date < '2008-01-01' THEN 2008 - extract(year FROM enroll_date) END * 500 AS bonus,\n+  CASE WHEN\n+    AVG(salary) OVER (PARTITION BY depname) < salary\n+    THEN 200 END AS depadj FROM empsalary\n+  )s;\n+SET spark.sql.parser.ansi.enabled=true;\n+\n+create temporary view int4_tbl as select * from values\n+  (0),\n+  (123456),\n+  (-123456),\n+  (2147483647),\n+  (-2147483647)\n+  as int4_tbl(f1);\n+\n+-- window function over ungrouped agg over empty row set (bug before 9.1)\n+SELECT SUM(COUNT(f1)) OVER () FROM int4_tbl WHERE f1=42;\n+\n+-- window function with ORDER BY an expression involving aggregates (9.1 bug)\n+select ten,\n+  sum(unique1) + sum(unique2) as res,\n+  rank() over (order by sum(unique1) + sum(unique2)) as rank\n+from tenk1\n+group by ten order by ten;\n+\n+-- window and aggregate with GROUP BY expression (9.2 bug)\n+-- explain\n+-- select first(max(x)) over (), y\n+--   from (select unique1 as x, ten+four as y from tenk1) ss\n+--   group by y;\n+\n+-- test non-default frame specifications\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten),\n+last(ten) over (partition by four order by ten)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and current row),\n+last(ten) over (partition by four order by ten range between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following),\n+last(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten/4 as two,\n+sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),\n+last(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten/4 as two,\n+sum(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row),\n+last(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT sum(unique1) over (order by four range between current row and unbounded following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between current row and unbounded following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between 2 preceding and 2 following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude no others),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT first(unique1) over (ORDER BY four rows between current row and 2 following exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT first(unique1) over (ORDER BY four rows between current row and 2 following exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT first(unique1) over (ORDER BY four rows between current row and 2 following exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT last(unique1) over (ORDER BY four rows between current row and 2 following exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT last(unique1) over (ORDER BY four rows between current row and 2 following exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT last(unique1) over (ORDER BY four rows between current row and 2 following exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between 2 preceding and 1 preceding),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between 1 following and 3 following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between unbounded preceding and 1 following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+SELECT sum(unique1) over (w range between current row and unbounded following),"
  }],
  "prId": 25816
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about `tenk2` and `int4_tbl`?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-19T04:53:01Z",
    "diffHunk": "@@ -0,0 +1,343 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA3/src/test/regress/sql/window.sql\n+\n+CREATE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE empsalary (\n+    depname string,\n+    empno integer,\n+    salary int,\n+    enroll_date date\n+) USING parquet;\n+\n+INSERT INTO empsalary VALUES\n+('develop', 10, 5200, '2007-08-01'),\n+('sales', 1, 5000, '2006-10-01'),\n+('personnel', 5, 3500, '2007-12-10'),\n+('sales', 4, 4800, '2007-08-08'),\n+('personnel', 2, 3900, '2006-12-23'),\n+('develop', 7, 4200, '2008-01-01'),\n+('develop', 9, 4500, '2008-01-01'),\n+('sales', 3, 4800, '2007-08-01'),\n+('develop', 8, 6000, '2006-10-01'),\n+('develop', 11, 5200, '2007-08-15');\n+\n+SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;\n+\n+SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;\n+\n+-- with GROUP BY\n+SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1\n+GROUP BY four, ten ORDER BY four, ten;\n+\n+SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);\n+\n+-- [SPARK-28064] Order by does not accept a call to rank()\n+-- SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;\n+\n+-- empty window specification\n+SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();\n+\n+-- no window operation\n+SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);\n+\n+-- cumulative aggregate\n+SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28065] ntile does not accept NULL as input\n+-- SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;\n+\n+SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT first(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- last returns the last row of the frame, which is CURRENT ROW in ORDER BY window.\n+SELECT last(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT last(ten) OVER (PARTITION BY four), ten, four FROM\n+(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s\n+ORDER BY four, ten;\n+\n+-- [SPARK-27951] ANSI SQL: NTH_VALUE function\n+-- SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four\n+-- FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum\n+FROM tenk1 GROUP BY ten, two;\n+\n+SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;\n+\n+SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +\n+  sum(hundred) OVER (PARTITION BY four ORDER BY ten)) AS cntsum\n+  FROM tenk1 WHERE unique2 < 10;\n+\n+-- opexpr with different windows evaluation.\n+SELECT * FROM(\n+  SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,\n+    count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum\n+    FROM tenk1\n+)sub WHERE total <> fourcount + twosum;\n+\n+SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum\n+FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);\n+\n+-- more than one window with GROUP BY\n+SELECT sum(salary),\n+  row_number() OVER (ORDER BY depname),\n+  sum(sum(salary)) OVER (ORDER BY depname DESC)\n+FROM empsalary GROUP BY depname;\n+\n+-- identical windows with different names\n+SELECT sum(salary) OVER w1, count(*) OVER w2\n+FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);\n+\n+-- subplan\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+-- SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)\n+-- FROM tenk1 s WHERE unique2 < 10;\n+\n+-- empty table\n+SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;\n+\n+-- mixture of agg/wfunc in the same window\n+SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n+\n+-- strict aggs\n+-- Temporarily turns off the ANSI mode because of compatibility issues between keywords\n+SET spark.sql.parser.ansi.enabled=false;\n+SELECT empno, depname, salary, bonus, depadj, MIN(bonus) OVER (ORDER BY empno), MAX(depadj) OVER () FROM(\n+SELECT *,\n+  CASE WHEN enroll_date < '2008-01-01' THEN 2008 - extract(year FROM enroll_date) END * 500 AS bonus,\n+  CASE WHEN\n+    AVG(salary) OVER (PARTITION BY depname) < salary\n+    THEN 200 END AS depadj FROM empsalary\n+  )s;\n+SET spark.sql.parser.ansi.enabled=true;\n+\n+create temporary view int4_tbl as select * from values\n+  (0),\n+  (123456),\n+  (-123456),\n+  (2147483647),\n+  (-2147483647)\n+  as int4_tbl(f1);\n+\n+-- window function over ungrouped agg over empty row set (bug before 9.1)\n+SELECT SUM(COUNT(f1)) OVER () FROM int4_tbl WHERE f1=42;\n+\n+-- window function with ORDER BY an expression involving aggregates (9.1 bug)\n+select ten,\n+  sum(unique1) + sum(unique2) as res,\n+  rank() over (order by sum(unique1) + sum(unique2)) as rank\n+from tenk1\n+group by ten order by ten;\n+\n+-- window and aggregate with GROUP BY expression (9.2 bug)\n+-- explain\n+-- select first(max(x)) over (), y\n+--   from (select unique1 as x, ten+four as y from tenk1) ss\n+--   group by y;\n+\n+-- test non-default frame specifications\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten),\n+last(ten) over (partition by four order by ten)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and current row),\n+last(ten) over (partition by four order by ten range between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following),\n+last(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten/4 as two,\n+sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),\n+last(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten/4 as two,\n+sum(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row),\n+last(ten/4) over (partition by four order by ten/4 rows between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT sum(unique1) over (order by four range between current row and unbounded following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between current row and unbounded following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between 2 preceding and 2 following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude no others),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (rows between 2 preceding and 2 following exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT first(unique1) over (ORDER BY four rows between current row and 2 following exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT first(unique1) over (ORDER BY four rows between current row and 2 following exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT first(unique1) over (ORDER BY four rows between current row and 2 following exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT last(unique1) over (ORDER BY four rows between current row and 2 following exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT last(unique1) over (ORDER BY four rows between current row and 2 following exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT last(unique1) over (ORDER BY four rows between current row and 2 following exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between 2 preceding and 1 preceding),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between 1 following and 3 following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+SELECT sum(unique1) over (rows between unbounded preceding and 1 following),\n+unique1, four\n+FROM tenk1 WHERE unique1 < 10;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+SELECT sum(unique1) over (w range between current row and unbounded following),\n+\tunique1, four\n+FROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (w range between unbounded preceding and current row exclude current row),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (w range between unbounded preceding and current row exclude group),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- SELECT sum(unique1) over (w range between unbounded preceding and current row exclude ties),\n+-- unique1, four\n+-- FROM tenk1 WHERE unique1 < 10 WINDOW w AS (order by four);\n+\n+-- [SPARK-27951] ANSI SQL: NTH_VALUE function\n+-- SELECT first_value(unique1) over w,\n+-- nth_value(unique1, 2) over w AS nth_2,\n+-- last_value(unique1) over w, unique1, four\n+-- FROM tenk1 WHERE unique1 < 10\n+-- WINDOW w AS (order by four range between current row and unbounded following);\n+\n+-- [SPARK-28501] Frame bound value must be a literal.\n+-- SELECT sum(unique1) over\n+-- (order by unique1\n+--   rows (SELECT unique1 FROM tenk1 ORDER BY unique1 LIMIT 1) + 1 PRECEDING),\n+-- unique1\n+-- FROM tenk1 WHERE unique1 < 10;\n+\n+CREATE TEMP VIEW v_window AS\n+SELECT i.id, sum(i.id) over (order by i.id rows between 1 preceding and 1 following) as sum_rows\n+FROM range(1, 11) i;\n+\n+SELECT * FROM v_window;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- CREATE OR REPLACE TEMP VIEW v_window AS\n+-- SELECT i, sum(i) over (order by i rows between 1 preceding and 1 following\n+--   exclude current row) as sum_rows FROM range(1, 10) i;\n+\n+-- SELECT * FROM v_window;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- CREATE OR REPLACE TEMP VIEW v_window AS\n+-- SELECT i, sum(i) over (order by i rows between 1 preceding and 1 following\n+--   exclude group) as sum_rows FROM range(1, 10) i;\n+-- SELECT * FROM v_window;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- CREATE OR REPLACE TEMP VIEW v_window AS\n+-- SELECT i, sum(i) over (order by i rows between 1 preceding and 1 following\n+--   exclude ties) as sum_rows FROM generate_series(1, 10) i;\n+\n+-- [SPARK-28428] Spark `exclude` always expecting `()`\n+-- CREATE OR REPLACE TEMP VIEW v_window AS\n+-- SELECT i, sum(i) over (order by i rows between 1 preceding and 1 following\n+--   exclude no others) as sum_rows FROM generate_series(1, 10) i;\n+-- SELECT * FROM v_window;\n+\n+-- [SPARK-28648] Adds support to `groups` unit type in window clauses\n+-- CREATE OR REPLACE TEMP VIEW v_window AS\n+-- SELECT i.id, sum(i.id) over (order by i.id groups between 1 preceding and 1 following) as sum_rows FROM range(1, 11) i;\n+-- SELECT * FROM v_window;\n+\n+DROP VIEW v_window;\n+DROP TABLE empsalary;",
    "line": 346
  }],
  "prId": 25816
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ur, did you regenerate the golden files after this removal?",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-09-29T21:44:45Z",
    "diffHunk": "@@ -187,10 +187,11 @@ sum(ten) over (partition by four order by ten range between unbounded preceding\n last(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)\n FROM (select distinct ten, four from tenk1) ss;\n \n-SELECT four, ten/4 as two,\n-sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),\n-last(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)\n-FROM (select distinct ten, four from tenk1) ss;\n+-- Failing on thrift server\n+-- SELECT four, ten/4 as two,\n+-- sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),\n+-- last(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)\n+-- FROM (select distinct ten, four from tenk1) ss;",
    "line": 194
  }],
  "prId": 25816
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "We need a JIRA issue if we are not going to cover this query.",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-10-13T00:50:40Z",
    "diffHunk": "@@ -0,0 +1,348 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA4/src/test/regress/sql/window.sql#L1-L319\n+\n+CREATE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE empsalary (\n+    depname string,\n+    empno integer,\n+    salary int,\n+    enroll_date date\n+) USING parquet;\n+\n+INSERT INTO empsalary VALUES\n+('develop', 10, 5200, '2007-08-01'),\n+('sales', 1, 5000, '2006-10-01'),\n+('personnel', 5, 3500, '2007-12-10'),\n+('sales', 4, 4800, '2007-08-08'),\n+('personnel', 2, 3900, '2006-12-23'),\n+('develop', 7, 4200, '2008-01-01'),\n+('develop', 9, 4500, '2008-01-01'),\n+('sales', 3, 4800, '2007-08-01'),\n+('develop', 8, 6000, '2006-10-01'),\n+('develop', 11, 5200, '2007-08-15');\n+\n+SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;\n+\n+SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;\n+\n+-- with GROUP BY\n+SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1\n+GROUP BY four, ten ORDER BY four, ten;\n+\n+SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);\n+\n+-- [SPARK-28064] Order by does not accept a call to rank()\n+-- SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;\n+\n+-- empty window specification\n+SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();\n+\n+-- no window operation\n+SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);\n+\n+-- cumulative aggregate\n+SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28065] ntile does not accept NULL as input\n+-- SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;\n+\n+SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT first(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- last returns the last row of the frame, which is CURRENT ROW in ORDER BY window.\n+SELECT last(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT last(ten) OVER (PARTITION BY four), ten, four FROM\n+(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s\n+ORDER BY four, ten;\n+\n+-- [SPARK-27951] ANSI SQL: NTH_VALUE function\n+-- SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four\n+-- FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum\n+FROM tenk1 GROUP BY ten, two;\n+\n+SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;\n+\n+SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +\n+  sum(hundred) OVER (PARTITION BY four ORDER BY ten)) AS cntsum\n+  FROM tenk1 WHERE unique2 < 10;\n+\n+-- opexpr with different windows evaluation.\n+SELECT * FROM(\n+  SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,\n+    count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum\n+    FROM tenk1\n+)sub WHERE total <> fourcount + twosum;\n+\n+SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum\n+FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);\n+\n+-- more than one window with GROUP BY\n+SELECT sum(salary),\n+  row_number() OVER (ORDER BY depname),\n+  sum(sum(salary)) OVER (ORDER BY depname DESC)\n+FROM empsalary GROUP BY depname;\n+\n+-- identical windows with different names\n+SELECT sum(salary) OVER w1, count(*) OVER w2\n+FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);\n+\n+-- subplan\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+-- SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)\n+-- FROM tenk1 s WHERE unique2 < 10;\n+\n+-- empty table\n+SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;\n+\n+-- mixture of agg/wfunc in the same window\n+SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n+\n+-- strict aggs\n+-- Temporarily turns off the ANSI mode because of compatibility issues between\n+-- keywords related to date (in this case, year)\n+SET spark.sql.parser.ansi.enabled=false;\n+SELECT empno, depname, salary, bonus, depadj, MIN(bonus) OVER (ORDER BY empno), MAX(depadj) OVER () FROM(\n+SELECT *,\n+  CASE WHEN enroll_date < '2008-01-01' THEN 2008 - extract(year FROM enroll_date) END * 500 AS bonus,\n+  CASE WHEN\n+    AVG(salary) OVER (PARTITION BY depname) < salary\n+    THEN 200 END AS depadj FROM empsalary\n+  )s;\n+SET spark.sql.parser.ansi.enabled=true;\n+\n+create temporary view int4_tbl as select * from values\n+  (0),\n+  (123456),\n+  (-123456),\n+  (2147483647),\n+  (-2147483647)\n+  as int4_tbl(f1);\n+\n+-- window function over ungrouped agg over empty row set (bug before 9.1)\n+SELECT SUM(COUNT(f1)) OVER () FROM int4_tbl WHERE f1=42;\n+\n+-- window function with ORDER BY an expression involving aggregates (9.1 bug)\n+select ten,\n+  sum(unique1) + sum(unique2) as res,\n+  rank() over (order by sum(unique1) + sum(unique2)) as rank\n+from tenk1\n+group by ten order by ten;\n+\n+-- window and aggregate with GROUP BY expression (9.2 bug)\n+-- explain\n+-- select first(max(x)) over (), y\n+--   from (select unique1 as x, ten+four as y from tenk1) ss\n+--   group by y;\n+\n+-- test non-default frame specifications\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten),\n+last(ten) over (partition by four order by ten)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and current row),\n+last(ten) over (partition by four order by ten range between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following),\n+last(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+-- Failing on thrift server"
  }],
  "prId": 25816
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "We need a JIRA issue if we are not going to cover this query, too.",
    "commit": "1ac60f1dbd23ae5c76151578e4a49e48be5cc043",
    "createdAt": "2019-10-13T00:51:04Z",
    "diffHunk": "@@ -0,0 +1,348 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- Window Functions Testing\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA4/src/test/regress/sql/window.sql#L1-L319\n+\n+CREATE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE empsalary (\n+    depname string,\n+    empno integer,\n+    salary int,\n+    enroll_date date\n+) USING parquet;\n+\n+INSERT INTO empsalary VALUES\n+('develop', 10, 5200, '2007-08-01'),\n+('sales', 1, 5000, '2006-10-01'),\n+('personnel', 5, 3500, '2007-12-10'),\n+('sales', 4, 4800, '2007-08-08'),\n+('personnel', 2, 3900, '2006-12-23'),\n+('develop', 7, 4200, '2008-01-01'),\n+('develop', 9, 4500, '2008-01-01'),\n+('sales', 3, 4800, '2007-08-01'),\n+('develop', 8, 6000, '2006-10-01'),\n+('develop', 11, 5200, '2007-08-15');\n+\n+SELECT depname, empno, salary, sum(salary) OVER (PARTITION BY depname) FROM empsalary ORDER BY depname, salary;\n+\n+SELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary) FROM empsalary;\n+\n+-- with GROUP BY\n+SELECT four, ten, SUM(SUM(four)) OVER (PARTITION BY four), AVG(ten) FROM tenk1\n+GROUP BY four, ten ORDER BY four, ten;\n+\n+SELECT depname, empno, salary, sum(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname);\n+\n+-- [SPARK-28064] Order by does not accept a call to rank()\n+-- SELECT depname, empno, salary, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary) ORDER BY rank() OVER w;\n+\n+-- empty window specification\n+SELECT COUNT(*) OVER () FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT COUNT(*) OVER w FROM tenk1 WHERE unique2 < 10 WINDOW w AS ();\n+\n+-- no window operation\n+SELECT four FROM tenk1 WHERE FALSE WINDOW w AS (PARTITION BY ten);\n+\n+-- cumulative aggregate\n+SELECT sum(four) OVER (PARTITION BY ten ORDER BY unique2) AS sum_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT row_number() OVER (ORDER BY unique2) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT rank() OVER (PARTITION BY four ORDER BY ten) AS rank_1, ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT dense_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT percent_rank() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT cume_dist() OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ntile(3) OVER (ORDER BY ten, four), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28065] ntile does not accept NULL as input\n+-- SELECT ntile(NULL) OVER (ORDER BY ten, four), ten, four FROM tenk1 LIMIT 2;\n+\n+SELECT lag(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- [SPARK-28068] `lag` second argument must be a literal in Spark\n+-- SELECT lag(ten, four, 0) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT lead(ten * 2, 1, -1) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT first(ten) OVER (PARTITION BY four ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+-- last returns the last row of the frame, which is CURRENT ROW in ORDER BY window.\n+SELECT last(four) OVER (ORDER BY ten), ten, four FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT last(ten) OVER (PARTITION BY four), ten, four FROM\n+(SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s\n+ORDER BY four, ten;\n+\n+-- [SPARK-27951] ANSI SQL: NTH_VALUE function\n+-- SELECT nth_value(ten, four + 1) OVER (PARTITION BY four), ten, four\n+-- FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten)s;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER (PARTITION BY two ORDER BY ten) AS wsum\n+FROM tenk1 GROUP BY ten, two;\n+\n+SELECT count(*) OVER (PARTITION BY four), four FROM (SELECT * FROM tenk1 WHERE two = 1)s WHERE unique2 < 10;\n+\n+SELECT (count(*) OVER (PARTITION BY four ORDER BY ten) +\n+  sum(hundred) OVER (PARTITION BY four ORDER BY ten)) AS cntsum\n+  FROM tenk1 WHERE unique2 < 10;\n+\n+-- opexpr with different windows evaluation.\n+SELECT * FROM(\n+  SELECT count(*) OVER (PARTITION BY four ORDER BY ten) +\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS total,\n+    count(*) OVER (PARTITION BY four ORDER BY ten) AS fourcount,\n+    sum(hundred) OVER (PARTITION BY two ORDER BY ten) AS twosum\n+    FROM tenk1\n+)sub WHERE total <> fourcount + twosum;\n+\n+SELECT avg(four) OVER (PARTITION BY four ORDER BY thousand / 100) FROM tenk1 WHERE unique2 < 10;\n+\n+SELECT ten, two, sum(hundred) AS gsum, sum(sum(hundred)) OVER win AS wsum\n+FROM tenk1 GROUP BY ten, two WINDOW win AS (PARTITION BY two ORDER BY ten);\n+\n+-- more than one window with GROUP BY\n+SELECT sum(salary),\n+  row_number() OVER (ORDER BY depname),\n+  sum(sum(salary)) OVER (ORDER BY depname DESC)\n+FROM empsalary GROUP BY depname;\n+\n+-- identical windows with different names\n+SELECT sum(salary) OVER w1, count(*) OVER w2\n+FROM empsalary WINDOW w1 AS (ORDER BY salary), w2 AS (ORDER BY salary);\n+\n+-- subplan\n+-- [SPARK-28379] Correlated scalar subqueries must be aggregated\n+-- SELECT lead(ten, (SELECT two FROM tenk1 WHERE s.unique2 = unique2)) OVER (PARTITION BY four ORDER BY ten)\n+-- FROM tenk1 s WHERE unique2 < 10;\n+\n+-- empty table\n+SELECT count(*) OVER (PARTITION BY four) FROM (SELECT * FROM tenk1 WHERE FALSE)s;\n+\n+-- mixture of agg/wfunc in the same window\n+SELECT sum(salary) OVER w, rank() OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n+\n+-- strict aggs\n+-- Temporarily turns off the ANSI mode because of compatibility issues between\n+-- keywords related to date (in this case, year)\n+SET spark.sql.parser.ansi.enabled=false;\n+SELECT empno, depname, salary, bonus, depadj, MIN(bonus) OVER (ORDER BY empno), MAX(depadj) OVER () FROM(\n+SELECT *,\n+  CASE WHEN enroll_date < '2008-01-01' THEN 2008 - extract(year FROM enroll_date) END * 500 AS bonus,\n+  CASE WHEN\n+    AVG(salary) OVER (PARTITION BY depname) < salary\n+    THEN 200 END AS depadj FROM empsalary\n+  )s;\n+SET spark.sql.parser.ansi.enabled=true;\n+\n+create temporary view int4_tbl as select * from values\n+  (0),\n+  (123456),\n+  (-123456),\n+  (2147483647),\n+  (-2147483647)\n+  as int4_tbl(f1);\n+\n+-- window function over ungrouped agg over empty row set (bug before 9.1)\n+SELECT SUM(COUNT(f1)) OVER () FROM int4_tbl WHERE f1=42;\n+\n+-- window function with ORDER BY an expression involving aggregates (9.1 bug)\n+select ten,\n+  sum(unique1) + sum(unique2) as res,\n+  rank() over (order by sum(unique1) + sum(unique2)) as rank\n+from tenk1\n+group by ten order by ten;\n+\n+-- window and aggregate with GROUP BY expression (9.2 bug)\n+-- explain\n+-- select first(max(x)) over (), y\n+--   from (select unique1 as x, ten+four as y from tenk1) ss\n+--   group by y;\n+\n+-- test non-default frame specifications\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten),\n+last(ten) over (partition by four order by ten)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and current row),\n+last(ten) over (partition by four order by ten range between unbounded preceding and current row)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+SELECT four, ten,\n+sum(ten) over (partition by four order by ten range between unbounded preceding and unbounded following),\n+last(ten) over (partition by four order by ten range between unbounded preceding and unbounded following)\n+FROM (select distinct ten, four from tenk1) ss;\n+\n+-- Failing on thrift server\n+-- SELECT four, ten/4 as two,\n+-- sum(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row),\n+-- last(ten/4) over (partition by four order by ten/4 range between unbounded preceding and current row)\n+-- FROM (select distinct ten, four from tenk1) ss;\n+\n+-- Failing on thrift server"
  }],
  "prId": 25816
}]