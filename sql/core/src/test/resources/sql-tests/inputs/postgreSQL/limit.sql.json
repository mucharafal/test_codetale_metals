[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Filed: https://issues.apache.org/jira/browse/SPARK-29650",
    "commit": "3abbe57b6d85c6794c0598b3a22324fb0e0a4bec",
    "createdAt": "2019-10-30T06:57:44Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- LIMIT\n+-- https://github.com/postgres/postgres/blob/REL_12_STABLE/src/test/regress/sql/limit.sql\n+\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 50\n+\t\tORDER BY unique1 LIMIT 2;\n+SELECT '' AS five, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60\n+\t\tORDER BY unique1 LIMIT 5;\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60 AND unique1 < 63\n+\t\tORDER BY unique1 LIMIT 5;\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT '' AS three, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 > 100\n+-- \t\tORDER BY unique1 LIMIT 3 OFFSET 20;\n+-- SELECT '' AS zero, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 8 OFFSET 99;\n+-- SELECT '' AS eleven, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 20 OFFSET 39;\n+-- SELECT '' AS ten, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990 LIMIT 5;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 LIMIT 5 OFFSET 900;\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+\n+-- Test null limit and offset.  The planner would discard a simple null\n+-- constant, so to ensure executor is exercised, do this:\n+-- [SPARK-29650] Discard a NULL constant in LIMIT\n+select * from int8_tbl limit (case when random() < 0.5 then bigint(null) end);",
    "line": 47
  }],
  "prId": 26311
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Although I believe `Apache Spark` behavior `random()*0` == `0.0` is more natural, do we have a JIRA issue for this difference from PostgreSQL where `random()*0` == `0`?",
    "commit": "3abbe57b6d85c6794c0598b3a22324fb0e0a4bec",
    "createdAt": "2019-11-05T03:16:29Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- LIMIT\n+-- https://github.com/postgres/postgres/blob/REL_12_STABLE/src/test/regress/sql/limit.sql\n+\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 50\n+\t\tORDER BY unique1 LIMIT 2;\n+SELECT '' AS five, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60\n+\t\tORDER BY unique1 LIMIT 5;\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60 AND unique1 < 63\n+\t\tORDER BY unique1 LIMIT 5;\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT '' AS three, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 > 100\n+-- \t\tORDER BY unique1 LIMIT 3 OFFSET 20;\n+-- SELECT '' AS zero, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 8 OFFSET 99;\n+-- SELECT '' AS eleven, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 20 OFFSET 39;\n+-- SELECT '' AS ten, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990 LIMIT 5;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 LIMIT 5 OFFSET 900;\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+\n+-- Test null limit and offset.  The planner would discard a simple null\n+-- constant, so to ensure executor is exercised, do this:\n+-- [SPARK-29650] Discard a NULL constant in LIMIT\n+select * from int8_tbl limit (case when random() < 0.5 then bigint(null) end);\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- select * from int8_tbl offset (case when random() < 0.5 then bigint(null) end);\n+\n+-- Test assorted cases involving backwards fetch from a LIMIT plan node\n+-- [SPARK-20965] Support PREPARE/EXECUTE/DECLARE/FETCH statements\n+-- begin;\n+--\n+-- declare c1 cursor for select * from int8_tbl limit 10;\n+-- fetch all in c1;\n+-- fetch 1 in c1;\n+-- fetch backward 1 in c1;\n+-- fetch backward all in c1;\n+-- fetch backward 1 in c1;\n+-- fetch all in c1;\n+--\n+-- declare c2 cursor for select * from int8_tbl limit 3;\n+-- fetch all in c2;\n+-- fetch 1 in c2;\n+-- fetch backward 1 in c2;\n+-- fetch backward all in c2;\n+-- fetch backward 1 in c2;\n+-- fetch all in c2;\n+--\n+-- declare c3 cursor for select * from int8_tbl offset 3;\n+-- fetch all in c3;\n+-- fetch 1 in c3;\n+-- fetch backward 1 in c3;\n+-- fetch backward all in c3;\n+-- fetch backward 1 in c3;\n+-- fetch all in c3;\n+--\n+-- declare c4 cursor for select * from int8_tbl offset 10;\n+-- fetch all in c4;\n+-- fetch 1 in c4;\n+-- fetch backward 1 in c4;\n+-- fetch backward all in c4;\n+-- fetch backward 1 in c4;\n+-- fetch all in c4;\n+--\n+-- rollback;\n+\n+DROP VIEW INT8_TBL;\n+\n+-- Stress test for variable LIMIT in conjunction with bounded-heap sorting\n+\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT\n+--   (SELECT n\n+--      FROM (VALUES (1)) AS x,\n+--           (SELECT n FROM generate_series(1,10) AS n\n+--              ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z\n+--   FROM generate_series(1,10) AS s;\n+\n+--\n+-- Test behavior of volatile and set-returning functions in conjunction\n+-- with ORDER BY and LIMIT.\n+--\n+\n+-- [SPARK-29631] Support ANSI SQL CREATE SEQUENCE\n+-- create temp sequence testseq;\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by unique2 limit 10;\n+\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by unique2 limit 10;\n+\n+-- select currval('testseq');\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by tenthous limit 10;\n+\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by tenthous limit 10;\n+\n+-- select currval('testseq');\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by unique2 limit 7;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by unique2 limit 7;\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by tenthous limit 7;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by tenthous limit 7;\n+\n+-- use of random() is to keep planner from folding the expressions together\n+-- explain (verbose, costs off)\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;\n+\n+-- explain (verbose, costs off)\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2\n+-- order by s2 desc;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2\n+-- order by s2 desc;\n+\n+-- test for failure to set all aggregates' aggtranstype\n+-- explain (verbose, costs off)\n+-- select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2\n+--   from tenk1 group by thousand order by thousand limit 3;\n+\n+select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2",
    "line": 163
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Sorry, but I missed your point and the result seems to be the same;\r\n```\r\nselect sum(tenthous) as s1, sum(tenthous) + random()*0 as s2\r\n  from tenk1 group by thousand order by thousand limit 3;\r\n  s1   |  s2   \r\n-------+-------\r\n 45000 | 45000\r\n 45010 | 45010\r\n 45020 | 45020\r\n(3 rows)\r\n```\r\nhttps://github.com/postgres/postgres/blob/REL_12_STABLE/src/test/regress/expected/limit.out#L497-L504\r\n\r\nAlso, I tried below;\r\n```\r\npostgres=# select * from (values (1)) t(v) where random() * 0.0 = 0.0;\r\n v \r\n---\r\n 1\r\n(1 row)\r\n\r\nscala> sql(\"\"\"select * from (values (1)) t(v) where random() * 0.0 = 0.0\"\"\").show()\r\n+---+\r\n|  v|\r\n+---+\r\n|  1|\r\n+---+\r\n```\r\nWhat's the difference here?",
    "commit": "3abbe57b6d85c6794c0598b3a22324fb0e0a4bec",
    "createdAt": "2019-11-05T05:04:06Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- LIMIT\n+-- https://github.com/postgres/postgres/blob/REL_12_STABLE/src/test/regress/sql/limit.sql\n+\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 50\n+\t\tORDER BY unique1 LIMIT 2;\n+SELECT '' AS five, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60\n+\t\tORDER BY unique1 LIMIT 5;\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60 AND unique1 < 63\n+\t\tORDER BY unique1 LIMIT 5;\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT '' AS three, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 > 100\n+-- \t\tORDER BY unique1 LIMIT 3 OFFSET 20;\n+-- SELECT '' AS zero, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 8 OFFSET 99;\n+-- SELECT '' AS eleven, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 20 OFFSET 39;\n+-- SELECT '' AS ten, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990 LIMIT 5;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 LIMIT 5 OFFSET 900;\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+\n+-- Test null limit and offset.  The planner would discard a simple null\n+-- constant, so to ensure executor is exercised, do this:\n+-- [SPARK-29650] Discard a NULL constant in LIMIT\n+select * from int8_tbl limit (case when random() < 0.5 then bigint(null) end);\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- select * from int8_tbl offset (case when random() < 0.5 then bigint(null) end);\n+\n+-- Test assorted cases involving backwards fetch from a LIMIT plan node\n+-- [SPARK-20965] Support PREPARE/EXECUTE/DECLARE/FETCH statements\n+-- begin;\n+--\n+-- declare c1 cursor for select * from int8_tbl limit 10;\n+-- fetch all in c1;\n+-- fetch 1 in c1;\n+-- fetch backward 1 in c1;\n+-- fetch backward all in c1;\n+-- fetch backward 1 in c1;\n+-- fetch all in c1;\n+--\n+-- declare c2 cursor for select * from int8_tbl limit 3;\n+-- fetch all in c2;\n+-- fetch 1 in c2;\n+-- fetch backward 1 in c2;\n+-- fetch backward all in c2;\n+-- fetch backward 1 in c2;\n+-- fetch all in c2;\n+--\n+-- declare c3 cursor for select * from int8_tbl offset 3;\n+-- fetch all in c3;\n+-- fetch 1 in c3;\n+-- fetch backward 1 in c3;\n+-- fetch backward all in c3;\n+-- fetch backward 1 in c3;\n+-- fetch all in c3;\n+--\n+-- declare c4 cursor for select * from int8_tbl offset 10;\n+-- fetch all in c4;\n+-- fetch 1 in c4;\n+-- fetch backward 1 in c4;\n+-- fetch backward all in c4;\n+-- fetch backward 1 in c4;\n+-- fetch all in c4;\n+--\n+-- rollback;\n+\n+DROP VIEW INT8_TBL;\n+\n+-- Stress test for variable LIMIT in conjunction with bounded-heap sorting\n+\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT\n+--   (SELECT n\n+--      FROM (VALUES (1)) AS x,\n+--           (SELECT n FROM generate_series(1,10) AS n\n+--              ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z\n+--   FROM generate_series(1,10) AS s;\n+\n+--\n+-- Test behavior of volatile and set-returning functions in conjunction\n+-- with ORDER BY and LIMIT.\n+--\n+\n+-- [SPARK-29631] Support ANSI SQL CREATE SEQUENCE\n+-- create temp sequence testseq;\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by unique2 limit 10;\n+\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by unique2 limit 10;\n+\n+-- select currval('testseq');\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by tenthous limit 10;\n+\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by tenthous limit 10;\n+\n+-- select currval('testseq');\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by unique2 limit 7;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by unique2 limit 7;\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by tenthous limit 7;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by tenthous limit 7;\n+\n+-- use of random() is to keep planner from folding the expressions together\n+-- explain (verbose, costs off)\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;\n+\n+-- explain (verbose, costs off)\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2\n+-- order by s2 desc;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2\n+-- order by s2 desc;\n+\n+-- test for failure to set all aggregates' aggtranstype\n+-- explain (verbose, costs off)\n+-- select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2\n+--   from tenk1 group by thousand order by thousand limit 3;\n+\n+select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2",
    "line": 163
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "The generated result is not the same in this PR.",
    "commit": "3abbe57b6d85c6794c0598b3a22324fb0e0a4bec",
    "createdAt": "2019-11-05T05:40:33Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+-- LIMIT\n+-- https://github.com/postgres/postgres/blob/REL_12_STABLE/src/test/regress/sql/limit.sql\n+\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 50\n+\t\tORDER BY unique1 LIMIT 2;\n+SELECT '' AS five, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60\n+\t\tORDER BY unique1 LIMIT 5;\n+SELECT '' AS two, unique1, unique2, stringu1\n+\t\tFROM onek WHERE unique1 > 60 AND unique1 < 63\n+\t\tORDER BY unique1 LIMIT 5;\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT '' AS three, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 > 100\n+-- \t\tORDER BY unique1 LIMIT 3 OFFSET 20;\n+-- SELECT '' AS zero, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 8 OFFSET 99;\n+-- SELECT '' AS eleven, unique1, unique2, stringu1\n+-- \t\tFROM onek WHERE unique1 < 50\n+-- \t\tORDER BY unique1 DESC LIMIT 20 OFFSET 39;\n+-- SELECT '' AS ten, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 OFFSET 990 LIMIT 5;\n+-- SELECT '' AS five, unique1, unique2, stringu1\n+-- \t\tFROM onek\n+-- \t\tORDER BY unique1 LIMIT 5 OFFSET 900;\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+\n+-- Test null limit and offset.  The planner would discard a simple null\n+-- constant, so to ensure executor is exercised, do this:\n+-- [SPARK-29650] Discard a NULL constant in LIMIT\n+select * from int8_tbl limit (case when random() < 0.5 then bigint(null) end);\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- select * from int8_tbl offset (case when random() < 0.5 then bigint(null) end);\n+\n+-- Test assorted cases involving backwards fetch from a LIMIT plan node\n+-- [SPARK-20965] Support PREPARE/EXECUTE/DECLARE/FETCH statements\n+-- begin;\n+--\n+-- declare c1 cursor for select * from int8_tbl limit 10;\n+-- fetch all in c1;\n+-- fetch 1 in c1;\n+-- fetch backward 1 in c1;\n+-- fetch backward all in c1;\n+-- fetch backward 1 in c1;\n+-- fetch all in c1;\n+--\n+-- declare c2 cursor for select * from int8_tbl limit 3;\n+-- fetch all in c2;\n+-- fetch 1 in c2;\n+-- fetch backward 1 in c2;\n+-- fetch backward all in c2;\n+-- fetch backward 1 in c2;\n+-- fetch all in c2;\n+--\n+-- declare c3 cursor for select * from int8_tbl offset 3;\n+-- fetch all in c3;\n+-- fetch 1 in c3;\n+-- fetch backward 1 in c3;\n+-- fetch backward all in c3;\n+-- fetch backward 1 in c3;\n+-- fetch all in c3;\n+--\n+-- declare c4 cursor for select * from int8_tbl offset 10;\n+-- fetch all in c4;\n+-- fetch 1 in c4;\n+-- fetch backward 1 in c4;\n+-- fetch backward all in c4;\n+-- fetch backward 1 in c4;\n+-- fetch all in c4;\n+--\n+-- rollback;\n+\n+DROP VIEW INT8_TBL;\n+\n+-- Stress test for variable LIMIT in conjunction with bounded-heap sorting\n+\n+-- [SPARK-28330] ANSI SQL: Top-level <result offset clause> in <query expression>\n+-- SELECT\n+--   (SELECT n\n+--      FROM (VALUES (1)) AS x,\n+--           (SELECT n FROM generate_series(1,10) AS n\n+--              ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z\n+--   FROM generate_series(1,10) AS s;\n+\n+--\n+-- Test behavior of volatile and set-returning functions in conjunction\n+-- with ORDER BY and LIMIT.\n+--\n+\n+-- [SPARK-29631] Support ANSI SQL CREATE SEQUENCE\n+-- create temp sequence testseq;\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by unique2 limit 10;\n+\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by unique2 limit 10;\n+\n+-- select currval('testseq');\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by tenthous limit 10;\n+\n+-- select unique1, unique2, nextval('testseq')\n+--   from tenk1 order by tenthous limit 10;\n+\n+-- select currval('testseq');\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by unique2 limit 7;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by unique2 limit 7;\n+\n+-- explain (verbose, costs off)\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by tenthous limit 7;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select unique1, unique2, generate_series(1,10)\n+--   from tenk1 order by tenthous limit 7;\n+\n+-- use of random() is to keep planner from folding the expressions together\n+-- explain (verbose, costs off)\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;\n+\n+-- explain (verbose, costs off)\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2\n+-- order by s2 desc;\n+\n+-- [SPARK-27767] Built-in function: generate_series\n+-- select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2\n+-- order by s2 desc;\n+\n+-- test for failure to set all aggregates' aggtranstype\n+-- explain (verbose, costs off)\n+-- select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2\n+--   from tenk1 group by thousand order by thousand limit 3;\n+\n+select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2",
    "line": 163
  }],
  "prId": 26311
}]