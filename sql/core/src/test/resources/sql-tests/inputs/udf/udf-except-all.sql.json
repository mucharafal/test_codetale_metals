[{
  "comments": [{
    "author": {
      "login": "imback82"
    },
    "body": "@HyukjinKwon, if I do `ON udf(tab3.k) = udf(tab4.k)`,\r\nI get the following from regular python UDF:\r\n```\r\n19:30:00.784 ERROR org.apache.spark.executor.Executor: Exception in task 0.0 in stage 93.0 (TID 8576)\r\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\r\n        at org.apache.spark.sql.catalyst.expressions.GenericInternalRow.genericGet(rows.scala:201)\r\n        at org.apache.spark.sql.catalyst.expressions.BaseGenericInternalRow.getAs(rows.scala:35)\r\n        at org.apache.spark.sql.catalyst.expressions.BaseGenericInternalRow.isNullAt(rows.scala:36)\r\n        at org.apache.spark.sql.catalyst.expressions.BaseGenericInternalRow.isNullAt$(rows.scala:36)\r\n        at org.apache.spark.sql.catalyst.expressions.GenericInternalRow.isNullAt(rows.scala:195)\r\n        at org.apache.spark.sql.catalyst.expressions.JoinedRow.isNullAt(JoinedRow.scala:70)\r\n        at org.apache.spark.sql.catalyst.expressions.GeneratedClass$SpecificUnsafeProjection.apply(Unknown Source)\r\n        at org.apache.spark.sql.execution.python.EvalPythonExec.$anonfun$doExecute$11(EvalPythonExec.scala:134)\r\n```\r\nand the following from the Scalar Pandas UDF:\r\n```\r\n19:30:27.748 ERROR org.apache.spark.executor.Executor: Exception in task 1.0 in stage 141.0 (TID 13066)\r\njava.lang.AssertionError: assertion failed: Invalid schema from pandas_udf: expected StringType, StringType, got StringType\r\n        at scala.Predef$.assert(Predef.scala:223)\r\n        at org.apache.spark.sql.execution.python.ArrowEvalPythonExec.$anonfun$evaluate$2(ArrowEvalPythonExec.scala:92)\r\n        at scala.collection.Iterator$$anon$11.nextCur(Iterator.scala:484)\r\n        at scala.collection.Iterator$$anon$11.hasNext(Iterator.scala:490)\r\n        at scala.collection.Iterator$$anon$10.hasNext(Iterator.scala:458)\r\n        at org.apache.spark.sql.catalyst.expressions.GeneratedClass$GeneratedIteratorForCodegenStage4.processNext(Unknown Source)\r\n        at org.apache.spark.sql.execution.BufferedRowIterator.hasNext(BufferedRowIterator.java:43)\r\n        at org.apache.spark.sql.execution.WholeStageCodegenExec$$anon$1.hasNext(WholeStageCodegenExec.scala:735)\r\n        at org.apache.spark.sql.execution.SparkPlan.$anonfun$getByteArrayRdd$1(SparkPlan.scala:328)\r\n```\r\n\r\nThe Scala version seems to work fine. Is this a known limitation? I couldn't find anything on JIRA related to this. Let me know if you want me to file one.\r\n",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-10T03:21:51Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Hm, sounds possibly this is a bug. Let's create a JIRA.\r\nBTW, if possible, it would be better to create a JIRA with a minimised and narrowed-down reproducer in its JIRA description - actually this is one of the key points of why we're doing this :D.\r\n\r\nFor instance, \r\n\r\n```python\r\nfrom pyspark.sql.functions import pandas_udf, PandasUDFType\r\n\r\n\r\n@pandas_udf(\"string\", PandasUDFType.SCALAR)\r\ndef noop(x):\r\n    return x + 1\r\n\r\nspark.udf.register(\"udf\", noop)\r\n\r\nspark.sql(\"CREATE TEMPORARY VIEW ...\")\r\nspark.sql(\"...udf(...)...\").show()\r\n```\r\n\r\n_If possible_, It might be even better if we can reproduce it via Python native APIs as well since it'd be very likely reproducible with Python API itself. For instance,\r\n\r\n```python\r\nfrom pyspark.sql.functions import pandas_udf, PandasUDFType\r\n\r\n\r\n@pandas_udf(\"string\", PandasUDFType.SCALAR)\r\ndef noop(x):\r\n    return x + 1\r\n\r\n\r\ndf1 = ...\r\ndf2 = ...\r\ndf1.join(df2 ...).show()\r\n```\r\n\r\nIt might be even better to show that it works in Scala API with a minimised reproducer in the JIRA description. That will make other contributors and committers can easily focus on bug-fixing itself alone.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-10T04:19:08Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "OK. I will update this thread after I create a JIRA.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-10T04:30:05Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ur, I think it is the bug I fix now. Please see #25091.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-10T04:48:19Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Cool. I will test it again once your changes are merged.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-10T04:53:08Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@imback82, it's merged. Let's add that condition here.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-11T00:28:12Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "OK, will do.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-11T00:53:54Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "@viirya your fix worked. Thanks!\r\n\r\n@HyukjinKwon I pushed a new commit with the changes.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-11T02:25:57Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON tab3.k = tab4.k)"
  }],
  "prId": 25090
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@imback82, can we manually list up the columns, for instance,  `SELECT udf(c1) FROM tab1`?",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:13:15Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "@HyukjinKwon, do you want this in all instances below?",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:38:48Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Yea, otherwise, it would just duplicate the tests in original files.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:45:49Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Done.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T05:05:39Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1"
  }],
  "prId": 25090
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would test a different combination here `udf(c1 > udf(6))`",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:13:38Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Changed.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:39:52Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);"
  }],
  "prId": 25090
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "`udf(array(1))`",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:13:55Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);",
    "line": 55
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Changed.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:40:02Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);",
    "line": 55
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Actually, changing to `udf(array(1))` gives the following message:\r\n```\r\ncannot resolve 'udf(cast(array(1) as string))' due to data type mismatch: cannot cast string to array<int>; line 3 pos 7\r\n```\r\n\r\nThe expected message is:\r\n```\r\nExceptAll can only be performed on tables with the compatible column types. array<int> <> int at the first column of the second table; \r\n```\r\n\r\n@HyukjinKwon do you still want this change?",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:47:44Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);",
    "line": 55
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Oh, yes. complex types cannot be supported via udf for now. I forgot. Yes, let's just don't do it for now and just replace `*` to UDF.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:56:53Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);",
    "line": 55
  }],
  "prId": 25090
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would add udfs in those tests. Otherwise, it would just duplicate tests in `except-all.sql`.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:14:25Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "@HyukjinKwon, I can replace * with udf(c1). Did you want something else?",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:44:35Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Yea, let's replace it.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:46:05Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Done.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T05:06:02Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4"
  }],
  "prId": 25090
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we use different combination here and below? For instnace,\r\n\r\n```\r\nudf(tab3.k) = tab4.k)\r\n```\r\n\r\n```\r\nudf(udf(tab3.k) = udf(tab4.k))\r\n```\r\n\r\n```\r\nSELECT * \r\nFROM   (SELECT tab3.k,\r\n               udf(tab4.v)\r\n        FROM   tab3 \r\n               JOIN tab4 \r\n                 ON udf(tab3.k) = udf(tab4.k))\r\n```",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T04:15:36Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON udf(tab3.k) = udf(tab4.k))"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Yes, this can be done now with your `udf` fix. :) ",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T05:25:41Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+-- This test file was converted from except-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT * FROM tab1\n+MINUS ALL\n+SELECT * FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+-- Note that there will one less NULL in the result compared to the non-udf result\n+-- because udf converts null to a string \"null\".\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT * FROM tab2 WHERE c1 > udf(6);\n+\n+-- Type Coerced ExceptAll\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT CAST(udf(1) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+EXCEPT ALL\n+SELECT array(1);\n+\n+-- Basic\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4;\n+\n+-- Basic\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3;\n+\n+-- EXCEPT ALL + INTERSECT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+INTERSECT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- EXCEPT ALL + EXCEPT\n+SELECT * FROM tab4\n+EXCEPT ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION ALL\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Mismatch on number of columns across both branches\n+SELECT k FROM tab3\n+EXCEPT ALL\n+SELECT k, v FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Using MINUS ALL\n+SELECT * FROM tab3\n+MINUS ALL\n+SELECT * FROM tab4\n+UNION\n+SELECT * FROM tab3\n+MINUS DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Chain of set operations\n+SELECT * FROM tab3\n+EXCEPT ALL\n+SELECT * FROM tab4\n+EXCEPT DISTINCT\n+SELECT * FROM tab3\n+EXCEPT DISTINCT\n+SELECT * FROM tab4;\n+\n+-- Join under except all. Should produce empty resultset since both left and right sets \n+-- are same.\n+SELECT * \n+FROM   (SELECT udf(tab3.k),\n+               udf(tab4.v)\n+        FROM   tab3 \n+               JOIN tab4 \n+                 ON udf(tab3.k) = udf(tab4.k))"
  }],
  "prId": 25090
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Is it intentionally to do `udf(6)`? Not `udf(c1) > 6`?",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T06:32:27Z",
    "diffHunk": "@@ -0,0 +1,162 @@\n+-- This test file was converted from except-all.sql.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT udf(c1) FROM tab1\n+MINUS ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT udf(c1) FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- Empty right relation\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2 WHERE udf(c1 > udf(6));",
    "line": 45
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Yes, I am trying a different combination of `udf`s.",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T07:07:03Z",
    "diffHunk": "@@ -0,0 +1,162 @@\n+-- This test file was converted from except-all.sql.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT udf(c1) FROM tab1\n+MINUS ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT udf(c1) FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- Empty right relation\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2 WHERE udf(c1 > udf(6));",
    "line": 45
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Yea, it's kind of a bit random but let's test different cases while we're here..",
    "commit": "2c8cc194fb6552cebe6cd1333cb88374c4a156a8",
    "createdAt": "2019-07-18T10:40:57Z",
    "diffHunk": "@@ -0,0 +1,162 @@\n+-- This test file was converted from except-all.sql.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (0), (1), (2), (2), (2), (2), (3), (null), (null) AS tab1(c1);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1), (2), (2), (3), (5), (5), (null) AS tab2(c1);\n+CREATE TEMPORARY VIEW tab3 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3),\n+    (2, 2)\n+    AS tab3(k, v);\n+CREATE TEMPORARY VIEW tab4 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3),\n+    (2, 2),\n+    (2, 2),\n+    (2, 20)\n+    AS tab4(k, v);\n+\n+-- Basic EXCEPT ALL\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- MINUS ALL (synonym for EXCEPT)\n+SELECT udf(c1) FROM tab1\n+MINUS ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- EXCEPT ALL same table in both branches\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2 WHERE udf(c1) IS NOT NULL;\n+\n+-- Empty left relation\n+SELECT udf(c1) FROM tab1 WHERE udf(c1) > 5\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2;\n+\n+-- Empty right relation\n+SELECT udf(c1) FROM tab1\n+EXCEPT ALL\n+SELECT udf(c1) FROM tab2 WHERE udf(c1 > udf(6));",
    "line": 45
  }],
  "prId": 25090
}]