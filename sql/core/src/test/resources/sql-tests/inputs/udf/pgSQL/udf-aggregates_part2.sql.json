[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we add a comment like:\r\n\r\n```\r\n-- This test file was converted from pgSQL/aggregates_part2.sql.\r\n-- Note that currently registered UDF returns a string. So there are some differences, for instance\r\n-- in string cast within UDF in Scala and Python.\r\n```",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-10T00:26:29Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+",
    "line": 11
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "fixed.",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-10T00:39:16Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+",
    "line": 11
  }],
  "prId": 25086
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@imback82, while we're here, let's also test multiple udf combinations. For instance, \r\n\r\n```sql\r\nselect udf(max(udf(unique2))) from tenk1 order by udf(max(unique2))+1;\r\n```",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-10T00:27:22Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+create temporary view int4_tbl as select * from values\n+  (0),\n+  (123456),\n+  (-123456),\n+  (2147483647),\n+  (-2147483647)\n+  as int4_tbl(f1);\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- The result is inconsistent with PostgreSQL because our AND does not have strict mode\n+SELECT\n+  -- boolean and transitions\n+  -- null because strict\n+  (NULL AND NULL) IS NULL AS `t`,\n+  (TRUE AND NULL) IS NULL AS `t`,\n+  (FALSE AND NULL) IS NULL AS `t`,\n+  (NULL AND TRUE) IS NULL AS `t`,\n+  (NULL AND FALSE) IS NULL AS `t`,\n+  -- and actual computations\n+  (TRUE AND TRUE) AS `t`,\n+  NOT (TRUE AND FALSE) AS `t`,\n+  NOT (FALSE AND TRUE) AS `t`,\n+  NOT (FALSE AND FALSE) AS `t`;\n+\n+-- The result is inconsistent with PostgreSQL because our OR does not have strict mode\n+SELECT\n+  -- boolean or transitions\n+  -- null because strict\n+  (NULL OR NULL) IS NULL AS `t`,\n+  (TRUE OR NULL) IS NULL AS `t`,\n+  (FALSE OR NULL) IS NULL AS `t`,\n+  (NULL OR TRUE) IS NULL AS `t`,\n+  (NULL OR FALSE) IS NULL AS `t`,\n+  -- actual computations\n+  (TRUE OR TRUE) AS `t`,\n+  (TRUE OR FALSE) AS `t`,\n+  (FALSE OR TRUE) AS `t`,\n+  NOT (FALSE OR FALSE) AS `t`;\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+-- explain\n+--  select min(unique1) from tenk1;\n+select min(udf(unique1)) from tenk1;\n+-- explain\n+--  select max(unique1) from tenk1;\n+select udf(max(unique1)) from tenk1;\n+-- explain\n+--  select max(unique1) from tenk1 where unique1 < 42;\n+select max(unique1) from tenk1 where udf(unique1) < 42;\n+-- explain\n+--  select max(unique1) from tenk1 where unique1 > 42;\n+select max(unique1) from tenk1 where unique1 > udf(42);\n+\n+-- the planner may choose a generic aggregate here if parallel query is\n+-- enabled, since that plan will be parallel safe and the \"optimized\"\n+-- plan, which has almost identical cost, will not be.  we want to test\n+-- the optimized plan, so temporarily disable parallel query.\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+-- explain\n+--  select max(unique1) from tenk1 where unique1 > 42000;\n+select max(unique1) from tenk1 where udf(unique1) > 42000;\n+-- rollback;\n+\n+-- multi-column index (uses tenk1_thous_tenthous)\n+-- explain\n+--  select max(tenthous) from tenk1 where thousand = 33;\n+select max(tenthous) from tenk1 where udf(thousand) = 33;\n+-- explain\n+--  select min(tenthous) from tenk1 where thousand = 33;\n+select min(tenthous) from tenk1 where udf(thousand) = 33;\n+\n+-- [SPARK-17348] Correlated column is not allowed in a non-equality predicate\n+-- check parameter propagation into an indexscan subquery\n+-- explain\n+--  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+--    from int4_tbl;\n+-- select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+--  from int4_tbl;\n+\n+-- check some cases that were handled incorrectly in 8.3.0\n+-- explain\n+--  select distinct max(unique2) from tenk1;\n+select distinct max(udf(unique2)) from tenk1;\n+-- explain\n+--  select max(unique2) from tenk1 order by 1;\n+select max(unique2) from tenk1 order by udf(1);\n+-- explain\n+--  select max(unique2) from tenk1 order by max(unique2);\n+select max(unique2) from tenk1 order by max(udf(unique2));\n+-- explain\n+--  select max(unique2) from tenk1 order by max(unique2)+1;\n+select max(unique2) from tenk1 order by udf(max(unique2))+1;"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "updated.",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-10T00:40:15Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350\n+\n+create temporary view int4_tbl as select * from values\n+  (0),\n+  (123456),\n+  (-123456),\n+  (2147483647),\n+  (-2147483647)\n+  as int4_tbl(f1);\n+\n+-- Test handling of Params within aggregate arguments in hashed aggregation.\n+-- Per bug report from Jeevan Chalke.\n+-- [SPARK-27877] Implement SQL-standard LATERAL subqueries\n+-- explain (verbose, costs off)\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+-- select s1, s2, sm\n+-- from generate_series(1, 3) s1,\n+--      lateral (select s2, sum(s1 + s2) sm\n+--               from generate_series(1, 3) s2 group by s2) ss\n+-- order by 1, 2;\n+\n+-- [SPARK-27878] Support ARRAY(sub-SELECT) expressions\n+-- explain (verbose, costs off)\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+-- select array(select sum(x+y) s\n+--             from generate_series(1,3) y group by y order by s)\n+--   from generate_series(1,3) x;\n+\n+-- [SPARK-27879] Implement bitwise integer aggregates(BIT_AND and BIT_OR)\n+--\n+-- test for bitwise integer aggregates\n+--\n+-- CREATE TEMPORARY TABLE bitwise_test(\n+--   i2 INT2,\n+--   i4 INT4,\n+--   i8 INT8,\n+--   i INTEGER,\n+--   x INT2,\n+--   y BIT(4)\n+-- );\n+\n+-- empty case\n+-- SELECT\n+--   BIT_AND(i2) AS \"?\",\n+--   BIT_OR(i4)  AS \"?\"\n+-- FROM bitwise_test;\n+\n+-- COPY bitwise_test FROM STDIN NULL 'null';\n+-- 1\t1\t1\t1\t1\tB0101\n+-- 3\t3\t3\tnull\t2\tB0100\n+-- 7\t7\t7\t3\t4\tB1100\n+-- \\.\n+\n+-- SELECT\n+--   BIT_AND(i2) AS \"1\",\n+--   BIT_AND(i4) AS \"1\",\n+--   BIT_AND(i8) AS \"1\",\n+--   BIT_AND(i)  AS \"?\",\n+--   BIT_AND(x)  AS \"0\",\n+--   BIT_AND(y)  AS \"0100\",\n+--\n+--   BIT_OR(i2)  AS \"7\",\n+--   BIT_OR(i4)  AS \"7\",\n+--   BIT_OR(i8)  AS \"7\",\n+--   BIT_OR(i)   AS \"?\",\n+--   BIT_OR(x)   AS \"7\",\n+--   BIT_OR(y)   AS \"1101\"\n+-- FROM bitwise_test;\n+\n+--\n+-- test boolean aggregates\n+--\n+-- first test all possible transition and final states\n+\n+-- The result is inconsistent with PostgreSQL because our AND does not have strict mode\n+SELECT\n+  -- boolean and transitions\n+  -- null because strict\n+  (NULL AND NULL) IS NULL AS `t`,\n+  (TRUE AND NULL) IS NULL AS `t`,\n+  (FALSE AND NULL) IS NULL AS `t`,\n+  (NULL AND TRUE) IS NULL AS `t`,\n+  (NULL AND FALSE) IS NULL AS `t`,\n+  -- and actual computations\n+  (TRUE AND TRUE) AS `t`,\n+  NOT (TRUE AND FALSE) AS `t`,\n+  NOT (FALSE AND TRUE) AS `t`,\n+  NOT (FALSE AND FALSE) AS `t`;\n+\n+-- The result is inconsistent with PostgreSQL because our OR does not have strict mode\n+SELECT\n+  -- boolean or transitions\n+  -- null because strict\n+  (NULL OR NULL) IS NULL AS `t`,\n+  (TRUE OR NULL) IS NULL AS `t`,\n+  (FALSE OR NULL) IS NULL AS `t`,\n+  (NULL OR TRUE) IS NULL AS `t`,\n+  (NULL OR FALSE) IS NULL AS `t`,\n+  -- actual computations\n+  (TRUE OR TRUE) AS `t`,\n+  (TRUE OR FALSE) AS `t`,\n+  (FALSE OR TRUE) AS `t`,\n+  NOT (FALSE OR FALSE) AS `t`;\n+\n+-- [SPARK-27880] Implement boolean aggregates(BOOL_AND, BOOL_OR and EVERY)\n+-- CREATE TEMPORARY TABLE bool_test(\n+--   b1 BOOL,\n+--   b2 BOOL,\n+--   b3 BOOL,\n+--   b4 BOOL);\n+\n+-- empty case\n+-- SELECT\n+--   BOOL_AND(b1)   AS \"n\",\n+--   BOOL_OR(b3)    AS \"n\"\n+-- FROM bool_test;\n+\n+-- COPY bool_test FROM STDIN NULL 'null';\n+-- TRUE\tnull\tFALSE\tnull\n+-- FALSE\tTRUE\tnull\tnull\n+-- null\tTRUE\tFALSE\tnull\n+-- \\.\n+\n+-- SELECT\n+--   BOOL_AND(b1)     AS \"f\",\n+--   BOOL_AND(b2)     AS \"t\",\n+--   BOOL_AND(b3)     AS \"f\",\n+--   BOOL_AND(b4)     AS \"n\",\n+--   BOOL_AND(NOT b2) AS \"f\",\n+--   BOOL_AND(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   EVERY(b1)     AS \"f\",\n+--   EVERY(b2)     AS \"t\",\n+--   EVERY(b3)     AS \"f\",\n+--   EVERY(b4)     AS \"n\",\n+--   EVERY(NOT b2) AS \"f\",\n+--   EVERY(NOT b3) AS \"t\"\n+-- FROM bool_test;\n+\n+-- SELECT\n+--   BOOL_OR(b1)      AS \"t\",\n+--   BOOL_OR(b2)      AS \"t\",\n+--   BOOL_OR(b3)      AS \"f\",\n+--   BOOL_OR(b4)      AS \"n\",\n+--   BOOL_OR(NOT b2)  AS \"f\",\n+--   BOOL_OR(NOT b3)  AS \"t\"\n+-- FROM bool_test;\n+\n+--\n+-- Test cases that should be optimized into indexscans instead of\n+-- the generic aggregate implementation.\n+--\n+\n+-- Basic cases\n+-- explain\n+--  select min(unique1) from tenk1;\n+select min(udf(unique1)) from tenk1;\n+-- explain\n+--  select max(unique1) from tenk1;\n+select udf(max(unique1)) from tenk1;\n+-- explain\n+--  select max(unique1) from tenk1 where unique1 < 42;\n+select max(unique1) from tenk1 where udf(unique1) < 42;\n+-- explain\n+--  select max(unique1) from tenk1 where unique1 > 42;\n+select max(unique1) from tenk1 where unique1 > udf(42);\n+\n+-- the planner may choose a generic aggregate here if parallel query is\n+-- enabled, since that plan will be parallel safe and the \"optimized\"\n+-- plan, which has almost identical cost, will not be.  we want to test\n+-- the optimized plan, so temporarily disable parallel query.\n+-- begin;\n+-- set local max_parallel_workers_per_gather = 0;\n+-- explain\n+--  select max(unique1) from tenk1 where unique1 > 42000;\n+select max(unique1) from tenk1 where udf(unique1) > 42000;\n+-- rollback;\n+\n+-- multi-column index (uses tenk1_thous_tenthous)\n+-- explain\n+--  select max(tenthous) from tenk1 where thousand = 33;\n+select max(tenthous) from tenk1 where udf(thousand) = 33;\n+-- explain\n+--  select min(tenthous) from tenk1 where thousand = 33;\n+select min(tenthous) from tenk1 where udf(thousand) = 33;\n+\n+-- [SPARK-17348] Correlated column is not allowed in a non-equality predicate\n+-- check parameter propagation into an indexscan subquery\n+-- explain\n+--  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+--    from int4_tbl;\n+-- select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt\n+--  from int4_tbl;\n+\n+-- check some cases that were handled incorrectly in 8.3.0\n+-- explain\n+--  select distinct max(unique2) from tenk1;\n+select distinct max(udf(unique2)) from tenk1;\n+-- explain\n+--  select max(unique2) from tenk1 order by 1;\n+select max(unique2) from tenk1 order by udf(1);\n+-- explain\n+--  select max(unique2) from tenk1 order by max(unique2);\n+select max(unique2) from tenk1 order by max(udf(unique2));\n+-- explain\n+--  select max(unique2) from tenk1 order by max(unique2)+1;\n+select max(unique2) from tenk1 order by udf(max(unique2))+1;"
  }],
  "prId": 25086
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Please use `REL_12_BETA2` here because BETA2 is already out and more closer to `REL_12`. I guess `REL_12_BETA2` will be the same with `REL_12_BETA1`.\r\nIf not, please make this up-to-date.",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-10T18:23:34Z",
    "diffHunk": "@@ -0,0 +1,232 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350",
    "line": 6
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Seems like there's one more case. Let me make a small PR separately to address this comment for `aggregates_part2.sql` as well.",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-11T00:44:30Z",
    "diffHunk": "@@ -0,0 +1,232 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350",
    "line": 6
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "+1.",
    "commit": "0550038260abd9ac975ae6ba8c53087fd33b0bdb",
    "createdAt": "2019-07-11T00:55:32Z",
    "diffHunk": "@@ -0,0 +1,232 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- AGGREGATES [Part 2]\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA1/src/test/regress/sql/aggregates.sql#L145-L350",
    "line": 6
  }],
  "prId": 25086
}]