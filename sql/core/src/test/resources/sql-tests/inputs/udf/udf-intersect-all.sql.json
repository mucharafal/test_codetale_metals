[{
  "comments": [{
    "author": {
      "login": "imback82"
    },
    "body": "I am using CAST here to avoid `nan` in the result (note that there are null values involved here).",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-11T16:49:11Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Yea, now we don't have to add such cases anymore. Let's get rid of them.",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T04:23:35Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Reverted.",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T05:51:59Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))"
  }],
  "prId": 25119
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think my comments I left at of your PRs are applied here too. Let's list up cols",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T04:23:17Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Yes, will do.",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T05:52:36Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1"
  }],
  "prId": 25119
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "We could try `udf(udf(tab1.k) = udf(tab2.k))` or `udf(udf(tab1.k) = tab2.k)`",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T04:24:07Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));\n+\n+-- Join under intersect all (2)\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab2.v) AS k,\n+               udf(tab1.k) AS v\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "@HyukjinKwon, did you really want this? This removes the join condition, and I get the following message:\r\n```\r\nJoin condition is missing or trivial.\r\nEither: use the CROSS JOIN syntax to allow cartesian products between these\r\nrelations, or: enable implicit cartesian products by setting the configuration\r\nvariable spark.sql.crossJoin.enabled=true;\r\n```\r\nDid you mean `udf(udf(tab1.k)) = udf(tab2.k)` or `udf(udf(tab1.k)) = tab2.k`.",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T06:19:12Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));\n+\n+-- Join under intersect all (2)\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab2.v) AS k,\n+               udf(tab1.k) AS v\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));"
  }],
  "prId": 25119
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Let's get rid of the casts.",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T04:24:19Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));\n+\n+-- Join under intersect all (2)\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab2.v) AS k,\n+               udf(tab1.k) AS v\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));\n+\n+-- Group by under intersect all\n+SELECT CAST(udf(v) AS BIGINT) FROM tab1 GROUP BY v\n+INTERSECT ALL\n+SELECT CAST(udf(k) AS BIGINT) FROM tab2 GROUP BY k;"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Done.",
    "commit": "42cf16bd46a6e33226540516b0344c52e543e57e",
    "createdAt": "2019-07-18T06:22:19Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v);\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v);\n+\n+-- Basic INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- INTERSECT ALL same table in both branches\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE udf(k) = 1;\n+\n+-- Empty left relation\n+SELECT * FROM tab1 WHERE k > udf(2)\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Empty right relation\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE CAST(udf(k) AS BIGINT) > CAST(udf(3) AS BIGINT);\n+\n+-- Type Coerced INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(udf(1) AS BIGINT), CAST(udf(2) AS BIGINT);\n+\n+-- Error as types of two side are not compatible\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), udf(2);\n+\n+-- Mismatch on number of columns across both branches\n+SELECT udf(k) FROM tab1\n+INTERSECT ALL\n+SELECT udf(k), udf(v) FROM tab2;\n+\n+-- Basic\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- Chain of different `set operations\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+EXCEPT\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+;\n+\n+-- test use parenthesis to control order of evaluation\n+(\n+  (\n+    (\n+      SELECT * FROM tab1\n+      EXCEPT\n+      SELECT * FROM tab2\n+    )\n+    EXCEPT\n+    SELECT * FROM tab1\n+  )\n+  INTERSECT ALL\n+  SELECT * FROM tab2\n+)\n+;\n+\n+-- Join under intersect all\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));\n+\n+-- Join under intersect all (2)\n+SELECT * \n+FROM   (SELECT udf(tab1.k),\n+               udf(tab2.v)\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT))\n+INTERSECT ALL \n+SELECT * \n+FROM   (SELECT udf(tab2.v) AS k,\n+               udf(tab1.k) AS v\n+        FROM   tab1 \n+               JOIN tab2 \n+                 ON CAST(udf(tab1.k) AS BIGINT) = CAST(udf(tab2.k) AS BIGINT));\n+\n+-- Group by under intersect all\n+SELECT CAST(udf(v) AS BIGINT) FROM tab1 GROUP BY v\n+INTERSECT ALL\n+SELECT CAST(udf(k) AS BIGINT) FROM tab2 GROUP BY k;"
  }],
  "prId": 25119
}]