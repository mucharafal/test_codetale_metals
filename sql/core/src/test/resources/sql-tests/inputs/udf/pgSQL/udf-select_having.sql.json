[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "After merging the PR I pointed out, let's try `HAVING udf(1 > 2)` combination as well.",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-15T12:43:07Z",
    "diffHunk": "@@ -0,0 +1,57 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+\n+-- errors: ungrouped column references\n+SELECT udf(a) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+SELECT 1 AS one FROM test_having HAVING udf(a) > 1;\n+\n+-- the really degenerate case: need not scan table at all\n+SELECT 1 AS one FROM test_having HAVING 1 > 2;"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Done",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-15T13:26:30Z",
    "diffHunk": "@@ -0,0 +1,57 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+\n+-- errors: ungrouped column references\n+SELECT udf(a) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+SELECT 1 AS one FROM test_having HAVING udf(a) > 1;\n+\n+-- the really degenerate case: need not scan table at all\n+SELECT 1 AS one FROM test_having HAVING 1 > 2;"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would comment this:\r\n\r\n```\r\n--\r\n-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\r\n--\r\n--\r\n-- SELECT_HAVING\r\n-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\r\n--\r\n-- This test file was converted from inputs/pgSQL/select_having.sql\r\n```\r\n\r\nto keep the original comment intact.",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-15T12:43:11Z",
    "diffHunk": "@@ -0,0 +1,57 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--",
    "line": 7
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Corrected",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-15T13:26:15Z",
    "diffHunk": "@@ -0,0 +1,57 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--",
    "line": 7
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@shivusondur, can we try this combination too? `udf(udf(1) > udf(2))`",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-18T04:10:08Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+\n+-- errors: ungrouped column references\n+SELECT udf(a) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+SELECT 1 AS one FROM test_having HAVING udf(a) > 1;\n+\n+-- the really degenerate case: need not scan table at all\n+SELECT 1 AS one FROM test_having HAVING udf(1 > 2);\n+SELECT 1 AS one FROM test_having HAVING udf(1 < 2);"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Handled",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-19T06:33:29Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+\n+-- errors: ungrouped column references\n+SELECT udf(a) FROM test_having HAVING udf(min(a)) < udf(max(a));\n+SELECT 1 AS one FROM test_having HAVING udf(a) > 1;\n+\n+-- the really degenerate case: need not scan table at all\n+SELECT 1 AS one FROM test_having HAVING udf(1 > 2);\n+SELECT 1 AS one FROM test_having HAVING udf(1 < 2);"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "here too:\r\n\r\n```\r\nudf(udf(min(a)) < udf(max(a)))\r\n```",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-18T04:10:28Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) < udf(max(a));"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Handled",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-19T06:33:18Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) < udf(max(a));"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Could we try `GROUP BY udf(b), c` too?",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-18T04:11:02Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Not Done\r\ngetting below errors.\r\n\"org.apache.spark.sql.AnalysisException\r\nexpression 'default.test_having.`b`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\"",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-19T06:32:14Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "`ORDER BY udf(b), c` too",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-18T04:11:14Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Not done, Bellow is the error\r\n\r\n\"org.apache.spark.sql.AnalysisException\r\nexpression 'default.test_having.`b`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\"",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-19T06:32:54Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we test `udf(min(udf(a)))` case too?",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-19T11:23:00Z",
    "diffHunk": "@@ -0,0 +1,62 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Handled, i added all combination",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-21T17:45:11Z",
    "diffHunk": "@@ -0,0 +1,62 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(min(a)), udf(max(a)) FROM test_having HAVING udf(min(a)) = udf(max(a));"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Hm, @shivusondur, seems working if we put udf in `ORDER BY`\r\n\r\n```python\r\nfrom pyspark.sql.functions import pandas_udf, PandasUDFType\r\n\r\n@pandas_udf(\"int\", PandasUDFType.SCALAR)\r\ndef noop(x):\r\n    return x\r\n\r\nspark.udf.register(\"udf\", noop)\r\n\r\nspark.range(10).selectExpr(\"id as b\", \"id as c\").createOrReplaceTempView(\"test_having\")\r\nsql(\"\"\"SELECT udf(b), udf(c) FROM test_having\r\n\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY udf(b), c\"\"\").show()\r\n```\r\n\r\n```\r\n+------+------+\r\n|udf(b)|udf(c)|\r\n+------+------+\r\n|     0|     0|\r\n|     1|     1|\r\n|     2|     2|\r\n|     3|     3|\r\n|     4|     4|\r\n|     5|     5|\r\n|     6|     6|\r\n|     7|     7|\r\n|     8|     8|\r\n|     9|     9|\r\n+------+------+\r\n```\r\n\r\ncan you double check this?",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-19T11:39:58Z",
    "diffHunk": "@@ -0,0 +1,62 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Handled, i added all the combination",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-21T17:45:42Z",
    "diffHunk": "@@ -0,0 +1,62 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY b, c;\n+\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY b, c;"
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we add a comment like:\r\n\r\n```\r\n-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\r\n```",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T02:36:30Z",
    "diffHunk": "@@ -0,0 +1,84 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+",
    "line": 10
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "> DIFF is correct. I added more combination of queries with udf() addition, so queries increased.\r\n> Added the \"-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\" comment",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T03:33:19Z",
    "diffHunk": "@@ -0,0 +1,84 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+",
    "line": 10
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@shivusondur, let's avoid to add more combinations. `select_having.sql` file is being matched and ported from https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\r\n\r\nIt's easier to review and check the diff if we match.\r\n\r\nIf we need, we can add separate test cases later in a different place but that's not what this JIRA targets.",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T03:48:44Z",
    "diffHunk": "@@ -0,0 +1,84 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+",
    "line": 10
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "@HyukjinKwon \r\n Now made the ../udf-select_having.sql  similar to ../select_having.sql, Only extra is udf() is added  wherever required.\r\nThanks for guiding me",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T07:20:01Z",
    "diffHunk": "@@ -0,0 +1,84 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+",
    "line": 10
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we add this todo on the top:\r\n```\r\n-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\r\n```\r\n\r\nand remove same lines below?",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T11:45:44Z",
    "diffHunk": "@@ -0,0 +1,58 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql",
    "line": 8
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "Done",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-23T03:43:41Z",
    "diffHunk": "@@ -0,0 +1,58 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql",
    "line": 8
  }],
  "prId": 25161
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we use different UDF combination comparing to the one right above?",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T11:47:08Z",
    "diffHunk": "@@ -0,0 +1,58 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY udf(b), udf(c);\n+\n+-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY udf(b), udf(c);\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(udf(min(udf(a)))), udf(udf(max(udf(a)))) FROM test_having HAVING udf(udf(min(udf(a)))) = udf(udf(max(udf(a))));\n+SELECT udf(udf(min(udf(a)))), udf(udf(max(udf(a)))) FROM test_having HAVING udf(udf(min(udf(a)))) < udf(udf(max(udf(a))));"
  }, {
    "author": {
      "login": "shivusondur"
    },
    "body": "updated like below\r\n\r\nSELECT udf(udf(min(udf(a)))), udf(udf(max(udf(a)))) FROM test_having HAVING udf(udf(min(udf(a)))) = udf(udf(max(udf(a))));\r\nSELECT udf(min(udf(a))), udf(udf(max(a))) FROM test_having HAVING udf(min(a)) < udf(max(udf(a)));\r\n",
    "commit": "8795d66b189712f54a55a3b0663273fb26126a8e",
    "createdAt": "2019-07-22T17:41:19Z",
    "diffHunk": "@@ -0,0 +1,58 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- SELECT_HAVING\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/select_having.sql\n+--\n+-- This test file was converted from inputs/pgSQL/select_having.sql\n+\n+-- load test data\n+CREATE TABLE test_having (a int, b int, c string, d string) USING parquet;\n+INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\n+INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\n+INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\n+INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\n+INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\n+INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\n+INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\n+INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\n+INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\n+INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n+\n+-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY udf(b), udf(c);\n+\n+-- TODO: We should add UDFs in GROUP BY clause when [SPARK-28445] is resolved.\n+-- HAVING is effectively equivalent to WHERE in this case\n+SELECT udf(b), udf(c) FROM test_having\n+\tGROUP BY b, c HAVING udf(b) = 3 ORDER BY udf(b), udf(c);\n+\n+-- [SPARK-28386] Cannot resolve ORDER BY columns with GROUP BY and HAVING\n+-- SELECT lower(c), count(c) FROM test_having\n+-- \tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n+-- \tORDER BY lower(c);\n+\n+SELECT udf(c), max(udf(a)) FROM test_having\n+\tGROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))\n+\tORDER BY c;\n+\n+-- test degenerate cases involving HAVING without GROUP BY\n+-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n+\n+SELECT udf(udf(min(udf(a)))), udf(udf(max(udf(a)))) FROM test_having HAVING udf(udf(min(udf(a)))) = udf(udf(max(udf(a))));\n+SELECT udf(udf(min(udf(a)))), udf(udf(max(udf(a)))) FROM test_having HAVING udf(udf(min(udf(a)))) < udf(udf(max(udf(a))));"
  }],
  "prId": 25161
}]