[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Does it work if we do `udf(a)` in `GROUP BY`? Seems this case is missing.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T01:03:58Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "will check.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T09:13:05Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "It does:\r\n```\r\n>>> from pyspark.sql.functions import pandas_udf, PandasUDFType\r\n>>> @pandas_udf(\"string\", PandasUDFType.SCALAR)\r\n... def noop(x):\r\n...     return x.apply(str)\r\n... \r\n>>> spark.udf.register(\"udf\", noop)\r\n<function noop at 0x7f2cf7d91b90>\r\n>>> \r\n>>> spark.sql(\"CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES (1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2) AS testData(a, b)\")\r\n\r\nDataFrame[]\r\n>>> \r\n>>> spark.sql(\"SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a)\").show()\r\n\r\n19/07/12 01:55:40 WARN ObjectStore: Failed to get database global_temp, returning NoSuchObjectException\r\n+-------------+-------------+                                                   \r\n|count(udf(a))|count(udf(b))|\r\n+-------------+-------------+\r\n|            2|            2|\r\n|            2|            2|\r\n|            2|            2|\r\n+-------------+-------------+\r\n\r\n>>> \r\n```",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T22:56:39Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "I will cover it.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T22:59:06Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "This one will not work and comes from group-analytics.sql:\r\n```\r\nspark.sql(\"SELECT udf(a + b), b, udf(SUM(a - b)) FROM testData GROUP BY udf(a + b), b WITH CUBE\").show()\r\npyspark.sql.utils.AnalysisException: u\"expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;;\\nAggregate [udf((a#0 + b#1))#152, b#153, spark_grouping_id#149], [udf((a#0 + b#153)) AS udf((a + b))#146, b#153, udf(sum(cast((a#0 - b#1) as bigint))) AS udf(sum(cast((a - b) as bigint)))#148]\\n+- Expand [List(a#0, b#1, udf((a#0 + b#1))#150, b#151, 0), List(a#0, b#1, udf((a#0 + b#1))#150, null, 1), List(a#0, b#1, null, b#151, 2), List(a#0, b#1, null, null, 3)], [a#0, b#1, udf((a#0 + b#1))#152, b#153, spark_grouping_id#149]\\n   +- Project [a#0, b#1, udf((a#0 + b#1)) AS udf((a#0 + b#1))#150, b#1 AS b#151]\\n      +- SubqueryAlias `testdata`\\n         +- Project [a#0, b#1]\\n            +- SubqueryAlias `testData`\\n               +- LocalRelation [a#0, b#1]\\n\"\r\n\r\n```\r\n\r\n",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T23:01:41Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;"
  }],
  "prId": 25098
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Seems udf is not used here.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T01:05:40Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- Aggregate with nulls.\n+SELECT SKEWNESS(udf(a)), udf(KURTOSIS(a)), udf(MIN(a)), MAX(udf(a)), udf(AVG(udf(a))), udf(VARIANCE(a)), STDDEV(udf(a)), udf(SUM(a)), udf(COUNT(a))\n+FROM testData;\n+\n+-- Aggregate with foldable input and multiple distinct groups.\n+SELECT COUNT(DISTINCT udf(b)), udf(COUNT(DISTINCT b, c)) FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a;\n+\n+-- Aliases in SELECT could be used in GROUP BY\n+SELECT a AS k, COUNT(udf(b)) FROM testData GROUP BY k;\n+SELECT a AS k, udf(COUNT(b)) FROM testData GROUP BY k HAVING k > 1;\n+\n+-- Aggregate functions cannot be used in GROUP BY\n+SELECT udf(COUNT(b)) AS k FROM testData GROUP BY k;\n+\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testDataHasSameNameWithAlias AS SELECT * FROM VALUES\n+(1, 1, 3), (1, 2, 1) AS testDataHasSameNameWithAlias(k, a, v);\n+SELECT k AS a, udf(COUNT(udf(v))) FROM testDataHasSameNameWithAlias GROUP BY a;\n+\n+-- turn off group by aliases\n+set spark.sql.groupByAliases=false;\n+\n+-- Check analysis exceptions\n+SELECT a AS k, udf(COUNT(udf(b))) FROM testData GROUP BY k;\n+\n+-- Aggregate with empty input and non-empty GroupBy expressions.\n+SELECT a, COUNT(udf(1)) FROM testData WHERE false GROUP BY a;\n+\n+-- Aggregate with empty input and empty GroupBy expressions.\n+SELECT udf(COUNT(1)) FROM testData WHERE false;\n+SELECT 1 FROM (SELECT udf(COUNT(1)) FROM testData WHERE false) t;\n+\n+-- Aggregate with empty GroupBy expressions and filter on top\n+SELECT 1 from (\n+  SELECT 1 AS z,\n+  udf(MIN(a.x))\n+  FROM (select 1 as x) a\n+  WHERE false\n+) b\n+where b.z != b.z;\n+\n+-- SPARK-24369 multiple distinct aggregations having the same argument set\n+SELECT corr(DISTINCT x, y), udf(corr(DISTINCT y, x)), count(*)\n+  FROM (VALUES (1, 1), (2, 2), (2, 2)) t(x, y);\n+\n+-- SPARK-25708 HAVING without GROUP BY means global aggregate\n+SELECT udf(1) FROM range(10) HAVING true;\n+\n+SELECT udf(udf(1)) FROM range(10) HAVING MAX(id) > 0;\n+\n+SELECT udf(id) FROM range(10) HAVING id > 0;\n+\n+-- Test data\n+CREATE OR REPLACE TEMPORARY VIEW test_agg AS SELECT * FROM VALUES\n+  (1, true), (1, false),\n+  (2, true),\n+  (3, false), (3, null),\n+  (4, null), (4, null),\n+  (5, null), (5, true), (5, false) AS test_agg(k, v);\n+\n+-- empty table\n+SELECT udf(every(v)), udf(some(v)), any(v) FROM test_agg WHERE 1 = 0;\n+\n+-- all null values\n+SELECT udf(every(v)), some(v), any(v) FROM test_agg WHERE k = 4;\n+\n+-- aggregates are null Filtering\n+SELECT every(v), udf(some(v)), any(v) FROM test_agg WHERE k = 5;\n+\n+-- group by\n+SELECT k, every(v), udf(some(v)), any(v) FROM test_agg GROUP BY k;\n+\n+-- having\n+SELECT k, every(v) FROM test_agg GROUP BY k HAVING every(v) = false;"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Yeah it looked similar to the previous one but will fix it.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T09:13:23Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- Aggregate with nulls.\n+SELECT SKEWNESS(udf(a)), udf(KURTOSIS(a)), udf(MIN(a)), MAX(udf(a)), udf(AVG(udf(a))), udf(VARIANCE(a)), STDDEV(udf(a)), udf(SUM(a)), udf(COUNT(a))\n+FROM testData;\n+\n+-- Aggregate with foldable input and multiple distinct groups.\n+SELECT COUNT(DISTINCT udf(b)), udf(COUNT(DISTINCT b, c)) FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a;\n+\n+-- Aliases in SELECT could be used in GROUP BY\n+SELECT a AS k, COUNT(udf(b)) FROM testData GROUP BY k;\n+SELECT a AS k, udf(COUNT(b)) FROM testData GROUP BY k HAVING k > 1;\n+\n+-- Aggregate functions cannot be used in GROUP BY\n+SELECT udf(COUNT(b)) AS k FROM testData GROUP BY k;\n+\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testDataHasSameNameWithAlias AS SELECT * FROM VALUES\n+(1, 1, 3), (1, 2, 1) AS testDataHasSameNameWithAlias(k, a, v);\n+SELECT k AS a, udf(COUNT(udf(v))) FROM testDataHasSameNameWithAlias GROUP BY a;\n+\n+-- turn off group by aliases\n+set spark.sql.groupByAliases=false;\n+\n+-- Check analysis exceptions\n+SELECT a AS k, udf(COUNT(udf(b))) FROM testData GROUP BY k;\n+\n+-- Aggregate with empty input and non-empty GroupBy expressions.\n+SELECT a, COUNT(udf(1)) FROM testData WHERE false GROUP BY a;\n+\n+-- Aggregate with empty input and empty GroupBy expressions.\n+SELECT udf(COUNT(1)) FROM testData WHERE false;\n+SELECT 1 FROM (SELECT udf(COUNT(1)) FROM testData WHERE false) t;\n+\n+-- Aggregate with empty GroupBy expressions and filter on top\n+SELECT 1 from (\n+  SELECT 1 AS z,\n+  udf(MIN(a.x))\n+  FROM (select 1 as x) a\n+  WHERE false\n+) b\n+where b.z != b.z;\n+\n+-- SPARK-24369 multiple distinct aggregations having the same argument set\n+SELECT corr(DISTINCT x, y), udf(corr(DISTINCT y, x)), count(*)\n+  FROM (VALUES (1, 1), (2, 2), (2, 2)) t(x, y);\n+\n+-- SPARK-25708 HAVING without GROUP BY means global aggregate\n+SELECT udf(1) FROM range(10) HAVING true;\n+\n+SELECT udf(udf(1)) FROM range(10) HAVING MAX(id) > 0;\n+\n+SELECT udf(id) FROM range(10) HAVING id > 0;\n+\n+-- Test data\n+CREATE OR REPLACE TEMPORARY VIEW test_agg AS SELECT * FROM VALUES\n+  (1, true), (1, false),\n+  (2, true),\n+  (3, false), (3, null),\n+  (4, null), (4, null),\n+  (5, null), (5, true), (5, false) AS test_agg(k, v);\n+\n+-- empty table\n+SELECT udf(every(v)), udf(some(v)), any(v) FROM test_agg WHERE 1 = 0;\n+\n+-- all null values\n+SELECT udf(every(v)), some(v), any(v) FROM test_agg WHERE k = 4;\n+\n+-- aggregates are null Filtering\n+SELECT every(v), udf(some(v)), any(v) FROM test_agg WHERE k = 5;\n+\n+-- group by\n+SELECT k, every(v), udf(some(v)), any(v) FROM test_agg GROUP BY k;\n+\n+-- having\n+SELECT k, every(v) FROM test_agg GROUP BY k HAVING every(v) = false;"
  }],
  "prId": 25098
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "We could try `udf(every(udf(v)))` combination too.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-11T01:06:10Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY a;\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- Aggregate with nulls.\n+SELECT SKEWNESS(udf(a)), udf(KURTOSIS(a)), udf(MIN(a)), MAX(udf(a)), udf(AVG(udf(a))), udf(VARIANCE(a)), STDDEV(udf(a)), udf(SUM(a)), udf(COUNT(a))\n+FROM testData;\n+\n+-- Aggregate with foldable input and multiple distinct groups.\n+SELECT COUNT(DISTINCT udf(b)), udf(COUNT(DISTINCT b, c)) FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a;\n+\n+-- Aliases in SELECT could be used in GROUP BY\n+SELECT a AS k, COUNT(udf(b)) FROM testData GROUP BY k;\n+SELECT a AS k, udf(COUNT(b)) FROM testData GROUP BY k HAVING k > 1;\n+\n+-- Aggregate functions cannot be used in GROUP BY\n+SELECT udf(COUNT(b)) AS k FROM testData GROUP BY k;\n+\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testDataHasSameNameWithAlias AS SELECT * FROM VALUES\n+(1, 1, 3), (1, 2, 1) AS testDataHasSameNameWithAlias(k, a, v);\n+SELECT k AS a, udf(COUNT(udf(v))) FROM testDataHasSameNameWithAlias GROUP BY a;\n+\n+-- turn off group by aliases\n+set spark.sql.groupByAliases=false;\n+\n+-- Check analysis exceptions\n+SELECT a AS k, udf(COUNT(udf(b))) FROM testData GROUP BY k;\n+\n+-- Aggregate with empty input and non-empty GroupBy expressions.\n+SELECT a, COUNT(udf(1)) FROM testData WHERE false GROUP BY a;\n+\n+-- Aggregate with empty input and empty GroupBy expressions.\n+SELECT udf(COUNT(1)) FROM testData WHERE false;\n+SELECT 1 FROM (SELECT udf(COUNT(1)) FROM testData WHERE false) t;\n+\n+-- Aggregate with empty GroupBy expressions and filter on top\n+SELECT 1 from (\n+  SELECT 1 AS z,\n+  udf(MIN(a.x))\n+  FROM (select 1 as x) a\n+  WHERE false\n+) b\n+where b.z != b.z;\n+\n+-- SPARK-24369 multiple distinct aggregations having the same argument set\n+SELECT corr(DISTINCT x, y), udf(corr(DISTINCT y, x)), count(*)\n+  FROM (VALUES (1, 1), (2, 2), (2, 2)) t(x, y);\n+\n+-- SPARK-25708 HAVING without GROUP BY means global aggregate\n+SELECT udf(1) FROM range(10) HAVING true;\n+\n+SELECT udf(udf(1)) FROM range(10) HAVING MAX(id) > 0;\n+\n+SELECT udf(id) FROM range(10) HAVING id > 0;\n+\n+-- Test data\n+CREATE OR REPLACE TEMPORARY VIEW test_agg AS SELECT * FROM VALUES\n+  (1, true), (1, false),\n+  (2, true),\n+  (3, false), (3, null),\n+  (4, null), (4, null),\n+  (5, null), (5, true), (5, false) AS test_agg(k, v);\n+\n+-- empty table\n+SELECT udf(every(v)), udf(some(v)), any(v) FROM test_agg WHERE 1 = 0;\n+\n+-- all null values\n+SELECT udf(every(v)), some(v), any(v) FROM test_agg WHERE k = 4;"
  }],
  "prId": 25098
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "This one seems not having an udf.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-18T04:16:33Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT CAST(udf(a) as int), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY 1;"
  }],
  "prId": 25098
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "we could test `udf(COUNT(udf(b)))` combination too.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-18T04:17:09Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT CAST(udf(a) as int), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;"
  }],
  "prId": 25098
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would focus on adding udfs in `GROUP BY` clause because this test targets to test `GROUP BY` basically.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-18T04:18:19Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT CAST(udf(a) as int), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT CAST(udf(a + b) as INT), udf(COUNT(b)) FROM testData GROUP BY a + b;"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Ah, right. It had to be a grouped aggregate udf. Okay! Let's don't add them here for now then.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-18T10:39:26Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT CAST(udf(a) as int), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(b)) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT CAST(udf(a + b) as INT), udf(COUNT(b)) FROM testData GROUP BY a + b;"
  }],
  "prId": 25098
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Doesn't we want to comment out this query before the issue is fixed?\r\n",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-19T15:24:45Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(udf(b))) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY udf(1);\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- [SPARK-28445] Inconsistency between Scala and Python/Panda udfs when groupby with udf() is used\n+-- Using  SELECT udf(a + 1) + 1, udf(COUNT(b)) FROM testData GROUP BY udf(a + 1) is not an option.\n+-- It will make Scala UDF work, but Python and Pandas udfs will fail with an AnalysisException.\n+-- The above should be added after SPARK-28445.\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY udf(a + 1);"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "And, let's change it to\r\n\r\n```sql\r\nSELECT udf(a + 1), udf(COUNT(b)) FROM testData GROUP BY udf(a + 1);\r\n```\r\n\r\nas @viirya pointed out.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-20T06:14:43Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(udf(b))) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY udf(1);\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- [SPARK-28445] Inconsistency between Scala and Python/Panda udfs when groupby with udf() is used\n+-- Using  SELECT udf(a + 1) + 1, udf(COUNT(b)) FROM testData GROUP BY udf(a + 1) is not an option.\n+-- It will make Scala UDF work, but Python and Pandas udfs will fail with an AnalysisException.\n+-- The above should be added after SPARK-28445.\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY udf(a + 1);"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "If the problem is that `git diff --no-index` isn't pretty,\r\n\r\n1. run without commenting this\r\n2. save the diff by `git diff --no-index`\r\n3. manually remove the diff related to this query\r\n4. update PR description\r\n5. rerun the test after commenting this query back\r\n6. push it to this PR.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-20T06:18:36Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(udf(b))) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY udf(1);\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- [SPARK-28445] Inconsistency between Scala and Python/Panda udfs when groupby with udf() is used\n+-- Using  SELECT udf(a + 1) + 1, udf(COUNT(b)) FROM testData GROUP BY udf(a + 1) is not an option.\n+-- It will make Scala UDF work, but Python and Pandas udfs will fail with an AnalysisException.\n+-- The above should be added after SPARK-28445.\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY udf(a + 1);"
  }, {
    "author": {
      "login": "skonto"
    },
    "body": "Ok I will do the above.",
    "commit": "9dc5aa12cfd0783fb75876611bad4bb054a6d819",
    "createdAt": "2019-07-22T00:15:36Z",
    "diffHunk": "@@ -0,0 +1,161 @@\n+-- This test file was converted from group-by.sql.\n+-- Test data.\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b);\n+\n+-- Aggregate with empty GroupBy expressions.\n+SELECT udf(a), udf(COUNT(b)) FROM testData;\n+SELECT COUNT(udf(a)), udf(COUNT(b)) FROM testData;\n+\n+-- Aggregate with non-empty GroupBy expressions.\n+SELECT udf(a), COUNT(udf(b)) FROM testData GROUP BY a;\n+SELECT udf(a), udf(COUNT(udf(b))) FROM testData GROUP BY b;\n+SELECT COUNT(udf(a)), COUNT(udf(b)) FROM testData GROUP BY udf(a);\n+\n+-- Aggregate grouped by literals.\n+SELECT 'foo', COUNT(udf(a)) FROM testData GROUP BY 1;\n+\n+-- Aggregate grouped by literals (whole stage code generation).\n+SELECT 'foo' FROM testData WHERE a = 0 GROUP BY udf(1);\n+\n+-- Aggregate grouped by literals (hash aggregate).\n+SELECT 'foo', udf(APPROX_COUNT_DISTINCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate grouped by literals (sort aggregate).\n+SELECT 'foo', MAX(STRUCT(udf(a))) FROM testData WHERE a = 0 GROUP BY 1;\n+\n+-- Aggregate with complex GroupBy expressions.\n+SELECT udf(a + b), udf(COUNT(b)) FROM testData GROUP BY a + b;\n+SELECT udf(a + 2), udf(COUNT(b)) FROM testData GROUP BY a + 1;\n+\n+-- [SPARK-28445] Inconsistency between Scala and Python/Panda udfs when groupby with udf() is used\n+-- Using  SELECT udf(a + 1) + 1, udf(COUNT(b)) FROM testData GROUP BY udf(a + 1) is not an option.\n+-- It will make Scala UDF work, but Python and Pandas udfs will fail with an AnalysisException.\n+-- The above should be added after SPARK-28445.\n+SELECT udf(a + 1 + 1), udf(COUNT(b)) FROM testData GROUP BY udf(a + 1);"
  }],
  "prId": 25098
}]