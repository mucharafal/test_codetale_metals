[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "let's explicitly test UDF here instead of `*`.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T04:26:49Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Done.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T21:10:50Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;"
  }],
  "prId": 25124
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think `values (\"one\", udf(1))` is not allowed as of SPARK-28291. We can add that test here, and comment them with linking `SPARK-28291` JIRA. ",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T04:28:09Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);",
    "line": 12
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "See `udf-aggregates_part1.sql` to  check how I commented them.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T04:28:29Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);",
    "line": 12
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "I added a comment at the top of the file.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T20:34:46Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);",
    "line": 12
  }],
  "prId": 25124
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would test `udf(udf(a))` too",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T04:28:57Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);\n+\n+-- single column multiple rows\n+select udf(a) from values 1, 2, 3 as data(a);\n+\n+-- three rows\n+select udf(a), b from values (\"one\", 1), (\"two\", 2), (\"three\", null) as data(a, b);\n+\n+-- null type\n+select udf(a), b from values (\"one\", null), (\"two\", null) as data(a, b);\n+\n+-- int and long coercion\n+select udf(a), b from values (\"one\", 1), (\"two\", 2L) as data(a, b);\n+\n+-- foldable expressions\n+select udf(a), udf(b) from values (\"one\", 1 + 0), (\"two\", 1 + 3L) as data(a, b);"
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Done.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T20:38:13Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);\n+\n+-- single column multiple rows\n+select udf(a) from values 1, 2, 3 as data(a);\n+\n+-- three rows\n+select udf(a), b from values (\"one\", 1), (\"two\", 2), (\"three\", null) as data(a, b);\n+\n+-- null type\n+select udf(a), b from values (\"one\", null), (\"two\", null) as data(a, b);\n+\n+-- int and long coercion\n+select udf(a), b from values (\"one\", 1), (\"two\", 2L) as data(a, b);\n+\n+-- foldable expressions\n+select udf(a), udf(b) from values (\"one\", 1 + 0), (\"two\", 1 + 3L) as data(a, b);"
  }],
  "prId": 25124
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Let's add udf in all tests. Otherwise, it just duplicates the original file.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T04:29:22Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);\n+\n+-- single column multiple rows\n+select udf(a) from values 1, 2, 3 as data(a);\n+\n+-- three rows\n+select udf(a), b from values (\"one\", 1), (\"two\", 2), (\"three\", null) as data(a, b);\n+\n+-- null type\n+select udf(a), b from values (\"one\", null), (\"two\", null) as data(a, b);\n+\n+-- int and long coercion\n+select udf(a), b from values (\"one\", 1), (\"two\", 2L) as data(a, b);\n+\n+-- foldable expressions\n+select udf(a), udf(b) from values (\"one\", 1 + 0), (\"two\", 1 + 3L) as data(a, b);\n+\n+-- complex types\n+select udf(a), b from values (\"one\", array(0, 1)), (\"two\", array(2, 3)) as data(a, b);\n+\n+-- decimal and double coercion\n+select udf(a), b from values (\"one\", 2.0), (\"two\", 3.0D) as data(a, b);\n+\n+-- error reporting: nondeterministic function rand\n+select udf(a), b from values (\"one\", rand(5)), (\"two\", 3.0D) as data(a, b);\n+\n+-- error reporting: different number of columns\n+select udf(a), udf(b) from values (\"one\", 2.0), (\"two\") as data(a, b);\n+\n+-- error reporting: types that are incompatible\n+select udf(a), udf(b) from values (\"one\", array(0, 1)), (\"two\", struct(1, 2)) as data(a, b);\n+\n+-- error reporting: number aliases different from number data values\n+select udf(a), udf(b) from values (\"one\"), (\"two\") as data(a, b);\n+\n+-- error reporting: unresolved expression\n+select udf(a), udf(b) from values (\"one\", random_not_exist_func(1)), (\"two\", 2) as data(a, b);\n+\n+-- error reporting: aggregate expression\n+select udf(a), udf(b) from values (\"one\", count(1)), (\"two\", 2) as data(a, b);\n+\n+-- string to timestamp",
    "line": 53
  }, {
    "author": {
      "login": "imback82"
    },
    "body": "Changed to `udf(a), b` since `b` is an array type.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-18T20:50:57Z",
    "diffHunk": "@@ -0,0 +1,54 @@\n+-- This test file was converted from intersect-all.sql.\n+-- Note that currently registered UDF returns a string. So there are some differences, for instance\n+-- in string cast within UDF in Scala and Python.\n+\n+-- single row, without table and column alias\n+select * from values (\"one\", 1);\n+\n+-- single row, without column alias\n+select * from values (\"one\", 1) as data;\n+\n+-- single row\n+select udf(a), b from values (\"one\", 1) as data(a, b);\n+\n+-- single column multiple rows\n+select udf(a) from values 1, 2, 3 as data(a);\n+\n+-- three rows\n+select udf(a), b from values (\"one\", 1), (\"two\", 2), (\"three\", null) as data(a, b);\n+\n+-- null type\n+select udf(a), b from values (\"one\", null), (\"two\", null) as data(a, b);\n+\n+-- int and long coercion\n+select udf(a), b from values (\"one\", 1), (\"two\", 2L) as data(a, b);\n+\n+-- foldable expressions\n+select udf(a), udf(b) from values (\"one\", 1 + 0), (\"two\", 1 + 3L) as data(a, b);\n+\n+-- complex types\n+select udf(a), b from values (\"one\", array(0, 1)), (\"two\", array(2, 3)) as data(a, b);\n+\n+-- decimal and double coercion\n+select udf(a), b from values (\"one\", 2.0), (\"two\", 3.0D) as data(a, b);\n+\n+-- error reporting: nondeterministic function rand\n+select udf(a), b from values (\"one\", rand(5)), (\"two\", 3.0D) as data(a, b);\n+\n+-- error reporting: different number of columns\n+select udf(a), udf(b) from values (\"one\", 2.0), (\"two\") as data(a, b);\n+\n+-- error reporting: types that are incompatible\n+select udf(a), udf(b) from values (\"one\", array(0, 1)), (\"two\", struct(1, 2)) as data(a, b);\n+\n+-- error reporting: number aliases different from number data values\n+select udf(a), udf(b) from values (\"one\"), (\"two\") as data(a, b);\n+\n+-- error reporting: unresolved expression\n+select udf(a), udf(b) from values (\"one\", random_not_exist_func(1)), (\"two\", 2) as data(a, b);\n+\n+-- error reporting: aggregate expression\n+select udf(a), udf(b) from values (\"one\", count(1)), (\"two\", 2) as data(a, b);\n+\n+-- string to timestamp",
    "line": 53
  }],
  "prId": 25124
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@imback82, can we add a todo that says we should add UDFs in VALUES clause when SPARK-28291 is resolved? It's kind of sad because I actually intended to test such cases here.",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-19T11:45:52Z",
    "diffHunk": "@@ -0,0 +1,53 @@\n+-- This test file was converted from inline-table.sql.\n+-- [SPARK-28291] UDFs cannot be evaluated within inline table definition",
    "line": 2
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "e.g.:\r\n\r\n```\r\n-- TODO: we should ...\r\n```",
    "commit": "1ba0886b8d2928252efba4c09da816c72c1e8657",
    "createdAt": "2019-07-19T11:46:32Z",
    "diffHunk": "@@ -0,0 +1,53 @@\n+-- This test file was converted from inline-table.sql.\n+-- [SPARK-28291] UDFs cannot be evaluated within inline table definition",
    "line": 2
  }],
  "prId": 25124
}]