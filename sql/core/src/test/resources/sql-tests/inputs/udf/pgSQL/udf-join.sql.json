[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@huaxingao, seems this file almost added `udf(...)` once for every possibility. Can we use other combinations in general? For instance,\r\n\r\n```\r\nudf(...)\r\nudf(udf(...))\r\n```\r\n\r\nor \r\n\r\n```\r\non (udf(...) = ...)\r\non (... = udf(...))\r\non (udf(...) = udf(udf(...)))\r\n\r\n```",
    "commit": "4392745e379a2f389f366af7d4edb85d1dd4032e",
    "createdAt": "2019-08-12T04:44:03Z",
    "diffHunk": "@@ -0,0 +1,2081 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+-- This test file was converted from pgSQL/join.sql.\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t)",
    "line": 78
  }],
  "prId": 25371
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "The purpose of this test, looks like, is to use constants as join key, so I think we should not rewrite `2` to `udf(2)`?",
    "commit": "4392745e379a2f389f366af7d4edb85d1dd4032e",
    "createdAt": "2019-08-18T04:25:07Z",
    "diffHunk": "@@ -0,0 +1,2081 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+-- This test file was converted from pgSQL/join.sql.\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t)\n+  FROM J1_TBL AS tx;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(i)), udf(j), udf(t)\n+  FROM J1_TBL tx;\n+\n+SELECT udf('') AS `xxx`, a, udf(udf(b)), c\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), udf(b), udf(udf(c))\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), b, udf(c), udf(d), e\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT udf('') AS `xxx`, udf(i), udf(k), udf(t)\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT udf('') AS `xxx`, udf(t1.i), udf(k), udf(t)\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(ii)), udf(udf(tt)), udf(udf(kk))\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT udf('') AS `xxx`, udf(udf(j1_tbl.i)), udf(j), udf(t), udf(a.i), udf(a.k), udf(b.i),  udf(b.k)\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY udf(udf(a)), udf(d);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT udf('') AS `xxx`, udf(udf(udf(a))), udf(b), udf(c), udf(d)\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT udf('') AS `xxx`, udf(udf(a)), udf(udf(b)), udf(udf(c)), udf(udf(udf(d)))\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT udf('') AS `xxx`, udf(J1_TBL.i), udf(udf(J1_TBL.j)), udf(J1_TBL.t), udf(J2_TBL.i), udf(J2_TBL.k)\n+  FROM J1_TBL JOIN J2_TBL ON (udf(J1_TBL.i) = J2_TBL.i);\n+\n+SELECT udf('') AS `xxx`, udf(udf(J1_TBL.i)), udf(udf(J1_TBL.j)), udf(udf(J1_TBL.t)), J2_TBL.i, J2_TBL.k\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = udf(J2_TBL.k));\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT udf('') AS `xxx`, udf(J1_TBL.i), udf(J1_TBL.j), udf(J1_TBL.t), udf(J2_TBL.i), udf(J2_TBL.k)\n+  FROM J1_TBL JOIN J2_TBL ON (udf(J1_TBL.i) <= udf(udf(J2_TBL.k)));\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY udf(i), udf(udf(k)), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(udf(i)), udf(j), udf(t), udf(k)\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(udf(j)), udf(t), udf(k)\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(udf(t)), udf(k)\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), t, udf(udf(k))\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(udf(t));\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(udf(k))\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (udf(k) = 1);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (udf(udf(i)) = udf(1));\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT udf(name) as name, t2.n FROM t2) as s2\n+INNER JOIN\n+(SELECT udf(udf(name)) as name, t3.n FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, t2.n FROM t2) as s2\n+LEFT JOIN\n+(SELECT udf(name) as name, t3.n FROM t3) s3\n+USING (name);\n+\n+SELECT udf(name), udf(udf(s2.n)), udf(s3.n) FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, udf(n) as s2_n, udf(2) as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT udf(name) as name, udf(udf(n)) as s3_n, udf(3) as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(udf(n)) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT udf(udf(name)) as name, udf(n) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(n) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT udf(udf(name)) as name, udf(udf(n)) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, udf(n) as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT udf(name) as name, udf(n) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT udf(udf(udf(name))) as name, udf(n) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(n) as s1_n, udf(udf(1)) as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT udf(name) as name, udf(udf(n)) as s2_n, udf(2) as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT udf(udf(name)) as name, udf(n) as s3_n, udf(3) as s3_2 FROM t3) s3;\n+\n+SELECT name, udf(udf(s1_n)), udf(s2_n), udf(s3_n) FROM\n+(SELECT name, udf(udf(n)) as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, udf(n) as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, udf(udf(n)) as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, udf(udf(n)) as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, udf(n) as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT s1.name, udf(s1_n), s2.name, udf(udf(s2_n)) FROM\n+  (SELECT name, udf(n) as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, udf(2) as s2_n FROM t2) as s2"
  }],
  "prId": 25371
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This is from join.sql, but looks it is pgsql specific stuff? Does it make sense to keep it? @HyukjinKwon ",
    "commit": "4392745e379a2f389f366af7d4edb85d1dd4032e",
    "createdAt": "2019-08-18T04:29:35Z",
    "diffHunk": "@@ -0,0 +1,2081 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+-- This test file was converted from pgSQL/join.sql.\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t)\n+  FROM J1_TBL AS tx;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(i)), udf(j), udf(t)\n+  FROM J1_TBL tx;\n+\n+SELECT udf('') AS `xxx`, a, udf(udf(b)), c\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), udf(b), udf(udf(c))\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), b, udf(c), udf(d), e\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT udf('') AS `xxx`, udf(i), udf(k), udf(t)\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT udf('') AS `xxx`, udf(t1.i), udf(k), udf(t)\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(ii)), udf(udf(tt)), udf(udf(kk))\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT udf('') AS `xxx`, udf(udf(j1_tbl.i)), udf(j), udf(t), udf(a.i), udf(a.k), udf(b.i),  udf(b.k)\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY udf(udf(a)), udf(d);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT udf('') AS `xxx`, udf(udf(udf(a))), udf(b), udf(c), udf(d)\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT udf('') AS `xxx`, udf(udf(a)), udf(udf(b)), udf(udf(c)), udf(udf(udf(d)))\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT udf('') AS `xxx`, udf(J1_TBL.i), udf(udf(J1_TBL.j)), udf(J1_TBL.t), udf(J2_TBL.i), udf(J2_TBL.k)\n+  FROM J1_TBL JOIN J2_TBL ON (udf(J1_TBL.i) = J2_TBL.i);\n+\n+SELECT udf('') AS `xxx`, udf(udf(J1_TBL.i)), udf(udf(J1_TBL.j)), udf(udf(J1_TBL.t)), J2_TBL.i, J2_TBL.k\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = udf(J2_TBL.k));\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT udf('') AS `xxx`, udf(J1_TBL.i), udf(J1_TBL.j), udf(J1_TBL.t), udf(J2_TBL.i), udf(J2_TBL.k)\n+  FROM J1_TBL JOIN J2_TBL ON (udf(J1_TBL.i) <= udf(udf(J2_TBL.k)));\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY udf(i), udf(udf(k)), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(udf(i)), udf(j), udf(t), udf(k)\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(udf(j)), udf(t), udf(k)\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(udf(t)), udf(k)\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), t, udf(udf(k))\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(udf(t));\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(udf(k))\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (udf(k) = 1);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (udf(udf(i)) = udf(1));\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT udf(name) as name, t2.n FROM t2) as s2\n+INNER JOIN\n+(SELECT udf(udf(name)) as name, t3.n FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, t2.n FROM t2) as s2\n+LEFT JOIN\n+(SELECT udf(name) as name, t3.n FROM t3) s3\n+USING (name);\n+\n+SELECT udf(name), udf(udf(s2.n)), udf(s3.n) FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, udf(n) as s2_n, udf(2) as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT udf(name) as name, udf(udf(n)) as s3_n, udf(3) as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(udf(n)) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT udf(udf(name)) as name, udf(n) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(n) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT udf(udf(name)) as name, udf(udf(n)) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, udf(n) as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT udf(name) as name, udf(n) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT udf(udf(udf(name))) as name, udf(n) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(n) as s1_n, udf(udf(1)) as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT udf(name) as name, udf(udf(n)) as s2_n, udf(2) as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT udf(udf(name)) as name, udf(n) as s3_n, udf(3) as s3_2 FROM t3) s3;\n+\n+SELECT name, udf(udf(s1_n)), udf(s2_n), udf(s3_n) FROM\n+(SELECT name, udf(udf(n)) as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, udf(n) as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, udf(udf(n)) as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, udf(udf(n)) as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, udf(n) as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT s1.name, udf(s1_n), s2.name, udf(udf(s2_n)) FROM\n+  (SELECT name, udf(n) as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, udf(2) as s2_n FROM t2) as s2\n+ON (udf(udf(s1_n)) = udf(s2_n));\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select udf(udf(x1)), udf(x2) from x;\n+select udf(y1), udf(udf(y2)) from y;\n+\n+select * from x left join y on (udf(x1) = udf(udf(y1)) and udf(x2) is not null);\n+select * from x left join y on (udf(udf(x1)) = udf(y1) and udf(y2) is not null);\n+\n+select * from (x left join y on (udf(x1) = udf(udf(y1)))) left join x xx(xx1,xx2)\n+on (udf(udf(x1)) = udf(xx1));\n+select * from (x left join y on (udf(x1) = udf(y1))) left join x xx(xx1,xx2)\n+on (udf(x1) = xx1 and udf(x2) is not null);\n+select * from (x left join y on (x1 = udf(y1))) left join x xx(xx1,xx2)\n+on (udf(x1) = udf(udf(xx1)) and udf(y2) is not null);\n+select * from (x left join y on (udf(x1) = y1)) left join x xx(xx1,xx2)\n+on (udf(udf(x1)) = udf(xx1) and udf(udf(xx2)) is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (udf(udf(x1)) = udf(udf(y1)))) left join x xx(xx1,xx2)\n+on (udf(x1) = udf(xx1)) where (udf(x2) is not null);\n+select * from (x left join y on (udf(x1) = udf(y1))) left join x xx(xx1,xx2)\n+on (udf(x1) = xx1) where (udf(y2) is not null);\n+select * from (x left join y on (udf(x1) = udf(y1))) left join x xx(xx1,xx2)\n+on (x1 = udf(xx1)) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select udf(udf(count(*))) from tenk1 a where udf(udf(unique1)) in\n+  (select udf(unique1) from tenk1 b join tenk1 c using (unique1)\n+   where udf(udf(b.unique2)) = udf(42));\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select udf(count(*)) from tenk1 x where\n+  udf(x.unique1) in (select udf(a.f1) from int4_tbl a,float8_tbl b where udf(udf(a.f1))=b.f1) and\n+  udf(x.unique1) = 0 and\n+  udf(x.unique1) in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=udf(udf(bb.f1)));\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select udf(udf(count(*))) from tenk1 x where\n+  udf(x.unique1) in (select udf(a.f1) from int4_tbl a,float8_tbl b where udf(udf(a.f1))=b.f1) and\n+  udf(x.unique1) = 0 and\n+  udf(udf(x.unique1)) in (select udf(aa.f1) from int4_tbl aa,float8_tbl bb where udf(aa.f1)=udf(udf(bb.f1)));\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select udf(123) as x) ss on udf(udf(i2.q1)) = udf(x)) on udf(udf(i1.q2)) = udf(udf(i2.q2))\n+order by udf(udf(1)), 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select udf(count(*))\n+from\n+  (select udf(t3.tenthous) as x1, udf(coalesce(udf(t1.stringu1), udf(t2.stringu1))) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on udf(t1.unique1) = udf(t2.unique1)\n+   join tenk1 t3 on t1.unique2 = udf(t3.unique2)) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where udf(t4.thousand) = udf(t5.unique1) and udf(udf(ss.x1)) = t4.tenthous and udf(ss.x2) = udf(udf(t5.stringu1));\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select udf(a.f1), udf(b.f1), udf(t.thousand), udf(t.tenthous) from\n+  tenk1 t,\n+  (select udf(udf(sum(udf(f1))+1)) as f1 from int4_tbl i4a) a,\n+  (select udf(sum(udf(f1))) as f1 from int4_tbl i4b) b\n+where b.f1 = udf(t.thousand) and udf(a.f1) = udf(b.f1) and udf((udf(a.f1)+udf(b.f1)+999)) = udf(udf(t.tenthous));\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by udf(udf(j2_tbl.i)) desc, udf(j2_tbl.k) asc) j2_tbl\n+  on udf(j1_tbl.i) = udf(j2_tbl.i) and udf(j1_tbl.i) = udf(j2_tbl.k);\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select udf(count(*)) from\n+  (select * from tenk1 x order by udf(x.thousand), udf(udf(x.twothousand)), x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by udf(y.unique2)) y\n+  on udf(x.thousand) = y.unique2 and x.twothousand = udf(y.hundred) and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on udf(udf(tt1.joincol)) = udf(tt2.joincol);\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on udf(udf(tt1.joincol)) = udf(udf(tt2.joincol));\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select udf(count(*)) from tenk1 a, tenk1 b\n+  where udf(a.hundred) = b.thousand and udf(udf((b.fivethous % 10)) < 10);\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+DROP TABLE IF EXISTS tt3;\n+CREATE TABLE tt3(f1 int, f2 string) USING parquet;\n+INSERT INTO tt3 SELECT x.id, repeat('xyzzy', 100) FROM range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+DROP TABLE IF EXISTS tt4;\n+CREATE TABLE tt4(f1 int) USING parquet;\n+INSERT INTO tt4 VALUES (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT udf(udf(a.f1)) as f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON udf(b.f1) = udf(c.f1)\n+        WHERE udf(c.f1) IS NULL\n+) AS d ON udf(a.f1) = d.f1\n+WHERE udf(udf(d.f1)) IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where udf(tt5.f1) = udf(tt6.f1) and udf(tt5.f1) = udf(udf(tt5.f2) - udf(tt6.f2));\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select udf(udf(yy.pkyy)) as yy_pkyy, udf(yy.pkxx) as yy_pkxx, udf(yya.pkyy) as yya_pkyy,\n+       udf(xxa.pkxx) as xxa_pkxx, udf(xxb.pkxx) as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON udf(yy.pkyy) = udf(yya.pkyy)\n+     left join xx xxa on udf(yya.pkxx) = udf(udf(xxa.pkxx))\n+     left join xx xxb on udf(udf(coalesce (xxa.pkxx, 1))) = udf(xxb.pkxx);\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (udf(f2) = udf(udf(f3)))\n+      left join zt1 on (udf(udf(f3)) = udf(f1))\n+where udf(f2) = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = udf(f3))\n+      left join zv1 on (udf(f3) = f1)\n+where udf(f2) = udf(53);\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select udf(a.unique2), udf(a.ten), udf(b.tenthous), udf(b.unique2), udf(b.hundred)\n+from tenk1 a left join tenk1 b on a.unique2 = udf(b.tenthous)\n+where udf(a.unique1) = 42 and\n+      ((udf(b.unique2) is null and udf(a.ten) = 2) or udf(udf(b.hundred)) = udf(udf(3)));\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on udf(i) = x and i = udf(y) and udf(x) = udf(i);\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select udf(t1.q2), udf(count(t2.*))\n+from int8_tbl t1 left join int8_tbl t2 on (udf(udf(t1.q2)) = t2.q1)\n+group by udf(t1.q2) order by 1;\n+\n+select udf(udf(t1.q2)), udf(count(t2.*))\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (udf(udf(t1.q2)) = udf(t2.q1))\n+group by udf(udf(t1.q2)) order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select udf(t1.q2) as q2, udf(udf(count(t2.*)))\n+from int8_tbl t1 left join\n+  (select udf(q1) as q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (udf(t1.q2) = udf(t2.q1))\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select udf(c.name), udf(ss.code), udf(ss.b_cnt), udf(ss.const)\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select udf(count(1)) as cnt, b.a as a from b group by b.a) as b_grp\n+     on udf(a.code) = udf(udf(b_grp.a))\n+  ) as ss\n+  on (udf(udf(c.a)) = udf(ss.code))\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT udf(sub5.key5) as key5, udf(udf(COALESCE(sub6.value1, 1))) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = udf(sub6.key6)\n+    ) sub4\n+    ON udf(sub4.key5) = sub3.key3\n+) sub2\n+ON udf(udf(sub1.key1)) = udf(udf(sub2.key3));\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT udf(sub3.key3) as key3, udf(value2), udf(COALESCE(value2, 66)) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON udf(udf(sub5.key5)) = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = udf(udf(sub2.key3));\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)",
    "line": 821
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Yea, actually there are multiple instances like that IIRC. Let's just keep it for simplicity for now (e.g., when we port some more changes or tests from PostgreSQL).",
    "commit": "4392745e379a2f389f366af7d4edb85d1dd4032e",
    "createdAt": "2019-08-18T13:34:31Z",
    "diffHunk": "@@ -0,0 +1,2081 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+-- This test file was converted from pgSQL/join.sql.\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t)\n+  FROM J1_TBL AS tx;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(i)), udf(j), udf(t)\n+  FROM J1_TBL tx;\n+\n+SELECT udf('') AS `xxx`, a, udf(udf(b)), c\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), udf(b), udf(udf(c))\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), b, udf(c), udf(d), e\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT udf('') AS `xxx`, udf(i), udf(k), udf(t)\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- resolve previous ambiguity by specifying the table name\n+SELECT udf('') AS `xxx`, udf(t1.i), udf(k), udf(t)\n+  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(ii)), udf(udf(tt)), udf(udf(kk))\n+  FROM (J1_TBL CROSS JOIN J2_TBL)\n+    AS tx (ii, jj, tt, ii2, kk);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, tx.ii, tx.jj, tx.kk\n+--   FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))\n+--     AS tx (ii, jj, tt, ii2, kk);\n+\n+SELECT udf('') AS `xxx`, udf(udf(j1_tbl.i)), udf(j), udf(t), udf(a.i), udf(a.k), udf(b.i),  udf(b.k)\n+  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;\n+\n+\n+--\n+--\n+-- Inner joins (equi-joins)\n+--\n+--\n+\n+--\n+-- Inner joins (equi-joins) with USING clause\n+-- The USING syntax changes the shape of the resulting table\n+-- by including a column in the USING clause only once in the result.\n+--\n+\n+-- Inner equi-join on specified column\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL INNER JOIN J2_TBL USING (i);\n+\n+-- Same as above, slightly different syntax\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)\n+  ORDER BY udf(udf(a)), udf(d);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)\n+--   ORDER BY b, t1.a;\n+\n+\n+--\n+-- NATURAL JOIN\n+-- Inner equi-join on all columns with the same name\n+--\n+\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL NATURAL JOIN J2_TBL;\n+\n+SELECT udf('') AS `xxx`, udf(udf(udf(a))), udf(b), udf(c), udf(d)\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);\n+\n+SELECT udf('') AS `xxx`, udf(udf(a)), udf(udf(b)), udf(udf(c)), udf(udf(udf(d)))\n+  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- mismatch number of columns\n+-- currently, Postgres will fill in with underlying names\n+-- SELECT '' AS `xxx`, *\n+--   FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);\n+\n+\n+--\n+-- Inner joins (equi-joins)\n+--\n+\n+SELECT udf('') AS `xxx`, udf(J1_TBL.i), udf(udf(J1_TBL.j)), udf(J1_TBL.t), udf(J2_TBL.i), udf(J2_TBL.k)\n+  FROM J1_TBL JOIN J2_TBL ON (udf(J1_TBL.i) = J2_TBL.i);\n+\n+SELECT udf('') AS `xxx`, udf(udf(J1_TBL.i)), udf(udf(J1_TBL.j)), udf(udf(J1_TBL.t)), J2_TBL.i, J2_TBL.k\n+  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = udf(J2_TBL.k));\n+\n+\n+--\n+-- Non-equi-joins\n+--\n+\n+SELECT udf('') AS `xxx`, udf(J1_TBL.i), udf(J1_TBL.j), udf(J1_TBL.t), udf(J2_TBL.i), udf(J2_TBL.k)\n+  FROM J1_TBL JOIN J2_TBL ON (udf(J1_TBL.i) <= udf(udf(J2_TBL.k)));\n+\n+\n+--\n+-- Outer joins\n+-- Note that OUTER is a noise word\n+--\n+\n+SELECT udf(udf('')) AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i)\n+  ORDER BY udf(i), udf(udf(k)), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(udf(i)), udf(j), udf(t), udf(k)\n+  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(udf(j)), udf(t), udf(k)\n+  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(udf(t)), udf(k)\n+  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(t);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), t, udf(udf(k))\n+  FROM J1_TBL FULL JOIN J2_TBL USING (i)\n+  ORDER BY udf(udf(i)), udf(k), udf(udf(t));\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(udf(k))\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (udf(k) = 1);\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t), udf(k)\n+  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (udf(udf(i)) = udf(1));\n+\n+--\n+-- semijoin selectivity for <>\n+--\n+-- explain (costs off)\n+-- select * from int4_tbl i4, tenk1 a\n+-- where exists(select * from tenk1 b\n+--              where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)\n+--       and i4.f1 = a.tenthous;\n+\n+\n+--\n+-- More complicated constructs\n+--\n+\n+--\n+-- Multiway full join\n+--\n+\n+CREATE TABLE t1 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t2 (name STRING, n INTEGER) USING parquet;\n+CREATE TABLE t3 (name STRING, n INTEGER) USING parquet;\n+\n+INSERT INTO t1 VALUES ( 'bb', 11 );\n+INSERT INTO t2 VALUES ( 'bb', 12 );\n+INSERT INTO t2 VALUES ( 'cc', 22 );\n+INSERT INTO t2 VALUES ( 'ee', 42 );\n+INSERT INTO t3 VALUES ( 'bb', 13 );\n+INSERT INTO t3 VALUES ( 'cc', 23 );\n+INSERT INTO t3 VALUES ( 'dd', 33 );\n+\n+SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);\n+\n+--\n+-- Test interactions of join syntax and subqueries\n+--\n+\n+-- Basic cases (we expect planner to pull up the subquery here)\n+SELECT * FROM\n+(SELECT udf(name) as name, t2.n FROM t2) as s2\n+INNER JOIN\n+(SELECT udf(udf(name)) as name, t3.n FROM t3) s3\n+USING (name);\n+\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, t2.n FROM t2) as s2\n+LEFT JOIN\n+(SELECT udf(name) as name, t3.n FROM t3) s3\n+USING (name);\n+\n+SELECT udf(name), udf(udf(s2.n)), udf(s3.n) FROM\n+(SELECT * FROM t2) as s2\n+FULL JOIN\n+(SELECT * FROM t3) s3\n+USING (name);\n+\n+-- Cases with non-nullable expressions in subquery results;\n+-- make sure these go to null as expected\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, udf(n) as s2_n, udf(2) as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT udf(name) as name, udf(udf(n)) as s3_n, udf(3) as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(udf(n)) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL LEFT JOIN\n+(SELECT udf(udf(name)) as name, udf(n) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(n) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT udf(udf(name)) as name, udf(udf(n)) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(udf(name)) as name, udf(n) as s1_n, 1 as s1_1 FROM t1) as s1\n+NATURAL INNER JOIN\n+(SELECT udf(name) as name, udf(n) as s2_n, 2 as s2_2 FROM t2) as s2\n+NATURAL INNER JOIN\n+(SELECT udf(udf(udf(name))) as name, udf(n) as s3_n, 3 as s3_2 FROM t3) s3;\n+\n+SELECT * FROM\n+(SELECT udf(name) as name, udf(n) as s1_n, udf(udf(1)) as s1_1 FROM t1) as s1\n+NATURAL FULL JOIN\n+(SELECT udf(name) as name, udf(udf(n)) as s2_n, udf(2) as s2_2 FROM t2) as s2\n+NATURAL FULL JOIN\n+(SELECT udf(udf(name)) as name, udf(n) as s3_n, udf(3) as s3_2 FROM t3) s3;\n+\n+SELECT name, udf(udf(s1_n)), udf(s2_n), udf(s3_n) FROM\n+(SELECT name, udf(udf(n)) as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, udf(n) as s2_n FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, udf(udf(n)) as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+SELECT * FROM\n+(SELECT name, n as s1_n FROM t1) as s1\n+NATURAL FULL JOIN\n+  (SELECT * FROM\n+    (SELECT name, udf(udf(n)) as s2_n, 2 as s2_2 FROM t2) as s2\n+    NATURAL FULL JOIN\n+    (SELECT name, udf(n) as s3_n FROM t3) as s3\n+  ) ss2;\n+\n+-- Constants as join keys can also be problematic\n+SELECT s1.name, udf(s1_n), s2.name, udf(udf(s2_n)) FROM\n+  (SELECT name, udf(n) as s1_n FROM t1) as s1\n+FULL JOIN\n+  (SELECT name, udf(2) as s2_n FROM t2) as s2\n+ON (udf(udf(s1_n)) = udf(s2_n));\n+\n+\n+-- Test for propagation of nullability constraints into sub-joins\n+\n+create or replace temporary view x as select * from\n+  (values (1,11), (2,22), (3,null), (4,44), (5,null))\n+  as v(x1, x2);\n+\n+create or replace temporary view y as select * from\n+  (values (1,111), (2,222), (3,333), (4,null))\n+  as v(y1, y2);\n+\n+select udf(udf(x1)), udf(x2) from x;\n+select udf(y1), udf(udf(y2)) from y;\n+\n+select * from x left join y on (udf(x1) = udf(udf(y1)) and udf(x2) is not null);\n+select * from x left join y on (udf(udf(x1)) = udf(y1) and udf(y2) is not null);\n+\n+select * from (x left join y on (udf(x1) = udf(udf(y1)))) left join x xx(xx1,xx2)\n+on (udf(udf(x1)) = udf(xx1));\n+select * from (x left join y on (udf(x1) = udf(y1))) left join x xx(xx1,xx2)\n+on (udf(x1) = xx1 and udf(x2) is not null);\n+select * from (x left join y on (x1 = udf(y1))) left join x xx(xx1,xx2)\n+on (udf(x1) = udf(udf(xx1)) and udf(y2) is not null);\n+select * from (x left join y on (udf(x1) = y1)) left join x xx(xx1,xx2)\n+on (udf(udf(x1)) = udf(xx1) and udf(udf(xx2)) is not null);\n+-- these should NOT give the same answers as above\n+select * from (x left join y on (udf(udf(x1)) = udf(udf(y1)))) left join x xx(xx1,xx2)\n+on (udf(x1) = udf(xx1)) where (udf(x2) is not null);\n+select * from (x left join y on (udf(x1) = udf(y1))) left join x xx(xx1,xx2)\n+on (udf(x1) = xx1) where (udf(y2) is not null);\n+select * from (x left join y on (udf(x1) = udf(y1))) left join x xx(xx1,xx2)\n+on (x1 = udf(xx1)) where (xx2 is not null);\n+\n+--\n+-- regression test: check for bug with propagation of implied equality\n+-- to outside an IN\n+--\n+select udf(udf(count(*))) from tenk1 a where udf(udf(unique1)) in\n+  (select udf(unique1) from tenk1 b join tenk1 c using (unique1)\n+   where udf(udf(b.unique2)) = udf(42));\n+\n+--\n+-- regression test: check for failure to generate a plan with multiple\n+-- degenerate IN clauses\n+--\n+select udf(count(*)) from tenk1 x where\n+  udf(x.unique1) in (select udf(a.f1) from int4_tbl a,float8_tbl b where udf(udf(a.f1))=b.f1) and\n+  udf(x.unique1) = 0 and\n+  udf(x.unique1) in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=udf(udf(bb.f1)));\n+\n+-- try that with GEQO too\n+-- begin;\n+-- set geqo = on;\n+-- set geqo_threshold = 2;\n+select udf(udf(count(*))) from tenk1 x where\n+  udf(x.unique1) in (select udf(a.f1) from int4_tbl a,float8_tbl b where udf(udf(a.f1))=b.f1) and\n+  udf(x.unique1) = 0 and\n+  udf(udf(x.unique1)) in (select udf(aa.f1) from int4_tbl aa,float8_tbl bb where udf(aa.f1)=udf(udf(bb.f1)));\n+-- rollback;\n+\n+-- Skip this test because table b inherits from table a and we do not support this feature, see inherits.sql\n+--\n+-- regression test: be sure we cope with proven-dummy append rels\n+--\n+-- explain (costs off)\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+-- select aa, bb, unique1, unique1\n+--   from tenk1 right join b on aa = unique1\n+--   where bb < bb and bb is null;\n+\n+--\n+-- regression test: check handling of empty-FROM subquery underneath outer join\n+--\n+-- explain (costs off)\n+-- select * from int8_tbl i1 left join (int8_tbl i2 join\n+--   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2\n+-- order by 1, 2;\n+\n+select * from int8_tbl i1 left join (int8_tbl i2 join\n+  (select udf(123) as x) ss on udf(udf(i2.q1)) = udf(x)) on udf(udf(i1.q2)) = udf(udf(i2.q2))\n+order by udf(udf(1)), 2;\n+\n+--\n+-- regression test: check a case where join_clause_is_movable_into() gives\n+-- an imprecise result, causing an assertion failure\n+--\n+select udf(count(*))\n+from\n+  (select udf(t3.tenthous) as x1, udf(coalesce(udf(t1.stringu1), udf(t2.stringu1))) as x2\n+   from tenk1 t1\n+   left join tenk1 t2 on udf(t1.unique1) = udf(t2.unique1)\n+   join tenk1 t3 on t1.unique2 = udf(t3.unique2)) ss,\n+  tenk1 t4,\n+  tenk1 t5\n+where udf(t4.thousand) = udf(t5.unique1) and udf(udf(ss.x1)) = t4.tenthous and udf(ss.x2) = udf(udf(t5.stringu1));\n+\n+--\n+-- regression test: check a case where we formerly missed including an EC\n+-- enforcement clause because it was expected to be handled at scan level\n+--\n+-- explain (costs off)\n+-- select a.f1, b.f1, t.thousand, t.tenthous from\n+--   tenk1 t,\n+--   (select sum(f1)+1 as f1 from int4_tbl i4a) a,\n+--   (select sum(f1) as f1 from int4_tbl i4b) b\n+-- where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;\n+\n+select udf(a.f1), udf(b.f1), udf(t.thousand), udf(t.tenthous) from\n+  tenk1 t,\n+  (select udf(udf(sum(udf(f1))+1)) as f1 from int4_tbl i4a) a,\n+  (select udf(sum(udf(f1))) as f1 from int4_tbl i4b) b\n+where b.f1 = udf(t.thousand) and udf(a.f1) = udf(b.f1) and udf((udf(a.f1)+udf(b.f1)+999)) = udf(udf(t.tenthous));\n+\n+--\n+-- check a case where we formerly got confused by conflicting sort orders\n+-- in redundant merge join path keys\n+--\n+-- explain (costs off)\n+-- select * from\n+--   j1_tbl full join\n+--   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl\n+--   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;\n+\n+select * from\n+  j1_tbl full join\n+  (select * from j2_tbl order by udf(udf(j2_tbl.i)) desc, udf(j2_tbl.k) asc) j2_tbl\n+  on udf(j1_tbl.i) = udf(j2_tbl.i) and udf(j1_tbl.i) = udf(j2_tbl.k);\n+\n+--\n+-- a different check for handling of redundant sort keys in merge joins\n+--\n+-- explain (costs off)\n+-- select count(*) from\n+--   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x\n+--   left join\n+--   (select * from tenk1 y order by y.unique2) y\n+--   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;\n+\n+select udf(count(*)) from\n+  (select * from tenk1 x order by udf(x.thousand), udf(udf(x.twothousand)), x.fivethous) x\n+  left join\n+  (select * from tenk1 y order by udf(y.unique2)) y\n+  on udf(x.thousand) = y.unique2 and x.twothousand = udf(y.hundred) and x.fivethous = y.unique2;\n+\n+\n+--\n+-- Clean up\n+--\n+\n+DROP TABLE t1;\n+DROP TABLE t2;\n+DROP TABLE t3;\n+\n+DROP TABLE J1_TBL;\n+DROP TABLE J2_TBL;\n+\n+-- Both DELETE and UPDATE allow the specification of additional tables\n+-- to \"join\" against to determine which rows should be modified.\n+\n+-- CREATE TEMP TABLE t1 (a int, b int);\n+-- CREATE TEMP TABLE t2 (a int, b int);\n+-- CREATE TEMP TABLE t3 (x int, y int);\n+\n+-- INSERT INTO t1 VALUES (5, 10);\n+-- INSERT INTO t1 VALUES (15, 20);\n+-- INSERT INTO t1 VALUES (100, 100);\n+-- INSERT INTO t1 VALUES (200, 1000);\n+-- INSERT INTO t2 VALUES (200, 2000);\n+-- INSERT INTO t3 VALUES (5, 20);\n+-- INSERT INTO t3 VALUES (6, 7);\n+-- INSERT INTO t3 VALUES (7, 8);\n+-- INSERT INTO t3 VALUES (500, 100);\n+\n+-- DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;\n+-- SELECT * FROM t3;\n+-- DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;\n+-- SELECT * FROM t3;\n+\n+-- Test join against inheritance tree\n+\n+-- create temp table t2a () inherits (t2);\n+\n+-- insert into t2a values (200, 2001);\n+\n+-- select * from t1 left join t2 on (t1.a = t2.a);\n+\n+-- Test matching of column name with wrong alias\n+\n+-- select t1.x from t1 join t3 on (t1.a = t3.x);\n+\n+--\n+-- regression test for 8.1 merge right join bug\n+--\n+\n+create or replace temporary view tt1 as select * from\n+  (values (1, 11), (2, NULL))\n+  as v(tt1_id, joincol);\n+\n+create or replace temporary view tt2 as select * from\n+  (values (21, 11), (22, 11))\n+  as v(tt2_id, joincol);\n+\n+-- set enable_hashjoin to off;\n+-- set enable_nestloop to off;\n+\n+-- these should give the same results\n+\n+select tt1.*, tt2.* from tt1 left join tt2 on udf(udf(tt1.joincol)) = udf(tt2.joincol);\n+\n+select tt1.*, tt2.* from tt2 right join tt1 on udf(udf(tt1.joincol)) = udf(udf(tt2.joincol));\n+\n+-- reset enable_hashjoin;\n+-- reset enable_nestloop;\n+\n+--\n+-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)\n+--\n+\n+-- set work_mem to '64kB';\n+-- set enable_mergejoin to off;\n+\n+-- explain (costs off)\n+-- select count(*) from tenk1 a, tenk1 b\n+--   where a.hundred = b.thousand and (b.fivethous % 10) < 10;\n+select udf(count(*)) from tenk1 a, tenk1 b\n+  where udf(a.hundred) = b.thousand and udf(udf((b.fivethous % 10)) < 10);\n+\n+-- reset work_mem;\n+-- reset enable_mergejoin;\n+\n+--\n+-- regression test for 8.2 bug with improper re-ordering of left joins\n+--\n+\n+DROP TABLE IF EXISTS tt3;\n+CREATE TABLE tt3(f1 int, f2 string) USING parquet;\n+INSERT INTO tt3 SELECT x.id, repeat('xyzzy', 100) FROM range(1,10001) x;\n+-- create index tt3i on tt3(f1);\n+-- analyze tt3;\n+\n+DROP TABLE IF EXISTS tt4;\n+CREATE TABLE tt4(f1 int) USING parquet;\n+INSERT INTO tt4 VALUES (0),(1),(9999);\n+-- analyze tt4;\n+\n+SELECT udf(udf(a.f1)) as f1\n+FROM tt4 a\n+LEFT JOIN (\n+        SELECT b.f1\n+        FROM tt3 b LEFT JOIN tt3 c ON udf(b.f1) = udf(c.f1)\n+        WHERE udf(c.f1) IS NULL\n+) AS d ON udf(a.f1) = d.f1\n+WHERE udf(udf(d.f1)) IS NULL;\n+\n+--\n+-- regression test for proper handling of outer joins within antijoins\n+--\n+\n+-- create temp table tt4x(c1 int, c2 int, c3 int);\n+\n+-- explain (costs off)\n+-- select * from tt4x t1\n+-- where not exists (\n+--   select 1 from tt4x t2\n+--     left join tt4x t3 on t2.c3 = t3.c1\n+--     left join ( select t5.c1 as c1\n+--                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1\n+--               ) a1 on t3.c2 = a1.c1\n+--   where t1.c1 = t2.c2\n+-- );\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3494\n+--\n+\n+create or replace temporary view tt5 as select * from\n+  (values (1, 10), (1, 11))\n+  as v(f1, f2);\n+create or replace temporary view tt6 as select * from\n+  (values (1, 9), (1, 2), (2, 9))\n+  as v(f1, f2);\n+\n+select * from tt5,tt6 where udf(tt5.f1) = udf(tt6.f1) and udf(tt5.f1) = udf(udf(tt5.f2) - udf(tt6.f2));\n+\n+--\n+-- regression test for problems of the sort depicted in bug #3588\n+--\n+\n+create or replace temporary view xx as select * from\n+  (values (1), (2), (3))\n+  as v(pkxx);\n+create or replace temporary view yy as select * from\n+  (values (101, 1), (201, 2), (301, NULL))\n+  as v(pkyy, pkxx);\n+\n+select udf(udf(yy.pkyy)) as yy_pkyy, udf(yy.pkxx) as yy_pkxx, udf(yya.pkyy) as yya_pkyy,\n+       udf(xxa.pkxx) as xxa_pkxx, udf(xxb.pkxx) as xxb_pkxx\n+from yy\n+     left join (SELECT * FROM yy where pkyy = 101) as yya ON udf(yy.pkyy) = udf(yya.pkyy)\n+     left join xx xxa on udf(yya.pkxx) = udf(udf(xxa.pkxx))\n+     left join xx xxb on udf(udf(coalesce (xxa.pkxx, 1))) = udf(xxb.pkxx);\n+\n+--\n+-- regression test for improper pushing of constants across outer-join clauses\n+-- (as seen in early 8.2.x releases)\n+--\n+\n+create or replace temporary view zt1 as select * from\n+  (values (53))\n+  as v(f1);\n+create or replace temporary view zt2 as select * from\n+  (values (53))\n+  as v(f2);\n+create or replace temporary view zt3(f3 int) using parquet;\n+\n+select * from\n+  zt2 left join zt3 on (udf(f2) = udf(udf(f3)))\n+      left join zt1 on (udf(udf(f3)) = udf(f1))\n+where udf(f2) = 53;\n+\n+create temp view zv1 as select *,'dummy' AS junk from zt1;\n+\n+select * from\n+  zt2 left join zt3 on (f2 = udf(f3))\n+      left join zv1 on (udf(f3) = f1)\n+where udf(f2) = udf(53);\n+\n+--\n+-- regression test for improper extraction of OR indexqual conditions\n+-- (as seen in early 8.3.x releases)\n+--\n+\n+select udf(a.unique2), udf(a.ten), udf(b.tenthous), udf(b.unique2), udf(b.hundred)\n+from tenk1 a left join tenk1 b on a.unique2 = udf(b.tenthous)\n+where udf(a.unique1) = 42 and\n+      ((udf(b.unique2) is null and udf(a.ten) = 2) or udf(udf(b.hundred)) = udf(udf(3)));\n+\n+--\n+-- test proper positioning of one-time quals in EXISTS (8.4devel bug)\n+--\n+-- prepare foo(bool) as\n+--   select count(*) from tenk1 a left join tenk1 b\n+--     on (a.unique2 = b.unique1 and exists\n+--         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));\n+-- execute foo(true);\n+-- execute foo(false);\n+\n+--\n+-- test for sane behavior with noncanonical merge clauses, per bug #4926\n+--\n+\n+-- begin;\n+\n+-- set enable_mergejoin = 1;\n+-- set enable_hashjoin = 0;\n+-- set enable_nestloop = 0;\n+\n+create or replace temporary view a (i integer) using parquet;\n+create or replace temporary view b (x integer, y integer) using parquet;\n+\n+select * from a left join b on udf(i) = x and i = udf(y) and udf(x) = udf(i);\n+\n+-- rollback;\n+\n+--\n+-- test handling of merge clauses using record_ops\n+--\n+-- begin;\n+\n+-- create type mycomptype as (id int, v bigint);\n+\n+-- create temp table tidv (idv mycomptype);\n+-- create index on tidv (idv);\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- set enable_mergejoin = 0;\n+\n+-- explain (costs off)\n+-- select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;\n+\n+-- rollback;\n+\n+--\n+-- test NULL behavior of whole-row Vars, per bug #5025\n+--\n+select udf(t1.q2), udf(count(t2.*))\n+from int8_tbl t1 left join int8_tbl t2 on (udf(udf(t1.q2)) = t2.q1)\n+group by udf(t1.q2) order by 1;\n+\n+select udf(udf(t1.q2)), udf(count(t2.*))\n+from int8_tbl t1 left join (select * from int8_tbl) t2 on (udf(udf(t1.q2)) = udf(t2.q1))\n+group by udf(udf(t1.q2)) order by 1;\n+\n+-- [SPARK-28330] Enhance query limit\n+-- select t1.q2, count(t2.*)\n+-- from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)\n+-- group by t1.q2 order by 1;\n+\n+select udf(t1.q2) as q2, udf(udf(count(t2.*)))\n+from int8_tbl t1 left join\n+  (select udf(q1) as q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2\n+  on (udf(t1.q2) = udf(t2.q1))\n+group by t1.q2 order by 1;\n+\n+--\n+-- test incorrect failure to NULL pulled-up subexpressions\n+--\n+-- begin;\n+create or replace temporary view a as select * from\n+  (values ('p'), ('q'))\n+  as v(code);\n+create or replace temporary view b as select * from\n+  (values ('p', 1), ('p', 2))\n+  as v(a, num);\n+create or replace temporary view c as select * from\n+  (values ('A', 'p'), ('B', 'q'), ('C', null))\n+  as v(name, a);\n+\n+select udf(c.name), udf(ss.code), udf(ss.b_cnt), udf(ss.const)\n+from c left join\n+  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const\n+   from a left join\n+     (select udf(count(1)) as cnt, b.a as a from b group by b.a) as b_grp\n+     on udf(a.code) = udf(udf(b_grp.a))\n+  ) as ss\n+  on (udf(udf(c.a)) = udf(ss.code))\n+order by c.name;\n+\n+-- rollback;\n+\n+--\n+-- test incorrect handling of placeholders that only appear in targetlists,\n+-- per bug #6154\n+--\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT udf(sub5.key5) as key5, udf(udf(COALESCE(sub6.value1, 1))) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON sub5.key5 = udf(sub6.key6)\n+    ) sub4\n+    ON udf(sub4.key5) = sub3.key3\n+) sub2\n+ON udf(udf(sub1.key1)) = udf(udf(sub2.key3));\n+\n+-- test the path using join aliases, too\n+SELECT * FROM\n+( SELECT 1 as key1 ) sub1\n+LEFT JOIN\n+( SELECT udf(sub3.key3) as key3, udf(value2), udf(COALESCE(value2, 66)) as value3 FROM\n+    ( SELECT 1 as key3 ) sub3\n+    LEFT JOIN\n+    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM\n+        ( SELECT 1 as key5 ) sub5\n+        LEFT JOIN\n+        ( SELECT 2 as key6, 42 as value1 ) sub6\n+        ON udf(udf(sub5.key5)) = sub6.key6\n+    ) sub4\n+    ON sub4.key5 = sub3.key3\n+) sub2\n+ON sub1.key1 = udf(udf(sub2.key3));\n+\n+--\n+-- test case where a PlaceHolderVar is used as a nestloop parameter\n+--\n+\n+-- EXPLAIN (COSTS OFF)",
    "line": 821
  }],
  "prId": 25371
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we add the cases like `udf(column)` -> `column` as well at here and below? Seems like `CORRELATION NAMES` has a good combination but the others look it doesn't.",
    "commit": "4392745e379a2f389f366af7d4edb85d1dd4032e",
    "createdAt": "2019-08-19T00:28:14Z",
    "diffHunk": "@@ -0,0 +1,2081 @@\n+--\n+-- Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group\n+--\n+--\n+-- JOIN\n+-- Test JOIN clauses\n+-- https://github.com/postgres/postgres/blob/REL_12_BETA2/src/test/regress/sql/join.sql\n+--\n+-- This test file was converted from pgSQL/join.sql.\n+\n+CREATE OR REPLACE TEMPORARY VIEW INT4_TBL AS SELECT * FROM\n+  (VALUES (0), (123456), (-123456), (2147483647), (-2147483647))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW INT8_TBL AS SELECT * FROM\n+  (VALUES\n+    (123, 456),\n+    (123, 4567890123456789),\n+    (4567890123456789, 123),\n+    (4567890123456789, 4567890123456789),\n+    (4567890123456789, -4567890123456789))\n+  AS v(q1, q2);\n+CREATE OR REPLACE TEMPORARY VIEW FLOAT8_TBL AS SELECT * FROM\n+  (VALUES (0.0), (1004.30), (-34.84),\n+    (cast('1.2345678901234e+200' as double)), (cast('1.2345678901234e-200' as double)))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW TEXT_TBL AS SELECT * FROM\n+  (VALUES ('doh!'), ('hi de ho neighbor'))\n+  AS v(f1);\n+CREATE OR REPLACE TEMPORARY VIEW tenk2 AS SELECT * FROM tenk1;\n+\n+CREATE TABLE J1_TBL (\n+  i integer,\n+  j integer,\n+  t string\n+) USING parquet;\n+\n+CREATE TABLE J2_TBL (\n+  i integer,\n+  k integer\n+) USING parquet;\n+\n+\n+INSERT INTO J1_TBL VALUES (1, 4, 'one');\n+INSERT INTO J1_TBL VALUES (2, 3, 'two');\n+INSERT INTO J1_TBL VALUES (3, 2, 'three');\n+INSERT INTO J1_TBL VALUES (4, 1, 'four');\n+INSERT INTO J1_TBL VALUES (5, 0, 'five');\n+INSERT INTO J1_TBL VALUES (6, 6, 'six');\n+INSERT INTO J1_TBL VALUES (7, 7, 'seven');\n+INSERT INTO J1_TBL VALUES (8, 8, 'eight');\n+INSERT INTO J1_TBL VALUES (0, NULL, 'zero');\n+INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');\n+INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');\n+\n+INSERT INTO J2_TBL VALUES (1, -1);\n+INSERT INTO J2_TBL VALUES (2, 2);\n+INSERT INTO J2_TBL VALUES (3, -3);\n+INSERT INTO J2_TBL VALUES (2, 4);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (5, -5);\n+INSERT INTO J2_TBL VALUES (0, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, NULL);\n+INSERT INTO J2_TBL VALUES (NULL, 0);\n+\n+-- [SPARK-20856] Do not need onerow because it only used for test statement using nested joins\n+-- useful in some tests below\n+-- create temp table onerow();\n+-- insert into onerow default values;\n+-- analyze onerow;\n+\n+\n+--\n+-- CORRELATION NAMES\n+-- Make sure that table/column aliases are supported\n+-- before diving into more complex join syntax.\n+--\n+\n+SELECT udf('') AS `xxx`, udf(i), udf(j), udf(t)\n+  FROM J1_TBL AS tx;\n+\n+SELECT udf(udf('')) AS `xxx`, udf(udf(i)), udf(j), udf(t)\n+  FROM J1_TBL tx;\n+\n+SELECT udf('') AS `xxx`, a, udf(udf(b)), c\n+  FROM J1_TBL AS t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), udf(b), udf(udf(c))\n+  FROM J1_TBL t1 (a, b, c);\n+\n+SELECT udf('') AS `xxx`, udf(a), b, udf(c), udf(d), e\n+  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);\n+\n+-- [SPARK-28377] Fully support correlation names in the FROM clause\n+-- SELECT '' AS \"xxx\", t1.a, t2.e\n+--   FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)\n+--   WHERE t1.a = t2.d;\n+\n+\n+--\n+-- CROSS JOIN\n+-- Qualifications are not allowed on cross joins,\n+-- which degenerate into a standard unqualified inner join.\n+--\n+\n+SELECT udf('') AS `xxx`, *\n+  FROM J1_TBL CROSS JOIN J2_TBL;\n+\n+-- ambiguous column\n+SELECT udf('') AS `xxx`, udf(i), udf(k), udf(t)"
  }],
  "prId": 25371
}]