[{
  "comments": [{
    "author": {
      "login": "mgyucht"
    },
    "body": "Indenting these comments allows them to show up in the .out files. This is kind of a hack based on the preprocessing done by SQLQueryTestSuite. I prefer this because the result of the query is only visible in the .out files, so this way you can compare the comments to the output side-by-side.",
    "commit": "8bb8963bb6e9af0fff5cab33c1e366267e8b7eaf",
    "createdAt": "2018-05-25T08:47:32Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+-- Unit tests for simple NOT IN predicate subquery across a single column.\n+--\n+-- ``col NOT IN expr'' is quite difficult to reason about. There are many edge cases, some of the\n+-- rules are confusing to the uninitiated, and precedence and treatment of null values is plain\n+-- unintuitive. To make this simpler to understand, I've come up with a plain English way of\n+-- describing the expected behavior of this query.\n+--\n+-- - If the subquery is empty (i.e. returns no rows), the row should be returned, regardless of\n+--   whether the filtered columns include nulls.\n+-- - If the subquery contains a result with all columns null, then the row should not be returned.\n+-- - If for all non-null filter columns there exists a row in the subquery in which each column\n+--   either\n+--   1. is equal to the corresponding filter column or\n+--   2. is null\n+--   then the row should not be returned. (This includes the case where all filter columns are\n+--   null.)\n+-- - Otherwise, the row should be returned.\n+--\n+-- Using these rules, we can come up with a set of test cases for single-column and multi-column\n+-- NOT IN test cases.\n+--\n+-- Test cases for single-column ``WHERE a NOT IN (SELECT c FROM r ...)'':\n+-- | # | does subquery include null? | is a null? | a = c? | row with a included in result? |\n+-- | 1 | empty                       |            |        | yes                            |\n+-- | 2 | yes                         |            |        | no                             |\n+-- | 3 | no                          | yes        |        | no                             |\n+-- | 4 | no                          | no         | yes    | no                             |\n+-- | 5 | no                          | no         | no     | yes                            |\n+--\n+-- There are also some considerations around correlated subqueries. Correlated subqueries can\n+-- cause cases 2, 3, or 4 to be reduced to case 1 by limiting the number of rows returned by the\n+-- subquery, so the row from the parent table should always be included in the output.\n+\n+CREATE TEMPORARY VIEW m AS SELECT * FROM VALUES\n+  (null, 1.0),\n+  (2, 3.0),\n+  (4, 5.0)\n+  AS m(a, b);\n+\n+CREATE TEMPORARY VIEW s AS SELECT * FROM VALUES\n+  (null, 1.0),\n+  (2, 3.0),\n+  (6, 7.0)\n+  AS s(c, d);\n+\n+  -- Uncorrelated NOT IN Subquery test cases",
    "line": 46
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Oh, that makes sense. Maybe we should just make this work out of the box with SqlQueryTestSuite. If we do this, does that mean we are going to execute a dummy query for each comment line?",
    "commit": "8bb8963bb6e9af0fff5cab33c1e366267e8b7eaf",
    "createdAt": "2018-05-25T09:37:26Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+-- Unit tests for simple NOT IN predicate subquery across a single column.\n+--\n+-- ``col NOT IN expr'' is quite difficult to reason about. There are many edge cases, some of the\n+-- rules are confusing to the uninitiated, and precedence and treatment of null values is plain\n+-- unintuitive. To make this simpler to understand, I've come up with a plain English way of\n+-- describing the expected behavior of this query.\n+--\n+-- - If the subquery is empty (i.e. returns no rows), the row should be returned, regardless of\n+--   whether the filtered columns include nulls.\n+-- - If the subquery contains a result with all columns null, then the row should not be returned.\n+-- - If for all non-null filter columns there exists a row in the subquery in which each column\n+--   either\n+--   1. is equal to the corresponding filter column or\n+--   2. is null\n+--   then the row should not be returned. (This includes the case where all filter columns are\n+--   null.)\n+-- - Otherwise, the row should be returned.\n+--\n+-- Using these rules, we can come up with a set of test cases for single-column and multi-column\n+-- NOT IN test cases.\n+--\n+-- Test cases for single-column ``WHERE a NOT IN (SELECT c FROM r ...)'':\n+-- | # | does subquery include null? | is a null? | a = c? | row with a included in result? |\n+-- | 1 | empty                       |            |        | yes                            |\n+-- | 2 | yes                         |            |        | no                             |\n+-- | 3 | no                          | yes        |        | no                             |\n+-- | 4 | no                          | no         | yes    | no                             |\n+-- | 5 | no                          | no         | no     | yes                            |\n+--\n+-- There are also some considerations around correlated subqueries. Correlated subqueries can\n+-- cause cases 2, 3, or 4 to be reduced to case 1 by limiting the number of rows returned by the\n+-- subquery, so the row from the parent table should always be included in the output.\n+\n+CREATE TEMPORARY VIEW m AS SELECT * FROM VALUES\n+  (null, 1.0),\n+  (2, 3.0),\n+  (4, 5.0)\n+  AS m(a, b);\n+\n+CREATE TEMPORARY VIEW s AS SELECT * FROM VALUES\n+  (null, 1.0),\n+  (2, 3.0),\n+  (6, 7.0)\n+  AS s(c, d);\n+\n+  -- Uncorrelated NOT IN Subquery test cases",
    "line": 46
  }, {
    "author": {
      "login": "mgyucht"
    },
    "body": "No, it gets bundled with the query immediately after it. This is why the `;` is on the line after the last line of the query, so that the comment shows up with that query rather than with the following one.",
    "commit": "8bb8963bb6e9af0fff5cab33c1e366267e8b7eaf",
    "createdAt": "2018-05-25T09:40:11Z",
    "diffHunk": "@@ -0,0 +1,123 @@\n+-- Unit tests for simple NOT IN predicate subquery across a single column.\n+--\n+-- ``col NOT IN expr'' is quite difficult to reason about. There are many edge cases, some of the\n+-- rules are confusing to the uninitiated, and precedence and treatment of null values is plain\n+-- unintuitive. To make this simpler to understand, I've come up with a plain English way of\n+-- describing the expected behavior of this query.\n+--\n+-- - If the subquery is empty (i.e. returns no rows), the row should be returned, regardless of\n+--   whether the filtered columns include nulls.\n+-- - If the subquery contains a result with all columns null, then the row should not be returned.\n+-- - If for all non-null filter columns there exists a row in the subquery in which each column\n+--   either\n+--   1. is equal to the corresponding filter column or\n+--   2. is null\n+--   then the row should not be returned. (This includes the case where all filter columns are\n+--   null.)\n+-- - Otherwise, the row should be returned.\n+--\n+-- Using these rules, we can come up with a set of test cases for single-column and multi-column\n+-- NOT IN test cases.\n+--\n+-- Test cases for single-column ``WHERE a NOT IN (SELECT c FROM r ...)'':\n+-- | # | does subquery include null? | is a null? | a = c? | row with a included in result? |\n+-- | 1 | empty                       |            |        | yes                            |\n+-- | 2 | yes                         |            |        | no                             |\n+-- | 3 | no                          | yes        |        | no                             |\n+-- | 4 | no                          | no         | yes    | no                             |\n+-- | 5 | no                          | no         | no     | yes                            |\n+--\n+-- There are also some considerations around correlated subqueries. Correlated subqueries can\n+-- cause cases 2, 3, or 4 to be reduced to case 1 by limiting the number of rows returned by the\n+-- subquery, so the row from the parent table should always be included in the output.\n+\n+CREATE TEMPORARY VIEW m AS SELECT * FROM VALUES\n+  (null, 1.0),\n+  (2, 3.0),\n+  (4, 5.0)\n+  AS m(a, b);\n+\n+CREATE TEMPORARY VIEW s AS SELECT * FROM VALUES\n+  (null, 1.0),\n+  (2, 3.0),\n+  (6, 7.0)\n+  AS s(c, d);\n+\n+  -- Uncorrelated NOT IN Subquery test cases",
    "line": 46
  }],
  "prId": 21425
}]