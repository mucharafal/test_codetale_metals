[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Is this expected?",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-26T10:33:35Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "I don't know. it seems is forbidden or other reason.",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-26T10:35:42Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Can you check the PgSQL behaviour? If it supports this query, we should do.",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-26T12:46:41Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "```\r\n[SQL]SELECT COMPANY.DEP_ID,\r\n       avg(SALARY),\r\n       avg(SALARY) FILTER (WHERE EXISTS (SELECT ID\r\n               FROM DEPARTMENT\r\n               WHERE DEPARTMENT.ID = COMPANY.DEP_ID))\r\nFROM COMPANY;\r\n\r\n[Err] ERROR:  column \"company.dep_id\" must appear in the GROUP BY clause or be used in an aggregate function\r\nLINE 1: SELECT COMPANY.DEP_ID,\r\n               ^\r\n```",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-27T02:40:26Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "I tried and it seemed that the query passed in pg;\r\n```\r\npostgres=# SELECT emp.dept_id, avg(salary), avg(salary) FILTER (WHERE EXISTS (SELECT state FROM dept WHERE dept.dept_id = emp.dept_id)) FROM emp GROUP BY dept_id;\r\n dept_id |         avg          |         avg          \r\n---------+----------------------+----------------------\r\n         | 400.0000000000000000 |                     \r\n      10 | 133.3333333333333333 | 133.3333333333333333\r\n     100 | 400.0000000000000000 |                     \r\n      30 | 400.0000000000000000 | 400.0000000000000000\r\n      70 | 150.0000000000000000 | 150.0000000000000000\r\n      20 | 300.0000000000000000 | 300.0000000000000000\r\n(6 rows)\r\n```\r\nDo I miss something?",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-27T12:21:49Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "```\r\nSELECT COMPANY.DEP_ID,\r\n       avg(SALARY),\r\n       avg(SALARY) FILTER (WHERE EXISTS (SELECT ID\r\n               FROM DEPARTMENT\r\n               WHERE DEPARTMENT.ID = COMPANY.DEP_ID))\r\nFROM COMPANY GROUP BY DEP_ID;\r\n```\r\nI'm sorry, I lost the group by clause.\r\nPgSQL supports this query.",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T01:48:48Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "If so, we should support this, too.",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T02:31:43Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "It seems difficult to implement. \r\nI references the implement that IN/EXISTS predicate sub-queries used in Filter, it converts the subquery to semi/anti join. But we cannot do the same.\r\nDo you have a good idea?\r\ncc @cloud-fan ",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T04:11:16Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "The ohter dbms-like systems support this query, oracle, mysql, presto, ...? Can you check?",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T04:21:27Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "I just checked oracle, mysql, presto, hive, Redshift, Vertica, DB2, all of them not support this query.",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T04:44:47Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Can you show us error messages of part of them(e.g., oracle and db2)? What's a kind of errors?",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T05:32:24Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "The error message of MySQL is:\r\n```\r\n[SQL]SELECT emp.dept_id,\r\n       avg(salary),\r\n       avg(salary) FILTER (WHERE EXISTS (SELECT state\r\n               FROM dept\r\n               WHERE id = emp.dept_id))\r\nFROM emp\r\nGROUP BY dept_id;\r\n[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '(WHERE EXISTS (SELECT state\r\n               FROM dept\r\n               WHERE id =' at line 3\r\n```",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T06:52:19Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "How about Oracle? It has more meaningful errors like \"FILTER syntax does not support subqueries, brabrabra\"?",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T06:56:59Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "The error message of Oracle is:\r\n```\r\nSELECT TEST.\"emp\".dept_id, avg(salary), avg(salary) FILTER (WHERE EXISTS (SELECT state FROM TEST.\"dept\" WHERE id = TEST.\"emp\".dept_id))\r\nFROM TEST.\"emp\" GROUP BY dept_id\r\n> ORA-00923: FROM keyword not found where expected\r\n  \r\n> Time: 0.026s\r\n```",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T09:02:32Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Ah, I see. Thanks. Then, yes, I personally think its ok not to support subqueries in this pr. Can you throw an exception with an explicit error message in `CheckAnalysis`?  cc: @gatorsmile @cloud-fan ",
    "commit": "cb31eea000d316305830ffb149f10fa5f3c5d333",
    "createdAt": "2019-11-28T23:58:05Z",
    "diffHunk": "@@ -0,0 +1,332 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 27\n+\n+\n+-- !query 0\n+CREATE OR REPLACE TEMPORARY VIEW testData AS SELECT * FROM VALUES\n+(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2), (null, 1), (3, null), (null, null)\n+AS testData(a, b)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+org.apache.spark.sql.AnalysisException\n+grouping expressions sequence is empty, and 'testdata.`a`' is not an aggregate function. Wrap '(count(testdata.`b`) AS `count(b)`)' in windowing function(s) or wrap 'testdata.`a`' in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 2\n+SELECT COUNT(a) FILTER (WHERE a = 1), COUNT(b) FILTER (WHERE a > 1) FROM testData\n+-- !query 2 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 2 output\n+2\t4\n+\n+\n+-- !query 3\n+SELECT a, COUNT(b) FILTER (WHERE a >= 2) FROM testData GROUP BY a\n+-- !query 3 schema\n+struct<a:int,count(b):bigint>\n+-- !query 3 output\n+1\t0\n+2\t2\n+3\t2\n+NULL\t0\n+\n+\n+-- !query 4\n+SELECT a, COUNT(b) FILTER (WHERE a != 2) FROM testData GROUP BY b\n+-- !query 4 schema\n+struct<>\n+-- !query 4 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 5\n+SELECT COUNT(a) FILTER (WHERE a >= 0), COUNT(b) FILTER (WHERE a >= 3) FROM testData GROUP BY a\n+-- !query 5 schema\n+struct<count(a):bigint,count(b):bigint>\n+-- !query 5 output\n+0\t0\n+2\t0\n+2\t0\n+3\t2\n+\n+\n+-- !query 6\n+SELECT 'foo', COUNT(a) FILTER (WHERE b <= 2) FROM testData GROUP BY 1\n+-- !query 6 schema\n+struct<foo:string,count(a):bigint>\n+-- !query 6 output\n+foo\t6\n+\n+\n+-- !query 7\n+SELECT 'foo', APPROX_COUNT_DISTINCT(a) FILTER (WHERE b >= 0) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 7 schema\n+struct<foo:string,approx_count_distinct(a):bigint>\n+-- !query 7 output\n+\n+\n+\n+-- !query 8\n+SELECT 'foo', MAX(STRUCT(a)) FILTER (WHERE b >= 1) FROM testData WHERE a = 0 GROUP BY 1\n+-- !query 8 schema\n+struct<foo:string,max(named_struct(a, a)):struct<a:int>>\n+-- !query 8 output\n+\n+\n+\n+-- !query 9\n+SELECT a + b, COUNT(b) FILTER (WHERE b >= 2) FROM testData GROUP BY a + b\n+-- !query 9 schema\n+struct<(a + b):int,count(b):bigint>\n+-- !query 9 output\n+2\t0\n+3\t1\n+4\t1\n+5\t1\n+NULL\t0\n+\n+\n+-- !query 10\n+SELECT a + 2, COUNT(b) FILTER (WHERE b IN (1, 2)) FROM testData GROUP BY a + 1\n+-- !query 10 schema\n+struct<>\n+-- !query 10 output\n+org.apache.spark.sql.AnalysisException\n+expression 'testdata.`a`' is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in first() (or first_value) if you don't care which value you get.;\n+\n+\n+-- !query 11\n+SELECT a + 1 + 1, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY a + 1\n+-- !query 11 schema\n+struct<((a + 1) + 1):int,count(b):bigint>\n+-- !query 11 output\n+3\t2\n+4\t2\n+5\t2\n+NULL\t1\n+\n+\n+-- !query 12\n+SELECT COUNT(DISTINCT b) FILTER (WHERE b > 0), COUNT(DISTINCT b, c) FILTER (WHERE b > 0 AND c > 2)\n+FROM (SELECT 1 AS a, 2 AS b, 3 AS c) GROUP BY a\n+-- !query 12 schema\n+struct<count(DISTINCT b):bigint,count(DISTINCT b, c):bigint>\n+-- !query 12 output\n+1\t1\n+\n+\n+-- !query 13\n+SELECT a AS k, COUNT(b) FILTER (WHERE b = 1 OR b = 2) FROM testData GROUP BY k\n+-- !query 13 schema\n+struct<k:int,count(b):bigint>\n+-- !query 13 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 14\n+SELECT a AS k, COUNT(b) FILTER (WHERE NOT b < 0) FROM testData GROUP BY k HAVING k > 1\n+-- !query 14 schema\n+struct<k:int,count(b):bigint>\n+-- !query 14 output\n+2\t2\n+3\t2\n+\n+\n+-- !query 15\n+SELECT COUNT(b) FILTER (WHERE a > 0) AS k FROM testData GROUP BY k\n+-- !query 15 schema\n+struct<>\n+-- !query 15 output\n+org.apache.spark.sql.AnalysisException\n+aggregate functions are not allowed in GROUP BY, but found count(testdata.`b`);\n+\n+\n+-- !query 16\n+SELECT a AS k, COUNT(b) FILTER (WHERE b > 0) FROM testData GROUP BY k\n+-- !query 16 schema\n+struct<k:int,count(b):bigint>\n+-- !query 16 output\n+1\t2\n+2\t2\n+3\t2\n+NULL\t1\n+\n+\n+-- !query 17\n+SELECT a, COUNT(1) FILTER (WHERE b > 1) FROM testData WHERE false GROUP BY a\n+-- !query 17 schema\n+struct<a:int,count(1):bigint>\n+-- !query 17 output\n+\n+\n+\n+-- !query 18\n+SELECT COUNT(1) FILTER (WHERE b = 2) FROM testData WHERE false\n+-- !query 18 schema\n+struct<count(1):bigint>\n+-- !query 18 output\n+0\n+\n+\n+-- !query 19\n+SELECT 1 FROM (SELECT COUNT(1) FILTER (WHERE a >= 3 OR b <= 1) FROM testData WHERE false) t\n+-- !query 19 schema\n+struct<1:int>\n+-- !query 19 output\n+1\n+\n+\n+-- !query 20\n+CREATE TEMPORARY VIEW EMP AS SELECT * FROM VALUES\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (100, \"emp 1\", date \"2005-01-01\", 100.00D, 10),\n+  (200, \"emp 2\", date \"2003-01-01\", 200.00D, 10),\n+  (300, \"emp 3\", date \"2002-01-01\", 300.00D, 20),\n+  (400, \"emp 4\", date \"2005-01-01\", 400.00D, 30),\n+  (500, \"emp 5\", date \"2001-01-01\", 400.00D, NULL),\n+  (600, \"emp 6 - no dept\", date \"2001-01-01\", 400.00D, 100),\n+  (700, \"emp 7\", date \"2010-01-01\", 400.00D, 100),\n+  (800, \"emp 8\", date \"2016-01-01\", 150.00D, 70)\n+AS EMP(id, emp_name, hiredate, salary, dept_id)\n+-- !query 20 schema\n+struct<>\n+-- !query 20 output\n+\n+\n+\n+-- !query 21\n+CREATE TEMPORARY VIEW DEPT AS SELECT * FROM VALUES\n+  (10, \"dept 1\", \"CA\"),\n+  (20, \"dept 2\", \"NY\"),\n+  (30, \"dept 3\", \"TX\"),\n+  (40, \"dept 4 - unassigned\", \"OR\"),\n+  (50, \"dept 5 - unassigned\", \"NJ\"),\n+  (70, \"dept 7\", \"FL\")\n+AS DEPT(dept_id, dept_name, state)\n+-- !query 21 schema\n+struct<>\n+-- !query 21 output\n+\n+\n+\n+-- !query 22\n+SELECT emp.dept_id,\n+       avg(salary),\n+       avg(salary) FILTER (WHERE EXISTS (SELECT state\n+               FROM dept\n+               WHERE dept.dept_id = emp.dept_id))\n+FROM emp\n+GROUP BY dept_id\n+-- !query 22 schema\n+struct<>\n+-- !query 22 output\n+org.apache.spark.sql.AnalysisException\n+IN/EXISTS predicate sub-queries can only be used in Filter/Join and a few commands: Aggregate [dept_id#x], [dept_id#x, avg(salary#x) AS avg(salary)#x, avg(salary#x) AS avg(salary)#x]",
    "line": 420
  }],
  "prId": 26656
}]