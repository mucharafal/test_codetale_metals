[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "use `k` and `v`",
    "commit": "89d03af70d8ed152c3e9b4bc302f060a8e4be50d",
    "createdAt": "2018-07-28T05:41:53Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 17\n+\n+\n+-- !query 0\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3)\n+    AS tab1(k, v)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3)\n+    AS tab2(k, v)\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+\n+\n+\n+-- !query 2\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 2 schema\n+struct<k:int,v:int>\n+-- !query 2 output\n+1\t2\n+2\t3\n+\n+\n+-- !query 3\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE k = 1\n+-- !query 3 schema\n+struct<k:int,v:int>\n+-- !query 3 output\n+1\t2\n+1\t2\n+1\t3\n+\n+\n+-- !query 4\n+SELECT * FROM tab1 WHERE k > 2\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 4 schema\n+struct<k:int,v:int>\n+-- !query 4 output\n+\n+\n+\n+-- !query 5\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE k > 2\n+-- !query 5 schema\n+struct<k:int,v:int>\n+-- !query 5 output\n+\n+\n+\n+-- !query 6\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(1 AS BIGINT), CAST(2 AS BIGINT)\n+-- !query 6 schema\n+struct<k:bigint,v:bigint>\n+-- !query 6 output\n+1\t2\n+\n+\n+-- !query 7\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), 2\n+-- !query 7 schema\n+struct<>\n+-- !query 7 output\n+org.apache.spark.sql.AnalysisException\n+IntersectAll can only be performed on tables with the compatible column types. array<int> <> int at the first column of the second table;\n+\n+\n+-- !query 8\n+SELECT c1 FROM tab1\n+INTERSECT ALL\n+SELECT c1, c2 FROM tab2"
  }],
  "prId": 21886
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "also add another duplicate rows for (1, 2);",
    "commit": "89d03af70d8ed152c3e9b4bc302f060a8e4be50d",
    "createdAt": "2018-07-28T05:43:05Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 17\n+\n+\n+-- !query 0\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3)\n+    AS tab1(k, v)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), ",
    "line": 23
  }],
  "prId": 21886
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "also add another duplicate row (1, 3)",
    "commit": "89d03af70d8ed152c3e9b4bc302f060a8e4be50d",
    "createdAt": "2018-07-28T05:43:17Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 17\n+\n+\n+-- !query 0\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),",
    "line": 9
  }],
  "prId": 21886
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "add one more row (3, 4)",
    "commit": "89d03af70d8ed152c3e9b4bc302f060a8e4be50d",
    "createdAt": "2018-07-28T05:43:35Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 17\n+\n+\n+-- !query 0\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (2, 3)\n+    AS tab1(k, v)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (2, 3)"
  }],
  "prId": 21886
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "This misses one row (1, 3). Could you investigate the cause?",
    "commit": "89d03af70d8ed152c3e9b4bc302f060a8e4be50d",
    "createdAt": "2018-07-29T16:59:34Z",
    "diffHunk": "@@ -0,0 +1,236 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 17\n+\n+\n+-- !query 0\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v)\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+\n+\n+\n+-- !query 2\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 2 schema\n+struct<k:int,v:int>\n+-- !query 2 output\n+1\t2\n+1\t2\n+2\t3\n+NULL\tNULL\n+NULL\tNULL\n+\n+\n+-- !query 3\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE k = 1\n+-- !query 3 schema\n+struct<k:int,v:int>\n+-- !query 3 output\n+1\t2\n+1\t2\n+1\t3\n+1\t3\n+\n+\n+-- !query 4\n+SELECT * FROM tab1 WHERE k > 2\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 4 schema\n+struct<k:int,v:int>\n+-- !query 4 output\n+\n+\n+\n+-- !query 5\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE k > 3\n+-- !query 5 schema\n+struct<k:int,v:int>\n+-- !query 5 output\n+\n+\n+\n+-- !query 6\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(1 AS BIGINT), CAST(2 AS BIGINT)\n+-- !query 6 schema\n+struct<k:bigint,v:bigint>\n+-- !query 6 output\n+1\t2\n+\n+\n+-- !query 7\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), 2\n+-- !query 7 schema\n+struct<>\n+-- !query 7 output\n+org.apache.spark.sql.AnalysisException\n+IntersectAll can only be performed on tables with the compatible column types. array<int> <> int at the first column of the second table;\n+\n+\n+-- !query 8\n+SELECT k FROM tab1\n+INTERSECT ALL\n+SELECT k, v FROM tab2\n+-- !query 8 schema\n+struct<>\n+-- !query 8 output\n+org.apache.spark.sql.AnalysisException\n+IntersectAll can only be performed on tables with the same number of columns, but the first table has 1 columns and the second table has 2 columns;\n+\n+\n+-- !query 9\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 9 schema\n+struct<k:int,v:int>\n+-- !query 9 output\n+1\t2\n+1\t2\n+2\t3\n+NULL\tNULL\n+NULL\tNULL\n+\n+\n+-- !query 10\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 10 schema\n+struct<k:int,v:int>\n+-- !query 10 output\n+1\t2\n+1\t2\n+2\t3\n+NULL\tNULL\n+NULL\tNULL",
    "line": 47
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@gatorsmile Thank you.. I just went over my notes. The reason for the difference in output is because in Spark we give the same precedence to to all the set operators. The operators are basically evaluated in the order they appear in the query from left to right. But per standard, INTERSECT should have higher precedence over UNION and EXCEPT. We do have this problem in our current support of EXCEPT (DISTINCT) and INTERSECT (DISTINCT). I am fixing the test now to add parenthesize around the query block to force certain order of evaluation. I have opened https://issues.apache.org/jira/browse/SPARK-24966 to work in fixing the precedence in our grammer.",
    "commit": "89d03af70d8ed152c3e9b4bc302f060a8e4be50d",
    "createdAt": "2018-07-30T00:26:21Z",
    "diffHunk": "@@ -0,0 +1,236 @@\n+-- Automatically generated by SQLQueryTestSuite\n+-- Number of queries: 17\n+\n+\n+-- !query 0\n+CREATE TEMPORARY VIEW tab1 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2),\n+    (1, 3),\n+    (1, 3),\n+    (2, 3),\n+    (null, null),\n+    (null, null)\n+    AS tab1(k, v)\n+-- !query 0 schema\n+struct<>\n+-- !query 0 output\n+\n+\n+\n+-- !query 1\n+CREATE TEMPORARY VIEW tab2 AS SELECT * FROM VALUES\n+    (1, 2), \n+    (1, 2), \n+    (2, 3),\n+    (3, 4),\n+    (null, null),\n+    (null, null)\n+    AS tab2(k, v)\n+-- !query 1 schema\n+struct<>\n+-- !query 1 output\n+\n+\n+\n+-- !query 2\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 2 schema\n+struct<k:int,v:int>\n+-- !query 2 output\n+1\t2\n+1\t2\n+2\t3\n+NULL\tNULL\n+NULL\tNULL\n+\n+\n+-- !query 3\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab1 WHERE k = 1\n+-- !query 3 schema\n+struct<k:int,v:int>\n+-- !query 3 output\n+1\t2\n+1\t2\n+1\t3\n+1\t3\n+\n+\n+-- !query 4\n+SELECT * FROM tab1 WHERE k > 2\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 4 schema\n+struct<k:int,v:int>\n+-- !query 4 output\n+\n+\n+\n+-- !query 5\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2 WHERE k > 3\n+-- !query 5 schema\n+struct<k:int,v:int>\n+-- !query 5 output\n+\n+\n+\n+-- !query 6\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT CAST(1 AS BIGINT), CAST(2 AS BIGINT)\n+-- !query 6 schema\n+struct<k:bigint,v:bigint>\n+-- !query 6 output\n+1\t2\n+\n+\n+-- !query 7\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT array(1), 2\n+-- !query 7 schema\n+struct<>\n+-- !query 7 output\n+org.apache.spark.sql.AnalysisException\n+IntersectAll can only be performed on tables with the compatible column types. array<int> <> int at the first column of the second table;\n+\n+\n+-- !query 8\n+SELECT k FROM tab1\n+INTERSECT ALL\n+SELECT k, v FROM tab2\n+-- !query 8 schema\n+struct<>\n+-- !query 8 output\n+org.apache.spark.sql.AnalysisException\n+IntersectAll can only be performed on tables with the same number of columns, but the first table has 1 columns and the second table has 2 columns;\n+\n+\n+-- !query 9\n+SELECT * FROM tab2\n+INTERSECT ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 9 schema\n+struct<k:int,v:int>\n+-- !query 9 output\n+1\t2\n+1\t2\n+2\t3\n+NULL\tNULL\n+NULL\tNULL\n+\n+\n+-- !query 10\n+SELECT * FROM tab1\n+EXCEPT\n+SELECT * FROM tab2\n+UNION ALL\n+SELECT * FROM tab1\n+INTERSECT ALL\n+SELECT * FROM tab2\n+-- !query 10 schema\n+struct<k:int,v:int>\n+-- !query 10 output\n+1\t2\n+1\t2\n+2\t3\n+NULL\tNULL\n+NULL\tNULL",
    "line": 47
  }],
  "prId": 21886
}]