[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Could you add the generated result(JDK8/JDK11) into this PR, please?",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-23T06:15:46Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You mean add a comment in the code? What is the point?\r\n\r\nIf you modify the code again, you have to run the benchmark both with the old code and the new code and post your results. The results on my machine will be different than on anyone else's.\r\n\r\nAnd JDK8/JDK11 differences are kinda irrelevant here.",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-23T15:48:28Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "@vanzin . No~ What you need is just to run the benchmark with `SPARK_GENERATE_BENCHMARK_FILES=1`. It will generate the result for you.\r\n> You mean add a comment in the code? What is the point?\r\n\r\nDid you take a look at the other benchmarks recently? For example, the following.\r\n```scala\r\n/**\r\n * Benchmark for CoalescedRDD.\r\n * Measures rdd.coalesce performance under various combinations of\r\n * coalesced partitions and preferred hosts\r\n * To run this benchmark:\r\n * {{{\r\n *   1. without sbt:\r\n *      bin/spark-submit --class <this class> --jars <spark core test jar>\r\n *   2. build/sbt \"core/test:runMain <this class>\"\r\n *   3. generate result:\r\n *      SPARK_GENERATE_BENCHMARK_FILES=1 build/sbt \"core/test:runMain <this class>\"\r\n *      Results will be written to \"benchmarks/CoalescedRDD-results.txt\".\r\n * }}}\r\n * */\r\n```\r\n\r\nSince Apache Spark 3.0.0, we are tracking all the benchmark results with the generated files between Apache Spark versions. Please see https://issues.apache.org/jira/browse/SPARK-25475 .\r\n\r\ncc @cloud-fan ",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T20:21:01Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I had not seen that. Ok, I'll add the results file even though this is kind of an odd benchmark.",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T20:31:55Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thank you, @vanzin !",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T20:54:30Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I added the files but it's still rather pointless, in my view. A single measurement at some random point in time made with some random hardware is not useful for comparison.\r\n\r\nWhoever updates the code still needs to redo those measurements with both the old an new version, because the values in those files don't mean anything.\r\n\r\nAnd also you'd better hope those instructions copy & pasted into dozens of files never change.",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T20:57:02Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thanks. I completely agree with you, @vanzin ! I also have been noticing that those different and mixed results exists everywhere (especially Mac/Server results.)\r\n\r\n> A single measurement at some random point in time made with some random hardware is not useful for comparison.\r\n\r\nThat's the reason we recommend `r3.xlarge` EC2 instance as a standard machine for a long time and try to help to generate the result on that. All the existing result txt files are the `r3.xlarge` generated result. Additionally, I will do the regeneration before 3.0.0 release to make a baseline.\r\n\r\nAlso, the current `BenchmarkBase` is a way for us to automate in the downstream. We can track the performance by commit by commit on the same machine (if you want).",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T22:21:07Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You don't need those files to automate things. You start from somewhere to define a baseline, then compare from that. The results don't need to be committed to git. They can be managed by that automation.\r\n\r\nThe process you mention also ignores changes to the benchmarks themselves, even if those should be rarer.\r\n\r\nBut in any case, I just want to get this code in and don't really care that much about what you're doing with these files. As I said, this benchmark is different from the others and the base class was just a way to reuse code for measurements.",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T22:27:24Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {",
    "line": 47
  }],
  "prId": 26218
}, {
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "nit: remove empty line",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-23T08:26:22Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+\n+object MetricsAggregationBenchmark extends BenchmarkBase {\n+\n+  private def metricTrackingBenchmark(\n+      timer: Benchmark.Timer,\n+      numMetrics: Int,\n+      numTasks: Int,\n+      numStages: Int): Measurements = {\n+    val conf = new SparkConf()\n+      .set(LIVE_ENTITY_UPDATE_PERIOD, 0L)\n+      .set(ASYNC_TRACKING_ENABLED, false)\n+    val kvstore = new ElementTrackingStore(new InMemoryStore(), conf)\n+    val listener = new SQLAppStatusListener(conf, kvstore, live = true)\n+    val store = new SQLAppStatusStore(kvstore, Some(listener))\n+\n+    val metrics = (0 until numMetrics).map { i =>\n+      new SQLMetricInfo(s\"metric$i\", i.toLong, \"average\")\n+    }\n+\n+    val planInfo = new SparkPlanInfo(\n+      getClass().getName(),\n+      getClass().getName(),\n+      Nil,\n+      Map.empty,\n+      metrics)\n+\n+    val idgen = new AtomicInteger()\n+    val executionId = idgen.incrementAndGet()\n+    val executionStart = SparkListenerSQLExecutionStart(\n+      executionId,\n+      getClass().getName(),\n+      getClass().getName(),\n+      getClass().getName(),\n+      planInfo,\n+      System.currentTimeMillis())\n+\n+    val executionEnd = SparkListenerSQLExecutionEnd(executionId, System.currentTimeMillis())\n+\n+    val properties = new Properties()\n+    properties.setProperty(SQLExecution.EXECUTION_ID_KEY, executionId.toString)\n+\n+    timer.startTiming()\n+    listener.onOtherEvent(executionStart)\n+\n+    val taskEventsTime = (0 until numStages).map { _ =>\n+      val stageInfo = new StageInfo(idgen.incrementAndGet(), 0, getClass().getName(),\n+        numTasks, Nil, Nil, getClass().getName())\n+\n+      val jobId = idgen.incrementAndGet()\n+      val jobStart = SparkListenerJobStart(\n+        jobId = jobId,\n+        time = System.currentTimeMillis(),\n+        stageInfos = Seq(stageInfo),\n+        properties)\n+\n+      val stageStart = SparkListenerStageSubmitted(stageInfo)\n+\n+      val taskOffset = idgen.incrementAndGet().toLong\n+      val taskEvents = (0 until numTasks).map { i =>\n+        val info = new TaskInfo(\n+          taskId = taskOffset + i.toLong,\n+          index = i,\n+          attemptNumber = 0,\n+          // The following fields are not used.\n+          launchTime = 0,\n+          executorId = \"\",\n+          host = \"\",\n+          taskLocality = null,\n+          speculative = false)\n+        info.markFinished(TaskState.FINISHED, 1L)\n+\n+        val accumulables = (0 until numMetrics).map { mid =>\n+          val acc = new LongAccumulator\n+          acc.metadata = AccumulatorMetadata(mid, None, false)\n+          acc.toInfo(Some(i.toLong), None)\n+        }\n+\n+        info.setAccumulables(accumulables)\n+\n+        val start = SparkListenerTaskStart(stageInfo.stageId, stageInfo.attemptNumber, info)\n+        val end = SparkListenerTaskEnd(stageInfo.stageId, stageInfo.attemptNumber,\n+          taskType = \"\",\n+          reason = null,\n+          info,\n+          new ExecutorMetrics(),\n+          null)\n+\n+        (start, end)\n+      }\n+\n+      val jobEnd = SparkListenerJobEnd(\n+        jobId = jobId,\n+        time = System.currentTimeMillis(),\n+        JobSucceeded)\n+\n+      listener.onJobStart(jobStart)\n+      listener.onStageSubmitted(stageStart)\n+\n+      val (_, _taskEventsTime) = Utils.timeTakenMs {\n+        taskEvents.foreach { case (start, end) =>\n+          listener.onTaskStart(start)\n+          listener.onTaskEnd(end)\n+        }\n+      }\n+\n+      listener.onJobEnd(jobEnd)\n+      _taskEventsTime\n+    }\n+\n+    val (_, aggTime) = Utils.timeTakenMs {\n+      listener.onOtherEvent(executionEnd)\n+      val metrics = store.executionMetrics(executionId)\n+      assert(metrics.size == numMetrics, s\"${metrics.size} != $numMetrics\")\n+    }\n+\n+    timer.stopTiming()\n+    kvstore.close()\n+\n+    Measurements(taskEventsTime, aggTime)\n+  }\n+\n+  override def runBenchmarkSuite(mainArgs: Array[String]): Unit = {\n+    val metricCount = 50\n+    val taskCount = 100000\n+    val stageCounts = Seq(1, 2, 3)\n+\n+    val benchmark = new Benchmark(\n+      s\"metrics aggregation ($metricCount metrics, $taskCount tasks per stage)\", 1,\n+      warmupTime = 0.seconds)\n+\n+    // Run this outside the measurement code so that classes are loaded and JIT is triggered,\n+    // otherwise the first run tends to be much slower than others. Also because this benchmark is a\n+    // bit weird and doesn't really map to what the Benchmark class expects, so it's a bit harder\n+    // to use warmupTime and friends effectively.\n+    benchmark.out.printf(\"Warming up...\\n\")\n+    stageCounts.foreach { count =>\n+      metricTrackingBenchmark(new Benchmark.Timer(-1), metricCount, taskCount, count)\n+    }\n+\n+    val measurements = mutable.HashMap[Int, Seq[Measurements]]()\n+\n+    stageCounts.foreach { count =>\n+      benchmark.addTimerCase(s\"$count stage(s)\") { timer =>\n+        val m = metricTrackingBenchmark(timer, metricCount, taskCount, count)\n+        val all = measurements.getOrElse(count, Nil)\n+        measurements(count) = all ++ Seq(m)\n+      }\n+    }\n+\n+    benchmark.run()\n+\n+    benchmark.out.printf(\"Stage Count    Stage Proc. Time    Aggreg. Time\\n\")\n+    stageCounts.foreach { count =>\n+      val data = measurements(count)\n+      val eventsTimes = data.flatMap(_.taskEventsTimes)\n+      val aggTimes = data.map(_.aggregationTime)\n+\n+      val msg = \"     %d              %d                %d\\n\".format(\n+        count,\n+        eventsTimes.sum / eventsTimes.size,\n+        aggTimes.sum / aggTimes.size)\n+      benchmark.out.printf(msg)\n+    }\n+  }\n+\n+  /**\n+   * Finer-grained measurements of how long it takes to run some parts of the benchmark. This is\n+   * collected by the benchmark method, so this collection slightly affects the overall benchmark\n+   * results, but this data helps with seeing where the time is going, since this benchmark is\n+   * triggering a whole lot of code in the listener class.\n+   */\n+  case class Measurements(\n+      taskEventsTimes: Seq[Long],\n+      aggregationTime: Long)\n+"
  }],
  "prId": 26218
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "We need an object description like the other benchmarks.",
    "commit": "6377c701620d9c6b344993a8bf4c2c1acd267c00",
    "createdAt": "2019-10-24T20:23:03Z",
    "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.ui\n+\n+import java.util.Properties\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import scala.collection.mutable\n+import scala.concurrent.duration._\n+\n+import org.apache.spark.{SparkConf, TaskState}\n+import org.apache.spark.benchmark.{Benchmark, BenchmarkBase}\n+import org.apache.spark.executor.ExecutorMetrics\n+import org.apache.spark.internal.config.Status._\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.metric.SQLMetricInfo\n+import org.apache.spark.status.ElementTrackingStore\n+import org.apache.spark.util.{AccumulatorMetadata, LongAccumulator, Utils}\n+import org.apache.spark.util.kvstore.InMemoryStore\n+",
    "line": 36
  }],
  "prId": 26218
}]