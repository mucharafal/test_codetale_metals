[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Should log something here, since otherwise it's hard to debug what's happening.\n",
    "commit": "fbc471bd8de9d7742b4329f79610ab9dd8fe123c",
    "createdAt": "2015-10-19T00:54:09Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.jdbc\n+\n+import java.sql.Connection\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import com.spotify.docker.client.messages.ContainerConfig\n+import com.spotify.docker.client._\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.scalatest.BeforeAndAfterAll\n+\n+abstract class DatabaseOnDocker {\n+  /**\n+   * The docker image to be pulled\n+   */\n+  def imageName: String\n+\n+  /**\n+   * A Seq of environment variables in the form of VAR=value\n+   */\n+  def env: Seq[String]\n+\n+  /**\n+   * jdbcUrl should be a lazy val or a function since `ip` it relies on is only available after\n+   * the docker container starts\n+   */\n+  def jdbcUrl: String\n+\n+  private val docker: DockerClient = DockerClientFactory.get()\n+  private var containerId: String = null\n+\n+  lazy val ip = docker.inspectContainer(containerId).networkSettings.ipAddress\n+\n+  def start(): Unit = {\n+    while (true) {\n+      try {\n+        val config = ContainerConfig.builder()\n+          .image(imageName).env(env.asJava)\n+          .build()\n+        containerId = docker.createContainer(config).id\n+        docker.startContainer(containerId)\n+        return\n+      } catch {\n+        case e: ImageNotFoundException => retry(5)(docker.pull(imageName))",
    "line": 64
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Also... why not _first_ try to pull the image and only then try to start the container?\n",
    "commit": "fbc471bd8de9d7742b4329f79610ab9dd8fe123c",
    "createdAt": "2015-10-19T00:54:46Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.jdbc\n+\n+import java.sql.Connection\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import com.spotify.docker.client.messages.ContainerConfig\n+import com.spotify.docker.client._\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.scalatest.BeforeAndAfterAll\n+\n+abstract class DatabaseOnDocker {\n+  /**\n+   * The docker image to be pulled\n+   */\n+  def imageName: String\n+\n+  /**\n+   * A Seq of environment variables in the form of VAR=value\n+   */\n+  def env: Seq[String]\n+\n+  /**\n+   * jdbcUrl should be a lazy val or a function since `ip` it relies on is only available after\n+   * the docker container starts\n+   */\n+  def jdbcUrl: String\n+\n+  private val docker: DockerClient = DockerClientFactory.get()\n+  private var containerId: String = null\n+\n+  lazy val ip = docker.inspectContainer(containerId).networkSettings.ipAddress\n+\n+  def start(): Unit = {\n+    while (true) {\n+      try {\n+        val config = ContainerConfig.builder()\n+          .image(imageName).env(env.asJava)\n+          .build()\n+        containerId = docker.createContainer(config).id\n+        docker.startContainer(containerId)\n+        return\n+      } catch {\n+        case e: ImageNotFoundException => retry(5)(docker.pull(imageName))",
    "line": 64
  }],
  "prId": 8101
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "If an exception is thrown here, then I don't think that the Docker container will be cleaned up.\n",
    "commit": "fbc471bd8de9d7742b4329f79610ab9dd8fe123c",
    "createdAt": "2015-10-19T01:18:29Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.jdbc\n+\n+import java.sql.Connection\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import com.spotify.docker.client.messages.ContainerConfig\n+import com.spotify.docker.client._\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.scalatest.BeforeAndAfterAll\n+\n+abstract class DatabaseOnDocker {\n+  /**\n+   * The docker image to be pulled\n+   */\n+  def imageName: String\n+\n+  /**\n+   * A Seq of environment variables in the form of VAR=value\n+   */\n+  def env: Seq[String]\n+\n+  /**\n+   * jdbcUrl should be a lazy val or a function since `ip` it relies on is only available after\n+   * the docker container starts\n+   */\n+  def jdbcUrl: String\n+\n+  private val docker: DockerClient = DockerClientFactory.get()\n+  private var containerId: String = null\n+\n+  lazy val ip = docker.inspectContainer(containerId).networkSettings.ipAddress\n+\n+  def start(): Unit = {\n+    while (true) {\n+      try {\n+        val config = ContainerConfig.builder()\n+          .image(imageName).env(env.asJava)\n+          .build()\n+        containerId = docker.createContainer(config).id\n+        docker.startContainer(containerId)\n+        return\n+      } catch {\n+        case e: ImageNotFoundException => retry(5)(docker.pull(imageName))\n+      }\n+    }\n+  }\n+\n+  private def retry[T](n: Int)(fn: => T): T = {\n+    try {\n+      fn\n+    } catch {\n+      case e if n > 1 =>\n+        retry(n - 1)(fn)\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    docker.killContainer(containerId)\n+    docker.removeContainer(containerId)\n+    DockerClientFactory.close(docker)\n+  }\n+}\n+\n+abstract class DatabaseIntegrationSuite extends SparkFunSuite\n+  with BeforeAndAfterAll with SharedSQLContext {\n+\n+  def db: DatabaseOnDocker\n+\n+  def waitForDatabase(ip: String, maxMillis: Long) {\n+    val before = System.currentTimeMillis()\n+    var lastException: java.sql.SQLException = null\n+    while (true) {\n+      if (System.currentTimeMillis() > before + maxMillis) {\n+        throw new java.sql.SQLException(s\"Database not up after $maxMillis ms.\", lastException)\n+      }\n+      try {\n+        val conn = java.sql.DriverManager.getConnection(db.jdbcUrl)\n+        conn.close()\n+        return\n+      } catch {\n+        case e: java.sql.SQLException =>\n+          lastException = e\n+          java.lang.Thread.sleep(250)\n+      }\n+    }\n+  }\n+\n+  def setupDatabase(ip: String): Unit = {\n+    val conn: Connection = java.sql.DriverManager.getConnection(db.jdbcUrl)\n+    try {\n+      dataPreparation(conn)\n+    } finally {\n+      conn.close()\n+    }\n+  }\n+\n+  /**\n+   * Prepare databases and tables for testing\n+   */\n+  def dataPreparation(connection: Connection)\n+\n+  override def beforeAll() {\n+    super.beforeAll()\n+    db.start()\n+    waitForDatabase(db.ip, 60000)\n+    setupDatabase(db.ip)",
    "line": 127
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Just hit this problem while testing this out locally.\n",
    "commit": "fbc471bd8de9d7742b4329f79610ab9dd8fe123c",
    "createdAt": "2015-10-19T01:18:43Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.jdbc\n+\n+import java.sql.Connection\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import com.spotify.docker.client.messages.ContainerConfig\n+import com.spotify.docker.client._\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.scalatest.BeforeAndAfterAll\n+\n+abstract class DatabaseOnDocker {\n+  /**\n+   * The docker image to be pulled\n+   */\n+  def imageName: String\n+\n+  /**\n+   * A Seq of environment variables in the form of VAR=value\n+   */\n+  def env: Seq[String]\n+\n+  /**\n+   * jdbcUrl should be a lazy val or a function since `ip` it relies on is only available after\n+   * the docker container starts\n+   */\n+  def jdbcUrl: String\n+\n+  private val docker: DockerClient = DockerClientFactory.get()\n+  private var containerId: String = null\n+\n+  lazy val ip = docker.inspectContainer(containerId).networkSettings.ipAddress\n+\n+  def start(): Unit = {\n+    while (true) {\n+      try {\n+        val config = ContainerConfig.builder()\n+          .image(imageName).env(env.asJava)\n+          .build()\n+        containerId = docker.createContainer(config).id\n+        docker.startContainer(containerId)\n+        return\n+      } catch {\n+        case e: ImageNotFoundException => retry(5)(docker.pull(imageName))\n+      }\n+    }\n+  }\n+\n+  private def retry[T](n: Int)(fn: => T): T = {\n+    try {\n+      fn\n+    } catch {\n+      case e if n > 1 =>\n+        retry(n - 1)(fn)\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    docker.killContainer(containerId)\n+    docker.removeContainer(containerId)\n+    DockerClientFactory.close(docker)\n+  }\n+}\n+\n+abstract class DatabaseIntegrationSuite extends SparkFunSuite\n+  with BeforeAndAfterAll with SharedSQLContext {\n+\n+  def db: DatabaseOnDocker\n+\n+  def waitForDatabase(ip: String, maxMillis: Long) {\n+    val before = System.currentTimeMillis()\n+    var lastException: java.sql.SQLException = null\n+    while (true) {\n+      if (System.currentTimeMillis() > before + maxMillis) {\n+        throw new java.sql.SQLException(s\"Database not up after $maxMillis ms.\", lastException)\n+      }\n+      try {\n+        val conn = java.sql.DriverManager.getConnection(db.jdbcUrl)\n+        conn.close()\n+        return\n+      } catch {\n+        case e: java.sql.SQLException =>\n+          lastException = e\n+          java.lang.Thread.sleep(250)\n+      }\n+    }\n+  }\n+\n+  def setupDatabase(ip: String): Unit = {\n+    val conn: Connection = java.sql.DriverManager.getConnection(db.jdbcUrl)\n+    try {\n+      dataPreparation(conn)\n+    } finally {\n+      conn.close()\n+    }\n+  }\n+\n+  /**\n+   * Prepare databases and tables for testing\n+   */\n+  def dataPreparation(connection: Connection)\n+\n+  override def beforeAll() {\n+    super.beforeAll()\n+    db.start()\n+    waitForDatabase(db.ip, 60000)\n+    setupDatabase(db.ip)",
    "line": 127
  }],
  "prId": 8101
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Hey, so what's the deal with this? Is this factory still necessary or was it an artifact of legacy Docker bugs or docker-client issues?\n",
    "commit": "fbc471bd8de9d7742b4329f79610ab9dd8fe123c",
    "createdAt": "2015-10-21T20:25:57Z",
    "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.jdbc\n+\n+import java.sql.Connection\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import com.spotify.docker.client.messages.ContainerConfig\n+import com.spotify.docker.client._\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.test.SharedSQLContext\n+import org.scalatest.BeforeAndAfterAll\n+\n+abstract class DatabaseOnDocker {\n+  /**\n+   * The docker image to be pulled\n+   */\n+  def imageName: String\n+\n+  /**\n+   * A Seq of environment variables in the form of VAR=value\n+   */\n+  def env: Seq[String]\n+\n+  /**\n+   * jdbcUrl should be a lazy val or a function since `ip` it relies on is only available after\n+   * the docker container starts\n+   */\n+  def jdbcUrl: String\n+\n+  private val docker: DockerClient = DockerClientFactory.get()\n+  private var containerId: String = null\n+\n+  lazy val ip = docker.inspectContainer(containerId).networkSettings.ipAddress\n+\n+  def start(): Unit = {\n+    while (true) {\n+      try {\n+        val config = ContainerConfig.builder()\n+          .image(imageName).env(env.asJava)\n+          .build()\n+        containerId = docker.createContainer(config).id\n+        docker.startContainer(containerId)\n+        return\n+      } catch {\n+        case e: ImageNotFoundException => retry(5)(docker.pull(imageName))\n+      }\n+    }\n+  }\n+\n+  private def retry[T](n: Int)(fn: => T): T = {\n+    try {\n+      fn\n+    } catch {\n+      case e if n > 1 =>\n+        retry(n - 1)(fn)\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    docker.killContainer(containerId)\n+    docker.removeContainer(containerId)\n+    DockerClientFactory.close(docker)\n+  }\n+}\n+\n+abstract class DatabaseIntegrationSuite extends SparkFunSuite\n+  with BeforeAndAfterAll with SharedSQLContext {\n+\n+  def db: DatabaseOnDocker\n+\n+  def waitForDatabase(ip: String, maxMillis: Long) {\n+    val before = System.currentTimeMillis()\n+    var lastException: java.sql.SQLException = null\n+    while (true) {\n+      if (System.currentTimeMillis() > before + maxMillis) {\n+        throw new java.sql.SQLException(s\"Database not up after $maxMillis ms.\", lastException)\n+      }\n+      try {\n+        val conn = java.sql.DriverManager.getConnection(db.jdbcUrl)\n+        conn.close()\n+        return\n+      } catch {\n+        case e: java.sql.SQLException =>\n+          lastException = e\n+          java.lang.Thread.sleep(250)\n+      }\n+    }\n+  }\n+\n+  def setupDatabase(ip: String): Unit = {\n+    val conn: Connection = java.sql.DriverManager.getConnection(db.jdbcUrl)\n+    try {\n+      dataPreparation(conn)\n+    } finally {\n+      conn.close()\n+    }\n+  }\n+\n+  /**\n+   * Prepare databases and tables for testing\n+   */\n+  def dataPreparation(connection: Connection)\n+\n+  override def beforeAll() {\n+    super.beforeAll()\n+    db.start()\n+    waitForDatabase(db.ip, 60000)\n+    setupDatabase(db.ip)\n+  }\n+\n+  override def afterAll() {\n+    try {\n+      db.close()\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory and morgue for DockerClient objects.  In the DockerClient we use,\n+ * calling close() closes the desired DockerClient but also renders all other\n+ * DockerClients inoperable.  This is inconvenient if we have more than one\n+ * open, such as during tests.\n+ */\n+object DockerClientFactory {",
    "line": 145
  }],
  "prId": 8101
}]