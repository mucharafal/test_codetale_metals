[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Why wholestage-off case doesn't get much improvement as wholestage-on case?",
    "commit": "07ff4d3a69967e13438dd8bd3e4130bf23b65c7d",
    "createdAt": "2018-04-28T02:56:09Z",
    "diffHunk": "@@ -222,6 +222,61 @@ class JoinBenchmark extends BenchmarkBase {\n      */\n   }\n \n+  val expensiveFunc = (first: Int, second: Int) => {\n+    for (i <- 1 to 2000) {\n+      Math.sqrt(i * i * i)\n+    }\n+    Math.abs(first - second)\n+  }\n+\n+  def innerRangeTest(N: Int, M: Int): Unit = {\n+    import sparkSession.implicits._\n+    val expUdf = sparkSession.udf.register(\"expensiveFunc\", expensiveFunc)\n+    val df1 = sparkSession.sparkContext.parallelize(1 to M).\n+      cartesian(sparkSession.sparkContext.parallelize(1 to N)).\n+      toDF(\"col1a\", \"col1b\")\n+    val df2 = sparkSession.sparkContext.parallelize(1 to M).\n+      cartesian(sparkSession.sparkContext.parallelize(1 to N)).\n+      toDF(\"col2a\", \"col2b\")\n+    val df = df1.join(df2, 'col1a === 'col2a and ('col1b < 'col2b + 3) and ('col1b > 'col2b - 3))\n+    assert(df.queryExecution.sparkPlan.find(_.isInstanceOf[SortMergeJoinExec]).isDefined)\n+    df.where(expUdf('col1b, 'col2b) < 3).count()\n+  }\n+\n+  ignore(\"sort merge inner range join\") {\n+    sparkSession.conf.set(\"spark.sql.join.smj.useInnerRangeOptimization\", \"false\")\n+    val N = 2 << 5\n+    val M = 100\n+    runBenchmark(\"sort merge inner range join\", N * M) {\n+      innerRangeTest(N, M)\n+    }\n+\n+    /*\n+     *AMD EPYC 7401 24-Core Processor\n+     *sort merge join:                      Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+     *---------------------------------------------------------------------------------------------\n+     *sort merge join wholestage off            13822 / 14068          0.0     2159662.3       1.0X\n+     *sort merge join wholestage on               3863 / 4226          0.0      603547.0       3.6X\n+     */\n+  }\n+\n+  ignore(\"sort merge inner range join optimized\") {\n+    sparkSession.conf.set(\"spark.sql.join.smj.useInnerRangeOptimization\", \"true\")\n+    val N = 2 << 5\n+    val M = 100\n+    runBenchmark(\"sort merge inner range join optimized\", N * M) {\n+      innerRangeTest(N, M)\n+    }\n+\n+    /*\n+     *AMD EPYC 7401 24-Core Processor\n+     *sort merge join:                      Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\n+     *---------------------------------------------------------------------------------------------\n+     *sort merge join wholestage off            12723 / 12800          0.0     1988008.4       1.0X"
  }],
  "prId": 21109
}]