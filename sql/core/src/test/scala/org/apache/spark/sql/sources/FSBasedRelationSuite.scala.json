[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "For append, we can have a little bit more tests. Here are two in my mind:\n- having a df that only will be written to a subset of partitions;\n- having a df that contains new partitioning values (we need to create new dirs).\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T00:16:46Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {\n+  import caseInsensitiveContext._\n+  import caseInsensitiveContext.implicits._\n+\n+  var basePath: Path = _\n+\n+  var fs: FileSystem = _\n+\n+  val dataSchema =\n+    StructType(\n+      Seq(\n+        StructField(\"a\", IntegerType, nullable = false),\n+        StructField(\"b\", StringType, nullable = false)))\n+\n+  val testDF = (for {\n+    i <- 1 to 3\n+    p <- 1 to 2\n+  } yield (i, s\"val_$i\", p)).toDF(\"a\", \"b\", \"p1\")\n+\n+  before {\n+    basePath = new Path(Utils.createTempDir().getCanonicalPath)\n+    fs = basePath.getFileSystem(sparkContext.hadoopConfiguration)\n+    TestResult.reset()\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column not included in data files\") {\n+    fs.mkdirs(new Path(basePath, \"p1=1/p2=hello\"))\n+    fs.mkdirs(new Path(basePath, \"p1=2/p2=world\"))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column included in data files\") {\n+    val data = sparkContext.parallelize(Seq.empty[String])\n+    data.saveAsTextFile(new Path(basePath, \"p1=1/p2=hello\").toString)\n+    data.saveAsTextFile(new Path(basePath, \"p1=2/p2=world\").toString)\n+\n+    val dataSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false)))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Append\") {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Also, when we append to existing dataset, what will happen if the partitioning columns provided in `save` does not match those encoded by the dir structure. For example, we say `partitionColumns = Seq(\"p1\")`, but the existing dir struct is like `/p1=.../p2=...`. \n\nAlso, what will happen if the ordering of partitioning columns does not match? For example, we say `partitionColumns = Seq(\"p1\", \"p2\")`, but the existing dir struct is like `/p2=.../p1=...`. \n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T00:20:16Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {\n+  import caseInsensitiveContext._\n+  import caseInsensitiveContext.implicits._\n+\n+  var basePath: Path = _\n+\n+  var fs: FileSystem = _\n+\n+  val dataSchema =\n+    StructType(\n+      Seq(\n+        StructField(\"a\", IntegerType, nullable = false),\n+        StructField(\"b\", StringType, nullable = false)))\n+\n+  val testDF = (for {\n+    i <- 1 to 3\n+    p <- 1 to 2\n+  } yield (i, s\"val_$i\", p)).toDF(\"a\", \"b\", \"p1\")\n+\n+  before {\n+    basePath = new Path(Utils.createTempDir().getCanonicalPath)\n+    fs = basePath.getFileSystem(sparkContext.hadoopConfiguration)\n+    TestResult.reset()\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column not included in data files\") {\n+    fs.mkdirs(new Path(basePath, \"p1=1/p2=hello\"))\n+    fs.mkdirs(new Path(basePath, \"p1=2/p2=world\"))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column included in data files\") {\n+    val data = sparkContext.parallelize(Seq.empty[String])\n+    data.saveAsTextFile(new Path(basePath, \"p1=1/p2=hello\").toString)\n+    data.saveAsTextFile(new Path(basePath, \"p1=2/p2=world\").toString)\n+\n+    val dataSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false)))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Append\") {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Seems if we want to append and data exist, we need to discover the partitioning structures for `save` method (we do not need it for `saveAsTable`) and make sure we can safely write data.\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T00:24:01Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {\n+  import caseInsensitiveContext._\n+  import caseInsensitiveContext.implicits._\n+\n+  var basePath: Path = _\n+\n+  var fs: FileSystem = _\n+\n+  val dataSchema =\n+    StructType(\n+      Seq(\n+        StructField(\"a\", IntegerType, nullable = false),\n+        StructField(\"b\", StringType, nullable = false)))\n+\n+  val testDF = (for {\n+    i <- 1 to 3\n+    p <- 1 to 2\n+  } yield (i, s\"val_$i\", p)).toDF(\"a\", \"b\", \"p1\")\n+\n+  before {\n+    basePath = new Path(Utils.createTempDir().getCanonicalPath)\n+    fs = basePath.getFileSystem(sparkContext.hadoopConfiguration)\n+    TestResult.reset()\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column not included in data files\") {\n+    fs.mkdirs(new Path(basePath, \"p1=1/p2=hello\"))\n+    fs.mkdirs(new Path(basePath, \"p1=2/p2=world\"))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column included in data files\") {\n+    val data = sparkContext.parallelize(Seq.empty[String])\n+    data.saveAsTextFile(new Path(basePath, \"p1=1/p2=hello\").toString)\n+    data.saveAsTextFile(new Path(basePath, \"p1=2/p2=world\").toString)\n+\n+    val dataSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false)))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Append\") {"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Thank you very much for the extra test cases, they did help me catching more bugs :)\n\nAs for the last issue, currently all `FSBasedRelation` instances do partition discovery while being instantiated. Later we can add `PARTITIONED BY` clause to the data sources DDL, and probably a corresponding overloaded version of `SQLContext.load()` with user defined partition columns schema.\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-29T16:38:16Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {\n+  import caseInsensitiveContext._\n+  import caseInsensitiveContext.implicits._\n+\n+  var basePath: Path = _\n+\n+  var fs: FileSystem = _\n+\n+  val dataSchema =\n+    StructType(\n+      Seq(\n+        StructField(\"a\", IntegerType, nullable = false),\n+        StructField(\"b\", StringType, nullable = false)))\n+\n+  val testDF = (for {\n+    i <- 1 to 3\n+    p <- 1 to 2\n+  } yield (i, s\"val_$i\", p)).toDF(\"a\", \"b\", \"p1\")\n+\n+  before {\n+    basePath = new Path(Utils.createTempDir().getCanonicalPath)\n+    fs = basePath.getFileSystem(sparkContext.hadoopConfiguration)\n+    TestResult.reset()\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column not included in data files\") {\n+    fs.mkdirs(new Path(basePath, \"p1=1/p2=hello\"))\n+    fs.mkdirs(new Path(basePath, \"p1=2/p2=world\"))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column included in data files\") {\n+    val data = sparkContext.parallelize(Seq.empty[String])\n+    data.saveAsTextFile(new Path(basePath, \"p1=1/p2=hello\").toString)\n+    data.saveAsTextFile(new Path(basePath, \"p1=2/p2=world\").toString)\n+\n+    val dataSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false)))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Append\") {"
  }],
  "prId": 5526
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Ignore?\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T19:16:45Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {\n+  import caseInsensitiveContext._\n+  import caseInsensitiveContext.implicits._\n+\n+  var basePath: Path = _\n+\n+  var fs: FileSystem = _\n+\n+  val dataSchema =\n+    StructType(\n+      Seq(\n+        StructField(\"a\", IntegerType, nullable = false),\n+        StructField(\"b\", StringType, nullable = false)))\n+\n+  val testDF = (for {\n+    i <- 1 to 3\n+    p <- 1 to 2\n+  } yield (i, s\"val_$i\", p)).toDF(\"a\", \"b\", \"p1\")\n+\n+  before {\n+    basePath = new Path(Utils.createTempDir().getCanonicalPath)\n+    fs = basePath.getFileSystem(sparkContext.hadoopConfiguration)\n+    TestResult.reset()\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column not included in data files\") {\n+    fs.mkdirs(new Path(basePath, \"p1=1/p2=hello\"))\n+    fs.mkdirs(new Path(basePath, \"p1=2/p2=world\"))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column included in data files\") {\n+    val data = sparkContext.parallelize(Seq.empty[String])\n+    data.saveAsTextFile(new Path(basePath, \"p1=1/p2=hello\").toString)\n+    data.saveAsTextFile(new Path(basePath, \"p1=2/p2=world\").toString)\n+\n+    val dataSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false)))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Append\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Append,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 4) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - ErrorIfExists\") {\n+    fs.delete(basePath, true)\n+\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    assert(TestResult.writtenRows.sameElements(testDF.collect()))\n+\n+    intercept[IOException] {\n+      testDF.save(\n+        source = classOf[SimpleFSBasedSource].getCanonicalName,\n+        mode = SaveMode.Overwrite,\n+        options = Map(\n+          \"path\" -> basePath.toString,\n+          \"schema\" -> dataSchema.json),\n+        partitionColumns = Seq(\"p1\"))\n+    }\n+  }\n+\n+  ignore(\"save() - partitioned table - Ignore\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    assert(TestResult.writtenRows.isEmpty)\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Overwrite\") {\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Append\") {\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Append,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 4) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - ErrorIfExists\") {\n+    fs.delete(basePath, true)\n+\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    assert(TestResult.writtenRows.sameElements(testDF.collect()))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    intercept[IOException] {\n+      testDF.saveAsTable(\n+        tableName = \"t\",\n+        source = classOf[SimpleFSBasedSource].getCanonicalName,\n+        mode = SaveMode.Overwrite,\n+        options = Map(\n+          \"path\" -> basePath.toString,\n+          \"schema\" -> dataSchema.json),\n+        partitionColumns = Seq(\"p1\"))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Ignore\") {\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Oops, thanks.\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T22:49:15Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {\n+  import caseInsensitiveContext._\n+  import caseInsensitiveContext.implicits._\n+\n+  var basePath: Path = _\n+\n+  var fs: FileSystem = _\n+\n+  val dataSchema =\n+    StructType(\n+      Seq(\n+        StructField(\"a\", IntegerType, nullable = false),\n+        StructField(\"b\", StringType, nullable = false)))\n+\n+  val testDF = (for {\n+    i <- 1 to 3\n+    p <- 1 to 2\n+  } yield (i, s\"val_$i\", p)).toDF(\"a\", \"b\", \"p1\")\n+\n+  before {\n+    basePath = new Path(Utils.createTempDir().getCanonicalPath)\n+    fs = basePath.getFileSystem(sparkContext.hadoopConfiguration)\n+    TestResult.reset()\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column not included in data files\") {\n+    fs.mkdirs(new Path(basePath, \"p1=1/p2=hello\"))\n+    fs.mkdirs(new Path(basePath, \"p1=2/p2=world\"))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"load() - partitioned table - partition column included in data files\") {\n+    val data = sparkContext.parallelize(Seq.empty[String])\n+    data.saveAsTextFile(new Path(basePath, \"p1=1/p2=hello\").toString)\n+    data.saveAsTextFile(new Path(basePath, \"p1=2/p2=world\").toString)\n+\n+    val dataSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false)))\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.queryExecution.analyzed.collect {\n+      case LogicalRelation(relation: SimpleFSBasedRelation) =>\n+        assert(relation.dataSchema === dataSchema)\n+      case _ =>\n+        fail(\"Couldn't find expected SimpleFSBasedRelation instance\")\n+    }\n+\n+    val expectedSchema =\n+      StructType(\n+        Seq(\n+          StructField(\"a\", IntegerType, nullable = false),\n+          StructField(\"p1\", IntegerType, nullable = true),\n+          StructField(\"b\", StringType, nullable = false),\n+          StructField(\"p2\", StringType, nullable = true)))\n+\n+    assert(df.schema === expectedSchema)\n+\n+    df.select(\"b\").where($\"a\" > 0 && $\"p1\" === 1).collect()\n+\n+    // Check for column pruning, filter push-down, and partition pruning\n+    assert(TestResult.requiredColumns.toSet === Set(\"a\", \"b\"))\n+    assert(TestResult.filters === Seq(GreaterThan(\"a\", 0)))\n+    assert(TestResult.inputPaths === Seq(new Path(basePath, \"p1=1\").toString))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - Append\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Append,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 4) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+  }\n+\n+  ignore(\"save() - partitioned table - ErrorIfExists\") {\n+    fs.delete(basePath, true)\n+\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    assert(TestResult.writtenRows.sameElements(testDF.collect()))\n+\n+    intercept[IOException] {\n+      testDF.save(\n+        source = classOf[SimpleFSBasedSource].getCanonicalName,\n+        mode = SaveMode.Overwrite,\n+        options = Map(\n+          \"path\" -> basePath.toString,\n+          \"schema\" -> dataSchema.json),\n+        partitionColumns = Seq(\"p1\"))\n+    }\n+  }\n+\n+  ignore(\"save() - partitioned table - Ignore\") {\n+    testDF.save(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    assert(TestResult.writtenRows.isEmpty)\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Overwrite\") {\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Overwrite - select and overwrite the same table\") {\n+    TestResult.rowsToRead = testDF.rdd\n+\n+    val df = load(\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json))\n+\n+    df.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 2) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Append\") {\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Append,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    // Written rows shouldn't contain dynamic partition column\n+    val expectedRows = for (i <- 1 to 3; _ <- 1 to 4) yield Row(i, s\"val_$i\")\n+    assert(TestResult.writtenRows.sameElements(expectedRows))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - ErrorIfExists\") {\n+    fs.delete(basePath, true)\n+\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,\n+      options = Map(\n+        \"path\" -> basePath.toString,\n+        \"schema\" -> dataSchema.json),\n+      partitionColumns = Seq(\"p1\"))\n+\n+    assert(TestResult.writtenRows.sameElements(testDF.collect()))\n+\n+    assertResult(table(\"t\").schema) {\n+      StructType(\n+        dataSchema ++ Seq(\n+          StructField(\"p1\", IntegerType, nullable = true)))\n+    }\n+\n+    intercept[IOException] {\n+      testDF.saveAsTable(\n+        tableName = \"t\",\n+        source = classOf[SimpleFSBasedSource].getCanonicalName,\n+        mode = SaveMode.Overwrite,\n+        options = Map(\n+          \"path\" -> basePath.toString,\n+          \"schema\" -> dataSchema.json),\n+        partitionColumns = Seq(\"p1\"))\n+    }\n+\n+    sql(\"DROP TABLE t\")\n+  }\n+\n+  ignore(\"saveAsTable() - partitioned table - Ignore\") {\n+    testDF.saveAsTable(\n+      tableName = \"t\",\n+      source = classOf[SimpleFSBasedSource].getCanonicalName,\n+      mode = SaveMode.Overwrite,"
  }],
  "prId": 5526
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "This looks pretty good.  I would also add a test case that involves a self join (as those are quite error prone).  I'm not sure how hard this would be, but it would also be awesome if we could use this harness (or something similar) on concrete implementations like json and parquet.\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T19:18:51Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Please also add error message tests for when the functions are called on a datasource that does not support partitioning.\n",
    "commit": "5351a1b7da2bcefe310e053c280b6caa476fb148",
    "createdAt": "2015-04-24T19:54:01Z",
    "diffHunk": "@@ -0,0 +1,425 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.io.IOException\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.hadoop.fs.{FileSystem, Path}\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.{Row, SQLContext, SaveMode}\n+import org.apache.spark.util.Utils\n+\n+class SimpleFSBasedSource extends RelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String]): BaseRelation = {\n+    SimpleFSBasedRelation(parameters)(sqlContext)\n+  }\n+}\n+\n+case class SimpleFSBasedRelation\n+    (parameter: Map[String, String])\n+    (val sqlContext: SQLContext)\n+  extends FSBasedRelation {\n+\n+  class SimpleOutputWriter extends OutputWriter {\n+    override def write(row: Row): Unit = TestResult.writtenRows += row\n+  }\n+\n+  override val path = parameter(\"path\")\n+\n+  override def dataSchema: StructType =\n+    DataType.fromJson(parameter(\"schema\")).asInstanceOf[StructType]\n+\n+  override def buildScan(\n+      requiredColumns: Array[String],\n+      filters: Array[Filter],\n+      inputPaths: Array[String]): RDD[Row] = {\n+    val basePath = new Path(path)\n+    val fs = basePath.getFileSystem(sqlContext.sparkContext.hadoopConfiguration)\n+\n+    // Used to test queries like \"INSERT OVERWRITE tbl SELECT * FROM tbl\". Source directory\n+    // shouldn't be removed before scanning the data.\n+    assert(inputPaths.map(new Path(_)).forall(fs.exists))\n+\n+    TestResult.requiredColumns = requiredColumns\n+    TestResult.filters = filters\n+    TestResult.inputPaths = inputPaths\n+\n+    Option(TestResult.rowsToRead).getOrElse(sqlContext.emptyResult)\n+  }\n+\n+  override def outputWriterClass: Class[_ <: OutputWriter] = classOf[SimpleOutputWriter]\n+}\n+\n+object TestResult {\n+  var requiredColumns: Array[String] = _\n+  var filters: Array[Filter] = _\n+  var inputPaths: Array[String] = _\n+  var rowsToRead: RDD[Row] = _\n+  var writtenRows: ArrayBuffer[Row] = ArrayBuffer.empty[Row]\n+\n+  def reset(): Unit = {\n+    requiredColumns = null\n+    filters = null\n+    inputPaths = null\n+    rowsToRead = null\n+    writtenRows.clear()\n+  }\n+}\n+\n+class FSBasedRelationSuite extends DataSourceTest {"
  }],
  "prId": 5526
}]