[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "(Undo this whitespace change and the next one)",
    "commit": "07ff4d3a69967e13438dd8bd3e4130bf23b65c7d",
    "createdAt": "2018-06-07T12:59:15Z",
    "diffHunk": "@@ -70,27 +70,41 @@ class InnerJoinSuite extends SparkPlanTest with SharedSQLContext {\n     (3, 2)\n   ).toDF(\"a\", \"b\")\n \n+  private lazy val rangeTestData1 = Seq(\n+    (1, 3), (1, 4), (1, 7), (1, 8), (1, 10),\n+    (2, 1), (2, 2), (2, 3), (2, 8),\n+    (3, 1), (3, 2), (3, 3), (3, 5),\n+    (4, 1), (4, 2), (4, 3)\n+  ).toDF(\"a\", \"b\")\n+\n+  private lazy val rangeTestData2 = Seq(\n+    (1, 1), (1, 2), (1, 2), (1, 3), (1, 5), (1, 7), (1, 20),\n+    (2, 1), (2, 2), (2, 3), (2, 5), (2, 6),\n+    (3, 3), (3, 6)\n+  ).toDF(\"a\", \"b\")\n+\n   // Note: the input dataframes and expression must be evaluated lazily because\n   // the SQLContext should be used only within a test to keep SQL tests stable\n   private def testInnerJoin(\n-      testName: String,\n-      leftRows: => DataFrame,\n-      rightRows: => DataFrame,\n-      condition: () => Expression,\n-      expectedAnswer: Seq[Product]): Unit = {\n+                             testName: String,\n+                             leftRows: => DataFrame,\n+                             rightRows: => DataFrame,\n+                             condition: () => Expression,\n+                             expectedAnswer: Seq[Product],\n+                             expectRangeJoin: Boolean = false): Unit = {\n \n     def extractJoinParts(): Option[ExtractEquiJoinKeys.ReturnType] = {\n       val join = Join(leftRows.logicalPlan, rightRows.logicalPlan, Inner, Some(condition()))\n       ExtractEquiJoinKeys.unapply(join)\n     }\n \n     def makeBroadcastHashJoin(\n-        leftKeys: Seq[Expression],\n-        rightKeys: Seq[Expression],\n-        boundCondition: Option[Expression],\n-        leftPlan: SparkPlan,\n-        rightPlan: SparkPlan,\n-        side: BuildSide) = {\n+                               leftKeys: Seq[Expression],"
  }],
  "prId": 21109
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "If you want to avoid a `var`, just `configOptions.zipWithIndex.foreach { case ((config, confValue), counter) =>`. Just a tiny bit more idiomatic.",
    "commit": "07ff4d3a69967e13438dd8bd3e4130bf23b65c7d",
    "createdAt": "2018-06-07T13:00:56Z",
    "diffHunk": "@@ -117,101 +131,170 @@ class InnerJoinSuite extends SparkPlanTest with SharedSQLContext {\n     }\n \n     def makeSortMergeJoin(\n-        leftKeys: Seq[Expression],\n-        rightKeys: Seq[Expression],\n-        boundCondition: Option[Expression],\n-        leftPlan: SparkPlan,\n-        rightPlan: SparkPlan) = {\n-      val sortMergeJoin = joins.SortMergeJoinExec(leftKeys, rightKeys, Inner, boundCondition,\n-        leftPlan, rightPlan)\n+                           leftKeys: Seq[Expression],\n+                           rightKeys: Seq[Expression],\n+                           boundCondition: Option[Expression],\n+                           rangeConditions: Seq[BinaryComparison],\n+                           leftPlan: SparkPlan,\n+                           rightPlan: SparkPlan) = {\n+      val sortMergeJoin = joins.SortMergeJoinExec(leftKeys, rightKeys, Inner, rangeConditions,\n+        boundCondition, leftPlan, rightPlan)\n       EnsureRequirements(spark.sessionState.conf).apply(sortMergeJoin)\n     }\n \n-    test(s\"$testName using BroadcastHashJoin (build=left)\") {\n-      extractJoinParts().foreach { case (_, leftKeys, rightKeys, boundCondition, _, _) =>\n-        withSQLConf(SQLConf.SHUFFLE_PARTITIONS.key -> \"1\") {\n-          checkAnswer2(leftRows, rightRows, (leftPlan: SparkPlan, rightPlan: SparkPlan) =>\n-            makeBroadcastHashJoin(\n-              leftKeys, rightKeys, boundCondition, leftPlan, rightPlan, joins.BuildLeft),\n-            expectedAnswer.map(Row.fromTuple),\n-            sortAnswers = true)\n+    val configOptions = List(\n+      (\"spark.sql.codegen.wholeStage\", \"true\"),\n+      (\"spark.sql.codegen.wholeStage\", \"false\"))\n+\n+    // Disabling these because the code would never follow this path in case of a inner range join\n+    if (!expectRangeJoin) {\n+      var counter = 1"
  }, {
    "author": {
      "login": "zecevicp"
    },
    "body": "OK, will do that.",
    "commit": "07ff4d3a69967e13438dd8bd3e4130bf23b65c7d",
    "createdAt": "2018-06-07T13:52:20Z",
    "diffHunk": "@@ -117,101 +131,170 @@ class InnerJoinSuite extends SparkPlanTest with SharedSQLContext {\n     }\n \n     def makeSortMergeJoin(\n-        leftKeys: Seq[Expression],\n-        rightKeys: Seq[Expression],\n-        boundCondition: Option[Expression],\n-        leftPlan: SparkPlan,\n-        rightPlan: SparkPlan) = {\n-      val sortMergeJoin = joins.SortMergeJoinExec(leftKeys, rightKeys, Inner, boundCondition,\n-        leftPlan, rightPlan)\n+                           leftKeys: Seq[Expression],\n+                           rightKeys: Seq[Expression],\n+                           boundCondition: Option[Expression],\n+                           rangeConditions: Seq[BinaryComparison],\n+                           leftPlan: SparkPlan,\n+                           rightPlan: SparkPlan) = {\n+      val sortMergeJoin = joins.SortMergeJoinExec(leftKeys, rightKeys, Inner, rangeConditions,\n+        boundCondition, leftPlan, rightPlan)\n       EnsureRequirements(spark.sessionState.conf).apply(sortMergeJoin)\n     }\n \n-    test(s\"$testName using BroadcastHashJoin (build=left)\") {\n-      extractJoinParts().foreach { case (_, leftKeys, rightKeys, boundCondition, _, _) =>\n-        withSQLConf(SQLConf.SHUFFLE_PARTITIONS.key -> \"1\") {\n-          checkAnswer2(leftRows, rightRows, (leftPlan: SparkPlan, rightPlan: SparkPlan) =>\n-            makeBroadcastHashJoin(\n-              leftKeys, rightKeys, boundCondition, leftPlan, rightPlan, joins.BuildLeft),\n-            expectedAnswer.map(Row.fromTuple),\n-            sortAnswers = true)\n+    val configOptions = List(\n+      (\"spark.sql.codegen.wholeStage\", \"true\"),\n+      (\"spark.sql.codegen.wholeStage\", \"false\"))\n+\n+    // Disabling these because the code would never follow this path in case of a inner range join\n+    if (!expectRangeJoin) {\n+      var counter = 1"
  }],
  "prId": 21109
}]