[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Same general comment as PlanTestBase vs PlanTest above",
    "commit": "6c0b0d569ae1d779fd9253da0c7e97d12634063c",
    "createdAt": "2017-10-23T07:44:08Z",
    "diffHunk": "@@ -52,249 +36,23 @@ import org.apache.spark.util.{UninterruptibleThread, Utils}\n  * Subclasses should *not* create `SQLContext`s in the test suite constructor, which is\n  * prone to leaving multiple overlapping [[org.apache.spark.SparkContext]]s in the same JVM.\n  */\n-private[sql] trait SQLTestUtils\n-  extends SparkFunSuite with Eventually\n-  with BeforeAndAfterAll\n-  with SQLTestData\n-  with PlanTest { self =>\n-\n-  protected def sparkContext = spark.sparkContext\n-\n+private[sql] trait SQLTestUtils extends SparkFunSuite with SQLTestUtilsBase with PlanTest {"
  }, {
    "author": {
      "login": "nkronenfeld"
    },
    "body": "This has more changes - I left the data initialization stuff in SQLTestUtils, as it wouldn't be needed by external tests.  All the <'s below are things that I pulled out of SQLTestUtilsBase and put back into SQLTestUtils\r\n\r\nRunning similarly:\r\n\r\n    git checkout 4a779bdac3e75c17b7d36c5a009ba6c948fa9fb6 SQLTestUtils.scala\r\n    diff SQLTestUtils.scala SQLTestUtilsBase.scala\r\n\r\nI get\r\n\r\n    27d26\r\n    < import scala.util.control.NonFatal\r\n    30c29\r\n    < import org.scalatest.BeforeAndAfterAll\r\n    ---\r\n    > import org.scalatest.{BeforeAndAfterAll, Suite}\r\n    33d31\r\n    < import org.apache.spark.SparkFunSuite\r\n    38c36\r\n    < import org.apache.spark.sql.catalyst.plans.PlanTest\r\n    ---\r\n    > import org.apache.spark.sql.catalyst.plans.PlanTestBase\r\n    40d37\r\n    < import org.apache.spark.sql.catalyst.util._\r\n    43c40\r\n    < import org.apache.spark.util.{UninterruptibleThread, Utils}\r\n    ---\r\n    > import org.apache.spark.util.Utils\r\n    46c43\r\n    <  * Helper trait that should be extended by all SQL test suites.\r\n    ---\r\n    >  * Helper trait that can be extended by all external SQL test suites.\r\n    48,49c45\r\n    <  * This allows subclasses to plugin a custom `SQLContext`. It comes with test data\r\n    <  * prepared in advance as well as all implicit conversions used extensively by dataframes.\r\n    ---\r\n    >  * This allows subclasses to plugin a custom `SQLContext`.\r\n    55,56c51,52\r\n    < private[sql] trait SQLTestUtils\r\n    <   extends SparkFunSuite with Eventually\r\n    ---\r\n    > private[sql] trait SQLTestUtilsBase\r\n    >   extends Eventually\r\n    59c55\r\n    <   with PlanTest { self =>\r\n    ---\r\n    >   with PlanTestBase { self: Suite =>\r\n    63,65d58\r\n    <   // Whether to materialize all test data before the first test is run\r\n    <   private var loadTestDataBeforeTests = false\r\n    < \r\n    80,94d72\r\n    <   /**\r\n    <    * Materialize the test data immediately after the `SQLContext` is set up.\r\n    <    * This is necessary if the data is accessed by name but not through direct reference.\r\n    <    */\r\n    <   protected def setupTestData(): Unit = {\r\n    <     loadTestDataBeforeTests = true\r\n    <   }\r\n    < \r\n    <   protected override def beforeAll(): Unit = {\r\n    <     super.beforeAll()\r\n    <     if (loadTestDataBeforeTests) {\r\n    <       loadTestData()\r\n    <     }\r\n    <   }\r\n    < \r\n    300,354d277\r\n    <   /**\r\n    <    * Disable stdout and stderr when running the test. To not output the logs to the console,\r\n    <    * ConsoleAppender's `follow` should be set to `true` so that it will honors reassignments of\r\n    <    * System.out or System.err. Otherwise, ConsoleAppender will still output to the console even if\r\n    <    * we change System.out and System.err.\r\n    <    */\r\n    <   protected def testQuietly(name: String)(f: => Unit): Unit = {\r\n    <     test(name) {\r\n    <       quietly {\r\n    <         f\r\n    <       }\r\n    <     }\r\n    <   }\r\n    < \r\n    <   /**\r\n    <    * Run a test on a separate `UninterruptibleThread`.\r\n    <    */\r\n    <   protected def testWithUninterruptibleThread(name: String, quietly: Boolean = false)\r\n    <     (body: => Unit): Unit = {\r\n    <     val timeoutMillis = 10000\r\n    <     @transient var ex: Throwable = null\r\n    < \r\n    <     def runOnThread(): Unit = {\r\n    <       val thread = new UninterruptibleThread(s\"Testing thread for test $name\") {\r\n    <         override def run(): Unit = {\r\n    <           try {\r\n    <             body\r\n    <           } catch {\r\n    <             case NonFatal(e) =>\r\n    <               ex = e\r\n    <           }\r\n    <         }\r\n    <       }\r\n    <       thread.setDaemon(true)\r\n    <       thread.start()\r\n    <       thread.join(timeoutMillis)\r\n    <       if (thread.isAlive) {\r\n    <         thread.interrupt()\r\n    <         // If this interrupt does not work, then this thread is most likely running something that\r\n    <         // is not interruptible. There is not much point to wait for the thread to termniate, and\r\n    <         // we rather let the JVM terminate the thread on exit.\r\n    <         fail(\r\n    <           s\"Test '$name' running on o.a.s.util.UninterruptibleThread timed out after\" +\r\n    <             s\" $timeoutMillis ms\")\r\n    <       } else if (ex != null) {\r\n    <         throw ex\r\n    <       }\r\n    <     }\r\n    < \r\n    <     if (quietly) {\r\n    <       testQuietly(name) { runOnThread() }\r\n    <     } else {\r\n    <       test(name) { runOnThread() }\r\n    <     }\r\n    <   }\r\n    365,407d287\r\n    <   }\r\n    < }\r\n    < \r\n    < private[sql] object SQLTestUtils {\r\n    < \r\n    <   def compareAnswers(\r\n    <       sparkAnswer: Seq[Row],\r\n    <       expectedAnswer: Seq[Row],\r\n    <       sort: Boolean): Option[String] = {\r\n    <     def prepareAnswer(answer: Seq[Row]): Seq[Row] = {\r\n    <       // Converts data to types that we can do equality comparison using Scala collections.\r\n    <       // For BigDecimal type, the Scala type has a better definition of equality test (similar to\r\n    <       // Java's java.math.BigDecimal.compareTo).\r\n    <       // For binary arrays, we convert it to Seq to avoid of calling java.util.Arrays.equals for\r\n    <       // equality test.\r\n    <       // This function is copied from Catalyst's QueryTest\r\n    <       val converted: Seq[Row] = answer.map { s =>\r\n    <         Row.fromSeq(s.toSeq.map {\r\n    <           case d: java.math.BigDecimal => BigDecimal(d)\r\n    <           case b: Array[Byte] => b.toSeq\r\n    <           case o => o\r\n    <         })\r\n    <       }\r\n    <       if (sort) {\r\n    <         converted.sortBy(_.toString())\r\n    <       } else {\r\n    <         converted\r\n    <       }\r\n    <     }\r\n    <     if (prepareAnswer(expectedAnswer) != prepareAnswer(sparkAnswer)) {\r\n    <       val errorMessage =\r\n    <         s\"\"\"\r\n    <            | == Results ==\r\n    <            | ${sideBySide(\r\n    <           s\"== Expected Answer - ${expectedAnswer.size} ==\" +:\r\n    <             prepareAnswer(expectedAnswer).map(_.toString()),\r\n    <           s\"== Actual Answer - ${sparkAnswer.size} ==\" +:\r\n    <             prepareAnswer(sparkAnswer).map(_.toString())).mkString(\"\\n\")}\r\n    <       \"\"\".stripMargin\r\n    <       Some(errorMessage)\r\n    <     } else {\r\n    <       None\r\n    <     }\r\n    ",
    "commit": "6c0b0d569ae1d779fd9253da0c7e97d12634063c",
    "createdAt": "2017-10-23T15:50:15Z",
    "diffHunk": "@@ -52,249 +36,23 @@ import org.apache.spark.util.{UninterruptibleThread, Utils}\n  * Subclasses should *not* create `SQLContext`s in the test suite constructor, which is\n  * prone to leaving multiple overlapping [[org.apache.spark.SparkContext]]s in the same JVM.\n  */\n-private[sql] trait SQLTestUtils\n-  extends SparkFunSuite with Eventually\n-  with BeforeAndAfterAll\n-  with SQLTestData\n-  with PlanTest { self =>\n-\n-  protected def sparkContext = spark.sparkContext\n-\n+private[sql] trait SQLTestUtils extends SparkFunSuite with SQLTestUtilsBase with PlanTest {"
  }],
  "prId": 19529
}, {
  "comments": [{
    "author": {
      "login": "jiangxb1987"
    },
    "body": "Could you move this after `SQLTestUtilsBase` ?",
    "commit": "6c0b0d569ae1d779fd9253da0c7e97d12634063c",
    "createdAt": "2017-10-24T15:17:51Z",
    "diffHunk": "@@ -52,17 +55,142 @@ import org.apache.spark.util.{UninterruptibleThread, Utils}\n  * Subclasses should *not* create `SQLContext`s in the test suite constructor, which is\n  * prone to leaving multiple overlapping [[org.apache.spark.SparkContext]]s in the same JVM.\n  */\n-private[sql] trait SQLTestUtils\n-  extends SparkFunSuite with Eventually\n+private[sql] trait SQLTestUtils extends SparkFunSuite with SQLTestUtilsBase with PlanTest {\n+  // Whether to materialize all test data before the first test is run\n+  private var loadTestDataBeforeTests = false\n+\n+  protected override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    if (loadTestDataBeforeTests) {\n+      loadTestData()\n+    }\n+  }\n+\n+  /**\n+   * Materialize the test data immediately after the `SQLContext` is set up.\n+   * This is necessary if the data is accessed by name but not through direct reference.\n+   */\n+  protected def setupTestData(): Unit = {\n+    loadTestDataBeforeTests = true\n+  }\n+\n+  /**\n+   * Disable stdout and stderr when running the test. To not output the logs to the console,\n+   * ConsoleAppender's `follow` should be set to `true` so that it will honors reassignments of\n+   * System.out or System.err. Otherwise, ConsoleAppender will still output to the console even if\n+   * we change System.out and System.err.\n+   */\n+  protected def testQuietly(name: String)(f: => Unit): Unit = {\n+    test(name) {\n+      quietly {\n+        f\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Run a test on a separate `UninterruptibleThread`.\n+   */\n+  protected def testWithUninterruptibleThread(name: String, quietly: Boolean = false)\n+    (body: => Unit): Unit = {\n+    val timeoutMillis = 10000\n+    @transient var ex: Throwable = null\n+\n+    def runOnThread(): Unit = {\n+      val thread = new UninterruptibleThread(s\"Testing thread for test $name\") {\n+        override def run(): Unit = {\n+          try {\n+            body\n+          } catch {\n+            case NonFatal(e) =>\n+              ex = e\n+          }\n+        }\n+      }\n+      thread.setDaemon(true)\n+      thread.start()\n+      thread.join(timeoutMillis)\n+      if (thread.isAlive) {\n+        thread.interrupt()\n+        // If this interrupt does not work, then this thread is most likely running something that\n+        // is not interruptible. There is not much point to wait for the thread to termniate, and\n+        // we rather let the JVM terminate the thread on exit.\n+        fail(\n+          s\"Test '$name' running on o.a.s.util.UninterruptibleThread timed out after\" +\n+            s\" $timeoutMillis ms\")\n+      } else if (ex != null) {\n+        throw ex\n+      }\n+    }\n+\n+    if (quietly) {\n+      testQuietly(name) { runOnThread() }\n+    } else {\n+      test(name) { runOnThread() }\n+    }\n+  }\n+}\n+\n+private[sql] object SQLTestUtils {"
  }, {
    "author": {
      "login": "nkronenfeld"
    },
    "body": "done",
    "commit": "6c0b0d569ae1d779fd9253da0c7e97d12634063c",
    "createdAt": "2017-10-25T15:00:27Z",
    "diffHunk": "@@ -52,17 +55,142 @@ import org.apache.spark.util.{UninterruptibleThread, Utils}\n  * Subclasses should *not* create `SQLContext`s in the test suite constructor, which is\n  * prone to leaving multiple overlapping [[org.apache.spark.SparkContext]]s in the same JVM.\n  */\n-private[sql] trait SQLTestUtils\n-  extends SparkFunSuite with Eventually\n+private[sql] trait SQLTestUtils extends SparkFunSuite with SQLTestUtilsBase with PlanTest {\n+  // Whether to materialize all test data before the first test is run\n+  private var loadTestDataBeforeTests = false\n+\n+  protected override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    if (loadTestDataBeforeTests) {\n+      loadTestData()\n+    }\n+  }\n+\n+  /**\n+   * Materialize the test data immediately after the `SQLContext` is set up.\n+   * This is necessary if the data is accessed by name but not through direct reference.\n+   */\n+  protected def setupTestData(): Unit = {\n+    loadTestDataBeforeTests = true\n+  }\n+\n+  /**\n+   * Disable stdout and stderr when running the test. To not output the logs to the console,\n+   * ConsoleAppender's `follow` should be set to `true` so that it will honors reassignments of\n+   * System.out or System.err. Otherwise, ConsoleAppender will still output to the console even if\n+   * we change System.out and System.err.\n+   */\n+  protected def testQuietly(name: String)(f: => Unit): Unit = {\n+    test(name) {\n+      quietly {\n+        f\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Run a test on a separate `UninterruptibleThread`.\n+   */\n+  protected def testWithUninterruptibleThread(name: String, quietly: Boolean = false)\n+    (body: => Unit): Unit = {\n+    val timeoutMillis = 10000\n+    @transient var ex: Throwable = null\n+\n+    def runOnThread(): Unit = {\n+      val thread = new UninterruptibleThread(s\"Testing thread for test $name\") {\n+        override def run(): Unit = {\n+          try {\n+            body\n+          } catch {\n+            case NonFatal(e) =>\n+              ex = e\n+          }\n+        }\n+      }\n+      thread.setDaemon(true)\n+      thread.start()\n+      thread.join(timeoutMillis)\n+      if (thread.isAlive) {\n+        thread.interrupt()\n+        // If this interrupt does not work, then this thread is most likely running something that\n+        // is not interruptible. There is not much point to wait for the thread to termniate, and\n+        // we rather let the JVM terminate the thread on exit.\n+        fail(\n+          s\"Test '$name' running on o.a.s.util.UninterruptibleThread timed out after\" +\n+            s\" $timeoutMillis ms\")\n+      } else if (ex != null) {\n+        throw ex\n+      }\n+    }\n+\n+    if (quietly) {\n+      testQuietly(name) { runOnThread() }\n+    } else {\n+      test(name) { runOnThread() }\n+    }\n+  }\n+}\n+\n+private[sql] object SQLTestUtils {"
  }],
  "prId": 19529
}]