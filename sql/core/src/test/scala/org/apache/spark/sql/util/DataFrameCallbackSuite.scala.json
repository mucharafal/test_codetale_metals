[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about we update `onSuccess` to only collect commands we are interested?",
    "commit": "f63b773ad924fdd39eacf8ed53ece6966deba9ca",
    "createdAt": "2017-04-21T03:08:53Z",
    "diffHunk": "@@ -183,21 +183,22 @@ class DataFrameCallbackSuite extends QueryTest with SharedSQLContext {\n     }\n \n     withTable(\"tab\") {\n-      sql(\"CREATE TABLE tab(i long) using parquet\")\n+      sql(\"CREATE TABLE tab(i long) using parquet\") // adds commands(1) via onSuccess\n       spark.range(10).write.insertInto(\"tab\")\n-      assert(commands.length == 2)\n-      assert(commands(1)._1 == \"insertInto\")\n-      assert(commands(1)._2.isInstanceOf[InsertIntoTable])\n-      assert(commands(1)._2.asInstanceOf[InsertIntoTable].table\n+      assert(commands.length == 3)\n+      assert(commands(2)._1 == \"insertInto\")\n+      assert(commands(2)._2.isInstanceOf[InsertIntoTable])\n+      assert(commands(2)._2.asInstanceOf[InsertIntoTable].table\n         .asInstanceOf[UnresolvedRelation].tableIdentifier.table == \"tab\")\n     }\n+    // exiting withTable adds commands(3) via onSuccess (drops tab)",
    "line": 17
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I don't think it is a good idea to come up with a way to exclude commands, since this is captured by a listener. Simply noting that onSuccess will issue a drop command is sufficient.",
    "commit": "f63b773ad924fdd39eacf8ed53ece6966deba9ca",
    "createdAt": "2017-04-21T04:21:59Z",
    "diffHunk": "@@ -183,21 +183,22 @@ class DataFrameCallbackSuite extends QueryTest with SharedSQLContext {\n     }\n \n     withTable(\"tab\") {\n-      sql(\"CREATE TABLE tab(i long) using parquet\")\n+      sql(\"CREATE TABLE tab(i long) using parquet\") // adds commands(1) via onSuccess\n       spark.range(10).write.insertInto(\"tab\")\n-      assert(commands.length == 2)\n-      assert(commands(1)._1 == \"insertInto\")\n-      assert(commands(1)._2.isInstanceOf[InsertIntoTable])\n-      assert(commands(1)._2.asInstanceOf[InsertIntoTable].table\n+      assert(commands.length == 3)\n+      assert(commands(2)._1 == \"insertInto\")\n+      assert(commands(2)._2.isInstanceOf[InsertIntoTable])\n+      assert(commands(2)._2.asInstanceOf[InsertIntoTable].table\n         .asInstanceOf[UnresolvedRelation].tableIdentifier.table == \"tab\")\n     }\n+    // exiting withTable adds commands(3) via onSuccess (drops tab)",
    "line": 17
  }],
  "prId": 17540
}]