[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "add tests below to make sure includeTimestamp errors are checked. \n",
    "commit": "8f97b66f55ececd91434a3f9a3b28dd6c5412d46",
    "createdAt": "2016-07-01T22:44:56Z",
    "diffHunk": "@@ -85,6 +86,47 @@ class TextSocketStreamSuite extends StreamTest with SharedSQLContext with Before\n     }\n   }\n \n+  test(\"timestamped usage\") {\n+    serverThread = new ServerThread()\n+    serverThread.start()\n+\n+    val provider = new TextSocketSourceProvider\n+    val parameters = Map(\"host\" -> \"localhost\", \"port\" -> serverThread.port.toString,\n+      \"includeTimestamp\" -> \"true\")\n+    val schema = provider.sourceSchema(sqlContext, None, \"\", parameters)._2\n+    assert(schema === StructType(StructField(\"value\", StringType) ::\n+      StructField(\"timestamp\", TimestampType) :: Nil))\n+\n+    source = provider.createSource(sqlContext, \"\", None, \"\", parameters)\n+\n+    failAfter(streamingTimeout) {\n+      serverThread.enqueue(\"hello\")\n+      while (source.getOffset.isEmpty) {\n+        Thread.sleep(10)\n+      }\n+      val offset1 = source.getOffset.get\n+      val batch1 = source.getBatch(None, offset1)\n+      val batch1Seq = batch1.as[(String, Timestamp)].collect().toSeq\n+      assert(batch1Seq.map(_._1) === Seq(\"hello\"))\n+      val batch1Stamp = batch1Seq(0)._2\n+\n+      serverThread.enqueue(\"world\")\n+      while (source.getOffset.get === offset1) {\n+        Thread.sleep(10)\n+      }\n+      val offset2 = source.getOffset.get\n+      val batch2 = source.getBatch(Some(offset1), offset2)\n+      val batch2Seq = batch2.as[(String, Timestamp)].collect().toSeq\n+      assert(batch2Seq.map(_._1) === Seq(\"world\"))\n+      val batch2Stamp = batch2Seq(0)._2\n+      assert(!batch2Stamp.before(batch1Stamp))\n+\n+      // Try stopping the source to make sure this does not block forever.\n+      source.stop()\n+      source = null\n+    }\n+  }\n+",
    "line": 61
  }],
  "prId": 13957
}]