[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "The first `null` here should be an empty `Seq`. The schema of the testing Parquet data file is:\n\n```\nmessage TestProtobuf.SchemaConverterRepetition {\n  optional int32 optionalPrimitive;\n  required int32 requiredPrimitive;\n  repeated int32 repeatedPrimitive;\n  optional group optionalMessage {\n    optional int32 someId;\n  }\n  required group requiredMessage {\n    optional int32 someId;\n  }\n  repeated group repeatedMessage {\n    optional int32 someId;\n  }\n}\n```\n\nAs stated by parquet-format spec, `repeatedPrimitive` should be interpreted as a required list of required elements, so it should never be null.\n",
    "commit": "fb23f28875871f82148a25838db723ddd67f9d05",
    "createdAt": "2015-08-10T16:02:58Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+package org.apache.spark.sql.parquet\n+\n+import java.net.URL\n+\n+import org.apache.parquet.schema.{GroupType, PrimitiveType, MessageType}\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.{Row, QueryTest, DataFrame, SQLContext}\n+import org.apache.spark.sql.catalyst.expressions.{GenericRow, Attribute}\n+import org.apache.spark.sql.test.TestSQLContext\n+import org.scalatest.FunSuite\n+\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+class ProtoParquetTypesConverterTest extends QueryTest with ParquetTest {\n+  override val sqlContext: SQLContext = TestSQLContext\n+\n+  def fetchRows(file: String, table: String ): Array[Row] = {\n+    val resource: URL = getClass.getResource(file)\n+    val pf: DataFrame = sqlContext.read.parquet(resource.toURI.toString)\n+    pf.registerTempTable(table)\n+    sqlContext.sql(\"select * from \"  + table).collect()\n+  }\n+\n+  test(\"should work with repeated primitive\") {\n+    val rows: Array[Row] = fetchRows(\"/old-repeated-int.parquet\", \"repeated_int\")\n+    assert(rows(0) == Row(Seq(1,2,3)))\n+  }\n+\n+  test(\"should work with repeated complex\") {\n+    val rows: Array[Row] = fetchRows(\"/old-repeated-message.parquet\", \"repeated_struct\")\n+    val array: mutable.WrappedArray[GenericRow] = rows(0)(0).asInstanceOf[mutable.WrappedArray[GenericRow]]\n+    assert(array.length === 3)\n+    assert(array(0)=== Row(\"First inner\",null,null))\n+    assert(array(1) === Row(null,\"Second inner\",null))\n+    assert(array(2) === Row(null, null,\"Third inner\"))\n+  }\n+\n+\n+  test(\"should work with repeated complex with more than one item in array\") {\n+    val rows: Array[Row] = fetchRows(\"/proto-repeated-struct.parquet\", \"my_complex_table\")\n+    assert(rows.length === 1)\n+    val array: mutable.WrappedArray[GenericRow] = rows(0)(0).asInstanceOf[mutable.WrappedArray[GenericRow]]\n+    assert(array.length === 2)\n+    assert(array(0) === Row(\"0 - 1\", \"0 - 2\", \"0 - 3\"))\n+    assert(array(1) === Row(\"1 - 1\", \"1 - 2\", \"1 - 3\"))\n+  }\n+\n+  test(\"should work with repeated complex with many rows\") {\n+    val rows: Array[Row] = fetchRows(\"/proto-struct-with-array-many.parquet\", \"many_complex_rows\")\n+    assert(rows.length === 3)\n+    val row0: mutable.WrappedArray[GenericRow] = rows(0)(0).asInstanceOf[mutable.WrappedArray[GenericRow]]\n+    val row1: mutable.WrappedArray[GenericRow] = rows(1)(0).asInstanceOf[mutable.WrappedArray[GenericRow]]\n+    val row2: mutable.WrappedArray[GenericRow] = rows(2)(0).asInstanceOf[mutable.WrappedArray[GenericRow]]\n+    assert(row0(0) === Row(\"0 - 0 - 1\", \"0 - 0 - 2\",\"0 - 0 - 3\"))\n+    assert(row0(1)=== Row(\"0 - 1 - 1\", \"0 - 1 - 2\", \"0 - 1 - 3\"))\n+    assert(row1(0) === Row(\"1 - 0 - 1\", \"1 - 0 - 2\",\"1 - 0 - 3\"))\n+    assert(row1(1) === Row(\"1 - 1 - 1\", \"1 - 1 - 2\", \"1 - 1 - 3\"))\n+    assert(row2(0) === Row(\"2 - 0 - 1\", \"2 - 0 - 2\",\"2 - 0 - 3\"))\n+    assert(row2(1) === Row(\"2 - 1 - 1\", \"2 - 1 - 2\", \"2 - 1 - 3\"))\n+  }\n+\n+  test(\"should work with complex type containing array\") {\n+    val rows: Array[Row] = fetchRows(\"/proto-struct-with-array.parquet\", \"struct_containing_array\")\n+    assert(rows.length === 1)\n+    val theRow: GenericRow = rows(0).asInstanceOf[GenericRow]\n+    val expected = Row(10,9,null,null,Row(9),Seq(Row(9),Row(10)))",
    "line": 68
  }],
  "prId": 8063
}]