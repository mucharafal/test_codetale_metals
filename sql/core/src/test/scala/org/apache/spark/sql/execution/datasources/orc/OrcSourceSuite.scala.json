[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "@kevinyu98 . This works, but there is a side effect with this. I mean this creates additional directory who name is '*' literally. And, newly inserted data go into that directory.",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-11-27T20:34:06Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "kevinyu98"
    },
    "body": "@dongjoon-hyun Hello Dongjoon, yes, you are right. It will create a directory with the name is '*', and it is the same behavior prior spark 2.4. I was just following the examples from the jira. Do you have any suggestions here? Thanks.",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-11-28T21:42:51Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I have two suggestions.\r\n\r\n1. Is this PR aiming only one-level subdirectories? Could you check the behavior on one, two, three level subdirectories in Parquet Hive tables first?\r\n2. Since the test case looks general for both Parquet/ORC, please add a test case for Parquet while you are here.",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-11-29T02:49:35Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "kevinyu98"
    },
    "body": "@dongjoon-hyun Thanks for the suggestions. I tried with three level subdirectores for Parquet/ORC. Here is the result:\r\n\r\nsql(\"set spark.sql.hive.convertMetastoreOrc=true\")\r\n\r\n three level directories\r\n\r\n ORC:\r\n\r\n \r\n\r\n - \"/*\" can read sub directory data, but not three level subdirectories \r\n - \"/\"  can only read current directory\r\n\r\n Parquet:\r\n\r\n - \"/*\" can read sub directory data, but not three level subdirectories\r\n - \"/\"  can only read current directory\r\n \r\n\r\n sql(\"set spark.sql.hive.convertMetastoreOrc=false\")\r\n\r\n ORC:\r\n\r\n - \"/\"  can read three level subdirectories\r\n - \"/*\" can't read any data\r\n\r\n parquet:\r\n\r\n - \"/\"  can only read current directory\r\n - \"/*\" can read sub directory data, but not three level subdirectories.\r\n\r\nWith sql(\"set spark.sql.hive.convertMetastoreOrc=true\"), the ORC and Parquet behavior is consistent. \r\n1. I think this PR is aiming only one-level subdirectores.\r\n2. Sure, I will add one more for Parquet.\r\n\r\n",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-11-29T22:58:33Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thank you for investigating. I agree with you for (1). For the test case, please add three-level subdirectories. That will help us to improve Spark later. You may file another JIRA issue for that as a new feature JIRA.",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-11-30T17:58:07Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "kevinyu98"
    },
    "body": "@dongjoon-hyun Sorry for the delay. My got some issues with my Intellij environment. Sure, I will add three level subdirectories for this PR. FYI, I also tried with `convertMetastoreParquet` for Parquet, the behavior is consistent. \r\nsql(\"set spark.sql.hive.convertMetastoreParquet = true\")\r\n\r\nthree level \r\n\r\nParquet:\r\n\r\n-- \"/\"  can only read current directory\r\n-- \"/*\" can read sub directory data, but not three level subdirectories.\r\n\r\nsql(\"set spark.sql.hive.convertMetastoreParquet = false\")\r\n\r\n-- \"/\"  can only read current directory\r\n-- \"/*\" can read sub directory data, but not three level subdirectories.\r\n",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-12-03T17:40:25Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "kevinyu98"
    },
    "body": "@dongjoon-hyun I forgot to add three level subdirectores in the last commit, I am adding now, will submit soon. ",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-12-03T22:51:08Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thanks, @kevinyu98 . Also, please update the title and description of this PR and SPARK-25993 JIRA issue.\r\n```\r\n- [Spark-25993][SQL][TEST]Add test cases for resolution of ORC table location \r\n+ [SPARK-25993][SQL][TEST] Add test cases for CREATE EXTERNAL TABLE with subdirectories\r\n```",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-12-04T04:07:48Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }, {
    "author": {
      "login": "kevinyu98"
    },
    "body": "done",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-12-05T22:43:55Z",
    "diffHunk": "@@ -186,6 +186,54 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {\n+    val tableName1 = \"spark_orc1\"\n+    val tableName2 = \"spark_orc2\"\n+\n+    withTempDir { dir =>\n+      val someDF1 = Seq((1, 1, \"orc1\"), (2, 2, \"orc2\")).toDF(\"c1\", \"c2\", \"c3\").repartition(1)\n+      withTable(tableName1, tableName2) {\n+        val dataDir = s\"${dir.getCanonicalPath}/dir1/\"\n+        val parentDir = s\"${dir.getCanonicalPath}/\"\n+        val wildCardDir = new File(s\"${dir}/*\").toURI\n+        someDF1.write.orc(dataDir)\n+        val parentDirStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName1(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '${parentDir}'\"\"\".stripMargin\n+        sql(parentDirStatement)\n+        val parentDirSqlStatement = s\"select * from ${tableName1}\"\n+        if (isConvertMetastore) {\n+          checkAnswer(sql(parentDirSqlStatement), Nil)\n+        } else {\n+         checkAnswer(sql(parentDirSqlStatement),\n+           (1 to 2).map(i => Row(i, i, s\"orc$i\")))\n+        }\n+\n+        val wildCardStatement =\n+          s\"\"\"\n+             |CREATE EXTERNAL TABLE $tableName2(\n+             |  c1 int,\n+             |  c2 int,\n+             |  c3 string)\n+             |STORED AS orc\n+             |LOCATION '$wildCardDir'\"\"\".stripMargin"
  }],
  "prId": 23108
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Since this test helper function is only used in `HiveOrcSourceSuite`, can we move this into `HiveOrcSourceSuite`?",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-12-05T06:34:35Z",
    "diffHunk": "@@ -186,6 +186,82 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {"
  }, {
    "author": {
      "login": "kevinyu98"
    },
    "body": "ok, I moved.",
    "commit": "fef8c6845ccce792474a8c65ee6ebfd9624bb4b4",
    "createdAt": "2018-12-05T22:44:49Z",
    "diffHunk": "@@ -186,6 +186,82 @@ abstract class OrcSuite extends OrcTest with BeforeAndAfterAll {\n     }\n   }\n \n+  protected def testORCTableLocation(isConvertMetastore: Boolean): Unit = {"
  }],
  "prId": 23108
}]