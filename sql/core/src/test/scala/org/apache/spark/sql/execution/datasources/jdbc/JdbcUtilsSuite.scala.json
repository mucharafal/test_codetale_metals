[{
  "comments": [{
    "author": {
      "login": "dilipbiswal"
    },
    "body": "> Without these changes we had to copy most of the spark jdbc package into our own codebase\r\nto allow us to create our own connection factory\r\n\r\nTrying to understand. So here we are passing JDBCOptions which is a spark class. I thought one of the goal was to make the custom connection factory code to not depend on spark classes ? \r\n",
    "commit": "edd3245ed5604dee2aad56c3ee0b8f99d76b48a0",
    "createdAt": "2018-09-26T23:14:23Z",
    "diffHunk": "@@ -65,4 +67,60 @@ class JdbcUtilsSuite extends SparkFunSuite {\n     }\n     assert(mismatchedInput.getMessage.contains(\"mismatched input '.' expecting\"))\n   }\n+\n+  test(\"Custom ConnectionFactory falls back to default when no factory specified\") {\n+    val options = new JDBCOptions(Map[String, String](\n+      \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+      \"dbtable\" -> \"table\")\n+    )\n+    assert(options.connectionFactoryProvider eq DefaultConnectionFactoryProvider)\n+  }\n+\n+  test(\"JdbcUtils uses the specified connection factory\") {\n+    val options = new JDBCOptions(Map[String, String](\n+      \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+      \"dbtable\" -> \"table\",\n+      JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER ->\n+        \"org.apache.spark.sql.execution.datasources.jdbc.TestFactory\")\n+    )\n+    val x = intercept[RuntimeException] {\n+      JdbcUtils.createConnectionFactory(options)()\n+    }\n+    assert(x.getMessage == \"This message will be tested in test\")\n+  }\n+\n+  test(\"invalid connection factory throws IllegalArgumentException\") {\n+\n+    val nonexisting = intercept[IllegalArgumentException] {\n+      new JDBCOptions(Map[String, String](\n+        \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+        \"dbtable\" -> \"table\",\n+        JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER -> \"notexistingclass\")\n+      )\n+    }\n+    assert(nonexisting.getMessage == \"notexistingclass is not a valid ConnectionFactoryProvider\")\n+\n+    val missingTrait = intercept[IllegalArgumentException] {\n+      new JDBCOptions(Map[String, String](\n+        \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+        \"dbtable\" -> \"table\",\n+        JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER ->\n+          \"org.apache.spark.sql.execution.datasources.jdbc.BadFactory\")\n+      )\n+    }\n+    assert(missingTrait.getMessage ==\n+      \"org.apache.spark.sql.execution.datasources.jdbc.BadFactory\" +\n+        \" is not a valid ConnectionFactoryProvider\")\n+\n+  }\n+}\n+\n+// this one does not implement ConnectionFactoryProvider\n+class BadFactory {\n+\n+}\n+\n+class TestFactory extends ConnectionFactoryProvider {\n+  override def createConnectionFactory(options: JDBCOptions): () => Connection =",
    "line": 67
  }, {
    "author": {
      "login": "fsauer65"
    },
    "body": "The intent is for the spark jdbc package to allow for custom connection factories by specifying a classname in the options to spark.sql.read. This class has to implement the trait ConnectionFactoryProvider which in this new setup would also be provided by spark jdbc. The only reason we had to copy code into our code base was to make changes to JdbcUtils to allow this and for those classes in spark jdbc that use JdbcUtils.createConnectionFactory to use ours instead. This PR would allow for this behavior out of the box but use the default factory when no className for a ConnectionFactoryProvider is specified.",
    "commit": "edd3245ed5604dee2aad56c3ee0b8f99d76b48a0",
    "createdAt": "2018-09-26T23:44:20Z",
    "diffHunk": "@@ -65,4 +67,60 @@ class JdbcUtilsSuite extends SparkFunSuite {\n     }\n     assert(mismatchedInput.getMessage.contains(\"mismatched input '.' expecting\"))\n   }\n+\n+  test(\"Custom ConnectionFactory falls back to default when no factory specified\") {\n+    val options = new JDBCOptions(Map[String, String](\n+      \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+      \"dbtable\" -> \"table\")\n+    )\n+    assert(options.connectionFactoryProvider eq DefaultConnectionFactoryProvider)\n+  }\n+\n+  test(\"JdbcUtils uses the specified connection factory\") {\n+    val options = new JDBCOptions(Map[String, String](\n+      \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+      \"dbtable\" -> \"table\",\n+      JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER ->\n+        \"org.apache.spark.sql.execution.datasources.jdbc.TestFactory\")\n+    )\n+    val x = intercept[RuntimeException] {\n+      JdbcUtils.createConnectionFactory(options)()\n+    }\n+    assert(x.getMessage == \"This message will be tested in test\")\n+  }\n+\n+  test(\"invalid connection factory throws IllegalArgumentException\") {\n+\n+    val nonexisting = intercept[IllegalArgumentException] {\n+      new JDBCOptions(Map[String, String](\n+        \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+        \"dbtable\" -> \"table\",\n+        JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER -> \"notexistingclass\")\n+      )\n+    }\n+    assert(nonexisting.getMessage == \"notexistingclass is not a valid ConnectionFactoryProvider\")\n+\n+    val missingTrait = intercept[IllegalArgumentException] {\n+      new JDBCOptions(Map[String, String](\n+        \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+        \"dbtable\" -> \"table\",\n+        JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER ->\n+          \"org.apache.spark.sql.execution.datasources.jdbc.BadFactory\")\n+      )\n+    }\n+    assert(missingTrait.getMessage ==\n+      \"org.apache.spark.sql.execution.datasources.jdbc.BadFactory\" +\n+        \" is not a valid ConnectionFactoryProvider\")\n+\n+  }\n+}\n+\n+// this one does not implement ConnectionFactoryProvider\n+class BadFactory {\n+\n+}\n+\n+class TestFactory extends ConnectionFactoryProvider {\n+  override def createConnectionFactory(options: JDBCOptions): () => Connection =",
    "line": 67
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "I see. OK. ",
    "commit": "edd3245ed5604dee2aad56c3ee0b8f99d76b48a0",
    "createdAt": "2018-09-26T23:50:52Z",
    "diffHunk": "@@ -65,4 +67,60 @@ class JdbcUtilsSuite extends SparkFunSuite {\n     }\n     assert(mismatchedInput.getMessage.contains(\"mismatched input '.' expecting\"))\n   }\n+\n+  test(\"Custom ConnectionFactory falls back to default when no factory specified\") {\n+    val options = new JDBCOptions(Map[String, String](\n+      \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+      \"dbtable\" -> \"table\")\n+    )\n+    assert(options.connectionFactoryProvider eq DefaultConnectionFactoryProvider)\n+  }\n+\n+  test(\"JdbcUtils uses the specified connection factory\") {\n+    val options = new JDBCOptions(Map[String, String](\n+      \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+      \"dbtable\" -> \"table\",\n+      JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER ->\n+        \"org.apache.spark.sql.execution.datasources.jdbc.TestFactory\")\n+    )\n+    val x = intercept[RuntimeException] {\n+      JdbcUtils.createConnectionFactory(options)()\n+    }\n+    assert(x.getMessage == \"This message will be tested in test\")\n+  }\n+\n+  test(\"invalid connection factory throws IllegalArgumentException\") {\n+\n+    val nonexisting = intercept[IllegalArgumentException] {\n+      new JDBCOptions(Map[String, String](\n+        \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+        \"dbtable\" -> \"table\",\n+        JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER -> \"notexistingclass\")\n+      )\n+    }\n+    assert(nonexisting.getMessage == \"notexistingclass is not a valid ConnectionFactoryProvider\")\n+\n+    val missingTrait = intercept[IllegalArgumentException] {\n+      new JDBCOptions(Map[String, String](\n+        \"url\" -> \"jdbc:mysql://foo.com/bar\",\n+        \"dbtable\" -> \"table\",\n+        JDBCOptions.JDBC_CONNECTION_FACTORY_PROVIDER ->\n+          \"org.apache.spark.sql.execution.datasources.jdbc.BadFactory\")\n+      )\n+    }\n+    assert(missingTrait.getMessage ==\n+      \"org.apache.spark.sql.execution.datasources.jdbc.BadFactory\" +\n+        \" is not a valid ConnectionFactoryProvider\")\n+\n+  }\n+}\n+\n+// this one does not implement ConnectionFactoryProvider\n+class BadFactory {\n+\n+}\n+\n+class TestFactory extends ConnectionFactoryProvider {\n+  override def createConnectionFactory(options: JDBCOptions): () => Connection =",
    "line": 67
  }],
  "prId": 22560
}]