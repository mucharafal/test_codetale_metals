[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can we also test dropping all the fields of a struct-type column?",
    "commit": "1f821986e7458ca4b87c898d6c3c6d73b0ac78ad",
    "createdAt": "2019-08-29T12:19:02Z",
    "diffHunk": "@@ -0,0 +1,850 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.test.SharedSparkSession\n+import org.apache.spark.sql.types._\n+\n+trait AlterTableTests extends SharedSparkSession {\n+\n+  protected def getTableMetadata(tableName: String): Table\n+\n+  protected val catalogAndNamespace: String\n+\n+  protected val v2Format: String\n+\n+  private def fullTableName(tableName: String): String = {\n+    if (catalogAndNamespace.isEmpty) {\n+      s\"default.$tableName\"\n+    } else {\n+      s\"${catalogAndNamespace}table_name\"\n+    }\n+  }\n+\n+  test(\"AlterTable: table does not exist\") {\n+    val t2 = s\"${catalogAndNamespace}fake_table\"\n+    withTable(t2) {\n+      sql(s\"CREATE TABLE $t2 (id int) USING $v2Format\")\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE ${catalogAndNamespace}table_name DROP COLUMN id\")\n+      }\n+\n+      assert(exc.getMessage.contains(s\"${catalogAndNamespace}table_name\"))\n+      assert(exc.getMessage.contains(\"Table or view not found\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: change rejected by implementation\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[SparkException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN id\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"Unsupported table change\"))\n+      assert(exc.getMessage.contains(\"Cannot drop all fields\")) // from the implementation",
    "line": 66
  }],
  "prId": 25502
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we test updating table property?",
    "commit": "1f821986e7458ca4b87c898d6c3c6d73b0ac78ad",
    "createdAt": "2019-08-29T12:19:39Z",
    "diffHunk": "@@ -0,0 +1,850 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.test.SharedSparkSession\n+import org.apache.spark.sql.types._\n+\n+trait AlterTableTests extends SharedSparkSession {\n+\n+  protected def getTableMetadata(tableName: String): Table\n+\n+  protected val catalogAndNamespace: String\n+\n+  protected val v2Format: String\n+\n+  private def fullTableName(tableName: String): String = {\n+    if (catalogAndNamespace.isEmpty) {\n+      s\"default.$tableName\"\n+    } else {\n+      s\"${catalogAndNamespace}table_name\"\n+    }\n+  }\n+\n+  test(\"AlterTable: table does not exist\") {\n+    val t2 = s\"${catalogAndNamespace}fake_table\"\n+    withTable(t2) {\n+      sql(s\"CREATE TABLE $t2 (id int) USING $v2Format\")\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE ${catalogAndNamespace}table_name DROP COLUMN id\")\n+      }\n+\n+      assert(exc.getMessage.contains(s\"${catalogAndNamespace}table_name\"))\n+      assert(exc.getMessage.contains(\"Table or view not found\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: change rejected by implementation\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[SparkException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN id\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"Unsupported table change\"))\n+      assert(exc.getMessage.contains(\"Cannot drop all fields\")) // from the implementation\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", IntegerType))\n+    }\n+  }\n+\n+  test(\"AlterTable: add top-level column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN data string\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", IntegerType).add(\"data\", StringType))\n+    }\n+  }\n+\n+  test(\"AlterTable: add column with comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN data string COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(\n+        StructField(\"id\", IntegerType),\n+        StructField(\"data\", StringType).withComment(\"doc\"))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add multiple columns\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMNS data string COMMENT 'doc', ts timestamp\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(\n+        StructField(\"id\", IntegerType),\n+        StructField(\"data\", StringType).withComment(\"doc\"),\n+        StructField(\"ts\", TimestampType))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN point.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column to map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.key.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column to map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.value.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column to array element\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.element.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add complex column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points array<struct<x: double, y: double>>\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column with comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.element.z double COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType).withComment(\"doc\"))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column parent must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ADD COLUMN point.z double\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column type int -> long\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN id TYPE bigint\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", LongType))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type float -> double\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: float, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN point.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column with struct type fails\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN point TYPE struct<x: double, y: double, z: double>\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point\"))\n+      assert(exc.getMessage.contains(\"update a struct by adding, deleting, or updating its fields\"))\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column with array type fails\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<int>) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN points TYPE array<long>\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"update the element by updating points.element\"))\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(IntegerType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column array element type\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<int>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.element TYPE long\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column with map type fails\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, m map<string, int>) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN m TYPE map<string, long>\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"update a map by updating m.key or m.value\"))\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"m\", MapType(StringType, IntegerType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column map value type\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, m map<string, int>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN m.value TYPE long\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"m\", MapType(StringType, LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<struct<x: float, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.key.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: float, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.value.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type in array\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: float, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.element.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN data TYPE string\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN point.x TYPE double\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column type must be compatible\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN id TYPE boolean\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"id\"))\n+      assert(exc.getMessage.contains(\"int cannot be cast to boolean\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN id COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(StructField(\"id\", IntegerType).withComment(\"doc\"))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column type and comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN id TYPE bigint COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(StructField(\"id\", LongType).withComment(\"doc\"))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN point.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\")))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.key.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\"))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.value.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\"))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment in array\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.element.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\"))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: comment update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN data COMMENT 'doc'\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested comment update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN point.x COMMENT 'doc'\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN id TO user_id\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"user_id\", IntegerType))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN point.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN point.key.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN points.value.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column in array element\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN points.element.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t RENAME COLUMN data TO some_string\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested rename column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t RENAME COLUMN point.x TO z\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, data string) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN data\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", IntegerType))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double, t: double>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN point.t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN point.key.y\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN points.value.y\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column in array element\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN points.element.y\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN data\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested drop column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN point.x\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: set location\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t SET LOCATION 's3://bucket/path'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.properties ===\n+        Map(\"provider\" -> v2Format, \"location\" -> \"s3://bucket/path\").asJava)\n+    }\n+  }\n+\n+  test(\"AlterTable: set table property\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t SET TBLPROPERTIES ('test'='34')\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.properties === Map(\"provider\" -> v2Format, \"test\" -> \"34\").asJava)\n+    }\n+  }\n+\n+  test(\"AlterTable: remove table property\") {",
    "line": 831
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I just realized that these are existing tests. Feel free to address these comments in followup.",
    "commit": "1f821986e7458ca4b87c898d6c3c6d73b0ac78ad",
    "createdAt": "2019-08-29T12:22:00Z",
    "diffHunk": "@@ -0,0 +1,850 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.test.SharedSparkSession\n+import org.apache.spark.sql.types._\n+\n+trait AlterTableTests extends SharedSparkSession {\n+\n+  protected def getTableMetadata(tableName: String): Table\n+\n+  protected val catalogAndNamespace: String\n+\n+  protected val v2Format: String\n+\n+  private def fullTableName(tableName: String): String = {\n+    if (catalogAndNamespace.isEmpty) {\n+      s\"default.$tableName\"\n+    } else {\n+      s\"${catalogAndNamespace}table_name\"\n+    }\n+  }\n+\n+  test(\"AlterTable: table does not exist\") {\n+    val t2 = s\"${catalogAndNamespace}fake_table\"\n+    withTable(t2) {\n+      sql(s\"CREATE TABLE $t2 (id int) USING $v2Format\")\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE ${catalogAndNamespace}table_name DROP COLUMN id\")\n+      }\n+\n+      assert(exc.getMessage.contains(s\"${catalogAndNamespace}table_name\"))\n+      assert(exc.getMessage.contains(\"Table or view not found\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: change rejected by implementation\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[SparkException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN id\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"Unsupported table change\"))\n+      assert(exc.getMessage.contains(\"Cannot drop all fields\")) // from the implementation\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", IntegerType))\n+    }\n+  }\n+\n+  test(\"AlterTable: add top-level column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN data string\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", IntegerType).add(\"data\", StringType))\n+    }\n+  }\n+\n+  test(\"AlterTable: add column with comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN data string COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(\n+        StructField(\"id\", IntegerType),\n+        StructField(\"data\", StringType).withComment(\"doc\"))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add multiple columns\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMNS data string COMMENT 'doc', ts timestamp\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(\n+        StructField(\"id\", IntegerType),\n+        StructField(\"data\", StringType).withComment(\"doc\"),\n+        StructField(\"ts\", TimestampType))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN point.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column to map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.key.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column to map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.value.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column to array element\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.element.z double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add complex column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points array<struct<x: double, y: double>>\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column with comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ADD COLUMN points.element.z double COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType),\n+          StructField(\"z\", DoubleType).withComment(\"doc\"))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: add nested column parent must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ADD COLUMN point.z double\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column type int -> long\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN id TYPE bigint\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", LongType))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type float -> double\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: float, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN point.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column with struct type fails\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN point TYPE struct<x: double, y: double, z: double>\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point\"))\n+      assert(exc.getMessage.contains(\"update a struct by adding, deleting, or updating its fields\"))\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column with array type fails\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<int>) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN points TYPE array<long>\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"update the element by updating points.element\"))\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(IntegerType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column array element type\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<int>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.element TYPE long\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column with map type fails\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, m map<string, int>) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN m TYPE map<string, long>\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"update a map by updating m.key or m.value\"))\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"m\", MapType(StringType, IntegerType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column map value type\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, m map<string, int>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN m.value TYPE long\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"m\", MapType(StringType, LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<struct<x: float, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.key.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: float, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.value.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested type in array\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: float, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.element.x TYPE double\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN data TYPE string\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN point.x TYPE double\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column type must be compatible\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN id TYPE boolean\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"id\"))\n+      assert(exc.getMessage.contains(\"int cannot be cast to boolean\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN id COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(StructField(\"id\", IntegerType).withComment(\"doc\"))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update column type and comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN id TYPE bigint COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === StructType(Seq(StructField(\"id\", LongType).withComment(\"doc\"))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN point.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\")))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.key.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\"))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.value.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\"))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: update nested column comment in array\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t ALTER COLUMN points.element.y COMMENT 'doc'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType).withComment(\"doc\"))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: comment update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN data COMMENT 'doc'\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested comment update column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t ALTER COLUMN point.x COMMENT 'doc'\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN id TO user_id\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"user_id\", IntegerType))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN point.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN point.key.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN points.value.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename nested column in array element\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t RENAME COLUMN points.element.y TO t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"t\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: rename column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t RENAME COLUMN data TO some_string\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested rename column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t RENAME COLUMN point.x TO z\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, data string) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN data\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType().add(\"id\", IntegerType))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point struct<x: double, y: double, t: double>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN point.t\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", StructType(Seq(\n+          StructField(\"x\", DoubleType),\n+          StructField(\"y\", DoubleType)))))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column in map key\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, point map<struct<x: double, y: double>, bigint>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN point.key.y\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"point\", MapType(StructType(Seq(\n+          StructField(\"x\", DoubleType))), LongType)))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column in map value\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points map<string, struct<x: double, y: double>>) \" +\n+        s\"USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN points.value.y\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", MapType(StringType, StructType(Seq(\n+          StructField(\"x\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop nested column in array element\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int, points array<struct<x: double, y: double>>) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t DROP COLUMN points.element.y\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.schema === new StructType()\n+        .add(\"id\", IntegerType)\n+        .add(\"points\", ArrayType(StructType(Seq(\n+          StructField(\"x\", DoubleType))))))\n+    }\n+  }\n+\n+  test(\"AlterTable: drop column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN data\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"data\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: nested drop column must exist\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+\n+      val exc = intercept[AnalysisException] {\n+        sql(s\"ALTER TABLE $t DROP COLUMN point.x\")\n+      }\n+\n+      assert(exc.getMessage.contains(\"point.x\"))\n+      assert(exc.getMessage.contains(\"missing field\"))\n+    }\n+  }\n+\n+  test(\"AlterTable: set location\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t SET LOCATION 's3://bucket/path'\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.properties ===\n+        Map(\"provider\" -> v2Format, \"location\" -> \"s3://bucket/path\").asJava)\n+    }\n+  }\n+\n+  test(\"AlterTable: set table property\") {\n+    val t = s\"${catalogAndNamespace}table_name\"\n+    withTable(t) {\n+      sql(s\"CREATE TABLE $t (id int) USING $v2Format\")\n+      sql(s\"ALTER TABLE $t SET TBLPROPERTIES ('test'='34')\")\n+\n+      val table = getTableMetadata(t)\n+\n+      assert(table.name === fullTableName(t))\n+      assert(table.properties === Map(\"provider\" -> v2Format, \"test\" -> \"34\").asJava)\n+    }\n+  }\n+\n+  test(\"AlterTable: remove table property\") {",
    "line": 831
  }],
  "prId": 25502
}]