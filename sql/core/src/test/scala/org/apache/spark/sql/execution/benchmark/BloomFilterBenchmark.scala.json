[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "I think we should also add this ORC feature to the SQL doc. ",
    "commit": "6e917e57db33a92274e79de9906194fb650a9171",
    "createdAt": "2018-10-05T02:19:28Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.benchmark\n+\n+import scala.util.Random\n+\n+import org.apache.spark.benchmark.Benchmark\n+\n+/**\n+ * Benchmark to measure read performance with Bloom filters.\n+ *\n+ * Currently, only ORC supports bloom filters, we will add Parquet BM as soon as it becomes\n+ * available.\n+ *\n+ * To run this benchmark:\n+ * {{{\n+ *   1. without sbt: bin/spark-submit --class <this class> <spark sql test jar>\n+ *   2. build/sbt \"sql/test:runMain <this class>\"\n+ *   3. generate result: SPARK_GENERATE_BENCHMARK_FILES=1 build/sbt \"sql/test:runMain <this class>\"\n+ *      Results will be written to \"benchmarks/BloomFilterBenchmark-results.txt\".\n+ * }}}\n+ */\n+object BloomFilterBenchmark extends SqlBasedBenchmark {\n+  import spark.implicits._\n+\n+  private val scaleFactor = 100\n+  private val N = scaleFactor * 1000 * 1000\n+  private val df = spark.range(N).map(_ => Random.nextInt)\n+\n+  private def writeBenchmark(): Unit = {\n+    withTempPath { dir =>\n+      val path = dir.getCanonicalPath\n+\n+      runBenchmark(s\"ORC Write\") {\n+        val benchmark = new Benchmark(s\"Write ${scaleFactor}M rows\", N, output = output)\n+        benchmark.addCase(\"Without bloom filter\") { _ =>\n+          df.write.mode(\"overwrite\").orc(path + \"/withoutBF\")\n+        }\n+        benchmark.addCase(\"With bloom filter\") { _ =>\n+          df.write.mode(\"overwrite\")\n+            .option(\"orc.bloom.filter.columns\", \"value\").orc(path + \"/withBF\")\n+        }\n+        benchmark.run()\n+      }\n+    }\n+  }\n+\n+  private def readBenchmark(): Unit = {\n+    withTempPath { dir =>\n+      val path = dir.getCanonicalPath\n+\n+      df.write.orc(path + \"/withoutBF\")\n+      df.write.option(\"orc.bloom.filter.columns\", \"value\").orc(path + \"/withBF\")",
    "line": 68
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Sorry, but Apache ORC is an independent Apache project which has its own website and documents. We should respect that. If we introduce new ORC configuration one by one in Apache Spark website, it will eventually duplicate Apache ORC document in Apache Spark document.\r\n\r\nWe had better guide ORC fans to Apache ORC website. If something is missing there, they can file an ORC JIRA, not SPARK JIRA.\r\n",
    "commit": "6e917e57db33a92274e79de9906194fb650a9171",
    "createdAt": "2018-10-05T03:19:40Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.benchmark\n+\n+import scala.util.Random\n+\n+import org.apache.spark.benchmark.Benchmark\n+\n+/**\n+ * Benchmark to measure read performance with Bloom filters.\n+ *\n+ * Currently, only ORC supports bloom filters, we will add Parquet BM as soon as it becomes\n+ * available.\n+ *\n+ * To run this benchmark:\n+ * {{{\n+ *   1. without sbt: bin/spark-submit --class <this class> <spark sql test jar>\n+ *   2. build/sbt \"sql/test:runMain <this class>\"\n+ *   3. generate result: SPARK_GENERATE_BENCHMARK_FILES=1 build/sbt \"sql/test:runMain <this class>\"\n+ *      Results will be written to \"benchmarks/BloomFilterBenchmark-results.txt\".\n+ * }}}\n+ */\n+object BloomFilterBenchmark extends SqlBasedBenchmark {\n+  import spark.implicits._\n+\n+  private val scaleFactor = 100\n+  private val N = scaleFactor * 1000 * 1000\n+  private val df = spark.range(N).map(_ => Random.nextInt)\n+\n+  private def writeBenchmark(): Unit = {\n+    withTempPath { dir =>\n+      val path = dir.getCanonicalPath\n+\n+      runBenchmark(s\"ORC Write\") {\n+        val benchmark = new Benchmark(s\"Write ${scaleFactor}M rows\", N, output = output)\n+        benchmark.addCase(\"Without bloom filter\") { _ =>\n+          df.write.mode(\"overwrite\").orc(path + \"/withoutBF\")\n+        }\n+        benchmark.addCase(\"With bloom filter\") { _ =>\n+          df.write.mode(\"overwrite\")\n+            .option(\"orc.bloom.filter.columns\", \"value\").orc(path + \"/withBF\")\n+        }\n+        benchmark.run()\n+      }\n+    }\n+  }\n+\n+  private def readBenchmark(): Unit = {\n+    withTempPath { dir =>\n+      val path = dir.getCanonicalPath\n+\n+      df.write.orc(path + \"/withoutBF\")\n+      df.write.option(\"orc.bloom.filter.columns\", \"value\").orc(path + \"/withBF\")",
    "line": 68
  }],
  "prId": 22605
}]