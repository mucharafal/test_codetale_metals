[{
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "I find this case a little odd. I think it makes sense to layer on in-memory tables because we need to return the same table instance. But why create an in-memory shadow table for tables that already exist?",
    "commit": "27598ce9b5ef7bc8224e37df6f14907e766ddd54",
    "createdAt": "2019-08-20T23:59:56Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2.utils\n+\n+import java.util\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.sql.catalog.v2.Identifier\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.execution.datasources.v2.V2SessionCatalog\n+import org.apache.spark.sql.sources.v2.Table\n+import org.apache.spark.sql.types.StructType\n+\n+/** A SessionCatalog that always loads an in memory Table, so we can test write code paths. */\n+private[v2] trait TestV2SessionCatalogBase[T <: Table] extends V2SessionCatalog {\n+\n+  protected val tables: util.Map[Identifier, T] = new ConcurrentHashMap[Identifier, T]()\n+\n+  protected def newTable(\n+      name: String,\n+      schema: StructType,\n+      partitions: Array[Transform],\n+      properties: util.Map[String, String]): T\n+\n+  private def fullIdentifier(ident: Identifier): Identifier = {\n+    if (ident.namespace().isEmpty) {\n+      Identifier.of(Array(\"default\"), ident.name())\n+    } else {\n+      ident\n+    }\n+  }\n+\n+  override def loadTable(ident: Identifier): Table = {\n+    val fullIdent = fullIdentifier(ident)\n+    if (tables.containsKey(fullIdent)) {\n+      tables.get(fullIdent)\n+    } else {\n+      // Table was created through the built-in catalog",
    "line": 59
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Nevermind, I get it.",
    "commit": "27598ce9b5ef7bc8224e37df6f14907e766ddd54",
    "createdAt": "2019-08-21T00:01:37Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2.utils\n+\n+import java.util\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.sql.catalog.v2.Identifier\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.execution.datasources.v2.V2SessionCatalog\n+import org.apache.spark.sql.sources.v2.Table\n+import org.apache.spark.sql.types.StructType\n+\n+/** A SessionCatalog that always loads an in memory Table, so we can test write code paths. */\n+private[v2] trait TestV2SessionCatalogBase[T <: Table] extends V2SessionCatalog {\n+\n+  protected val tables: util.Map[Identifier, T] = new ConcurrentHashMap[Identifier, T]()\n+\n+  protected def newTable(\n+      name: String,\n+      schema: StructType,\n+      partitions: Array[Transform],\n+      properties: util.Map[String, String]): T\n+\n+  private def fullIdentifier(ident: Identifier): Identifier = {\n+    if (ident.namespace().isEmpty) {\n+      Identifier.of(Array(\"default\"), ident.name())\n+    } else {\n+      ident\n+    }\n+  }\n+\n+  override def loadTable(ident: Identifier): Table = {\n+    val fullIdent = fullIdentifier(ident)\n+    if (tables.containsKey(fullIdent)) {\n+      tables.get(fullIdent)\n+    } else {\n+      // Table was created through the built-in catalog",
    "line": 59
  }],
  "prId": 25348
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "This doesn't always load an in-memory table, since `newTable` is abstract. Can you update the docs to be a bit more clear about what this does?",
    "commit": "27598ce9b5ef7bc8224e37df6f14907e766ddd54",
    "createdAt": "2019-08-21T00:02:19Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2.utils\n+\n+import java.util\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.sql.catalog.v2.Identifier\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.execution.datasources.v2.V2SessionCatalog\n+import org.apache.spark.sql.sources.v2.Table\n+import org.apache.spark.sql.types.StructType\n+\n+/** A SessionCatalog that always loads an in memory Table, so we can test write code paths. */"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I'm not sure that it makes sense for this to be separate, since the table cache is in memory but tables aren't necessarily in memory.",
    "commit": "27598ce9b5ef7bc8224e37df6f14907e766ddd54",
    "createdAt": "2019-08-21T00:02:45Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources.v2.utils\n+\n+import java.util\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.sql.catalog.v2.Identifier\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.execution.datasources.v2.V2SessionCatalog\n+import org.apache.spark.sql.sources.v2.Table\n+import org.apache.spark.sql.types.StructType\n+\n+/** A SessionCatalog that always loads an in memory Table, so we can test write code paths. */"
  }],
  "prId": 25348
}]