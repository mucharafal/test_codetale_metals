[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`after3 > after2`?",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-24T04:15:53Z",
    "diffHunk": "@@ -228,4 +229,21 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "rednaxelafx"
    },
    "body": "I actually deliberately wrote it this way. Note how I phrased in the assertion message as \"can result in codegen cache miss\" instead of \"will result in\".\r\n\r\nThat's because the code shape of this third query was deliberately chosen to be similar to the two queries before it: all three have `spark.range(some_const).select(some_expr).collect`, so if any future changes to codegen of `Range` or `Project` operators affect how much specialized code (such as constant values) we directly embed into the code, it's actually possible for this third query to generate the same code as the first two, which will result in a codegen cache hit -- the bytecode-compiled method count would therefore be the same.\r\n\r\nSo I'm making this check a bit loose. It's just there to indicate that it's acceptable to for a different query to encounter a codegen cache miss. WYDT?",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-24T04:58:58Z",
    "diffHunk": "@@ -228,4 +229,21 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "makes sense",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-24T05:25:45Z",
    "diffHunk": "@@ -228,4 +229,21 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }],
  "prId": 20224
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "nit: `a different query can result in codegen cache miss, that's okay` seems a misleading error message for the assert.",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T07:50:08Z",
    "diffHunk": "@@ -228,4 +229,35 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "rednaxelafx"
    },
    "body": "That assert is actually \"useless\" in the sense that the CodegenMetrics are always monotonically increasing, so `after3 >= after2` will always be true (note the `=` in there). I only put it in to show the intent that it's by design that a different query can cause codegen cache miss.\r\n\r\nWould you have any concrete suggestions in wording that assertion message? I'm totally open to suggestions here. I can move the current message into a comment and make the assert message look more like an assert message",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T08:04:25Z",
    "diffHunk": "@@ -228,4 +229,35 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "It is an error message so it's weird to use it to explain this assert. I think you can make it as a comment to explain the assert and remove the error message.",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T08:06:46Z",
    "diffHunk": "@@ -228,4 +229,35 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ok seems this assert is not very useful, how about we just remove it? We can just add a comment before `assert(after1 == after2, \"the same query run twice should hit the codegen cache\")` and say that different queries can cause codegen cache miss, so this assert proves the query is same?",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T08:18:47Z",
    "diffHunk": "@@ -228,4 +229,35 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "+1",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T08:26:33Z",
    "diffHunk": "@@ -228,4 +229,35 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }, {
    "author": {
      "login": "rednaxelafx"
    },
    "body": "Thanks for the suggestions, @viirya and @cloud-fan ! I'll move the assert message to a comment in the next update.",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T09:13:12Z",
    "diffHunk": "@@ -228,4 +229,35 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"the same query run twice should hit the codegen cache\")\n+\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"a different query can result in codegen cache miss, that's okay\")"
  }],
  "prId": 20224
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "hmm, I think we can just remove the above 3 lines and add a comment before L258, to say that the CodegenMetrics are always monotonically increasing, so `after1 == after2` proves we hit the codegen cache.",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T09:35:47Z",
    "diffHunk": "@@ -228,4 +229,38 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+\n+      // the same query run twice should hit the codegen cache\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"Should hit codegen cache. No new compilation to bytecode expected\")\n+\n+      // a different query can result in codegen cache miss, that's by design\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"always\")"
  }, {
    "author": {
      "login": "rednaxelafx"
    },
    "body": "I like that. Updating now.",
    "commit": "fd8983edaee5fe9a7968de45a174d6781128296e",
    "createdAt": "2018-01-25T10:16:13Z",
    "diffHunk": "@@ -228,4 +229,38 @@ class WholeStageCodegenSuite extends QueryTest with SharedSQLContext {\n       }\n     }\n   }\n+\n+  test(\"codegen stage IDs should be preserved in transformations after CollapseCodegenStages\") {\n+    // test case adapted from DataFrameSuite to trigger ReuseExchange\n+    withSQLConf(SQLConf.AUTO_BROADCASTJOIN_THRESHOLD.key -> \"2\") {\n+      val df = spark.range(100)\n+      val join = df.join(df, \"id\")\n+      val plan = join.queryExecution.executedPlan\n+      assert(!plan.find(p =>\n+        p.isInstanceOf[WholeStageCodegenExec] &&\n+          p.asInstanceOf[WholeStageCodegenExec].codegenStageId == 0).isDefined,\n+        \"codegen stage IDs should be preserved through ReuseExchange\")\n+      checkAnswer(join, df.toDF)\n+    }\n+  }\n+\n+  test(\"including codegen stage ID in generated class name should not regress codegen caching\") {\n+    import testImplicits._\n+\n+    withSQLConf(SQLConf.WHOLESTAGE_CODEGEN_USE_ID_IN_CLASS_NAME.key -> \"true\") {\n+      val bytecodeSizeHisto = CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE\n+\n+      // the same query run twice should hit the codegen cache\n+      spark.range(3).select('id + 2).collect\n+      val after1 = bytecodeSizeHisto.getCount\n+      spark.range(3).select('id + 2).collect\n+      val after2 = bytecodeSizeHisto.getCount // same query shape as above, deliberately\n+      assert(after1 == after2, \"Should hit codegen cache. No new compilation to bytecode expected\")\n+\n+      // a different query can result in codegen cache miss, that's by design\n+      spark.range(5).select('id * 2).collect\n+      val after3 = bytecodeSizeHisto.getCount\n+      assert(after3 >= after2, \"always\")"
  }],
  "prId": 20224
}]