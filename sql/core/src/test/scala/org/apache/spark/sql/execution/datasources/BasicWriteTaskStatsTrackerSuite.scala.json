[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "`file3 `?",
    "commit": "c0e81a1c87011efdc010f1c9ba28dde003458667",
    "createdAt": "2017-08-17T20:38:02Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.nio.charset.Charset\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Test how BasicWriteTaskStatsTracker handles files.\n+ */\n+class BasicWriteTaskStatsTrackerSuite extends SparkFunSuite {\n+\n+  private val tempDir = Utils.createTempDir()\n+  private val tempDirPath = new Path(tempDir.toURI)\n+  private val conf = new Configuration()\n+  private val localfs = tempDirPath.getFileSystem(conf)\n+  private val data1 = \"0123456789\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val data2 = \"012\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val len1 = data1.length\n+  private val len2 = data2.length\n+\n+  /**\n+   * In teardown delete the temp dir.\n+   */\n+  protected override def afterAll(): Unit = {\n+    Utils.deleteRecursively(tempDir)\n+  }\n+\n+  /**\n+   * Assert that the stats match that expected.\n+   * @param tracker tracker to check\n+   * @param files number of files expected\n+   * @param bytes total number of bytes expected\n+   */\n+  private def assertStats(\n+      tracker: BasicWriteTaskStatsTracker,\n+      files: Int,\n+      bytes: Int): Unit = {\n+    val stats = finalStatus(tracker)\n+    assert(files === stats.numFiles, \"Wrong number of files\")\n+    assert(bytes === stats.numBytes, \"Wrong byte count of file size\")\n+  }\n+\n+  private def finalStatus(tracker: BasicWriteTaskStatsTracker): BasicWriteTaskStats = {\n+    tracker.getFinalStats().asInstanceOf[BasicWriteTaskStats]\n+  }\n+\n+  test(\"No files in run\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    assertStats(tracker, 0, 0)\n+  }\n+\n+  test(\"Missing File\") {\n+    val missing = new Path(tempDirPath, \"missing\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(missing.toString)\n+    assertStats(tracker, 1, 0)\n+  }\n+\n+  test(\"Empty filename is forwarded\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(\"\")\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"Null filename is only picked up in final status\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(null)\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"0 byte file\") {\n+    val file = new Path(tempDirPath, \"file0\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    touch(file)\n+    assertStats(tracker, 1, 0)\n+  }\n+\n+  test(\"File with data\") {\n+    val file = new Path(tempDirPath, \"file-with-data\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    write1(file)\n+    assertStats(tracker, 1, len1)\n+  }\n+\n+  test(\"Open file\") {\n+    val file = new Path(tempDirPath, \"file-open\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    val stream = localfs.create(file, true)\n+    try {\n+      assertStats(tracker, 1, 0)\n+      stream.write(data1)\n+      stream.flush()\n+      assert(1 === finalStatus(tracker).numFiles, \"Wrong number of files\")\n+    } finally {\n+      stream.close()\n+    }\n+  }\n+\n+  test(\"Two files\") {\n+    val file1 = new Path(tempDirPath, \"f-2-1\")\n+    val file2 = new Path(tempDirPath, \"f-2-2\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file1.toString)\n+    write1(file1)\n+    tracker.newFile(file2.toString)\n+    write2(file2)\n+    assertStats(tracker, 2, len1 + len2)\n+  }\n+\n+  test(\"Three files, last one empty\") {\n+    val file1 = new Path(tempDirPath, \"f-3-1\")\n+    val file2 = new Path(tempDirPath, \"f-3-2\")\n+    val file3 = new Path(tempDirPath, \"f-3-2\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file1.toString)\n+    write1(file1)\n+    tracker.newFile(file2.toString)\n+    write2(file2)\n+    tracker.newFile(file3.toString)\n+    touch(file3)\n+    assertStats(tracker, 3, len1 + len2)\n+  }\n+\n+  test(\"Three files, one not found\") {\n+    val file1 = new Path(tempDirPath, \"f-4-1\")\n+    val file2 = new Path(tempDirPath, \"f-4-2\")\n+    val file3 = new Path(tempDirPath, \"f-3-2\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    // file 1\n+    tracker.newFile(file1.toString)\n+    write1(file1)\n+\n+    // file 2 is noted, but not visible\n+    tracker.newFile(file2.toString)\n+    touch(file3)"
  }, {
    "author": {
      "login": "steveloughran"
    },
    "body": "yeah, you are right. Spurious. Harmless but wrong. I was playing around with different sequences to see if I could confuse things. Will cut",
    "commit": "c0e81a1c87011efdc010f1c9ba28dde003458667",
    "createdAt": "2017-08-18T09:08:20Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.nio.charset.Charset\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Test how BasicWriteTaskStatsTracker handles files.\n+ */\n+class BasicWriteTaskStatsTrackerSuite extends SparkFunSuite {\n+\n+  private val tempDir = Utils.createTempDir()\n+  private val tempDirPath = new Path(tempDir.toURI)\n+  private val conf = new Configuration()\n+  private val localfs = tempDirPath.getFileSystem(conf)\n+  private val data1 = \"0123456789\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val data2 = \"012\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val len1 = data1.length\n+  private val len2 = data2.length\n+\n+  /**\n+   * In teardown delete the temp dir.\n+   */\n+  protected override def afterAll(): Unit = {\n+    Utils.deleteRecursively(tempDir)\n+  }\n+\n+  /**\n+   * Assert that the stats match that expected.\n+   * @param tracker tracker to check\n+   * @param files number of files expected\n+   * @param bytes total number of bytes expected\n+   */\n+  private def assertStats(\n+      tracker: BasicWriteTaskStatsTracker,\n+      files: Int,\n+      bytes: Int): Unit = {\n+    val stats = finalStatus(tracker)\n+    assert(files === stats.numFiles, \"Wrong number of files\")\n+    assert(bytes === stats.numBytes, \"Wrong byte count of file size\")\n+  }\n+\n+  private def finalStatus(tracker: BasicWriteTaskStatsTracker): BasicWriteTaskStats = {\n+    tracker.getFinalStats().asInstanceOf[BasicWriteTaskStats]\n+  }\n+\n+  test(\"No files in run\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    assertStats(tracker, 0, 0)\n+  }\n+\n+  test(\"Missing File\") {\n+    val missing = new Path(tempDirPath, \"missing\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(missing.toString)\n+    assertStats(tracker, 1, 0)\n+  }\n+\n+  test(\"Empty filename is forwarded\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(\"\")\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"Null filename is only picked up in final status\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(null)\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"0 byte file\") {\n+    val file = new Path(tempDirPath, \"file0\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    touch(file)\n+    assertStats(tracker, 1, 0)\n+  }\n+\n+  test(\"File with data\") {\n+    val file = new Path(tempDirPath, \"file-with-data\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    write1(file)\n+    assertStats(tracker, 1, len1)\n+  }\n+\n+  test(\"Open file\") {\n+    val file = new Path(tempDirPath, \"file-open\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    val stream = localfs.create(file, true)\n+    try {\n+      assertStats(tracker, 1, 0)\n+      stream.write(data1)\n+      stream.flush()\n+      assert(1 === finalStatus(tracker).numFiles, \"Wrong number of files\")\n+    } finally {\n+      stream.close()\n+    }\n+  }\n+\n+  test(\"Two files\") {\n+    val file1 = new Path(tempDirPath, \"f-2-1\")\n+    val file2 = new Path(tempDirPath, \"f-2-2\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file1.toString)\n+    write1(file1)\n+    tracker.newFile(file2.toString)\n+    write2(file2)\n+    assertStats(tracker, 2, len1 + len2)\n+  }\n+\n+  test(\"Three files, last one empty\") {\n+    val file1 = new Path(tempDirPath, \"f-3-1\")\n+    val file2 = new Path(tempDirPath, \"f-3-2\")\n+    val file3 = new Path(tempDirPath, \"f-3-2\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file1.toString)\n+    write1(file1)\n+    tracker.newFile(file2.toString)\n+    write2(file2)\n+    tracker.newFile(file3.toString)\n+    touch(file3)\n+    assertStats(tracker, 3, len1 + len2)\n+  }\n+\n+  test(\"Three files, one not found\") {\n+    val file1 = new Path(tempDirPath, \"f-4-1\")\n+    val file2 = new Path(tempDirPath, \"f-4-2\")\n+    val file3 = new Path(tempDirPath, \"f-3-2\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    // file 1\n+    tracker.newFile(file1.toString)\n+    write1(file1)\n+\n+    // file 2 is noted, but not visible\n+    tracker.newFile(file2.toString)\n+    touch(file3)"
  }],
  "prId": 18979
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "We may not be able to differentiate between `0 byte file` and `Missing File` in final metrics.",
    "commit": "c0e81a1c87011efdc010f1c9ba28dde003458667",
    "createdAt": "2017-08-18T07:30:52Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.nio.charset.Charset\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Test how BasicWriteTaskStatsTracker handles files.\n+ */\n+class BasicWriteTaskStatsTrackerSuite extends SparkFunSuite {\n+\n+  private val tempDir = Utils.createTempDir()\n+  private val tempDirPath = new Path(tempDir.toURI)\n+  private val conf = new Configuration()\n+  private val localfs = tempDirPath.getFileSystem(conf)\n+  private val data1 = \"0123456789\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val data2 = \"012\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val len1 = data1.length\n+  private val len2 = data2.length\n+\n+  /**\n+   * In teardown delete the temp dir.\n+   */\n+  protected override def afterAll(): Unit = {\n+    Utils.deleteRecursively(tempDir)\n+  }\n+\n+  /**\n+   * Assert that the stats match that expected.\n+   * @param tracker tracker to check\n+   * @param files number of files expected\n+   * @param bytes total number of bytes expected\n+   */\n+  private def assertStats(\n+      tracker: BasicWriteTaskStatsTracker,\n+      files: Int,\n+      bytes: Int): Unit = {\n+    val stats = finalStatus(tracker)\n+    assert(files === stats.numFiles, \"Wrong number of files\")\n+    assert(bytes === stats.numBytes, \"Wrong byte count of file size\")\n+  }\n+\n+  private def finalStatus(tracker: BasicWriteTaskStatsTracker): BasicWriteTaskStats = {\n+    tracker.getFinalStats().asInstanceOf[BasicWriteTaskStats]\n+  }\n+\n+  test(\"No files in run\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    assertStats(tracker, 0, 0)\n+  }\n+\n+  test(\"Missing File\") {\n+    val missing = new Path(tempDirPath, \"missing\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(missing.toString)\n+    assertStats(tracker, 1, 0)\n+  }\n+\n+  test(\"Empty filename is forwarded\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(\"\")\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"Null filename is only picked up in final status\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(null)\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"0 byte file\") {\n+    val file = new Path(tempDirPath, \"file0\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    touch(file)\n+    assertStats(tracker, 1, 0)",
    "line": 107
  }, {
    "author": {
      "login": "steveloughran"
    },
    "body": "I'm assuming that the file will *eventually* come into existence; that its absence straight after collection is simply a transient create inconsistency of the endpoint, like a brief caching of negative HEAD/GET requests (which AWS S3 does do as part of its DoS defences). The files will be there later.\r\n\r\nOne option: count the #of missing files and include that in the report. It shouldn't be a metric most of the time though: never on a \"real\" FS or consistent object store, rarely on an inconsistent one",
    "commit": "c0e81a1c87011efdc010f1c9ba28dde003458667",
    "createdAt": "2017-08-18T09:38:56Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.nio.charset.Charset\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Test how BasicWriteTaskStatsTracker handles files.\n+ */\n+class BasicWriteTaskStatsTrackerSuite extends SparkFunSuite {\n+\n+  private val tempDir = Utils.createTempDir()\n+  private val tempDirPath = new Path(tempDir.toURI)\n+  private val conf = new Configuration()\n+  private val localfs = tempDirPath.getFileSystem(conf)\n+  private val data1 = \"0123456789\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val data2 = \"012\".getBytes(Charset.forName(\"US-ASCII\"))\n+  private val len1 = data1.length\n+  private val len2 = data2.length\n+\n+  /**\n+   * In teardown delete the temp dir.\n+   */\n+  protected override def afterAll(): Unit = {\n+    Utils.deleteRecursively(tempDir)\n+  }\n+\n+  /**\n+   * Assert that the stats match that expected.\n+   * @param tracker tracker to check\n+   * @param files number of files expected\n+   * @param bytes total number of bytes expected\n+   */\n+  private def assertStats(\n+      tracker: BasicWriteTaskStatsTracker,\n+      files: Int,\n+      bytes: Int): Unit = {\n+    val stats = finalStatus(tracker)\n+    assert(files === stats.numFiles, \"Wrong number of files\")\n+    assert(bytes === stats.numBytes, \"Wrong byte count of file size\")\n+  }\n+\n+  private def finalStatus(tracker: BasicWriteTaskStatsTracker): BasicWriteTaskStats = {\n+    tracker.getFinalStats().asInstanceOf[BasicWriteTaskStats]\n+  }\n+\n+  test(\"No files in run\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    assertStats(tracker, 0, 0)\n+  }\n+\n+  test(\"Missing File\") {\n+    val missing = new Path(tempDirPath, \"missing\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(missing.toString)\n+    assertStats(tracker, 1, 0)\n+  }\n+\n+  test(\"Empty filename is forwarded\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(\"\")\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"Null filename is only picked up in final status\") {\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(null)\n+    intercept[IllegalArgumentException] {\n+      finalStatus(tracker)\n+    }\n+  }\n+\n+  test(\"0 byte file\") {\n+    val file = new Path(tempDirPath, \"file0\")\n+    val tracker = new BasicWriteTaskStatsTracker(conf)\n+    tracker.newFile(file.toString)\n+    touch(file)\n+    assertStats(tracker, 1, 0)",
    "line": 107
  }],
  "prId": 18979
}]