[{
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "nit: `state.get == ...`? also `state.get` in the error message",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T07:10:48Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        Iterator.empty\n+      } else {\n+        state.update(RunningCount(count))\n+        Iterator((key, count.toString))\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .flatMapGroupsWithState(stateFunc) // State: Int, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and not return anything for a\n+      CheckLastBatch((\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1 and\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"flatMapGroupsWithState - batch\") {\n+    // Function that returns running count only if its even, otherwise does not return\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done. not a nit! wrong test!",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:21:25Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        Iterator.empty\n+      } else {\n+        state.update(RunningCount(count))\n+        Iterator((key, count.toString))\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .flatMapGroupsWithState(stateFunc) // State: Int, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and not return anything for a\n+      CheckLastBatch((\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1 and\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"flatMapGroupsWithState - batch\") {\n+    // Function that returns running count only if its even, otherwise does not return\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "same here",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T07:14:58Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        Iterator.empty\n+      } else {\n+        state.update(RunningCount(count))\n+        Iterator((key, count.toString))\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .flatMapGroupsWithState(stateFunc) // State: Int, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and not return anything for a\n+      CheckLastBatch((\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1 and\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"flatMapGroupsWithState - batch\") {\n+    // Function that returns running count only if its even, otherwise does not return\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {\n+        throw new IllegalArgumentException(\"state.getOption should be empty\")\n+      }\n+      Iterator((key, values.size))\n+    }\n+    checkAnswer(\n+      Seq(\"a\", \"a\", \"b\").toDS.groupByKey(x => x).flatMapGroupsWithState(stateFunc).toDF,\n+      Seq((\"a\", 2), (\"b\", 1)).toDF)\n+  }\n+\n+  test(\"mapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count (-1 if count reached beyond 2 and state was just removed)\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      val count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        (key, \"-1\")\n+      } else {\n+        state.update(RunningCount(count))\n+        (key, count.toString)\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc) // Types = State: MyState, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and return count as -1\n+      CheckLastBatch((\"a\", \"-1\"), (\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"mapGroupsWithState - batch\") {\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done. thanks for catching these.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:21:34Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        Iterator.empty\n+      } else {\n+        state.update(RunningCount(count))\n+        Iterator((key, count.toString))\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .flatMapGroupsWithState(stateFunc) // State: Int, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and not return anything for a\n+      CheckLastBatch((\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1 and\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"flatMapGroupsWithState - batch\") {\n+    // Function that returns running count only if its even, otherwise does not return\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {\n+        throw new IllegalArgumentException(\"state.getOption should be empty\")\n+      }\n+      Iterator((key, values.size))\n+    }\n+    checkAnswer(\n+      Seq(\"a\", \"a\", \"b\").toDS.groupByKey(x => x).flatMapGroupsWithState(stateFunc).toDF,\n+      Seq((\"a\", 2), (\"b\", 1)).toDF)\n+  }\n+\n+  test(\"mapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count (-1 if count reached beyond 2 and state was just removed)\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      val count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        (key, \"-1\")\n+      } else {\n+        state.update(RunningCount(count))\n+        (key, count.toString)\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc) // Types = State: MyState, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and return count as -1\n+      CheckLastBatch((\"a\", \"-1\"), (\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"mapGroupsWithState - batch\") {\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: var -> val",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T21:50:50Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:32:15Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Could you add a test for `aggregation after mapGroupsWithState`?",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T22:05:42Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        Iterator.empty\n+      } else {\n+        state.update(RunningCount(count))\n+        Iterator((key, count.toString))\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .flatMapGroupsWithState(stateFunc) // State: Int, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and not return anything for a\n+      CheckLastBatch((\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1 and\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"flatMapGroupsWithState - batch\") {\n+    // Function that returns running count only if its even, otherwise does not return\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {\n+        throw new IllegalArgumentException(\"state.getOption should be empty\")\n+      }\n+      Iterator((key, values.size))\n+    }\n+    checkAnswer(\n+      Seq(\"a\", \"a\", \"b\").toDS.groupByKey(x => x).flatMapGroupsWithState(stateFunc).toDF,\n+      Seq((\"a\", 2), (\"b\", 1)).toDF)\n+  }\n+\n+  test(\"mapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count (-1 if count reached beyond 2 and state was just removed)\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      val count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        (key, \"-1\")\n+      } else {\n+        state.update(RunningCount(count))\n+        (key, count.toString)\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc) // Types = State: MyState, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and return count as -1\n+      CheckLastBatch((\"a\", \"-1\"), (\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"mapGroupsWithState - batch\") {\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {\n+        throw new IllegalArgumentException(\"state.getOption should be empty\")\n+      }\n+      (key, values.size)\n+    }\n+\n+    checkAnswer(\n+      spark.createDataset(Seq(\"a\", \"a\", \"b\"))\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc)\n+        .toDF,\n+      spark.createDataset(Seq((\"a\", 2), (\"b\", 1))).toDF)\n+  }\n+\n+  testQuietly(\"StateStore.abort on task failure handling\") {\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (MapGroupsWithStateSuite.failInTask) throw new Exception(\"expected failure\")\n+      val count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      state.update(RunningCount(count))\n+      (key, count)\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc) // Types = State: MyState, Out: (Str, Str)\n+\n+    def setFailInTask(value: Boolean): AssertOnQuery = AssertOnQuery { q =>\n+      MapGroupsWithStateSuite.failInTask = value\n+      true\n+    }\n+\n+    testStream(result, Append)(\n+      setFailInTask(false),\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", 1L)),\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", 2L)),\n+      setFailInTask(true),\n+      AddData(inputData, \"a\"),\n+      ExpectFailure[SparkException](),   // task should fail but should not increment count\n+      setFailInTask(false),\n+      StartStream(),\n+      CheckLastBatch((\"a\", 3L))     // task should not fail, and should show correct count\n+    )\n+  }",
    "line": 323
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Added.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T22:23:09Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfterAll\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.sql.KeyedState\n+import org.apache.spark.sql.catalyst.streaming.InternalOutputModes._\n+import org.apache.spark.sql.execution.streaming.{KeyedStateImpl, MemoryStream}\n+import org.apache.spark.sql.execution.streaming.state.StateStore\n+\n+/** Class to check custom state types */\n+case class RunningCount(count: Long)\n+\n+class MapGroupsWithStateSuite extends StreamTest with BeforeAndAfterAll {\n+\n+  import testImplicits._\n+\n+  override def afterAll(): Unit = {\n+    super.afterAll()\n+    StateStore.stop()\n+  }\n+\n+  test(\"state - get, exists, update, remove\") {\n+    var state: KeyedStateImpl[String] = null\n+\n+    def testState(\n+        expectedData: Option[String],\n+        shouldBeUpdated: Boolean = false,\n+        shouldBeRemoved: Boolean = false\n+      ): Unit = {\n+      if (expectedData.isDefined) {\n+        assert(state.exists)\n+        assert(state.get === expectedData.get)\n+      } else {\n+        assert(!state.exists)\n+        assert(state.get === null)\n+      }\n+      assert(state.isUpdated === shouldBeUpdated)\n+      assert(state.isRemoved === shouldBeRemoved)\n+    }\n+\n+    // Updating empty state\n+    state = KeyedStateImpl[String](null)\n+    testState(None)\n+    state.update(\"\")\n+    testState(Some(\"\"), shouldBeUpdated = true)\n+\n+    // Updating exiting state\n+    state = KeyedStateImpl[String](\"2\")\n+    testState(Some(\"2\"))\n+    state.update(\"3\")\n+    testState(Some(\"3\"), shouldBeUpdated = true)\n+\n+    // Removing state\n+    state.remove()\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+    state.remove()      // should be still callable\n+    state.update(\"4\")\n+    testState(Some(\"4\"), shouldBeRemoved = false, shouldBeUpdated = true)\n+\n+    // Updating by null is same as remove\n+    state.update(null)\n+    testState(None, shouldBeRemoved = true, shouldBeUpdated = false)\n+  }\n+\n+  test(\"flatMapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count if state is defined, otherwise does not return anything\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      var count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        Iterator.empty\n+      } else {\n+        state.update(RunningCount(count))\n+        Iterator((key, count.toString))\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .flatMapGroupsWithState(stateFunc) // State: Int, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and not return anything for a\n+      CheckLastBatch((\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1 and\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"flatMapGroupsWithState - batch\") {\n+    // Function that returns running count only if its even, otherwise does not return\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {\n+        throw new IllegalArgumentException(\"state.getOption should be empty\")\n+      }\n+      Iterator((key, values.size))\n+    }\n+    checkAnswer(\n+      Seq(\"a\", \"a\", \"b\").toDS.groupByKey(x => x).flatMapGroupsWithState(stateFunc).toDF,\n+      Seq((\"a\", 2), (\"b\", 1)).toDF)\n+  }\n+\n+  test(\"mapGroupsWithState - streaming\") {\n+    // Function to maintain running count up to 2, and then remove the count\n+    // Returns the data and the count (-1 if count reached beyond 2 and state was just removed)\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+\n+      val count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      if (count == 3) {\n+        state.remove()\n+        (key, \"-1\")\n+      } else {\n+        state.update(RunningCount(count))\n+        (key, count.toString)\n+      }\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc) // Types = State: MyState, Out: (Str, Str)\n+\n+    testStream(result, Append)(\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", \"1\")),\n+      assertNumStateRows(total = 1, updated = 1),\n+      AddData(inputData, \"a\", \"b\"),\n+      CheckLastBatch((\"a\", \"2\"), (\"b\", \"1\")),\n+      assertNumStateRows(total = 2, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"b\"), // should remove state for \"a\" and return count as -1\n+      CheckLastBatch((\"a\", \"-1\"), (\"b\", \"2\")),\n+      assertNumStateRows(total = 1, updated = 2),\n+      StopStream,\n+      StartStream(),\n+      AddData(inputData, \"a\", \"c\"), // should recreate state for \"a\" and return count as 1\n+      CheckLastBatch((\"a\", \"1\"), (\"c\", \"1\")),\n+      assertNumStateRows(total = 3, updated = 2)\n+    )\n+  }\n+\n+  test(\"mapGroupsWithState - batch\") {\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (state.exists) throw new IllegalArgumentException(\"state.exists should be false\")\n+      if (state.exists) {\n+        throw new IllegalArgumentException(\"state.getOption should be empty\")\n+      }\n+      (key, values.size)\n+    }\n+\n+    checkAnswer(\n+      spark.createDataset(Seq(\"a\", \"a\", \"b\"))\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc)\n+        .toDF,\n+      spark.createDataset(Seq((\"a\", 2), (\"b\", 1))).toDF)\n+  }\n+\n+  testQuietly(\"StateStore.abort on task failure handling\") {\n+    val stateFunc = (key: String, values: Iterator[String], state: KeyedState[RunningCount]) => {\n+      if (MapGroupsWithStateSuite.failInTask) throw new Exception(\"expected failure\")\n+      val count = Option(state.get).map(_.count).getOrElse(0L) + values.size\n+      state.update(RunningCount(count))\n+      (key, count)\n+    }\n+\n+    val inputData = MemoryStream[String]\n+    val result =\n+      inputData.toDS()\n+        .groupByKey(x => x)\n+        .mapGroupsWithState(stateFunc) // Types = State: MyState, Out: (Str, Str)\n+\n+    def setFailInTask(value: Boolean): AssertOnQuery = AssertOnQuery { q =>\n+      MapGroupsWithStateSuite.failInTask = value\n+      true\n+    }\n+\n+    testStream(result, Append)(\n+      setFailInTask(false),\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", 1L)),\n+      AddData(inputData, \"a\"),\n+      CheckLastBatch((\"a\", 2L)),\n+      setFailInTask(true),\n+      AddData(inputData, \"a\"),\n+      ExpectFailure[SparkException](),   // task should fail but should not increment count\n+      setFailInTask(false),\n+      StartStream(),\n+      CheckLastBatch((\"a\", 3L))     // task should not fail, and should show correct count\n+    )\n+  }",
    "line": 323
  }],
  "prId": 16758
}]