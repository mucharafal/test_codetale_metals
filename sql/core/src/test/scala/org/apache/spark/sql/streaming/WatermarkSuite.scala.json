[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: the comment is wrong\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T20:29:17Z",
    "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.streaming\n+\n+import org.scalatest.BeforeAndAfter\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.functions.{count, window}\n+\n+class WatermarkSuite extends StreamTest with BeforeAndAfter with Logging {\n+\n+  import testImplicits._\n+\n+  after {\n+    sqlContext.streams.active.foreach(_.stop())\n+  }\n+\n+  test(\"error on bad column\") {\n+    val inputData = MemoryStream[Int].toDF()\n+    val e = intercept[AnalysisException] {\n+      inputData.withWatermark(\"badColumn\", \"1 minute\")\n+    }\n+    assert(e.getMessage contains \"badColumn\")\n+  }\n+\n+  test(\"watermark metric\") {\n+    val inputData = MemoryStream[Int]\n+\n+    val windowedAggregation = inputData.toDF()\n+        .withColumn(\"eventTime\", $\"value\".cast(\"timestamp\"))\n+        .withWatermark(\"eventTime\", \"10 seconds\")\n+        .groupBy(window($\"eventTime\", \"5 seconds\") as 'window)\n+        .agg(count(\"*\") as 'count)\n+        .select($\"window\".getField(\"start\").cast(\"long\").as[Long], $\"count\".as[Long])\n+\n+    testStream(windowedAggregation)(\n+      AddData(inputData, 15),\n+      AssertOnLastQueryStatus { status =>\n+        status.triggerDetails.get(StreamMetrics.EVENT_TIME_WATERMARK) === \"5000\"\n+      },\n+      AddData(inputData, 15),\n+      AssertOnLastQueryStatus { status =>\n+        status.triggerDetails.get(StreamMetrics.EVENT_TIME_WATERMARK) === \"5000\"\n+      },\n+      AddData(inputData, 25),\n+      AssertOnLastQueryStatus { status =>\n+        status.triggerDetails.get(StreamMetrics.EVENT_TIME_WATERMARK) === \"15000\"\n+      }\n+    )\n+  }\n+\n+  test(\"append-mode watermark aggregation\") {\n+    val inputData = MemoryStream[Int]\n+\n+    val windowedAggregation = inputData.toDF()\n+      .withColumn(\"eventTime\", $\"value\".cast(\"timestamp\"))\n+      .withWatermark(\"eventTime\", \"10 seconds\")\n+      .groupBy(window($\"eventTime\", \"5 seconds\") as 'window)\n+      .agg(count(\"*\") as 'count)\n+      .select($\"window\".getField(\"start\").cast(\"long\").as[Long], $\"count\".as[Long])\n+\n+    testStream(windowedAggregation)(\n+      AddData(inputData, 10, 11, 12, 13, 14, 15),\n+      CheckAnswer(),\n+      AddData(inputData, 25), // Advance watermark to 15 seconds\n+      CheckAnswer(),\n+      AddData(inputData, 25), // Evict items less than previous watermark.\n+      CheckAnswer((10, 5))\n+    )\n+  }\n+\n+  ignore(\"recovery\") {\n+    val inputData = MemoryStream[Int]\n+\n+    val windowedAggregation = inputData.toDF()\n+        .withColumn(\"eventTime\", $\"value\".cast(\"timestamp\"))\n+        .withWatermark(\"eventTime\", \"10 seconds\")\n+        .groupBy(window($\"eventTime\", \"5 seconds\") as 'window)\n+        .agg(count(\"*\") as 'count)\n+        .select($\"window\".getField(\"start\").cast(\"long\").as[Long], $\"count\".as[Long])\n+\n+    testStream(windowedAggregation)(\n+      AddData(inputData, 10, 11, 12, 13, 14, 15),\n+      CheckAnswer(),\n+      AddData(inputData, 25), // Advance watermark to 15 seconds\n+      StopStream,\n+      StartStream(),\n+      CheckAnswer(),\n+      AddData(inputData, 25), // Evict items less than previous watermark.\n+      StopStream,\n+      StartStream(),\n+      CheckAnswer((10, 5))\n+    )\n+  }\n+\n+  test(\"dropping old data\") {\n+    val inputData = MemoryStream[Int]\n+\n+    val windowedAggregation = inputData.toDF()\n+        .withColumn(\"eventTime\", $\"value\".cast(\"timestamp\"))\n+        .withWatermark(\"eventTime\", \"10 seconds\")\n+        .groupBy(window($\"eventTime\", \"5 seconds\") as 'window)\n+        .agg(count(\"*\") as 'count)\n+        .select($\"window\".getField(\"start\").cast(\"long\").as[Long], $\"count\".as[Long])\n+\n+    testStream(windowedAggregation)(\n+      AddData(inputData, 10, 11, 12),\n+      CheckAnswer(),\n+      AddData(inputData, 25),     // Advance watermark to 15 seconds\n+      CheckAnswer(),\n+      AddData(inputData, 25),     // Evict items less than previous watermark.\n+      CheckAnswer((10, 3)),\n+      AddData(inputData, 10),     // 10 is later than 15 second watermark\n+      CheckAnswer((10, 3)),\n+      AddData(inputData, 25),     // 10 is later than 15 second watermark"
  }],
  "prId": 15702
}]