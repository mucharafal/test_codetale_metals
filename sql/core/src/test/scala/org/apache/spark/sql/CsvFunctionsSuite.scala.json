[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@MaxGekk, wouldn't the tests in `csv-functions.sql` be enough for SQL support test?",
    "commit": "24933a9e457fe6b0110de0aa27bc9eaa9dc00fb9",
    "createdAt": "2018-11-07T00:25:48Z",
    "diffHunk": "@@ -86,4 +86,82 @@ class CsvFunctionsSuite extends QueryTest with SharedSQLContext {\n \n     checkAnswer(df.select(to_csv($\"a\", options)), Row(\"26/08/2015 18:00\") :: Nil)\n   }\n+\n+  test(\"from_csv uses DDL strings for defining a schema - java\") {\n+    val df = Seq(\"\"\"1,\"haa\"\"\"\").toDS()\n+    checkAnswer(\n+      df.select(\n+        from_csv($\"value\", lit(\"a INT, b STRING\"), new java.util.HashMap[String, String]())),\n+      Row(Row(1, \"haa\")) :: Nil)\n+  }\n+\n+  test(\"roundtrip to_csv -> from_csv\") {\n+    val df = Seq(Tuple1(Tuple1(1)), Tuple1(null)).toDF(\"struct\")\n+    val schema = df.schema(0).dataType.asInstanceOf[StructType]\n+    val options = Map.empty[String, String]\n+    val readback = df.select(to_csv($\"struct\").as(\"csv\"))\n+      .select(from_csv($\"csv\", schema, options).as(\"struct\"))\n+\n+    checkAnswer(df, readback)\n+  }\n+\n+  test(\"roundtrip from_csv -> to_csv\") {\n+    val df = Seq(Some(\"1\"), None).toDF(\"csv\")\n+    val schema = new StructType().add(\"a\", IntegerType)\n+    val options = Map.empty[String, String]\n+    val readback = df.select(from_csv($\"csv\", schema, options).as(\"struct\"))\n+      .select(to_csv($\"struct\").as(\"csv\"))\n+\n+    checkAnswer(df, readback)\n+  }\n+\n+  test(\"infers schemas of a CSV string and pass to to from_csv\") {\n+    val in = Seq(\"\"\"0.123456789,987654321,\"San Francisco\"\"\"\").toDS()\n+    val options = Map.empty[String, String].asJava\n+    val out = in.select(from_csv('value, schema_of_csv(\"0.1,1,a\"), options) as \"parsed\")\n+    val expected = StructType(Seq(StructField(\n+      \"parsed\",\n+      StructType(Seq(\n+        StructField(\"_c0\", DoubleType, true),\n+        StructField(\"_c1\", IntegerType, true),\n+        StructField(\"_c2\", StringType, true))))))\n+\n+    assert(out.schema == expected)\n+  }\n+\n+  test(\"Support to_csv in SQL\") {",
    "line": 47
  }, {
    "author": {
      "login": "MaxGekk"
    },
    "body": "This is only for double check that the functions are available/(and work) from expressions in Scala. Probably we can make the test smaller.",
    "commit": "24933a9e457fe6b0110de0aa27bc9eaa9dc00fb9",
    "createdAt": "2018-11-07T07:14:51Z",
    "diffHunk": "@@ -86,4 +86,82 @@ class CsvFunctionsSuite extends QueryTest with SharedSQLContext {\n \n     checkAnswer(df.select(to_csv($\"a\", options)), Row(\"26/08/2015 18:00\") :: Nil)\n   }\n+\n+  test(\"from_csv uses DDL strings for defining a schema - java\") {\n+    val df = Seq(\"\"\"1,\"haa\"\"\"\").toDS()\n+    checkAnswer(\n+      df.select(\n+        from_csv($\"value\", lit(\"a INT, b STRING\"), new java.util.HashMap[String, String]())),\n+      Row(Row(1, \"haa\")) :: Nil)\n+  }\n+\n+  test(\"roundtrip to_csv -> from_csv\") {\n+    val df = Seq(Tuple1(Tuple1(1)), Tuple1(null)).toDF(\"struct\")\n+    val schema = df.schema(0).dataType.asInstanceOf[StructType]\n+    val options = Map.empty[String, String]\n+    val readback = df.select(to_csv($\"struct\").as(\"csv\"))\n+      .select(from_csv($\"csv\", schema, options).as(\"struct\"))\n+\n+    checkAnswer(df, readback)\n+  }\n+\n+  test(\"roundtrip from_csv -> to_csv\") {\n+    val df = Seq(Some(\"1\"), None).toDF(\"csv\")\n+    val schema = new StructType().add(\"a\", IntegerType)\n+    val options = Map.empty[String, String]\n+    val readback = df.select(from_csv($\"csv\", schema, options).as(\"struct\"))\n+      .select(to_csv($\"struct\").as(\"csv\"))\n+\n+    checkAnswer(df, readback)\n+  }\n+\n+  test(\"infers schemas of a CSV string and pass to to from_csv\") {\n+    val in = Seq(\"\"\"0.123456789,987654321,\"San Francisco\"\"\"\").toDS()\n+    val options = Map.empty[String, String].asJava\n+    val out = in.select(from_csv('value, schema_of_csv(\"0.1,1,a\"), options) as \"parsed\")\n+    val expected = StructType(Seq(StructField(\n+      \"parsed\",\n+      StructType(Seq(\n+        StructField(\"_c0\", DoubleType, true),\n+        StructField(\"_c1\", IntegerType, true),\n+        StructField(\"_c2\", StringType, true))))))\n+\n+    assert(out.schema == expected)\n+  }\n+\n+  test(\"Support to_csv in SQL\") {",
    "line": 47
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think we can just get rid of it. I can't imagine both functions are specifically broken alone in `selectExpr`.",
    "commit": "24933a9e457fe6b0110de0aa27bc9eaa9dc00fb9",
    "createdAt": "2018-11-07T08:24:54Z",
    "diffHunk": "@@ -86,4 +86,82 @@ class CsvFunctionsSuite extends QueryTest with SharedSQLContext {\n \n     checkAnswer(df.select(to_csv($\"a\", options)), Row(\"26/08/2015 18:00\") :: Nil)\n   }\n+\n+  test(\"from_csv uses DDL strings for defining a schema - java\") {\n+    val df = Seq(\"\"\"1,\"haa\"\"\"\").toDS()\n+    checkAnswer(\n+      df.select(\n+        from_csv($\"value\", lit(\"a INT, b STRING\"), new java.util.HashMap[String, String]())),\n+      Row(Row(1, \"haa\")) :: Nil)\n+  }\n+\n+  test(\"roundtrip to_csv -> from_csv\") {\n+    val df = Seq(Tuple1(Tuple1(1)), Tuple1(null)).toDF(\"struct\")\n+    val schema = df.schema(0).dataType.asInstanceOf[StructType]\n+    val options = Map.empty[String, String]\n+    val readback = df.select(to_csv($\"struct\").as(\"csv\"))\n+      .select(from_csv($\"csv\", schema, options).as(\"struct\"))\n+\n+    checkAnswer(df, readback)\n+  }\n+\n+  test(\"roundtrip from_csv -> to_csv\") {\n+    val df = Seq(Some(\"1\"), None).toDF(\"csv\")\n+    val schema = new StructType().add(\"a\", IntegerType)\n+    val options = Map.empty[String, String]\n+    val readback = df.select(from_csv($\"csv\", schema, options).as(\"struct\"))\n+      .select(to_csv($\"struct\").as(\"csv\"))\n+\n+    checkAnswer(df, readback)\n+  }\n+\n+  test(\"infers schemas of a CSV string and pass to to from_csv\") {\n+    val in = Seq(\"\"\"0.123456789,987654321,\"San Francisco\"\"\"\").toDS()\n+    val options = Map.empty[String, String].asJava\n+    val out = in.select(from_csv('value, schema_of_csv(\"0.1,1,a\"), options) as \"parsed\")\n+    val expected = StructType(Seq(StructField(\n+      \"parsed\",\n+      StructType(Seq(\n+        StructField(\"_c0\", DoubleType, true),\n+        StructField(\"_c1\", IntegerType, true),\n+        StructField(\"_c2\", StringType, true))))))\n+\n+    assert(out.schema == expected)\n+  }\n+\n+  test(\"Support to_csv in SQL\") {",
    "line": 47
  }],
  "prId": 22960
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "The only difference are the data at line 91 and `from_csv` and `from_json`.",
    "commit": "24933a9e457fe6b0110de0aa27bc9eaa9dc00fb9",
    "createdAt": "2018-11-07T04:58:14Z",
    "diffHunk": "@@ -86,4 +86,82 @@ class CsvFunctionsSuite extends QueryTest with SharedSQLContext {\n \n     checkAnswer(df.select(to_csv($\"a\", options)), Row(\"26/08/2015 18:00\") :: Nil)\n   }\n+\n+  test(\"from_csv uses DDL strings for defining a schema - java\") {\n+    val df = Seq(\"\"\"1,\"haa\"\"\"\").toDS()\n+    checkAnswer(\n+      df.select(\n+        from_csv($\"value\", lit(\"a INT, b STRING\"), new java.util.HashMap[String, String]())),",
    "line": 9
  }],
  "prId": 22960
}]