[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I think it doesn't affect the result. But looks like the third array should be `testVector.putArray(2, 3, 0)`?",
    "commit": "5ea4e8985002dd26922376d672af4db052063909",
    "createdAt": "2017-09-16T04:47:14Z",
    "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized\n+\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.util.ArrayData\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+class ColumnVectorSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  var testVector: WritableColumnVector = _\n+\n+  private def allocate(capacity: Int, dt: DataType): WritableColumnVector = {\n+    new OnHeapColumnVector(capacity, dt)\n+  }\n+\n+  override def afterEach(): Unit = {\n+    testVector.close()\n+  }\n+\n+  test(\"boolean\") {\n+    testVector = allocate(10, BooleanType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendBoolean(i % 2 == 0)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, BooleanType) === (i % 2 == 0))\n+    }\n+  }\n+\n+  test(\"byte\") {\n+    testVector = allocate(10, ByteType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendByte(i.toByte)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ByteType) === (i.toByte))\n+    }\n+  }\n+\n+  test(\"short\") {\n+    testVector = allocate(10, ShortType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendShort(i.toShort)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ShortType) === (i.toShort))\n+    }\n+  }\n+\n+  test(\"int\") {\n+    testVector = allocate(10, IntegerType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendInt(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, IntegerType) === i)\n+    }\n+  }\n+\n+  test(\"long\") {\n+    testVector = allocate(10, LongType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendLong(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, LongType) === i)\n+    }\n+  }\n+\n+  test(\"float\") {\n+    testVector = allocate(10, FloatType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendFloat(i.toFloat)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, FloatType) === i.toFloat)\n+    }\n+  }\n+\n+  test(\"double\") {\n+    testVector = allocate(10, DoubleType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendDouble(i.toDouble)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, DoubleType) === i.toDouble)\n+    }\n+  }\n+\n+  test(\"string\") {\n+    testVector = allocate(10, StringType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, StringType) === UTF8String.fromString(s\"str$i\"))\n+    }\n+  }\n+\n+  test(\"binary\") {\n+    testVector = allocate(10, BinaryType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      assert(array.get(i, BinaryType) === utf8)\n+    }\n+  }\n+\n+  test(\"array\") {\n+    val arrayType = ArrayType(IntegerType, true)\n+    testVector = allocate(10, arrayType)\n+\n+    // set the first element of the testVector\n+    val data = testVector.arrayData()\n+    var i = 0\n+    while (i < 6) {\n+      data.putInt(i, i)\n+      i += 1\n+    }\n+\n+    // Populate it with arrays [0], [1, 2], [], [3, 4, 5]\n+    testVector.putArray(0, 0, 1)\n+    testVector.putArray(1, 1, 2)\n+    testVector.putArray(2, 2, 0)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "+1",
    "commit": "5ea4e8985002dd26922376d672af4db052063909",
    "createdAt": "2017-09-16T14:36:26Z",
    "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized\n+\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.util.ArrayData\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+class ColumnVectorSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  var testVector: WritableColumnVector = _\n+\n+  private def allocate(capacity: Int, dt: DataType): WritableColumnVector = {\n+    new OnHeapColumnVector(capacity, dt)\n+  }\n+\n+  override def afterEach(): Unit = {\n+    testVector.close()\n+  }\n+\n+  test(\"boolean\") {\n+    testVector = allocate(10, BooleanType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendBoolean(i % 2 == 0)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, BooleanType) === (i % 2 == 0))\n+    }\n+  }\n+\n+  test(\"byte\") {\n+    testVector = allocate(10, ByteType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendByte(i.toByte)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ByteType) === (i.toByte))\n+    }\n+  }\n+\n+  test(\"short\") {\n+    testVector = allocate(10, ShortType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendShort(i.toShort)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ShortType) === (i.toShort))\n+    }\n+  }\n+\n+  test(\"int\") {\n+    testVector = allocate(10, IntegerType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendInt(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, IntegerType) === i)\n+    }\n+  }\n+\n+  test(\"long\") {\n+    testVector = allocate(10, LongType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendLong(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, LongType) === i)\n+    }\n+  }\n+\n+  test(\"float\") {\n+    testVector = allocate(10, FloatType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendFloat(i.toFloat)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, FloatType) === i.toFloat)\n+    }\n+  }\n+\n+  test(\"double\") {\n+    testVector = allocate(10, DoubleType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendDouble(i.toDouble)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, DoubleType) === i.toDouble)\n+    }\n+  }\n+\n+  test(\"string\") {\n+    testVector = allocate(10, StringType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, StringType) === UTF8String.fromString(s\"str$i\"))\n+    }\n+  }\n+\n+  test(\"binary\") {\n+    testVector = allocate(10, BinaryType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      assert(array.get(i, BinaryType) === utf8)\n+    }\n+  }\n+\n+  test(\"array\") {\n+    val arrayType = ArrayType(IntegerType, true)\n+    testVector = allocate(10, arrayType)\n+\n+    // set the first element of the testVector\n+    val data = testVector.arrayData()\n+    var i = 0\n+    while (i < 6) {\n+      data.putInt(i, i)\n+      i += 1\n+    }\n+\n+    // Populate it with arrays [0], [1, 2], [], [3, 4, 5]\n+    testVector.putArray(0, 0, 1)\n+    testVector.putArray(1, 1, 2)\n+    testVector.putArray(2, 2, 0)"
  }],
  "prId": 19230
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Is it better to add a test for `map`, too?",
    "commit": "5ea4e8985002dd26922376d672af4db052063909",
    "createdAt": "2017-09-17T23:53:54Z",
    "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized\n+\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.util.ArrayData\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+class ColumnVectorSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  var testVector: WritableColumnVector = _\n+\n+  private def allocate(capacity: Int, dt: DataType): WritableColumnVector = {\n+    new OnHeapColumnVector(capacity, dt)\n+  }\n+\n+  override def afterEach(): Unit = {\n+    testVector.close()\n+  }\n+\n+  test(\"boolean\") {\n+    testVector = allocate(10, BooleanType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendBoolean(i % 2 == 0)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, BooleanType) === (i % 2 == 0))\n+    }\n+  }\n+\n+  test(\"byte\") {\n+    testVector = allocate(10, ByteType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendByte(i.toByte)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ByteType) === (i.toByte))\n+    }\n+  }\n+\n+  test(\"short\") {\n+    testVector = allocate(10, ShortType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendShort(i.toShort)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ShortType) === (i.toShort))\n+    }\n+  }\n+\n+  test(\"int\") {\n+    testVector = allocate(10, IntegerType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendInt(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, IntegerType) === i)\n+    }\n+  }\n+\n+  test(\"long\") {\n+    testVector = allocate(10, LongType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendLong(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, LongType) === i)\n+    }\n+  }\n+\n+  test(\"float\") {\n+    testVector = allocate(10, FloatType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendFloat(i.toFloat)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, FloatType) === i.toFloat)\n+    }\n+  }\n+\n+  test(\"double\") {\n+    testVector = allocate(10, DoubleType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendDouble(i.toDouble)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, DoubleType) === i.toDouble)\n+    }\n+  }\n+\n+  test(\"string\") {\n+    testVector = allocate(10, StringType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, StringType) === UTF8String.fromString(s\"str$i\"))\n+    }\n+  }\n+\n+  test(\"binary\") {\n+    testVector = allocate(10, BinaryType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      assert(array.get(i, BinaryType) === utf8)\n+    }\n+  }\n+\n+  test(\"array\") {\n+    val arrayType = ArrayType(IntegerType, true)\n+    testVector = allocate(10, arrayType)\n+\n+    val data = testVector.arrayData()\n+    var i = 0\n+    while (i < 6) {\n+      data.putInt(i, i)\n+      i += 1\n+    }\n+\n+    // Populate it with arrays [0], [1, 2], [], [3, 4, 5]\n+    testVector.putArray(0, 0, 1)\n+    testVector.putArray(1, 1, 2)\n+    testVector.putArray(2, 3, 0)\n+    testVector.putArray(3, 3, 3)\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    assert(array.get(0, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(0))\n+    assert(array.get(1, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(1, 2))\n+    assert(array.get(2, arrayType).asInstanceOf[ArrayData].toIntArray() === Array.empty[Int])\n+    assert(array.get(3, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(3, 4, 5))\n+  }\n+\n+  test(\"struct\") {\n+    val schema = new StructType().add(\"int\", IntegerType).add(\"double\", DoubleType)\n+    testVector = allocate(10, schema)\n+    val c1 = testVector.getChildColumn(0)\n+    val c2 = testVector.getChildColumn(1)\n+    c1.putInt(0, 123)\n+    c2.putDouble(0, 3.45)\n+    c1.putInt(1, 456)\n+    c2.putDouble(1, 5.67)\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    assert(array.get(0, schema).asInstanceOf[ColumnarBatch.Row].get(0, IntegerType) === 123)\n+    assert(array.get(0, schema).asInstanceOf[ColumnarBatch.Row].get(1, DoubleType) === 3.45)\n+    assert(array.get(1, schema).asInstanceOf[ColumnarBatch.Row].get(0, IntegerType) === 456)\n+    assert(array.get(1, schema).asInstanceOf[ColumnarBatch.Row].get(1, DoubleType) === 5.67)\n+  }\n+}",
    "line": 201
  }, {
    "author": {
      "login": "liufengdb"
    },
    "body": "mapType is not supported in ColumnVector: https://github.com/apache/spark/blob/master/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ColumnVector.java#L235",
    "commit": "5ea4e8985002dd26922376d672af4db052063909",
    "createdAt": "2017-09-18T02:14:45Z",
    "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized\n+\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.util.ArrayData\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+class ColumnVectorSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  var testVector: WritableColumnVector = _\n+\n+  private def allocate(capacity: Int, dt: DataType): WritableColumnVector = {\n+    new OnHeapColumnVector(capacity, dt)\n+  }\n+\n+  override def afterEach(): Unit = {\n+    testVector.close()\n+  }\n+\n+  test(\"boolean\") {\n+    testVector = allocate(10, BooleanType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendBoolean(i % 2 == 0)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, BooleanType) === (i % 2 == 0))\n+    }\n+  }\n+\n+  test(\"byte\") {\n+    testVector = allocate(10, ByteType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendByte(i.toByte)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ByteType) === (i.toByte))\n+    }\n+  }\n+\n+  test(\"short\") {\n+    testVector = allocate(10, ShortType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendShort(i.toShort)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ShortType) === (i.toShort))\n+    }\n+  }\n+\n+  test(\"int\") {\n+    testVector = allocate(10, IntegerType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendInt(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, IntegerType) === i)\n+    }\n+  }\n+\n+  test(\"long\") {\n+    testVector = allocate(10, LongType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendLong(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, LongType) === i)\n+    }\n+  }\n+\n+  test(\"float\") {\n+    testVector = allocate(10, FloatType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendFloat(i.toFloat)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, FloatType) === i.toFloat)\n+    }\n+  }\n+\n+  test(\"double\") {\n+    testVector = allocate(10, DoubleType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendDouble(i.toDouble)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, DoubleType) === i.toDouble)\n+    }\n+  }\n+\n+  test(\"string\") {\n+    testVector = allocate(10, StringType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, StringType) === UTF8String.fromString(s\"str$i\"))\n+    }\n+  }\n+\n+  test(\"binary\") {\n+    testVector = allocate(10, BinaryType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      assert(array.get(i, BinaryType) === utf8)\n+    }\n+  }\n+\n+  test(\"array\") {\n+    val arrayType = ArrayType(IntegerType, true)\n+    testVector = allocate(10, arrayType)\n+\n+    val data = testVector.arrayData()\n+    var i = 0\n+    while (i < 6) {\n+      data.putInt(i, i)\n+      i += 1\n+    }\n+\n+    // Populate it with arrays [0], [1, 2], [], [3, 4, 5]\n+    testVector.putArray(0, 0, 1)\n+    testVector.putArray(1, 1, 2)\n+    testVector.putArray(2, 3, 0)\n+    testVector.putArray(3, 3, 3)\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    assert(array.get(0, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(0))\n+    assert(array.get(1, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(1, 2))\n+    assert(array.get(2, arrayType).asInstanceOf[ArrayData].toIntArray() === Array.empty[Int])\n+    assert(array.get(3, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(3, 4, 5))\n+  }\n+\n+  test(\"struct\") {\n+    val schema = new StructType().add(\"int\", IntegerType).add(\"double\", DoubleType)\n+    testVector = allocate(10, schema)\n+    val c1 = testVector.getChildColumn(0)\n+    val c2 = testVector.getChildColumn(1)\n+    c1.putInt(0, 123)\n+    c2.putDouble(0, 3.45)\n+    c1.putInt(1, 456)\n+    c2.putDouble(1, 5.67)\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    assert(array.get(0, schema).asInstanceOf[ColumnarBatch.Row].get(0, IntegerType) === 123)\n+    assert(array.get(0, schema).asInstanceOf[ColumnarBatch.Row].get(1, DoubleType) === 3.45)\n+    assert(array.get(1, schema).asInstanceOf[ColumnarBatch.Row].get(0, IntegerType) === 456)\n+    assert(array.get(1, schema).asInstanceOf[ColumnarBatch.Row].get(1, DoubleType) === 5.67)\n+  }\n+}",
    "line": 201
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see. \r\nDoes your change expect that  [this call](https://github.com/apache/spark/pull/19230/files#diff-7738d15a778268fd8b5574e2c655a660R213) finally throws an exception for `Map` element in array?",
    "commit": "5ea4e8985002dd26922376d672af4db052063909",
    "createdAt": "2017-09-18T08:28:13Z",
    "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized\n+\n+import org.scalatest.BeforeAndAfterEach\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.util.ArrayData\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+class ColumnVectorSuite extends SparkFunSuite with BeforeAndAfterEach {\n+\n+  var testVector: WritableColumnVector = _\n+\n+  private def allocate(capacity: Int, dt: DataType): WritableColumnVector = {\n+    new OnHeapColumnVector(capacity, dt)\n+  }\n+\n+  override def afterEach(): Unit = {\n+    testVector.close()\n+  }\n+\n+  test(\"boolean\") {\n+    testVector = allocate(10, BooleanType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendBoolean(i % 2 == 0)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, BooleanType) === (i % 2 == 0))\n+    }\n+  }\n+\n+  test(\"byte\") {\n+    testVector = allocate(10, ByteType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendByte(i.toByte)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ByteType) === (i.toByte))\n+    }\n+  }\n+\n+  test(\"short\") {\n+    testVector = allocate(10, ShortType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendShort(i.toShort)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, ShortType) === (i.toShort))\n+    }\n+  }\n+\n+  test(\"int\") {\n+    testVector = allocate(10, IntegerType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendInt(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, IntegerType) === i)\n+    }\n+  }\n+\n+  test(\"long\") {\n+    testVector = allocate(10, LongType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendLong(i)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, LongType) === i)\n+    }\n+  }\n+\n+  test(\"float\") {\n+    testVector = allocate(10, FloatType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendFloat(i.toFloat)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, FloatType) === i.toFloat)\n+    }\n+  }\n+\n+  test(\"double\") {\n+    testVector = allocate(10, DoubleType)\n+    (0 until 10).foreach { i =>\n+      testVector.appendDouble(i.toDouble)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, DoubleType) === i.toDouble)\n+    }\n+  }\n+\n+  test(\"string\") {\n+    testVector = allocate(10, StringType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      assert(array.get(i, StringType) === UTF8String.fromString(s\"str$i\"))\n+    }\n+  }\n+\n+  test(\"binary\") {\n+    testVector = allocate(10, BinaryType)\n+    (0 until 10).map { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      testVector.appendByteArray(utf8, 0, utf8.length)\n+    }\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    (0 until 10).foreach { i =>\n+      val utf8 = s\"str$i\".getBytes(\"utf8\")\n+      assert(array.get(i, BinaryType) === utf8)\n+    }\n+  }\n+\n+  test(\"array\") {\n+    val arrayType = ArrayType(IntegerType, true)\n+    testVector = allocate(10, arrayType)\n+\n+    val data = testVector.arrayData()\n+    var i = 0\n+    while (i < 6) {\n+      data.putInt(i, i)\n+      i += 1\n+    }\n+\n+    // Populate it with arrays [0], [1, 2], [], [3, 4, 5]\n+    testVector.putArray(0, 0, 1)\n+    testVector.putArray(1, 1, 2)\n+    testVector.putArray(2, 3, 0)\n+    testVector.putArray(3, 3, 3)\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    assert(array.get(0, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(0))\n+    assert(array.get(1, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(1, 2))\n+    assert(array.get(2, arrayType).asInstanceOf[ArrayData].toIntArray() === Array.empty[Int])\n+    assert(array.get(3, arrayType).asInstanceOf[ArrayData].toIntArray() === Array(3, 4, 5))\n+  }\n+\n+  test(\"struct\") {\n+    val schema = new StructType().add(\"int\", IntegerType).add(\"double\", DoubleType)\n+    testVector = allocate(10, schema)\n+    val c1 = testVector.getChildColumn(0)\n+    val c2 = testVector.getChildColumn(1)\n+    c1.putInt(0, 123)\n+    c2.putDouble(0, 3.45)\n+    c1.putInt(1, 456)\n+    c2.putDouble(1, 5.67)\n+\n+    val array = new ColumnVector.Array(testVector)\n+\n+    assert(array.get(0, schema).asInstanceOf[ColumnarBatch.Row].get(0, IntegerType) === 123)\n+    assert(array.get(0, schema).asInstanceOf[ColumnarBatch.Row].get(1, DoubleType) === 3.45)\n+    assert(array.get(1, schema).asInstanceOf[ColumnarBatch.Row].get(0, IntegerType) === 456)\n+    assert(array.get(1, schema).asInstanceOf[ColumnarBatch.Row].get(1, DoubleType) === 5.67)\n+  }\n+}",
    "line": 201
  }],
  "prId": 19230
}]