[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should this be out of the loop?\n",
    "commit": "36c8ddb6b51b3a7ee33950732287644a758615e7",
    "createdAt": "2016-01-07T06:44:41Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.execution.datasources.parquet\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.vectorized.ColumnVector\n+import org.apache.spark.sql.types.IntegerType\n+import org.apache.spark.unsafe.Platform\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark to low level memory access using different ways to manage buffers.\n+ */\n+object ColumnarBatchBenchmark {\n+\n+  // This benchmark reads and writes an array of ints.\n+  // TODO: there is a big (2x) penalty for a random access API for off heap.\n+  // Note: carefully if modifying this code. It's hard to reason about the JIT.\n+  def intAccess(iters: Long): Unit = {\n+    val count = 8 * 1000\n+\n+    // Accessing a java array.\n+    val javaArray = { i: Int =>\n+      val data = new Array[Int](count)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data(i) = i\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += data(i)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing ByteBuffers\n+    val byteBufferUnsafe = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing offheap byte buffers\n+    val directByteBuffer = { i: Int =>\n+      val data = ByteBuffer.allocateDirect(count * 4).asIntBuffer()\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.put(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.get()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Accessing ByteBuffer using the typed APIs\n+    val byteBufferApi = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.putInt(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.getInt()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Using unsafe memory\n+    val unsafeBuffer = { i: Int =>\n+      val data: Long = Platform.allocateMemory(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var ptr = data\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, ptr, i)\n+          ptr += 4\n+          i += 1\n+        }\n+        ptr = data\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(null, ptr)\n+          ptr += 4\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Access through the column API with on heap memory\n+    val columnOnHeap = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, false)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access through the column API with off heap memory\n+    def columnOffHeap = { i: Int => {\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }}\n+\n+    // Access by directly getting the buffer backing the column.\n+    val columnOffheapDirect = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var addr = col.valuesNativeAddress()\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, addr, i)\n+          addr += 4\n+          i += 1\n+        }\n+        i = 0\n+        addr = col.valuesNativeAddress()\n+        while (i < count) {\n+          sum += Platform.getInt(null, addr)\n+          addr += 4\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access by going through a batch of unsafe rows.\n+    val unsafeRowOnheap = { i: Int =>\n+      val buffer = new Array[Byte](count * 16)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        val row = new UnsafeRow(1)",
    "line": 203
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "It's already not in the inner loop. Count is big enough.\n",
    "commit": "36c8ddb6b51b3a7ee33950732287644a758615e7",
    "createdAt": "2016-01-12T00:08:36Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.execution.datasources.parquet\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.vectorized.ColumnVector\n+import org.apache.spark.sql.types.IntegerType\n+import org.apache.spark.unsafe.Platform\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark to low level memory access using different ways to manage buffers.\n+ */\n+object ColumnarBatchBenchmark {\n+\n+  // This benchmark reads and writes an array of ints.\n+  // TODO: there is a big (2x) penalty for a random access API for off heap.\n+  // Note: carefully if modifying this code. It's hard to reason about the JIT.\n+  def intAccess(iters: Long): Unit = {\n+    val count = 8 * 1000\n+\n+    // Accessing a java array.\n+    val javaArray = { i: Int =>\n+      val data = new Array[Int](count)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data(i) = i\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += data(i)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing ByteBuffers\n+    val byteBufferUnsafe = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing offheap byte buffers\n+    val directByteBuffer = { i: Int =>\n+      val data = ByteBuffer.allocateDirect(count * 4).asIntBuffer()\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.put(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.get()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Accessing ByteBuffer using the typed APIs\n+    val byteBufferApi = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.putInt(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.getInt()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Using unsafe memory\n+    val unsafeBuffer = { i: Int =>\n+      val data: Long = Platform.allocateMemory(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var ptr = data\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, ptr, i)\n+          ptr += 4\n+          i += 1\n+        }\n+        ptr = data\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(null, ptr)\n+          ptr += 4\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Access through the column API with on heap memory\n+    val columnOnHeap = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, false)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access through the column API with off heap memory\n+    def columnOffHeap = { i: Int => {\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }}\n+\n+    // Access by directly getting the buffer backing the column.\n+    val columnOffheapDirect = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var addr = col.valuesNativeAddress()\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, addr, i)\n+          addr += 4\n+          i += 1\n+        }\n+        i = 0\n+        addr = col.valuesNativeAddress()\n+        while (i < count) {\n+          sum += Platform.getInt(null, addr)\n+          addr += 4\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access by going through a batch of unsafe rows.\n+    val unsafeRowOnheap = { i: Int =>\n+      val buffer = new Array[Byte](count * 16)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        val row = new UnsafeRow(1)",
    "line": 203
  }],
  "prId": 10628
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "I'm really surprised that this one is faster than the Java Array, any clue?\n",
    "commit": "36c8ddb6b51b3a7ee33950732287644a758615e7",
    "createdAt": "2016-01-07T06:51:41Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.execution.datasources.parquet\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.vectorized.ColumnVector\n+import org.apache.spark.sql.types.IntegerType\n+import org.apache.spark.unsafe.Platform\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark to low level memory access using different ways to manage buffers.\n+ */\n+object ColumnarBatchBenchmark {\n+\n+  // This benchmark reads and writes an array of ints.\n+  // TODO: there is a big (2x) penalty for a random access API for off heap.\n+  // Note: carefully if modifying this code. It's hard to reason about the JIT.\n+  def intAccess(iters: Long): Unit = {\n+    val count = 8 * 1000\n+\n+    // Accessing a java array.\n+    val javaArray = { i: Int =>\n+      val data = new Array[Int](count)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data(i) = i\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += data(i)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing ByteBuffers\n+    val byteBufferUnsafe = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing offheap byte buffers\n+    val directByteBuffer = { i: Int =>\n+      val data = ByteBuffer.allocateDirect(count * 4).asIntBuffer()\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.put(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.get()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Accessing ByteBuffer using the typed APIs\n+    val byteBufferApi = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.putInt(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.getInt()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Using unsafe memory\n+    val unsafeBuffer = { i: Int =>\n+      val data: Long = Platform.allocateMemory(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var ptr = data\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, ptr, i)\n+          ptr += 4\n+          i += 1\n+        }\n+        ptr = data\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(null, ptr)\n+          ptr += 4\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Access through the column API with on heap memory\n+    val columnOnHeap = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, false)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access through the column API with off heap memory\n+    def columnOffHeap = { i: Int => {\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }}\n+\n+    // Access by directly getting the buffer backing the column.\n+    val columnOffheapDirect = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var addr = col.valuesNativeAddress()\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, addr, i)\n+          addr += 4\n+          i += 1\n+        }\n+        i = 0\n+        addr = col.valuesNativeAddress()\n+        while (i < count) {\n+          sum += Platform.getInt(null, addr)\n+          addr += 4\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access by going through a batch of unsafe rows.\n+    val unsafeRowOnheap = { i: Int =>\n+      val buffer = new Array[Byte](count * 16)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        val row = new UnsafeRow(1)\n+        var i = 0\n+        while (i < count) {\n+          row.pointTo(buffer, Platform.BYTE_ARRAY_OFFSET + i * 16, 16)\n+          row.setInt(0, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          row.pointTo(buffer, Platform.BYTE_ARRAY_OFFSET + i * 16, 16)\n+          sum += row.getInt(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Access by going through a batch of unsafe rows.\n+    val unsafeRowOffheap = { i: Int =>\n+      val buffer = Platform.allocateMemory(count * 16)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        val row = new UnsafeRow(1)\n+        var i = 0\n+        while (i < count) {\n+          row.pointTo(null, buffer + i * 16, 16)\n+          row.setInt(0, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          row.pointTo(null, buffer + i * 16, 16)\n+          sum += row.getInt(0)\n+          i += 1\n+        }\n+      }\n+      Platform.freeMemory(buffer)\n+    }\n+\n+    /*\n+    Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\n+    Int Read/Write:              Avg Time(ms)    Avg Rate(M/s)  Relative Rate\n+    -------------------------------------------------------------------------\n+    Java Array                          248.8          1317.04         1.00 X\n+    ByteBuffer Unsafe                   435.6           752.25         0.57 X\n+    ByteBuffer API                     1752.0           187.03         0.14 X\n+    DirectByteBuffer                    595.4           550.35         0.42 X\n+    Unsafe Buffer                       235.2          1393.20         1.06 X\n+    Column(on heap)                     189.8          1726.45         1.31 X",
    "line": 250
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "I agree it doesn't make sense. I think we're really susceptible to jvm jitting behavior.\n",
    "commit": "36c8ddb6b51b3a7ee33950732287644a758615e7",
    "createdAt": "2016-01-12T00:09:15Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.execution.datasources.parquet\n+\n+import java.nio.ByteBuffer\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.vectorized.ColumnVector\n+import org.apache.spark.sql.types.IntegerType\n+import org.apache.spark.unsafe.Platform\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark to low level memory access using different ways to manage buffers.\n+ */\n+object ColumnarBatchBenchmark {\n+\n+  // This benchmark reads and writes an array of ints.\n+  // TODO: there is a big (2x) penalty for a random access API for off heap.\n+  // Note: carefully if modifying this code. It's hard to reason about the JIT.\n+  def intAccess(iters: Long): Unit = {\n+    val count = 8 * 1000\n+\n+    // Accessing a java array.\n+    val javaArray = { i: Int =>\n+      val data = new Array[Int](count)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data(i) = i\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += data(i)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing ByteBuffers\n+    val byteBufferUnsafe = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(data.array(), Platform.BYTE_ARRAY_OFFSET + i * 4)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Accessing offheap byte buffers\n+    val directByteBuffer = { i: Int =>\n+      val data = ByteBuffer.allocateDirect(count * 4).asIntBuffer()\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.put(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.get()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Accessing ByteBuffer using the typed APIs\n+    val byteBufferApi = { i: Int =>\n+      val data = ByteBuffer.allocate(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          data.putInt(i)\n+          i += 1\n+        }\n+        data.rewind()\n+        i = 0\n+        while (i < count) {\n+          sum += data.getInt()\n+          i += 1\n+        }\n+        data.rewind()\n+      }\n+    }\n+\n+    // Using unsafe memory\n+    val unsafeBuffer = { i: Int =>\n+      val data: Long = Platform.allocateMemory(count * 4)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var ptr = data\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, ptr, i)\n+          ptr += 4\n+          i += 1\n+        }\n+        ptr = data\n+        i = 0\n+        while (i < count) {\n+          sum += Platform.getInt(null, ptr)\n+          ptr += 4\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Access through the column API with on heap memory\n+    val columnOnHeap = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, false)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access through the column API with off heap memory\n+    def columnOffHeap = { i: Int => {\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var i = 0\n+        while (i < count) {\n+          col.putInt(i, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          sum += col.getInt(i)\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }}\n+\n+    // Access by directly getting the buffer backing the column.\n+    val columnOffheapDirect = { i: Int =>\n+      val col = ColumnVector.allocate(count, IntegerType, true)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        var addr = col.valuesNativeAddress()\n+        var i = 0\n+        while (i < count) {\n+          Platform.putInt(null, addr, i)\n+          addr += 4\n+          i += 1\n+        }\n+        i = 0\n+        addr = col.valuesNativeAddress()\n+        while (i < count) {\n+          sum += Platform.getInt(null, addr)\n+          addr += 4\n+          i += 1\n+        }\n+      }\n+      col.close\n+    }\n+\n+    // Access by going through a batch of unsafe rows.\n+    val unsafeRowOnheap = { i: Int =>\n+      val buffer = new Array[Byte](count * 16)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        val row = new UnsafeRow(1)\n+        var i = 0\n+        while (i < count) {\n+          row.pointTo(buffer, Platform.BYTE_ARRAY_OFFSET + i * 16, 16)\n+          row.setInt(0, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          row.pointTo(buffer, Platform.BYTE_ARRAY_OFFSET + i * 16, 16)\n+          sum += row.getInt(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    // Access by going through a batch of unsafe rows.\n+    val unsafeRowOffheap = { i: Int =>\n+      val buffer = Platform.allocateMemory(count * 16)\n+      var sum = 0L\n+      for (n <- 0L until iters) {\n+        val row = new UnsafeRow(1)\n+        var i = 0\n+        while (i < count) {\n+          row.pointTo(null, buffer + i * 16, 16)\n+          row.setInt(0, i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < count) {\n+          row.pointTo(null, buffer + i * 16, 16)\n+          sum += row.getInt(0)\n+          i += 1\n+        }\n+      }\n+      Platform.freeMemory(buffer)\n+    }\n+\n+    /*\n+    Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\n+    Int Read/Write:              Avg Time(ms)    Avg Rate(M/s)  Relative Rate\n+    -------------------------------------------------------------------------\n+    Java Array                          248.8          1317.04         1.00 X\n+    ByteBuffer Unsafe                   435.6           752.25         0.57 X\n+    ByteBuffer API                     1752.0           187.03         0.14 X\n+    DirectByteBuffer                    595.4           550.35         0.42 X\n+    Unsafe Buffer                       235.2          1393.20         1.06 X\n+    Column(on heap)                     189.8          1726.45         1.31 X",
    "line": 250
  }],
  "prId": 10628
}]