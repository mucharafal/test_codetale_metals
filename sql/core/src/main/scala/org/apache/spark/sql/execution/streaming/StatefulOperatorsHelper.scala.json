[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "I am not sure why it is inside this generically named object `StatefulOperatorsHelper`. Rather make it a top-level trait `StreamingAggregationStateManager` in the `execution.streaming.state` package (similar to `FlatMapGroupsWithStateExecHelper`).\r\n\r\nIf you are modeling this against my state format PR for mapGroupsWithState, the only reason I put it in the `StateManager` class inside object` FlatMapGroupsWithStateExecHelper` was to avoid names like `FlatMapGroupsWithStateExec_StateManager`. I dont think that concern applies if you use the name `StreamingAggregationStateManager`.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T00:45:10Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Yeah right. I found your PR useful to get an idea of how to model the classes because it was dealing with similar requirement, but didn't indicate the reason why you place it into StatefulOperatorsHelper. I'll move them to the state package.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:24:22Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {"
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Add docs ",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T00:47:02Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Will fix.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:24:36Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {"
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "what does getValueExpressions mean? its not obvious from the name.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T00:47:41Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "It is to define the schema of value from / to state. For V1 it would be same to input schema and for V2 it would be `input schema - key schema`. Would `getStateValueExpressions` be OK for us?",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:28:14Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "It would be going to be `getStateValueSchema` btw, once we change return type.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T08:18:44Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]"
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "what are you getting? what are you putting? More docs please :)",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T00:48:25Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow\n+    def get(store: StateStore, key: UnsafeRow): UnsafeRow"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "I might think naively about this: I thought its interface is similar to StateStore so wondered we need to add docs, but I think I was wrong. Will add docs. Thanks for the insightful input!",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:35:07Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow\n+    def get(store: StateStore, key: UnsafeRow): UnsafeRow"
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "what is the row here? add docs.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T00:49:56Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Maybe rename this to `getKey` to be consistent with other methods.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T01:28:43Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Renaming sounds better. Will rename, and will also add docs.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:25:38Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow"
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "I dont think this method is needed if you rather add methods `getIterator` and `remove` to this interface. The only reason `restoreOriginRow` this being used is because the operator is directly accessing the `store` (through `store.remove()` and `store.iterator()`) and then trying to fix the row, instead of the delegating those operations to the `StateManager`. In fact, if there exists a `StateManager` to manage all the state in the store, then ALL operations to add/remove state should go through the manager and `store` should not be accessed directly. ",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T00:50:18Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "> In fact, if there exists a StateManager to manage all the state in the store, then ALL operations to add/remove state should go through the manager and store should not be accessed directly.\r\n\r\nTotally agreed that it should be better design of StateManager. I don't remember I tried to do before, so let me try applying your suggestion and see there's anything blocks.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:32:13Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow"
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Add docs on the state formats. How does each format organize the data in the row? ",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T01:18:16Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow\n+    def get(store: StateStore, key: UnsafeRow): UnsafeRow\n+    def put(store: StateStore, row: UnsafeRow): Unit\n+  }\n+\n+  object StreamingAggregationStateManager extends Logging {\n+    def createStateManager(\n+        keyExpressions: Seq[Attribute],\n+        childOutput: Seq[Attribute],\n+        stateFormatVersion: Int): StreamingAggregationStateManager = {\n+      stateFormatVersion match {\n+        case 1 => new StreamingAggregationStateManagerImplV1(keyExpressions, childOutput)\n+        case 2 => new StreamingAggregationStateManagerImplV2(keyExpressions, childOutput)\n+        case _ => throw new IllegalArgumentException(s\"Version $stateFormatVersion is invalid\")\n+      }\n+    }\n+  }\n+\n+  abstract class StreamingAggregationStateManagerBaseImpl(\n+      protected val keyExpressions: Seq[Attribute],\n+      protected val childOutput: Seq[Attribute]) extends StreamingAggregationStateManager {\n+\n+    @transient protected lazy val keyProjector =\n+      GenerateUnsafeProjection.generate(keyExpressions, childOutput)\n+\n+    def extractKey(row: InternalRow): UnsafeRow = keyProjector(row)\n+  }\n+\n+  class StreamingAggregationStateManagerImplV1(\n+      keyExpressions: Seq[Attribute],\n+      childOutput: Seq[Attribute])\n+    extends StreamingAggregationStateManagerBaseImpl(keyExpressions, childOutput) {\n+\n+    override def getValueExpressions: Seq[Attribute] = {\n+      childOutput\n+    }\n+\n+    override def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow = {\n+      rowPair.value\n+    }\n+\n+    override def get(store: StateStore, key: UnsafeRow): UnsafeRow = {\n+      store.get(key)\n+    }\n+\n+    override def put(store: StateStore, row: UnsafeRow): Unit = {\n+      store.put(extractKey(row), row)\n+    }\n+  }\n+\n+  class StreamingAggregationStateManagerImplV2("
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Great point. I might be in a rush to show its shape. Will add doc for state formats in both V1 and V2.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:38:17Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow\n+    def get(store: StateStore, key: UnsafeRow): UnsafeRow\n+    def put(store: StateStore, row: UnsafeRow): Unit\n+  }\n+\n+  object StreamingAggregationStateManager extends Logging {\n+    def createStateManager(\n+        keyExpressions: Seq[Attribute],\n+        childOutput: Seq[Attribute],\n+        stateFormatVersion: Int): StreamingAggregationStateManager = {\n+      stateFormatVersion match {\n+        case 1 => new StreamingAggregationStateManagerImplV1(keyExpressions, childOutput)\n+        case 2 => new StreamingAggregationStateManagerImplV2(keyExpressions, childOutput)\n+        case _ => throw new IllegalArgumentException(s\"Version $stateFormatVersion is invalid\")\n+      }\n+    }\n+  }\n+\n+  abstract class StreamingAggregationStateManagerBaseImpl(\n+      protected val keyExpressions: Seq[Attribute],\n+      protected val childOutput: Seq[Attribute]) extends StreamingAggregationStateManager {\n+\n+    @transient protected lazy val keyProjector =\n+      GenerateUnsafeProjection.generate(keyExpressions, childOutput)\n+\n+    def extractKey(row: InternalRow): UnsafeRow = keyProjector(row)\n+  }\n+\n+  class StreamingAggregationStateManagerImplV1(\n+      keyExpressions: Seq[Attribute],\n+      childOutput: Seq[Attribute])\n+    extends StreamingAggregationStateManagerBaseImpl(keyExpressions, childOutput) {\n+\n+    override def getValueExpressions: Seq[Attribute] = {\n+      childOutput\n+    }\n+\n+    override def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow = {\n+      rowPair.value\n+    }\n+\n+    override def get(store: StateStore, key: UnsafeRow): UnsafeRow = {\n+      store.get(key)\n+    }\n+\n+    override def put(store: StateStore, row: UnsafeRow): Unit = {\n+      store.put(extractKey(row), row)\n+    }\n+  }\n+\n+  class StreamingAggregationStateManagerImplV2("
  }],
  "prId": 21733
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "maybe rename `childOutput` to `inputRowAttributes` to make the name more meaningful in the context of the StateManager interface (which does not have any concept of child).",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T01:26:11Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow\n+    def get(store: StateStore, key: UnsafeRow): UnsafeRow\n+    def put(store: StateStore, row: UnsafeRow): Unit\n+  }\n+\n+  object StreamingAggregationStateManager extends Logging {\n+    def createStateManager(\n+        keyExpressions: Seq[Attribute],\n+        childOutput: Seq[Attribute],"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Sounds much better and you're right about concept of `child`. Will rename.",
    "commit": "19888abc281d7a0689bf57e4c76bda918ad9306b",
    "createdAt": "2018-08-01T07:36:11Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateUnsafeRowJoiner}\n+import org.apache.spark.sql.execution.streaming.state.{StateStore, UnsafeRowPair}\n+import org.apache.spark.sql.types.StructType\n+\n+object StatefulOperatorsHelper {\n+\n+  val supportedVersions = Seq(1, 2)\n+  val legacyVersion = 1\n+\n+  sealed trait StreamingAggregationStateManager extends Serializable {\n+    def extractKey(row: InternalRow): UnsafeRow\n+    def getValueExpressions: Seq[Attribute]\n+    def restoreOriginRow(rowPair: UnsafeRowPair): UnsafeRow\n+    def get(store: StateStore, key: UnsafeRow): UnsafeRow\n+    def put(store: StateStore, row: UnsafeRow): Unit\n+  }\n+\n+  object StreamingAggregationStateManager extends Logging {\n+    def createStateManager(\n+        keyExpressions: Seq[Attribute],\n+        childOutput: Seq[Attribute],"
  }],
  "prId": 21733
}]