[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "There is a race here right?  If I have a simple program:\n\n``` scala\ndef main(...): Unit = {\n  val myStream = sqlContext.streamFrom...start()\n  // Stream above could already be dead.\n  sqlContext.awaitAnyTermination()\n}\n```\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T00:18:11Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I know this problem. That's the level of guarantee this API can provide, only wait on currently active queries at the time `awaitAnyTermination` is called. \n\nActually I thought about this, and a part of me is saying that this API is need to be reconsidered.\n- Option 1: instead of `sqlContext.awaitAnyTermination()` (where its not clear what you are waiting on), how about `sqlContext.awaitAnyTermination(query1, query2, ...)`\n- Option 2: Forget this API for now. We can think about it later.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T00:41:09Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "The other option is to move `lastTerminatedQuery = null` into another call called `clearFailures`.  I think that give the user what they most likely want to call at the end of their `main()` without any extra work.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T00:47:52Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Still the semantics is not very clear. What if multiple queries terminate between a `clearFailures` and `awaitAnyTermination`. Then the use will get to know one of the failures, and miss the others.  I am almost inclined to go to option 2 and not check in stuff that we are not convinced about. \n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-04T02:34:33Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null"
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Why use `wait(10)` to wake up every 10 milliseconds? Looks waste a lot of CPU cycles and unnecessary thread context switches.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T00:42:49Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      lastTerminatedQuery\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated.\n+   * Returns the stopped query if any query was terminated.\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Option[ContinuousQuery] = {\n+    val endTime = System.currentTimeMillis + timeoutMs\n+    def timeLeft = math.max(endTime - System.currentTimeMillis, 0)\n+\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (timeLeft > 0 && lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "So that if there is a race condition between one thread calling awaitTermination, and the sqlcontext being terminated, the waiting thread does not get stuff indefinitely waiting for the notifyAll to come \n\nAlso calling something this cheap 100 times a second is really cpu intensive. :)\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T03:10:22Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      lastTerminatedQuery\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated.\n+   * Returns the stopped query if any query was terminated.\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Option[ContinuousQuery] = {\n+    val endTime = System.currentTimeMillis + timeoutMs\n+    def timeLeft = math.max(endTime - System.currentTimeMillis, 0)\n+\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (timeLeft > 0 && lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "> So that if there is a race condition between one thread calling awaitTermination, and the sqlcontext being terminated, the waiting thread does not get stuff indefinitely waiting for the notifyAll to come\n\nBut `awaitTerminationLock` can guarantee no race condition like this. Right?\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T21:29:48Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      lastTerminatedQuery\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated.\n+   * Returns the stopped query if any query was terminated.\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Option[ContinuousQuery] = {\n+    val endTime = System.currentTimeMillis + timeoutMs\n+    def timeLeft = math.max(endTime - System.currentTimeMillis, 0)\n+\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (timeLeft > 0 && lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I change the implementation to use CountDownLatch. Much simpler implementation.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-04T02:36:42Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      lastTerminatedQuery\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated.\n+   * Returns the stopped query if any query was terminated.\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Option[ContinuousQuery] = {\n+    val endTime = System.currentTimeMillis + timeoutMs\n+    def timeLeft = math.max(endTime - System.currentTimeMillis, 0)\n+\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (timeLeft > 0 && lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "You have not yet fixed this place.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-05T23:30:57Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      lastTerminatedQuery\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated.\n+   * Returns the stopped query if any query was terminated.\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Option[ContinuousQuery] = {\n+    val endTime = System.currentTimeMillis + timeoutMs\n+    def timeLeft = math.max(endTime - System.currentTimeMillis, 0)\n+\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (timeLeft > 0 && lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)"
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Same as the above comment about `wait(10)`.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T00:43:35Z",
    "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{Sink, StreamExecution}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ * \n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager {\n+\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  @volatile\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /** Returns a list of active queries associated with this SQLContext */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /** Returns an active query from this SQLContext or throws exception if bad name */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on this SQLContext is terminated, with or without\n+   * exceptions. Returns the query that has been terminated.\n+   */\n+  def awaitAnyTermination(): ContinuousQuery = {\n+    awaitTerminationLock.synchronized {\n+      lastTerminatedQuery = null\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)"
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "@marmbrus is it okay for this publicly visible API to be a class and not a trait?\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-04T03:26:50Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{ContinuousQueryListenerBus, Sink, StreamExecution}\n+import org.apache.spark.sql.util.ContinuousQueryListener\n+import org.apache.spark.sql.util.ContinuousQueryListener.{QueryTerminated, QueryStarted}\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ *\n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager(sqlContext: SQLContext) {",
    "line": 34
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: missing more doc\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-09T20:32:34Z",
    "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{ContinuousQueryListenerBus, Sink, StreamExecution}\n+import org.apache.spark.sql.util.ContinuousQueryListener\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ *\n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager(sqlContext: SQLContext) {\n+\n+  private val listenerBus = new ContinuousQueryListenerBus(sqlContext.sparkContext.listenerBus)\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /**\n+   * Returns a list of active queries associated with this SQLContext\n+   *\n+   * @since 2.0.0\n+   */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /**\n+   * Returns an active query from this SQLContext or throws exception if bad name\n+   *\n+   * @since 2.0.0\n+   */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on the associated SQLContext has terminated since the\n+   * creation of the context, or since `clearTermination()` was called. If any query was terminated\n+   * with an exception, then the exception will be thrown.\n+   *\n+   * If a query has terminated, then subsequent calls to `awaitAnyTermination()` will either\n+   * return immediately (if the query was terminated by `query.stop()`),\n+   * or throw the exception immediately (if the query was terminated with exception). Use\n+   * `resetTerminated()` to clear past terminations and wait for new terminations.\n+   *\n+   * Note that if multiple queries have terminated"
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "I guess it's possible that the user may call `awaitAnyTermination(Long.MaxValue)` then this will overflow. How about:\n\n```\n  def awaitAnyTermination(timeoutMs: Long): Boolean = {\n    val startTime = System.currentTimeMillis\n    def isTimeout = timeoutMs <= System.currentTimeMillis - startTime\n\n    awaitTerminationLock.synchronized {\n      while (!isTimeout && lastTerminatedQuery == null) {\n        awaitTerminationLock.wait(10)\n      }\n      if (lastTerminatedQuery != null && lastTerminatedQuery.exception.nonEmpty) {\n        throw lastTerminatedQuery.exception.get\n      }\n      lastTerminatedQuery != null\n    }\n  }\n```\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-09T20:32:38Z",
    "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{ContinuousQueryListenerBus, Sink, StreamExecution}\n+import org.apache.spark.sql.util.ContinuousQueryListener\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ *\n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager(sqlContext: SQLContext) {\n+\n+  private val listenerBus = new ContinuousQueryListenerBus(sqlContext.sparkContext.listenerBus)\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /**\n+   * Returns a list of active queries associated with this SQLContext\n+   *\n+   * @since 2.0.0\n+   */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /**\n+   * Returns an active query from this SQLContext or throws exception if bad name\n+   *\n+   * @since 2.0.0\n+   */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on the associated SQLContext has terminated since the\n+   * creation of the context, or since `clearTermination()` was called. If any query was terminated\n+   * with an exception, then the exception will be thrown.\n+   *\n+   * If a query has terminated, then subsequent calls to `awaitAnyTermination()` will either\n+   * return immediately (if the query was terminated by `query.stop()`),\n+   * or throw the exception immediately (if the query was terminated with exception). Use\n+   * `resetTerminated()` to clear past terminations and wait for new terminations.\n+   *\n+   * Note that if multiple queries have terminated\n+   * @throws ContinuousQueryException, if any query has terminated with an exception without\n+   *         `timeoutMs` milliseconds.\n+   *\n+   * @since 2.0.0\n+   */\n+  def awaitAnyTermination(): Unit = {\n+    awaitTerminationLock.synchronized {\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      if (lastTerminatedQuery != null && lastTerminatedQuery.exception.nonEmpty) {\n+        throw lastTerminatedQuery.exception.get\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on the associated SQLContext has terminated since the\n+   * creation of the context, or since `clearTermination()` was called. Returns whether the query\n+   * has terminated or not. If the query has terminated with an exception,\n+   * then the exception will be thrown.\n+   *\n+   * If a query has terminated, then subsequent calls to `awaitAnyTermination()` will either\n+   * return `true` immediately (if the query was terminated by `query.stop()`),\n+   * or throw the exception immediately (if the query was terminated with exception). Use\n+   * `resetTerminated()` to clear past terminations and wait for new terminations.\n+   *\n+   * @throws ContinuousQueryException, if any query has terminated with an exception\n+   *\n+   * @since 2.0.0\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Boolean = {\n+    val endTime = System.currentTimeMillis + timeoutMs"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Good catch. Thanks!\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-09T22:27:04Z",
    "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.execution.streaming.{ContinuousQueryListenerBus, Sink, StreamExecution}\n+import org.apache.spark.sql.util.ContinuousQueryListener\n+\n+/**\n+ * :: Experimental ::\n+ * A class to manage all the [[org.apache.spark.sql.ContinuousQuery ContinuousQueries]] active\n+ * on a [[SQLContext]].\n+ *\n+ * @since 2.0.0\n+ */\n+@Experimental\n+class ContinuousQueryManager(sqlContext: SQLContext) {\n+\n+  private val listenerBus = new ContinuousQueryListenerBus(sqlContext.sparkContext.listenerBus)\n+  private val activeQueries = new mutable.HashMap[String, ContinuousQuery]\n+  private val activeQueriesLock = new Object\n+  private val awaitTerminationLock = new Object\n+\n+  private var lastTerminatedQuery: ContinuousQuery = null\n+\n+  /**\n+   * Returns a list of active queries associated with this SQLContext\n+   *\n+   * @since 2.0.0\n+   */\n+  def active: Array[ContinuousQuery] = activeQueriesLock.synchronized {\n+    activeQueries.values.toArray\n+  }\n+\n+  /**\n+   * Returns an active query from this SQLContext or throws exception if bad name\n+   *\n+   * @since 2.0.0\n+   */\n+  def get(name: String): ContinuousQuery = activeQueriesLock.synchronized {\n+    activeQueries.get(name).getOrElse {\n+      throw new IllegalArgumentException(s\"There is no active query with name $name\")\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on the associated SQLContext has terminated since the\n+   * creation of the context, or since `clearTermination()` was called. If any query was terminated\n+   * with an exception, then the exception will be thrown.\n+   *\n+   * If a query has terminated, then subsequent calls to `awaitAnyTermination()` will either\n+   * return immediately (if the query was terminated by `query.stop()`),\n+   * or throw the exception immediately (if the query was terminated with exception). Use\n+   * `resetTerminated()` to clear past terminations and wait for new terminations.\n+   *\n+   * Note that if multiple queries have terminated\n+   * @throws ContinuousQueryException, if any query has terminated with an exception without\n+   *         `timeoutMs` milliseconds.\n+   *\n+   * @since 2.0.0\n+   */\n+  def awaitAnyTermination(): Unit = {\n+    awaitTerminationLock.synchronized {\n+      while (lastTerminatedQuery == null) {\n+        awaitTerminationLock.wait(10)\n+      }\n+      if (lastTerminatedQuery != null && lastTerminatedQuery.exception.nonEmpty) {\n+        throw lastTerminatedQuery.exception.get\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Wait until any of the queries on the associated SQLContext has terminated since the\n+   * creation of the context, or since `clearTermination()` was called. Returns whether the query\n+   * has terminated or not. If the query has terminated with an exception,\n+   * then the exception will be thrown.\n+   *\n+   * If a query has terminated, then subsequent calls to `awaitAnyTermination()` will either\n+   * return `true` immediately (if the query was terminated by `query.stop()`),\n+   * or throw the exception immediately (if the query was terminated with exception). Use\n+   * `resetTerminated()` to clear past terminations and wait for new terminations.\n+   *\n+   * @throws ContinuousQueryException, if any query has terminated with an exception\n+   *\n+   * @since 2.0.0\n+   */\n+  def awaitAnyTermination(timeoutMs: Long): Boolean = {\n+    val endTime = System.currentTimeMillis + timeoutMs"
  }],
  "prId": 11030
}]