[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "While I'm generally a fan of scala trickery. I have found massaging type with implicits often comes back to bite you.  You may be safe here, but I'd still prefer we just call a wrap method explicitly. \n",
    "commit": "111e3882f55d5bdd06b357512a0d4284adb78116",
    "createdAt": "2014-04-26T00:50:54Z",
    "diffHunk": "@@ -45,4 +50,146 @@ class JavaSchemaRDD(\n   override def wrapRDD(rdd: RDD[Row]): JavaRDD[Row] = JavaRDD.fromRDD(rdd)\n \n   val rdd = baseSchemaRDD.map(new Row(_))\n+\n+  // =======================================================================\n+  // Base RDD functions that do NOT change schema\n+  // =======================================================================\n+\n+  // Common RDD functions\n+\n+  /** Persist this RDD with the default storage level (`MEMORY_ONLY`). */\n+  def cache(): JavaSchemaRDD = {\n+    baseSchemaRDD.cache()\n+    this\n+  }\n+\n+  /** Persist this RDD with the default storage level (`MEMORY_ONLY`). */\n+  def persist(): JavaSchemaRDD = {\n+    baseSchemaRDD.persist()\n+    this\n+  }\n+\n+  /**\n+   * Set this RDD's storage level to persist its values across operations after the first time\n+   * it is computed. This can only be used to assign a new storage level if the RDD does not\n+   * have a storage level set yet..\n+   */\n+  def persist(newLevel: StorageLevel): JavaSchemaRDD = {\n+    baseSchemaRDD.persist(newLevel)\n+    this\n+  }\n+\n+  /**\n+   * Mark the RDD as non-persistent, and remove all blocks for it from memory and disk.\n+   *\n+   * @param blocking Whether to block until all blocks are deleted.\n+   * @return This RDD.\n+   */\n+  def unpersist(blocking: Boolean = true): JavaSchemaRDD = {\n+    baseSchemaRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  /** Assign a name to this RDD */\n+  def setName(name: String): JavaSchemaRDD = {\n+    baseSchemaRDD.setName(name)\n+    this\n+  }\n+\n+  // Transformations (return a new RDD)\n+\n+  /**\n+   * Return a new RDD that is reduced into `numPartitions` partitions.\n+   */\n+  def coalesce(numPartitions: Int, shuffle: Boolean = false): JavaSchemaRDD =\n+    baseSchemaRDD.coalesce(numPartitions, shuffle)\n+\n+  /**\n+   * Return a new RDD containing the distinct elements in this RDD.\n+   */\n+  def distinct(): JavaSchemaRDD = baseSchemaRDD.distinct()\n+\n+  /**\n+   * Return a new RDD containing the distinct elements in this RDD.\n+   */\n+  def distinct(numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.distinct(numPartitions)\n+\n+  /**\n+   * Return a new RDD containing only the elements that satisfy a predicate.\n+   */\n+  def filter(f: JFunction[Row, java.lang.Boolean]): JavaSchemaRDD =\n+    baseSchemaRDD.filter(x => f.call(new Row(x)).booleanValue())\n+\n+  /**\n+   * Return the intersection of this RDD and another one. The output will not contain any\n+   * duplicate elements, even if the input RDDs did.\n+   *\n+   * Note that this method performs a shuffle internally.\n+   */\n+  def intersection(other: JavaSchemaRDD): JavaSchemaRDD =\n+    baseSchemaRDD.intersection(other)\n+\n+  /**\n+   * Return the intersection of this RDD and another one. The output will not contain any\n+   * duplicate elements, even if the input RDDs did.\n+   *\n+   * Note that this method performs a shuffle internally.\n+   *\n+   * @param partitioner Partitioner to use for the resulting RDD\n+   */\n+  def intersection(other: JavaSchemaRDD, partitioner: Partitioner): JavaSchemaRDD =\n+    baseSchemaRDD.intersection(other, partitioner)\n+\n+  /**\n+   * Return the intersection of this RDD and another one. The output will not contain any\n+   * duplicate elements, even if the input RDDs did.  Performs a hash partition across the cluster\n+   *\n+   * Note that this method performs a shuffle internally.\n+   *\n+   * @param numPartitions How many partitions to use in the resulting RDD\n+   */\n+  def intersection(other: JavaSchemaRDD, numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.intersection(other, numPartitions)\n+\n+  /**\n+   * Return a new RDD that has exactly `numPartitions` partitions.\n+   *\n+   * Can increase or decrease the level of parallelism in this RDD. Internally, this uses\n+   * a shuffle to redistribute data.\n+   *\n+   * If you are decreasing the number of partitions in this RDD, consider using `coalesce`,\n+   * which can avoid performing a shuffle.\n+   */\n+  def repartition(numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.repartition(numPartitions)\n+\n+  /**\n+   * Return an RDD with the elements from `this` that are not in `other`.\n+   *\n+   * Uses `this` partitioner/partition size, because even if `other` is huge, the resulting\n+   * RDD will be <= us.\n+   */\n+  def subtract(other: JavaSchemaRDD): JavaSchemaRDD =\n+    baseSchemaRDD.subtract(other)\n+\n+  /**\n+   * Return an RDD with the elements from `this` that are not in `other`.\n+   */\n+  def subtract(other: JavaSchemaRDD, numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.subtract(other, numPartitions)\n+\n+  /**\n+   * Return an RDD with the elements from `this` that are not in `other`.\n+   */\n+  def subtract(other: JavaSchemaRDD, p: Partitioner): JavaSchemaRDD =\n+    baseSchemaRDD.subtract(other, p)\n+}\n+\n+object JavaSchemaRDD {\n+\n+  implicit def fromSchemaRDD(rdd: SchemaRDD): JavaSchemaRDD ="
  }, {
    "author": {
      "login": "kanzhang"
    },
    "body": "Point taken, will update. Thx\n",
    "commit": "111e3882f55d5bdd06b357512a0d4284adb78116",
    "createdAt": "2014-04-26T08:45:17Z",
    "diffHunk": "@@ -45,4 +50,146 @@ class JavaSchemaRDD(\n   override def wrapRDD(rdd: RDD[Row]): JavaRDD[Row] = JavaRDD.fromRDD(rdd)\n \n   val rdd = baseSchemaRDD.map(new Row(_))\n+\n+  // =======================================================================\n+  // Base RDD functions that do NOT change schema\n+  // =======================================================================\n+\n+  // Common RDD functions\n+\n+  /** Persist this RDD with the default storage level (`MEMORY_ONLY`). */\n+  def cache(): JavaSchemaRDD = {\n+    baseSchemaRDD.cache()\n+    this\n+  }\n+\n+  /** Persist this RDD with the default storage level (`MEMORY_ONLY`). */\n+  def persist(): JavaSchemaRDD = {\n+    baseSchemaRDD.persist()\n+    this\n+  }\n+\n+  /**\n+   * Set this RDD's storage level to persist its values across operations after the first time\n+   * it is computed. This can only be used to assign a new storage level if the RDD does not\n+   * have a storage level set yet..\n+   */\n+  def persist(newLevel: StorageLevel): JavaSchemaRDD = {\n+    baseSchemaRDD.persist(newLevel)\n+    this\n+  }\n+\n+  /**\n+   * Mark the RDD as non-persistent, and remove all blocks for it from memory and disk.\n+   *\n+   * @param blocking Whether to block until all blocks are deleted.\n+   * @return This RDD.\n+   */\n+  def unpersist(blocking: Boolean = true): JavaSchemaRDD = {\n+    baseSchemaRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  /** Assign a name to this RDD */\n+  def setName(name: String): JavaSchemaRDD = {\n+    baseSchemaRDD.setName(name)\n+    this\n+  }\n+\n+  // Transformations (return a new RDD)\n+\n+  /**\n+   * Return a new RDD that is reduced into `numPartitions` partitions.\n+   */\n+  def coalesce(numPartitions: Int, shuffle: Boolean = false): JavaSchemaRDD =\n+    baseSchemaRDD.coalesce(numPartitions, shuffle)\n+\n+  /**\n+   * Return a new RDD containing the distinct elements in this RDD.\n+   */\n+  def distinct(): JavaSchemaRDD = baseSchemaRDD.distinct()\n+\n+  /**\n+   * Return a new RDD containing the distinct elements in this RDD.\n+   */\n+  def distinct(numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.distinct(numPartitions)\n+\n+  /**\n+   * Return a new RDD containing only the elements that satisfy a predicate.\n+   */\n+  def filter(f: JFunction[Row, java.lang.Boolean]): JavaSchemaRDD =\n+    baseSchemaRDD.filter(x => f.call(new Row(x)).booleanValue())\n+\n+  /**\n+   * Return the intersection of this RDD and another one. The output will not contain any\n+   * duplicate elements, even if the input RDDs did.\n+   *\n+   * Note that this method performs a shuffle internally.\n+   */\n+  def intersection(other: JavaSchemaRDD): JavaSchemaRDD =\n+    baseSchemaRDD.intersection(other)\n+\n+  /**\n+   * Return the intersection of this RDD and another one. The output will not contain any\n+   * duplicate elements, even if the input RDDs did.\n+   *\n+   * Note that this method performs a shuffle internally.\n+   *\n+   * @param partitioner Partitioner to use for the resulting RDD\n+   */\n+  def intersection(other: JavaSchemaRDD, partitioner: Partitioner): JavaSchemaRDD =\n+    baseSchemaRDD.intersection(other, partitioner)\n+\n+  /**\n+   * Return the intersection of this RDD and another one. The output will not contain any\n+   * duplicate elements, even if the input RDDs did.  Performs a hash partition across the cluster\n+   *\n+   * Note that this method performs a shuffle internally.\n+   *\n+   * @param numPartitions How many partitions to use in the resulting RDD\n+   */\n+  def intersection(other: JavaSchemaRDD, numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.intersection(other, numPartitions)\n+\n+  /**\n+   * Return a new RDD that has exactly `numPartitions` partitions.\n+   *\n+   * Can increase or decrease the level of parallelism in this RDD. Internally, this uses\n+   * a shuffle to redistribute data.\n+   *\n+   * If you are decreasing the number of partitions in this RDD, consider using `coalesce`,\n+   * which can avoid performing a shuffle.\n+   */\n+  def repartition(numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.repartition(numPartitions)\n+\n+  /**\n+   * Return an RDD with the elements from `this` that are not in `other`.\n+   *\n+   * Uses `this` partitioner/partition size, because even if `other` is huge, the resulting\n+   * RDD will be <= us.\n+   */\n+  def subtract(other: JavaSchemaRDD): JavaSchemaRDD =\n+    baseSchemaRDD.subtract(other)\n+\n+  /**\n+   * Return an RDD with the elements from `this` that are not in `other`.\n+   */\n+  def subtract(other: JavaSchemaRDD, numPartitions: Int): JavaSchemaRDD =\n+    baseSchemaRDD.subtract(other, numPartitions)\n+\n+  /**\n+   * Return an RDD with the elements from `this` that are not in `other`.\n+   */\n+  def subtract(other: JavaSchemaRDD, p: Partitioner): JavaSchemaRDD =\n+    baseSchemaRDD.subtract(other, p)\n+}\n+\n+object JavaSchemaRDD {\n+\n+  implicit def fromSchemaRDD(rdd: SchemaRDD): JavaSchemaRDD ="
  }],
  "prId": 448
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "It might be safer, clearer to use the explicit type here.  Only for the Java stuff though.\n",
    "commit": "111e3882f55d5bdd06b357512a0d4284adb78116",
    "createdAt": "2014-05-05T22:37:30Z",
    "diffHunk": "@@ -45,4 +48,141 @@ class JavaSchemaRDD(\n   override def wrapRDD(rdd: RDD[Row]): JavaRDD[Row] = JavaRDD.fromRDD(rdd)\n \n   val rdd = baseSchemaRDD.map(new Row(_))\n+\n+  override def toString: String = baseSchemaRDD.toString\n+\n+  // =======================================================================\n+  // Base RDD functions that do NOT change schema\n+  // =======================================================================\n+\n+  // Common RDD functions\n+\n+  /** Persist this RDD with the default storage level (`MEMORY_ONLY`). */\n+  def cache(): this.type = {"
  }, {
    "author": {
      "login": "kanzhang"
    },
    "body": "Ah, yes.\n",
    "commit": "111e3882f55d5bdd06b357512a0d4284adb78116",
    "createdAt": "2014-05-05T22:48:51Z",
    "diffHunk": "@@ -45,4 +48,141 @@ class JavaSchemaRDD(\n   override def wrapRDD(rdd: RDD[Row]): JavaRDD[Row] = JavaRDD.fromRDD(rdd)\n \n   val rdd = baseSchemaRDD.map(new Row(_))\n+\n+  override def toString: String = baseSchemaRDD.toString\n+\n+  // =======================================================================\n+  // Base RDD functions that do NOT change schema\n+  // =======================================================================\n+\n+  // Common RDD functions\n+\n+  /** Persist this RDD with the default storage level (`MEMORY_ONLY`). */\n+  def cache(): this.type = {"
  }],
  "prId": 448
}]