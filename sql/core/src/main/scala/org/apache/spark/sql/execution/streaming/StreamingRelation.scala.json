[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "not very familiar with the streaming side, but IIRC, some of these plans are temporary and will be replaced before entering analyzer, and these plans don't need to extend MultiInstanceRelation.",
    "commit": "0786b81200bd01c33ad69efea1f5a6a1b35739cf",
    "createdAt": "2018-02-14T02:41:28Z",
    "diffHunk": "@@ -62,7 +64,7 @@ case class StreamingRelation(dataSource: DataSource, sourceName: String, output:\n case class StreamingExecutionRelation(",
    "line": 31
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "They need to extend MultiInstance relation, because Dataset.join() forces an analysis to disambiguate left and right in self-joins ([here](https://github.com/apache/spark/blob/357babde5a8eb9710de7016d7ae82dee21fa4ef3/sql/core/src/main/scala/org/apache/spark/sql/Dataset.scala#L914)) and when there is a self-join between two streaming Datasets (i.e. they contain StreamingRelation/StreamingRelationV2), without the MultiInstanceRelation, it throws the error (see PR description).\r\n\r\nRegarding StreamingExecutionRelation, while the other sources convert StreamingRelation to StreamingExecutionRelation, the MemoryStream directly injects StreamingExceutionRelation at that time of Dataset operations. Hence its good that StreamingExecutionRelation also extends MultiInstanceRelation.",
    "commit": "0786b81200bd01c33ad69efea1f5a6a1b35739cf",
    "createdAt": "2018-02-14T09:05:12Z",
    "diffHunk": "@@ -62,7 +64,7 @@ case class StreamingRelation(dataSource: DataSource, sourceName: String, output:\n case class StreamingExecutionRelation(",
    "line": 31
  }],
  "prId": 20598
}]