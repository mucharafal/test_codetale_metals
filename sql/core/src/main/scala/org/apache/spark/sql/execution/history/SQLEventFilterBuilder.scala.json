[{
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "This class will track the live executions and relevant jobs - so even jobs are finished, if relevant live execution is live, then jobs relevant events will not be filtered out.",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-06T22:02:15Z",
    "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {"
  }],
  "prId": 26416
}, {
  "comments": [{
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Nit: `jobStart.stageIds.foreach(stageId => _stageToTasks += stageId -> mutable.HashSet[Long]())`",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-14T17:15:18Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {\n+      // This is not a job created by SQL\n+      return\n+    }\n+\n+    val executionId = executionIdString.toLong\n+    val jobId = jobStart.jobId\n+\n+    val jobsForExecution = _liveExecutionToJobs.getOrElseUpdate(executionId,\n+      mutable.HashSet[Int]())\n+    jobsForExecution += jobId\n+\n+    _jobToStages += jobStart.jobId -> jobStart.stageIds\n+    stages ++= jobStart.stageIds\n+    jobStart.stageIds.foreach { stageId => _stageToTasks += stageId -> mutable.HashSet[Long]() }",
    "line": 63
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "same here.",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-15T03:38:23Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {\n+      // This is not a job created by SQL\n+      return\n+    }\n+\n+    val executionId = executionIdString.toLong\n+    val jobId = jobStart.jobId\n+\n+    val jobsForExecution = _liveExecutionToJobs.getOrElseUpdate(executionId,\n+      mutable.HashSet[Int]())\n+    jobsForExecution += jobId\n+\n+    _jobToStages += jobStart.jobId -> jobStart.stageIds\n+    stages ++= jobStart.stageIds\n+    jobStart.stageIds.foreach { stageId => _stageToTasks += stageId -> mutable.HashSet[Long]() }",
    "line": 63
  }],
  "prId": 26416
}, {
  "comments": [{
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "```\r\n    if (executionIdString != null) {\r\n      val executionId = executionIdString.toLong\r\n```\r\n?",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-14T17:16:53Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {",
    "line": 49
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "This is an intended early-return, as if the job is not related to the SQL execution we don't mind. In fact it's the same code as `SQLAppStatusListener.onJobStart`.",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-15T03:38:13Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {",
    "line": 49
  }, {
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "In this case early-return can can be converted to a negated whole function wrapping condition. Since there is an example like this + minor enough we can leave it as is.",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-15T11:57:33Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {",
    "line": 49
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "https://github.com/databricks/scala-style-guide#return-statements\r\n\r\n> Use return as a guard to simplify control flow without adding a level of indentation\r\n\r\nIf I understand correctly on the style guide, early return, especially placing return in mostly top of the method, is not a bad pattern which should be considered to be changed. This is a kind of preferences of individual, which should be checked with the style guide to not force one's preference.",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-17T23:01:48Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {",
    "line": 49
  }],
  "prId": 26416
}, {
  "comments": [{
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Same here.",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-14T17:17:35Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {\n+      // This is not a job created by SQL\n+      return\n+    }\n+\n+    val executionId = executionIdString.toLong\n+    val jobId = jobStart.jobId\n+\n+    val jobsForExecution = _liveExecutionToJobs.getOrElseUpdate(executionId,\n+      mutable.HashSet[Int]())\n+    jobsForExecution += jobId\n+\n+    _jobToStages += jobStart.jobId -> jobStart.stageIds\n+    stages ++= jobStart.stageIds\n+    jobStart.stageIds.foreach { stageId => _stageToTasks += stageId -> mutable.HashSet[Long]() }\n+  }\n+\n+  override def onStageSubmitted(stageSubmitted: SparkListenerStageSubmitted): Unit = {\n+    val stageId = stageSubmitted.stageInfo.stageId\n+    if (stages.contains(stageId)) {\n+      val rddInfos = stageSubmitted.stageInfo.rddInfos\n+      _stageToRDDs += stageId -> rddInfos.map(_.id)\n+    }\n+  }\n+\n+  override def onTaskStart(taskStart: SparkListenerTaskStart): Unit = {\n+    if (_stageToTasks.contains(taskStart.stageId)) {\n+      val curTasks = _stageToTasks(taskStart.stageId)\n+      curTasks += taskStart.taskInfo.taskId\n+    }\n+  }\n+\n+  override def onOtherEvent(event: SparkListenerEvent): Unit = event match {\n+    case e: SparkListenerSQLExecutionStart => onExecutionStart(e)\n+    case e: SparkListenerSQLExecutionEnd => onExecutionEnd(e)\n+    case _ => // Ignore\n+  }\n+\n+  private def onExecutionStart(event: SparkListenerSQLExecutionStart): Unit = {\n+    _liveExecutionToJobs += event.executionId -> mutable.HashSet[Int]()\n+  }\n+\n+  private def onExecutionEnd(event: SparkListenerSQLExecutionEnd): Unit = {\n+    val jobs = _liveExecutionToJobs.getOrElse(event.executionId, mutable.HashSet[Int]())\n+    _liveExecutionToJobs -= event.executionId\n+\n+    val stagesToDrop = _jobToStages.filter(kv => jobs.contains(kv._1)).values.flatten\n+    _jobToStages --= jobs\n+    stages --= stagesToDrop\n+    _stageToTasks --= stagesToDrop\n+    _stageToRDDs --= stagesToDrop\n+  }\n+\n+  override def createFilter(): EventFilter = {\n+    SQLLiveEntitiesEventFilter(this)\n+  }\n+}\n+\n+/**\n+ * This class filters out events which are related to the finished SQL executions based on the\n+ * given information.\n+ *\n+ * Note that filterXXX methods will return None instead of Some(false) if the event is related to\n+ * job but not coupled with live SQL executions, because the instance has the information about\n+ * jobs for live SQL executions which should be filtered in, but don't know whether the job is\n+ * related to the finished SQL executions, or job is NOT related to the SQL executions. For this\n+ * case, it just gives up the decision and let other filters decide it.\n+ *\n+ * The events which are not related to the SQL execution will be considered as \"Don't mind\".\n+ */\n+private[spark] class SQLLiveEntitiesEventFilter(\n+    liveExecutionToJobs: Map[Long, Set[Int]],\n+    _jobToStages: Map[Int, Seq[Int]],\n+    _stageToTasks: Map[Int, Set[Long]],\n+    _stageToRDDs: Map[Int, Seq[Int]])\n+  extends JobEventFilter(_jobToStages, _stageToTasks, _stageToRDDs) with Logging {\n+\n+  if (log.isDebugEnabled) {"
  }],
  "prId": 26416
}, {
  "comments": [{
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Nit: -indent",
    "commit": "e5d925025a606cbb5c365303149272900f255e33",
    "createdAt": "2019-11-14T17:20:44Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.history\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.deploy.history.{EventFilter, EventFilterBuilder, JobEventFilter}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.scheduler._\n+import org.apache.spark.sql.execution.SQLExecution\n+import org.apache.spark.sql.execution.ui._\n+import org.apache.spark.sql.streaming.StreamingQueryListener\n+\n+/**\n+ * This class tracks live SQL executions, and pass the list to the [[SQLLiveEntitiesEventFilter]]\n+ * to help SQLLiveEntitiesEventFilter to filter out finished SQL executions as well as relevant\n+ * jobs (+ stages/tasks/RDDs). Unlike BasicEventFilterBuilder, it doesn't concern about the status\n+ * of individual job - it only concerns whether SQL execution is finished or not.\n+ */\n+private[spark] class SQLEventFilterBuilder extends SparkListener with EventFilterBuilder {\n+  private val _liveExecutionToJobs = new mutable.HashMap[Long, mutable.Set[Int]]\n+  private val _jobToStages = new mutable.HashMap[Int, Seq[Int]]\n+  private val _stageToTasks = new mutable.HashMap[Int, mutable.Set[Long]]\n+  private val _stageToRDDs = new mutable.HashMap[Int, Seq[Int]]\n+  private val stages = new mutable.HashSet[Int]\n+\n+  def liveExecutionToJobs: Map[Long, Set[Int]] = _liveExecutionToJobs.mapValues(_.toSet).toMap\n+  def jobToStages: Map[Int, Seq[Int]] = _jobToStages.toMap\n+  def stageToTasks: Map[Int, Set[Long]] = _stageToTasks.mapValues(_.toSet).toMap\n+  def stageToRDDs: Map[Int, Seq[Int]] = _stageToRDDs.toMap\n+\n+  override def onJobStart(jobStart: SparkListenerJobStart): Unit = {\n+    val executionIdString = jobStart.properties.getProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionIdString == null) {\n+      // This is not a job created by SQL\n+      return\n+    }\n+\n+    val executionId = executionIdString.toLong\n+    val jobId = jobStart.jobId\n+\n+    val jobsForExecution = _liveExecutionToJobs.getOrElseUpdate(executionId,\n+      mutable.HashSet[Int]())\n+    jobsForExecution += jobId\n+\n+    _jobToStages += jobStart.jobId -> jobStart.stageIds\n+    stages ++= jobStart.stageIds\n+    jobStart.stageIds.foreach { stageId => _stageToTasks += stageId -> mutable.HashSet[Long]() }\n+  }\n+\n+  override def onStageSubmitted(stageSubmitted: SparkListenerStageSubmitted): Unit = {\n+    val stageId = stageSubmitted.stageInfo.stageId\n+    if (stages.contains(stageId)) {\n+      val rddInfos = stageSubmitted.stageInfo.rddInfos\n+      _stageToRDDs += stageId -> rddInfos.map(_.id)\n+    }\n+  }\n+\n+  override def onTaskStart(taskStart: SparkListenerTaskStart): Unit = {\n+    if (_stageToTasks.contains(taskStart.stageId)) {\n+      val curTasks = _stageToTasks(taskStart.stageId)\n+      curTasks += taskStart.taskInfo.taskId\n+    }\n+  }\n+\n+  override def onOtherEvent(event: SparkListenerEvent): Unit = event match {\n+    case e: SparkListenerSQLExecutionStart => onExecutionStart(e)\n+    case e: SparkListenerSQLExecutionEnd => onExecutionEnd(e)\n+    case _ => // Ignore\n+  }\n+\n+  private def onExecutionStart(event: SparkListenerSQLExecutionStart): Unit = {\n+    _liveExecutionToJobs += event.executionId -> mutable.HashSet[Int]()\n+  }\n+\n+  private def onExecutionEnd(event: SparkListenerSQLExecutionEnd): Unit = {\n+    val jobs = _liveExecutionToJobs.getOrElse(event.executionId, mutable.HashSet[Int]())\n+    _liveExecutionToJobs -= event.executionId\n+\n+    val stagesToDrop = _jobToStages.filter(kv => jobs.contains(kv._1)).values.flatten\n+    _jobToStages --= jobs\n+    stages --= stagesToDrop\n+    _stageToTasks --= stagesToDrop\n+    _stageToRDDs --= stagesToDrop\n+  }\n+\n+  override def createFilter(): EventFilter = {\n+    SQLLiveEntitiesEventFilter(this)\n+  }\n+}\n+\n+/**\n+ * This class filters out events which are related to the finished SQL executions based on the\n+ * given information.\n+ *\n+ * Note that filterXXX methods will return None instead of Some(false) if the event is related to\n+ * job but not coupled with live SQL executions, because the instance has the information about\n+ * jobs for live SQL executions which should be filtered in, but don't know whether the job is\n+ * related to the finished SQL executions, or job is NOT related to the SQL executions. For this\n+ * case, it just gives up the decision and let other filters decide it.\n+ *\n+ * The events which are not related to the SQL execution will be considered as \"Don't mind\".\n+ */\n+private[spark] class SQLLiveEntitiesEventFilter(\n+    liveExecutionToJobs: Map[Long, Set[Int]],\n+    _jobToStages: Map[Int, Seq[Int]],\n+    _stageToTasks: Map[Int, Set[Long]],\n+    _stageToRDDs: Map[Int, Seq[Int]])\n+  extends JobEventFilter(_jobToStages, _stageToTasks, _stageToRDDs) with Logging {\n+\n+  if (log.isDebugEnabled) {\n+    logDebug(s\"live executions : ${liveExecutionToJobs.keySet}\")\n+    logDebug(s\"jobs in live executions : ${liveExecutionToJobs.values.flatten}\")\n+  }\n+\n+  override def filterStageCompleted(event: SparkListenerStageCompleted): Option[Boolean] = {\n+    trueOrNone(super.filterStageCompleted(event))\n+  }\n+\n+  override def filterStageSubmitted(event: SparkListenerStageSubmitted): Option[Boolean] = {\n+    trueOrNone(super.filterStageSubmitted(event))\n+  }\n+\n+  override def filterTaskStart(event: SparkListenerTaskStart): Option[Boolean] = {\n+    trueOrNone(super.filterTaskStart(event))\n+  }\n+\n+  override def filterTaskGettingResult(event: SparkListenerTaskGettingResult): Option[Boolean] = {\n+    trueOrNone(super.filterTaskGettingResult(event))\n+  }\n+\n+  override def filterTaskEnd(event: SparkListenerTaskEnd): Option[Boolean] = {\n+    trueOrNone(super.filterTaskEnd(event))\n+  }\n+\n+  override def filterJobStart(event: SparkListenerJobStart): Option[Boolean] = {\n+    trueOrNone(super.filterJobStart(event))\n+  }\n+\n+  override def filterJobEnd(event: SparkListenerJobEnd): Option[Boolean] = {\n+    trueOrNone(super.filterJobEnd(event))\n+  }\n+\n+  override def filterUnpersistRDD(event: SparkListenerUnpersistRDD): Option[Boolean] = {\n+    trueOrNone(super.filterUnpersistRDD(event))\n+  }\n+\n+  override def filterExecutorMetricsUpdate(\n+      event: SparkListenerExecutorMetricsUpdate): Option[Boolean] = {\n+    trueOrNone(super.filterExecutorMetricsUpdate(event))\n+  }\n+\n+  override def filterSpeculativeTaskSubmitted(\n+      event: SparkListenerSpeculativeTaskSubmitted): Option[Boolean] = {\n+    trueOrNone(super.filterSpeculativeTaskSubmitted(event))\n+  }\n+\n+  override def filterOtherEvent(event: SparkListenerEvent): Option[Boolean] = event match {\n+    case e: SparkListenerSQLExecutionStart => filterExecutionStart(e)\n+    case e: SparkListenerSQLAdaptiveExecutionUpdate => filterAdaptiveExecutionUpdate(e)\n+    case e: SparkListenerSQLExecutionEnd => filterExecutionEnd(e)\n+    case e: SparkListenerDriverAccumUpdates => filterDriverAccumUpdates(e)\n+\n+      // these events are for finished batches so safer to ignore"
  }],
  "prId": 26416
}]