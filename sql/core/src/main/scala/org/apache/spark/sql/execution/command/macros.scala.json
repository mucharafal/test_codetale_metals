[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Why not replace this by a `BoundReference`? Then we don't need to do a lookup in the map, every time the macro gets used.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:48:31Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)\n+    val colNames = macroFunction.arguments.map(_.name)\n+    val colToIndex: Map[String, Int] = colNames.zipWithIndex.toMap\n+    macroFunction.body.transformUp {\n+      case u @ UnresolvedAttribute(nameParts) =>\n+        assert(nameParts.length == 1)\n+        colToIndex.get(nameParts.head).getOrElse(\n+          throw new AnalysisException(s\"Cannot create temporary macro '$macroName', \" +\n+            s\"cannot resolve: [${u}] given input columns: [${inputSet}]\"))\n+        u"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Why? The only thing that matters is that the name is in parameter list.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:49:07Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)\n+    val colNames = macroFunction.arguments.map(_.name)\n+    val colToIndex: Map[String, Int] = colNames.zipWithIndex.toMap\n+    macroFunction.body.transformUp {\n+      case u @ UnresolvedAttribute(nameParts) =>\n+        assert(nameParts.length == 1)"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Not needed.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:49:32Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "This will drop any function... Can we make it Macro specific?\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:51:43Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)\n+    val colNames = macroFunction.arguments.map(_.name)\n+    val colToIndex: Map[String, Int] = colNames.zipWithIndex.toMap\n+    macroFunction.body.transformUp {\n+      case u @ UnresolvedAttribute(nameParts) =>\n+        assert(nameParts.length == 1)\n+        colToIndex.get(nameParts.head).getOrElse(\n+          throw new AnalysisException(s\"Cannot create temporary macro '$macroName', \" +\n+            s\"cannot resolve: [${u}] given input columns: [${inputSet}]\"))\n+        u\n+      case _: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot create temporary macro '$macroName', \" +\n+          s\"cannot support subquery for macro.\")\n+    }\n+\n+    val macroInfo = macroFunction.arguments.mkString(\",\") + \"->\" + macroFunction.body.toString\n+    val info = new ExpressionInfo(macroInfo, macroName)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != colNames.size) {\n+        throw new AnalysisException(s\"actual number of arguments: ${children.size} != \" +\n+          s\"expected number of arguments: ${colNames.size} for Macro $macroName\")\n+      }\n+      macroFunction.body.transformUp {\n+        case u @ UnresolvedAttribute(nameParts) =>\n+          assert(nameParts.length == 1)\n+          colToIndex.get(nameParts.head).map(children(_)).getOrElse(\n+            throw new AnalysisException(s\"Macro '$macroInfo' cannot resolve '$u' \" +\n+              s\"given input expressions: [${children.mkString(\",\")}]\"))\n+      }\n+    }\n+    catalog.createTempFunction(macroName, info, builder, ignoreIfExists = false)\n+    Seq.empty[Row]\n+  }\n+}\n+\n+/**\n+ * The DDL command that drops a macro.\n+ * ifExists: returns an error if the macro doesn't exist, unless this is true.\n+ * {{{\n+ *    DROP TEMPORARY MACRO [IF EXISTS] macro_name;\n+ * }}}\n+ */\n+case class DropMacroCommand(macroName: String, ifExists: Boolean)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {",
    "line": 112
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "A `BoundReference` would allow you to directly get the index. See my previous comment.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:52:49Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)\n+    val colNames = macroFunction.arguments.map(_.name)\n+    val colToIndex: Map[String, Int] = colNames.zipWithIndex.toMap\n+    macroFunction.body.transformUp {\n+      case u @ UnresolvedAttribute(nameParts) =>\n+        assert(nameParts.length == 1)\n+        colToIndex.get(nameParts.head).getOrElse(\n+          throw new AnalysisException(s\"Cannot create temporary macro '$macroName', \" +\n+            s\"cannot resolve: [${u}] given input columns: [${inputSet}]\"))\n+        u\n+      case _: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot create temporary macro '$macroName', \" +\n+          s\"cannot support subquery for macro.\")\n+    }\n+\n+    val macroInfo = macroFunction.arguments.mkString(\",\") + \"->\" + macroFunction.body.toString\n+    val info = new ExpressionInfo(macroInfo, macroName)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != colNames.size) {\n+        throw new AnalysisException(s\"actual number of arguments: ${children.size} != \" +\n+          s\"expected number of arguments: ${colNames.size} for Macro $macroName\")\n+      }\n+      macroFunction.body.transformUp {\n+        case u @ UnresolvedAttribute(nameParts) =>"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "`colNames`?\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:53:58Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)\n+    val colNames = macroFunction.arguments.map(_.name)\n+    val colToIndex: Map[String, Int] = colNames.zipWithIndex.toMap\n+    macroFunction.body.transformUp {\n+      case u @ UnresolvedAttribute(nameParts) =>\n+        assert(nameParts.length == 1)\n+        colToIndex.get(nameParts.head).getOrElse(\n+          throw new AnalysisException(s\"Cannot create temporary macro '$macroName', \" +\n+            s\"cannot resolve: [${u}] given input columns: [${inputSet}]\"))"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "not needed\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T04:54:25Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "We should check that all parameter names are unique.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-17T17:26:14Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis.{FunctionRegistry, UnresolvedAttribute}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * This class provides arguments and body expression of the macro.\n+ */\n+case class MacroFunctionWrapper(arguments: Seq[AttributeReference], body: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(macroName: String, macroFunction: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val inputSet = AttributeSet(macroFunction.arguments)\n+    val colNames = macroFunction.arguments.map(_.name)"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "We do not validate the input type here. This would be entirely fine if macro arguments were defined without a `DataType`. I am not sure what we need to do here though. We have two options:\n- Ignore the DataType and rely on the expressions `inputTypes` to get casting done. This must be documented though. \n- Introduce casts to make sure the input conforms to the required input.\n\nWhat do you think?\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-20T04:15:00Z",
    "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    columns: Seq[AttributeReference],\n+    macroFunction: Expression)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {\n+        throw new AnalysisException(s\"Actual number of columns: ${children.size} != \" +\n+          s\"expected number of columns: ${columns.size} for Macro $macroName\")\n+      }\n+      macroFunction.transformUp {\n+        case b: BoundReference => children(b.ordinal)"
  }, {
    "author": {
      "login": "lianhuiwang"
    },
    "body": "@hvanhovell good points. Because Analyzer will check expression's checkInputDataTypes after ResolveFunctions, I think we do not validate input type here. Now i do not think it has benefits if we did casts, but it maybe cause unnecessary casts. I will add some comments for it. Thanks.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-20T04:38:14Z",
    "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    columns: Seq[AttributeReference],\n+    macroFunction: Expression)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {\n+        throw new AnalysisException(s\"Actual number of columns: ${children.size} != \" +\n+          s\"expected number of columns: ${columns.size} for Macro $macroName\")\n+      }\n+      macroFunction.transformUp {\n+        case b: BoundReference => children(b.ordinal)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Ok that is perfect.\n",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2016-06-20T04:58:24Z",
    "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    columns: Seq[AttributeReference],\n+    macroFunction: Expression)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {\n+        throw new AnalysisException(s\"Actual number of columns: ${children.size} != \" +\n+          s\"expected number of columns: ${columns.size} for Macro $macroName\")\n+      }\n+      macroFunction.transformUp {\n+        case b: BoundReference => children(b.ordinal)"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Why do we need this?",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:02:15Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)"
  }, {
    "author": {
      "login": "lianhuiwang"
    },
    "body": "because Analyzer will check macroFunction that is invalid if I donot use MacroFunctionWrapper.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-30T14:53:31Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Is this what Hive does? I really don't see why we should not support this.\r\n\r\nPlease note that we cannot use generators if we decide that an expression has to be a fully resolved expression at creation time.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:06:17Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse(\n+          throw new AnalysisException(s\"Cannot find colName: ${u} \" +\n+            s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\"))\n+        BoundReference(index, columns(index).dataType, columns(index).nullable)\n+      case u: UnresolvedFunction =>\n+        sparkSession.sessionState.catalog.lookupFunction(u.name, u.children)\n+      case s: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot support Subquery: ${s} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+      case u: UnresolvedGenerator =>"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Nit: put `}` on a new line",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:11:22Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "We should respect the case-sensitivity settings here. So a lookup might not be the best idea.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:12:23Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse("
  }, {
    "author": {
      "login": "lianhuiwang"
    },
    "body": "yes, i will do it, thanks.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-30T14:54:17Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse("
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "It might easier to use `StructType().toAttributes` here",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:15:00Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>"
  }, {
    "author": {
      "login": "lianhuiwang"
    },
    "body": "yes, i will do it, thanks.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-30T14:54:11Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Can you give an example of what this would look like?",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:16:30Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse(\n+          throw new AnalysisException(s\"Cannot find colName: ${u} \" +\n+            s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\"))\n+        BoundReference(index, columns(index).dataType, columns(index).nullable)\n+      case u: UnresolvedFunction =>\n+        sparkSession.sessionState.catalog.lookupFunction(u.name, u.children)\n+      case s: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot support Subquery: ${s} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+      case u: UnresolvedGenerator =>\n+        throw new AnalysisException(s\"Cannot support Generator: ${u} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+    }\n+\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + funcWrapper.macroFunction.toString"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "It is slightly better to `columns.size` in a separate variable, so we do not include `columns` in the closure.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T16:17:56Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse(\n+          throw new AnalysisException(s\"Cannot find colName: ${u} \" +\n+            s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\"))\n+        BoundReference(index, columns(index).dataType, columns(index).nullable)\n+      case u: UnresolvedFunction =>\n+        sparkSession.sessionState.catalog.lookupFunction(u.name, u.children)\n+      case s: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot support Subquery: ${s} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+      case u: UnresolvedGenerator =>\n+        throw new AnalysisException(s\"Cannot support Generator: ${u} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+    }\n+\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + funcWrapper.macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName, true)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {"
  }],
  "prId": 13706
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "How do we check at runtime? The current code does not seem to respect the types passed, and rely on the macro's expression to do some type validation, this means you can pass anything to the macro and the user can end up with an unexpected result:\r\n```sql\r\ncreate macro plus(a int, b int) as a + b;\r\nselect plus(1.0, 1.0) as result -- This returns a decimal, and not an int as expected\r\n```\r\nSo I think we should at least validate the input expressions. The hacky way would be to add casts, and have the analyzer fail if the cast cannot be made (this is terrible UX). A better way to would be to create some sentinel expression that makes sure the analyzer will insert the correct cast, and throws a relevant exception (mentioning the macro) when this blows up...",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T18:19:44Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse(\n+          throw new AnalysisException(s\"Cannot find colName: ${u} \" +\n+            s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\"))\n+        BoundReference(index, columns(index).dataType, columns(index).nullable)\n+      case u: UnresolvedFunction =>\n+        sparkSession.sessionState.catalog.lookupFunction(u.name, u.children)\n+      case s: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot support Subquery: ${s} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+      case u: UnresolvedGenerator =>\n+        throw new AnalysisException(s\"Cannot support Generator: ${u} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+    }\n+\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + funcWrapper.macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName, true)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {\n+        throw new AnalysisException(s\"Actual number of columns: ${children.size} != \" +\n+          s\"expected number of columns: ${columns.size} for Macro $macroName\")\n+      }\n+      macroFunction.transform {\n+        // Skip to validate the input type because check it at runtime."
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "On a related note, we are currently not sure if the macro produces a valid expression. Maybe we should run analysis on the macro expression to make sure it does not fail every query later on, e.g.:\r\n```scala\r\n\r\nval resolvedMacroFunction = try {\r\n  val plan = Project(Alias(macroFunction, \"m\")() :: Nil, OneRowRelation)\r\n  val analyzed @ Project(Seq(named), OneRowRelation) =\r\n    sparkSession.sessionState.analyzer.execute(plan)\r\n  sparkSession.sessionState.analyzer.checkAnalysis(analyzed)\r\n  named.children.head\r\n} catch {\r\n  case a: AnalysisException =>\r\n    ...\r\n}\r\n```\r\nNote that we cannot use generators if we use this approach...",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-28T18:29:38Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse(\n+          throw new AnalysisException(s\"Cannot find colName: ${u} \" +\n+            s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\"))\n+        BoundReference(index, columns(index).dataType, columns(index).nullable)\n+      case u: UnresolvedFunction =>\n+        sparkSession.sessionState.catalog.lookupFunction(u.name, u.children)\n+      case s: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot support Subquery: ${s} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+      case u: UnresolvedGenerator =>\n+        throw new AnalysisException(s\"Cannot support Generator: ${u} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+    }\n+\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + funcWrapper.macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName, true)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {\n+        throw new AnalysisException(s\"Actual number of columns: ${children.size} != \" +\n+          s\"expected number of columns: ${columns.size} for Macro $macroName\")\n+      }\n+      macroFunction.transform {\n+        // Skip to validate the input type because check it at runtime."
  }, {
    "author": {
      "login": "lianhuiwang"
    },
    "body": "Yes, Now i update it with you ideas. Thanks.",
    "commit": "4d8e843fb490845b8e5b55033ccac9bba93b7591",
    "createdAt": "2017-05-30T14:58:41Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.command\n+\n+import org.apache.spark.sql.{AnalysisException, Row, SparkSession}\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.StructField\n+\n+/**\n+ * This class provides arguments and body expression of the macro function.\n+ */\n+case class MacroFunctionWrapper(columns: Seq[StructField], macroFunction: Expression)\n+\n+/**\n+ * The DDL command that creates a macro.\n+ * To create a temporary macro, the syntax of using this command in SQL is:\n+ * {{{\n+ *    CREATE TEMPORARY MACRO macro_name([col_name col_type, ...]) expression;\n+ * }}}\n+ */\n+case class CreateMacroCommand(\n+    macroName: String,\n+    funcWrapper: MacroFunctionWrapper)\n+  extends RunnableCommand {\n+\n+  override def run(sparkSession: SparkSession): Seq[Row] = {\n+    val catalog = sparkSession.sessionState.catalog\n+    val columns = funcWrapper.columns.map { col =>\n+      AttributeReference(col.name, col.dataType, col.nullable, col.metadata)() }\n+    val colToIndex: Map[String, Int] = columns.map(_.name).zipWithIndex.toMap\n+    if (colToIndex.size != columns.size) {\n+      throw new AnalysisException(s\"Cannot support duplicate colNames \" +\n+        s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\")\n+    }\n+    val macroFunction = funcWrapper.macroFunction.transform {\n+      case u: UnresolvedAttribute =>\n+        val index = colToIndex.get(u.name).getOrElse(\n+          throw new AnalysisException(s\"Cannot find colName: ${u} \" +\n+            s\"for CREATE TEMPORARY MACRO $macroName, actual columns: ${columns.mkString(\",\")}\"))\n+        BoundReference(index, columns(index).dataType, columns(index).nullable)\n+      case u: UnresolvedFunction =>\n+        sparkSession.sessionState.catalog.lookupFunction(u.name, u.children)\n+      case s: SubqueryExpression =>\n+        throw new AnalysisException(s\"Cannot support Subquery: ${s} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+      case u: UnresolvedGenerator =>\n+        throw new AnalysisException(s\"Cannot support Generator: ${u} \" +\n+          s\"for CREATE TEMPORARY MACRO $macroName\")\n+    }\n+\n+    val macroInfo = columns.mkString(\",\") + \" -> \" + funcWrapper.macroFunction.toString\n+    val info = new ExpressionInfo(macroInfo, macroName, true)\n+    val builder = (children: Seq[Expression]) => {\n+      if (children.size != columns.size) {\n+        throw new AnalysisException(s\"Actual number of columns: ${children.size} != \" +\n+          s\"expected number of columns: ${columns.size} for Macro $macroName\")\n+      }\n+      macroFunction.transform {\n+        // Skip to validate the input type because check it at runtime."
  }],
  "prId": 13706
}]