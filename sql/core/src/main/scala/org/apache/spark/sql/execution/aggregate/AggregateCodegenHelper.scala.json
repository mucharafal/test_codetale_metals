[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Do we need to use `while`? Can we use `if` instead of `while`?",
    "commit": "5baa928d758eaf4c6711c4a8d67611995ca3af25",
    "createdAt": "2017-03-10T14:12:04Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate._\n+import org.apache.spark.sql.catalyst.expressions.codegen._\n+import org.apache.spark.sql.execution.CodegenSupport\n+import org.apache.spark.sql.types.StructType\n+\n+trait AggregateCodegenHelper {\n+  self: AggregateExec with CodegenSupport =>\n+\n+  protected val groupingAttributes = groupingExpressions.map(_.toAttribute)\n+  protected val groupingKeySchema = StructType.fromAttributes(groupingAttributes)\n+  protected val bufferSchema = StructType.fromAttributes(aggregateBufferAttributes)\n+\n+  protected lazy val declFunctions =\n+    aggregateExpressions.map(_.aggregateFunction.asInstanceOf[DeclarativeAggregate])\n+\n+  protected var bufVars: Seq[ExprCode] = _\n+\n+  override def usedInputs: AttributeSet = inputSet\n+\n+  protected def generateBufVarsInitCode(ctx: CodegenContext): String = {\n+    // generate variables for aggregation buffer\n+    val initExpr = declFunctions.flatMap(f => f.initialValues)\n+    bufVars = initExpr.map { e =>\n+      val isNull = ctx.freshName(\"bufIsNull\")\n+      val value = ctx.freshName(\"bufValue\")\n+      ctx.addMutableState(\"boolean\", isNull, \"\")\n+      ctx.addMutableState(ctx.javaType(e.dataType), value, \"\")\n+      // The initial expression should not access any column\n+      val ev = e.genCode(ctx)\n+      val initVars = s\"\"\"\n+         | $isNull = ${ev.isNull};\n+         | $value = ${ev.value};\n+       \"\"\".stripMargin\n+      ExprCode(ev.code + initVars, isNull, value)\n+    }\n+    evaluateVariables(bufVars)\n+  }\n+\n+  protected def generateBufVarsEvalCode(ctx: CodegenContext): String = {\n+    val initAgg = ctx.freshName(\"initAgg\")\n+    ctx.addMutableState(\"boolean\", initAgg, s\"$initAgg = false;\")\n+\n+    val initBufVar = generateBufVarsInitCode(ctx)\n+\n+    // generate variables for output\n+    val (resultVars, genResult) = if (modes.contains(Final) || modes.contains(Complete)) {\n+      // evaluate aggregate results\n+      ctx.currentVars = bufVars\n+      val aggResults = declFunctions.map(_.evaluateExpression).map { e =>\n+        BindReferences.bindReference(e, aggregateBufferAttributes).genCode(ctx)\n+      }\n+      val evaluateAggResults = evaluateVariables(aggResults)\n+      // evaluate result expressions\n+      ctx.currentVars = aggResults\n+      val resultVars = resultExpressions.map { e =>\n+        BindReferences.bindReference(e, aggregateAttributes).genCode(ctx)\n+      }\n+      (resultVars, s\"\"\"\n+        |$evaluateAggResults\n+        |${evaluateVariables(resultVars)}\n+       \"\"\".stripMargin)\n+    } else if (modes.contains(Partial) || modes.contains(PartialMerge)) {\n+      // output the aggregate buffer directly\n+      (bufVars, \"\")\n+    } else {\n+      // no aggregate function, the result should be literals\n+      val resultVars = resultExpressions.map(_.genCode(ctx))\n+      (resultVars, evaluateVariables(resultVars))\n+    }\n+\n+    val doAgg = ctx.freshName(\"doAggregateWithoutKey\")\n+    ctx.addNewFunction(doAgg,\n+      s\"\"\"\n+         | private void $doAgg() throws java.io.IOException {\n+         |   // initialize aggregation buffer\n+         |   $initBufVar\n+         |\n+         |   ${child.asInstanceOf[CodegenSupport].produce(ctx, this)}\n+         | }\n+       \"\"\".stripMargin)\n+\n+    val numOutput = metricTerm(ctx, \"numOutputRows\")\n+    val aggTime = metricTerm(ctx, \"aggTime\")\n+    val beforeAgg = ctx.freshName(\"beforeAgg\")\n+    s\"\"\"\n+       | while (!$initAgg) {",
    "line": 106
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "IIUC we can't because `continue` may exist in `${consume(ctx, resultVars).trim}`.",
    "commit": "5baa928d758eaf4c6711c4a8d67611995ca3af25",
    "createdAt": "2017-03-10T14:16:04Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate._\n+import org.apache.spark.sql.catalyst.expressions.codegen._\n+import org.apache.spark.sql.execution.CodegenSupport\n+import org.apache.spark.sql.types.StructType\n+\n+trait AggregateCodegenHelper {\n+  self: AggregateExec with CodegenSupport =>\n+\n+  protected val groupingAttributes = groupingExpressions.map(_.toAttribute)\n+  protected val groupingKeySchema = StructType.fromAttributes(groupingAttributes)\n+  protected val bufferSchema = StructType.fromAttributes(aggregateBufferAttributes)\n+\n+  protected lazy val declFunctions =\n+    aggregateExpressions.map(_.aggregateFunction.asInstanceOf[DeclarativeAggregate])\n+\n+  protected var bufVars: Seq[ExprCode] = _\n+\n+  override def usedInputs: AttributeSet = inputSet\n+\n+  protected def generateBufVarsInitCode(ctx: CodegenContext): String = {\n+    // generate variables for aggregation buffer\n+    val initExpr = declFunctions.flatMap(f => f.initialValues)\n+    bufVars = initExpr.map { e =>\n+      val isNull = ctx.freshName(\"bufIsNull\")\n+      val value = ctx.freshName(\"bufValue\")\n+      ctx.addMutableState(\"boolean\", isNull, \"\")\n+      ctx.addMutableState(ctx.javaType(e.dataType), value, \"\")\n+      // The initial expression should not access any column\n+      val ev = e.genCode(ctx)\n+      val initVars = s\"\"\"\n+         | $isNull = ${ev.isNull};\n+         | $value = ${ev.value};\n+       \"\"\".stripMargin\n+      ExprCode(ev.code + initVars, isNull, value)\n+    }\n+    evaluateVariables(bufVars)\n+  }\n+\n+  protected def generateBufVarsEvalCode(ctx: CodegenContext): String = {\n+    val initAgg = ctx.freshName(\"initAgg\")\n+    ctx.addMutableState(\"boolean\", initAgg, s\"$initAgg = false;\")\n+\n+    val initBufVar = generateBufVarsInitCode(ctx)\n+\n+    // generate variables for output\n+    val (resultVars, genResult) = if (modes.contains(Final) || modes.contains(Complete)) {\n+      // evaluate aggregate results\n+      ctx.currentVars = bufVars\n+      val aggResults = declFunctions.map(_.evaluateExpression).map { e =>\n+        BindReferences.bindReference(e, aggregateBufferAttributes).genCode(ctx)\n+      }\n+      val evaluateAggResults = evaluateVariables(aggResults)\n+      // evaluate result expressions\n+      ctx.currentVars = aggResults\n+      val resultVars = resultExpressions.map { e =>\n+        BindReferences.bindReference(e, aggregateAttributes).genCode(ctx)\n+      }\n+      (resultVars, s\"\"\"\n+        |$evaluateAggResults\n+        |${evaluateVariables(resultVars)}\n+       \"\"\".stripMargin)\n+    } else if (modes.contains(Partial) || modes.contains(PartialMerge)) {\n+      // output the aggregate buffer directly\n+      (bufVars, \"\")\n+    } else {\n+      // no aggregate function, the result should be literals\n+      val resultVars = resultExpressions.map(_.genCode(ctx))\n+      (resultVars, evaluateVariables(resultVars))\n+    }\n+\n+    val doAgg = ctx.freshName(\"doAggregateWithoutKey\")\n+    ctx.addNewFunction(doAgg,\n+      s\"\"\"\n+         | private void $doAgg() throws java.io.IOException {\n+         |   // initialize aggregation buffer\n+         |   $initBufVar\n+         |\n+         |   ${child.asInstanceOf[CodegenSupport].produce(ctx, this)}\n+         | }\n+       \"\"\".stripMargin)\n+\n+    val numOutput = metricTerm(ctx, \"numOutputRows\")\n+    val aggTime = metricTerm(ctx, \"aggTime\")\n+    val beforeAgg = ctx.freshName(\"beforeAgg\")\n+    s\"\"\"\n+       | while (!$initAgg) {",
    "line": 106
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see, thanks",
    "commit": "5baa928d758eaf4c6711c4a8d67611995ca3af25",
    "createdAt": "2017-03-10T14:32:46Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate._\n+import org.apache.spark.sql.catalyst.expressions.codegen._\n+import org.apache.spark.sql.execution.CodegenSupport\n+import org.apache.spark.sql.types.StructType\n+\n+trait AggregateCodegenHelper {\n+  self: AggregateExec with CodegenSupport =>\n+\n+  protected val groupingAttributes = groupingExpressions.map(_.toAttribute)\n+  protected val groupingKeySchema = StructType.fromAttributes(groupingAttributes)\n+  protected val bufferSchema = StructType.fromAttributes(aggregateBufferAttributes)\n+\n+  protected lazy val declFunctions =\n+    aggregateExpressions.map(_.aggregateFunction.asInstanceOf[DeclarativeAggregate])\n+\n+  protected var bufVars: Seq[ExprCode] = _\n+\n+  override def usedInputs: AttributeSet = inputSet\n+\n+  protected def generateBufVarsInitCode(ctx: CodegenContext): String = {\n+    // generate variables for aggregation buffer\n+    val initExpr = declFunctions.flatMap(f => f.initialValues)\n+    bufVars = initExpr.map { e =>\n+      val isNull = ctx.freshName(\"bufIsNull\")\n+      val value = ctx.freshName(\"bufValue\")\n+      ctx.addMutableState(\"boolean\", isNull, \"\")\n+      ctx.addMutableState(ctx.javaType(e.dataType), value, \"\")\n+      // The initial expression should not access any column\n+      val ev = e.genCode(ctx)\n+      val initVars = s\"\"\"\n+         | $isNull = ${ev.isNull};\n+         | $value = ${ev.value};\n+       \"\"\".stripMargin\n+      ExprCode(ev.code + initVars, isNull, value)\n+    }\n+    evaluateVariables(bufVars)\n+  }\n+\n+  protected def generateBufVarsEvalCode(ctx: CodegenContext): String = {\n+    val initAgg = ctx.freshName(\"initAgg\")\n+    ctx.addMutableState(\"boolean\", initAgg, s\"$initAgg = false;\")\n+\n+    val initBufVar = generateBufVarsInitCode(ctx)\n+\n+    // generate variables for output\n+    val (resultVars, genResult) = if (modes.contains(Final) || modes.contains(Complete)) {\n+      // evaluate aggregate results\n+      ctx.currentVars = bufVars\n+      val aggResults = declFunctions.map(_.evaluateExpression).map { e =>\n+        BindReferences.bindReference(e, aggregateBufferAttributes).genCode(ctx)\n+      }\n+      val evaluateAggResults = evaluateVariables(aggResults)\n+      // evaluate result expressions\n+      ctx.currentVars = aggResults\n+      val resultVars = resultExpressions.map { e =>\n+        BindReferences.bindReference(e, aggregateAttributes).genCode(ctx)\n+      }\n+      (resultVars, s\"\"\"\n+        |$evaluateAggResults\n+        |${evaluateVariables(resultVars)}\n+       \"\"\".stripMargin)\n+    } else if (modes.contains(Partial) || modes.contains(PartialMerge)) {\n+      // output the aggregate buffer directly\n+      (bufVars, \"\")\n+    } else {\n+      // no aggregate function, the result should be literals\n+      val resultVars = resultExpressions.map(_.genCode(ctx))\n+      (resultVars, evaluateVariables(resultVars))\n+    }\n+\n+    val doAgg = ctx.freshName(\"doAggregateWithoutKey\")\n+    ctx.addNewFunction(doAgg,\n+      s\"\"\"\n+         | private void $doAgg() throws java.io.IOException {\n+         |   // initialize aggregation buffer\n+         |   $initBufVar\n+         |\n+         |   ${child.asInstanceOf[CodegenSupport].produce(ctx, this)}\n+         | }\n+       \"\"\".stripMargin)\n+\n+    val numOutput = metricTerm(ctx, \"numOutputRows\")\n+    val aggTime = metricTerm(ctx, \"aggTime\")\n+    val beforeAgg = ctx.freshName(\"beforeAgg\")\n+    s\"\"\"\n+       | while (!$initAgg) {",
    "line": 106
  }],
  "prId": 17164
}]