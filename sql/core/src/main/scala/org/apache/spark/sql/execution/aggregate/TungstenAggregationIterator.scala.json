[{
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Leave it for further discussion, we can leave it configurable.\n",
    "commit": "0418127d3e1237ca88f99f3202a4032bae3dcd72",
    "createdAt": "2015-09-17T13:41:39Z",
    "diffHunk": "@@ -375,7 +377,11 @@ class TungstenAggregationIterator(\n         val buffer: UnsafeRow = hashMap.getAggregationBufferFromUnsafeRow(groupingKey)\n         if (buffer == null) {\n           // buffer == null means that we could not allocate more memory.\n-          // Now, we need to spill the map and switch to sort-based aggregation.\n+          throw new IOException(\"Not enough memory for more records\")\n+        }\n+\n+        if (hashMap.size() > 8888) {",
    "line": 17
  }],
  "prId": 8798
}, {
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "The root cause, we will switch to sort-based aggregation only we don't have enough memory, however, the first step of sort-based aggregation is spill, which also requires more memory to be allocated.\n",
    "commit": "0418127d3e1237ca88f99f3202a4032bae3dcd72",
    "createdAt": "2015-09-18T00:55:04Z",
    "diffHunk": "@@ -375,7 +377,11 @@ class TungstenAggregationIterator(\n         val buffer: UnsafeRow = hashMap.getAggregationBufferFromUnsafeRow(groupingKey)\n         if (buffer == null) {\n           // buffer == null means that we could not allocate more memory.",
    "line": 12
  }],
  "prId": 8798
}]