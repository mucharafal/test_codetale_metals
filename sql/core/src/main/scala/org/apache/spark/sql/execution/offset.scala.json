[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we avoid collect everything into driver side?",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-09-10T00:37:17Z",
    "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)",
    "line": 40
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "Do you have a good suggestion? Thanks.",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-09-10T04:36:22Z",
    "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)",
    "line": 40
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "@HyukjinKwon I have resolved this issue collect results to driver.",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-09-16T02:57:44Z",
    "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)",
    "line": 40
  }],
  "prId": 25416
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "We need some design about how to implement OFFSET on a distributed data set. The current approach works, but it's not robust as it needs to broadcast `arr` (which can be large if OFFSET is large) and relies on object equality.\r\n\r\nWe may need to follow how LIMIT is implemented in Spark.",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-10-09T08:25:32Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ * This operator will be used when a logical `Offset` operation is the final operator in an\n+ * logical plan, which happens when the user is collecting results back to the driver.\n+ */\n+case class CollectOffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)\n+\n+  private val serializer: Serializer = new UnsafeRowSerializer(child.output.size)\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    sparkContext.parallelize(executeCollect(), 1)\n+  }\n+\n+}\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    val rdd = child.execute()\n+    val arr = rdd.take(offset)\n+    rdd.filter(!arr.contains(_))",
    "line": 62
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "Yes, I think so.\r\nI have referenced the implement of `LIMIT`, but `OFFSET` looks can't follow the same way as `LIMIT`.\r\nSecond, `OFFSET` easier to generate large amounts of data than `LIMIT`.\r\nI have an immature suggestion give a limitation on `OFFSET`.",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-10-09T08:58:32Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ * This operator will be used when a logical `Offset` operation is the final operator in an\n+ * logical plan, which happens when the user is collecting results back to the driver.\n+ */\n+case class CollectOffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)\n+\n+  private val serializer: Serializer = new UnsafeRowSerializer(child.output.size)\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    sparkContext.parallelize(executeCollect(), 1)\n+  }\n+\n+}\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    val rdd = child.execute()\n+    val arr = rdd.take(offset)\n+    rdd.filter(!arr.contains(_))",
    "line": 62
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "A rough idea:\r\n1. get the numRecords of the first partition\r\n2. If the numRecords is bigger than OFFSET, go to step 4\r\n3. get numRecords of more partitions (quadruple and retry like LIMIT), until total numRecords is bigger than OFFSET.\r\n4. Now we have the numRecords of some head partitions that totoal numRecords exceeds the OFFSET, we can easily skip the head records.\r\n\r\nIf we have accurate per-partition numRecords statistics, we can go step 4 directly.",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-10-09T09:42:32Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ * This operator will be used when a logical `Offset` operation is the final operator in an\n+ * logical plan, which happens when the user is collecting results back to the driver.\n+ */\n+case class CollectOffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)\n+\n+  private val serializer: Serializer = new UnsafeRowSerializer(child.output.size)\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    sparkContext.parallelize(executeCollect(), 1)\n+  }\n+\n+}\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    val rdd = child.execute()\n+    val arr = rdd.take(offset)\n+    rdd.filter(!arr.contains(_))",
    "line": 62
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "@cloud-fan It is a better idea for me. I will reactor the current implement.",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-10-09T10:04:06Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ * This operator will be used when a logical `Offset` operation is the final operator in an\n+ * logical plan, which happens when the user is collecting results back to the driver.\n+ */\n+case class CollectOffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)\n+\n+  private val serializer: Serializer = new UnsafeRowSerializer(child.output.size)\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    sparkContext.parallelize(executeCollect(), 1)\n+  }\n+\n+}\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    val rdd = child.execute()\n+    val arr = rdd.take(offset)\n+    rdd.filter(!arr.contains(_))",
    "line": 62
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "@cloud-fan There are exists a problem the index of partition and the order of data are inconsistent.\r\nI have a new implement but not works file as I can't assurance the order of output produced by child plans.\r\n```\r\n  protected override def doExecute(): RDD[InternalRow] = {\r\n    val rdd = child.execute()\r\n    val partIdxToCountItr = rdd.mapPartitionsWithIndex{(partIdx, iter) => {\r\n      val partIdxToRowCount = scala.collection.mutable.Map[Int,Int]()\r\n      var rowCount = 0\r\n      while(iter.hasNext){\r\n        rowCount += 1\r\n        iter.next()\r\n      }\r\n      partIdxToRowCount.put(partIdx, rowCount)\r\n      partIdxToRowCount.iterator\r\n    }}.collect().iterator\r\n    var remainder = offset\r\n    val partIdxToSkipCount = scala.collection.mutable.Map[Int,Int]()\r\n    while (partIdxToCountItr.hasNext && remainder > 0) {\r\n      val kv = partIdxToCountItr.next()\r\n    \tval partIdx = kv._1\r\n      val count = kv._2\r\n      if (count > remainder) {\r\n        partIdxToSkipCount(partIdx) = remainder\r\n        remainder = 0\r\n      } else {\r\n        partIdxToSkipCount(partIdx) = count\r\n        remainder -= count\r\n      }\r\n    }\r\n    val broadcastPartIdxToSkipCount = sparkContext.broadcast(partIdxToSkipCount)\r\n    rdd.mapPartitionsWithIndex{(partIdx, iter) => {\r\n      val skipCount = broadcastPartIdxToSkipCount.value.getOrElse(partIdx, 0)\r\n      iter.drop(skipCount)\r\n    }}\r\n  }\r\n```",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-10-10T08:54:38Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ * This operator will be used when a logical `Offset` operation is the final operator in an\n+ * logical plan, which happens when the user is collecting results back to the driver.\n+ */\n+case class CollectOffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)\n+\n+  private val serializer: Serializer = new UnsafeRowSerializer(child.output.size)\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    sparkContext.parallelize(executeCollect(), 1)\n+  }\n+\n+}\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    val rdd = child.execute()\n+    val arr = rdd.take(offset)\n+    rdd.filter(!arr.contains(_))",
    "line": 62
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "So, I want know how to assurance the order?",
    "commit": "e50aff7cbf96f443eff6124962864296a1eecb5d",
    "createdAt": "2019-10-10T08:57:03Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.serializer.Serializer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, SinglePartition}\n+\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ * This operator will be used when a logical `Offset` operation is the final operator in an\n+ * logical plan, which happens when the user is collecting results back to the driver.\n+ */\n+case class CollectOffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = SinglePartition\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  override def executeCollect(): Array[InternalRow] = child.executeCollect.drop(offset)\n+\n+  private val serializer: Serializer = new UnsafeRowSerializer(child.output.size)\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    sparkContext.parallelize(executeCollect(), 1)\n+  }\n+\n+}\n+\n+/**\n+ * Skip the first `offset` elements and collect them to a single partition.\n+ */\n+case class OffsetExec(offset: Int, child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    val rdd = child.execute()\n+    val arr = rdd.take(offset)\n+    rdd.filter(!arr.contains(_))",
    "line": 62
  }],
  "prId": 25416
}]