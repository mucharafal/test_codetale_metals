[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "between `catalog.tableExists` and `catalog.createTable`, another user may create the table and then `catalog.createTable` fails.\r\n\r\nTo make it atomic, shall we just pass the `ignoreIfExists` parameter to catalog and ask the catalog to implement it? I checked hive catalog, it does have a `ignoreIfExists` parameter in its `createTable` method.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-16T01:24:39Z",
    "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "No, I don't think that adding more parameters to the API is the right answer. If the table already exists because of a race condition, then `createTable` throws an exception.\r\n\r\nThe purpose of this check is not for strict correctness with race conditions, it is to enforce consistency. If the catalog returns that the table exists, then Spark must not attempt to create it.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-16T19:22:50Z",
    "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I pushed a fix for the case where the table is created after the exists check and `ignoreIfExists` is true. If `ignoreIfExists` is true, then `TableAlreadyExistsException` should be caught and ignored.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-16T19:33:27Z",
    "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)"
  }],
  "prId": 24617
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "This trick seems to work, but I'm not a database expert so I don't know the common pitfalls to implement a CREATE TABLE. cc @gatorsmile @dilipbiswal ",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-17T12:56:19Z",
    "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    def create(): Unit = {\n+      catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)\n+    }\n+\n+    if (!catalog.tableExists(identifier)) {\n+      if (ignoreIfExists) {\n+        try {\n+          create()\n+        } catch {\n+          case _: TableAlreadyExistsException =>"
  }],
  "prId": 24617
}, {
  "comments": [{
    "author": {
      "login": "mccheah"
    },
    "body": "Might be worth adding a simple log at INFO level indicating there was a concurrent create, and then with an exception.\r\n\r\nI'm naturally wary of swallowing exceptions without logging them though.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T00:47:19Z",
    "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    def create(): Unit = {\n+      catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)\n+    }\n+\n+    if (!catalog.tableExists(identifier)) {\n+      if (ignoreIfExists) {\n+        try {\n+          create()\n+        } catch {\n+          case _: TableAlreadyExistsException =>\n+            // ignore the table that was created after checking existence"
  }],
  "prId": 24617
}, {
  "comments": [{
    "author": {
      "login": "mccheah"
    },
    "body": "I think this can be simplified a bit:\r\n\r\n```\r\ntry {\r\n  create()\r\n} catch {\r\n  case e: TableAlreadyExistsException if ignoreIfExists {\r\n    logInfo(\"Table was created concurrently. Ignoring.\", e)\r\n  }\r\n}\r\n```\r\n\r\nThis removes the need to have two branches both calling `create()` and only differing by one having a try-catch clause.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T00:54:19Z",
    "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    def create(): Unit = {\n+      catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)\n+    }\n+\n+    if (!catalog.tableExists(identifier)) {\n+      if (ignoreIfExists) {"
  }],
  "prId": 24617
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I checked presto's SPI, it asks the connector to implement a [`createTable`](https://github.com/prestodb/presto/blob/3060c65a1812c6c8b0c2ab725b0184dbad67f0ed/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorMetadata.java#L182) method with the `ignoreExisting` parameter.\r\n\r\nWhen implementing Hive/JDBC with data source v2, I think it's better to directly pass the `ignoreIfExists` flag, as these data sources support this flag natively.\r\n\r\nI don't know the exact reason why presto designed its SPI in this way, maybe it's because the data source can have a chance to optimize for the `ignoreIfExists` flag. I think it's better to follow the design of presto here.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T13:03:14Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+  import org.apache.spark.sql.catalog.v2.CatalogV2Implicits._\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      try {\n+        catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)",
    "line": 43
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "BTW I think it's a separated issue from adding CREATE TABLE support. I'm fine as long as we add a TODO here.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T13:04:29Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+  import org.apache.spark.sql.catalog.v2.CatalogV2Implicits._\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      try {\n+        catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)",
    "line": 43
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "@cloud-fan, adding an additional argument to the `createTable` method is a poor choice because it forces Spark to depend on sources to implement consistent behavior. Consistency and reliability is a problem in Spark that we are trying to address by making Spark handle these cases.\r\n\r\nThat's why not adding a flag to `createTable` is the right choice. It keeps the API simpler for implementers and guarantees consistent behavior.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T15:24:22Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+  import org.apache.spark.sql.catalog.v2.CatalogV2Implicits._\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      try {\n+        catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)",
    "line": 43
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "The question is if the downstream source has different behavior from what Spark wants to enforce if the `ignoreIfExists` flag is passed to the source vs. Spark deciding how to handle it. So I can imagine there being a discrepancy if the user gets different behavior from running the `IF NOT EXISTS` query directly on the Hive / SQL DB vs. running it through Spark.\r\n\r\nI think it's better to keep Spark consistent across sources, which does leave a concession for us being inconsistent in the above way. We should document the behavior of the SQL queries where they may deviate from the behavior of the underlying source where appropriate.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T18:30:31Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+  import org.apache.spark.sql.catalog.v2.CatalogV2Implicits._\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      try {\n+        catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)",
    "line": 43
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Thanks, @mccheah! I talked with Wenchen this morning and I think we are all in agreement now that we should guarantee consistency.",
    "commit": "9664638d65d496f560286261a3f90cfe1c53ab87",
    "createdAt": "2019-05-23T18:41:42Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import scala.collection.JavaConverters._\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalog.v2.{Identifier, TableCatalog}\n+import org.apache.spark.sql.catalog.v2.expressions.Transform\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.execution.LeafExecNode\n+import org.apache.spark.sql.types.StructType\n+\n+case class CreateTableExec(\n+    catalog: TableCatalog,\n+    identifier: Identifier,\n+    tableSchema: StructType,\n+    partitioning: Seq[Transform],\n+    tableProperties: Map[String, String],\n+    ignoreIfExists: Boolean) extends LeafExecNode {\n+  import org.apache.spark.sql.catalog.v2.CatalogV2Implicits._\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    if (!catalog.tableExists(identifier)) {\n+      try {\n+        catalog.createTable(identifier, tableSchema, partitioning.toArray, tableProperties.asJava)",
    "line": 43
  }],
  "prId": 24617
}]