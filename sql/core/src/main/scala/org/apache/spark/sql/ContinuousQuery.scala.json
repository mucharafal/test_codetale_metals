[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "doc for return value?\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-03T00:22:26Z",
    "diffHunk": "@@ -17,11 +17,45 @@\n \n package org.apache.spark.sql\n \n+import org.apache.spark.annotation.Experimental\n+\n /**\n+ * :: Experimental ::\n  * A handle to a query that is executing continuously in the background as new data arrives.\n+ * @since 2.0.0\n  */\n+@Experimental\n trait ContinuousQuery {\n \n+  /** Returns the name of the query */\n+  def name: String\n+\n+  def sqlContext: SQLContext\n+\n+  /** Whether the query is currently active or not */\n+  def isActive: Boolean\n+\n+  /** Returns the [[QueryException]] if the query was terminated by an exception. */\n+  def exception: Option[QueryException]\n+\n+  /** Returns current status of all the sources. */\n+  def sourceStatuses: Array[SourceStatus]\n+\n+  /** Returns current status of the sink. */\n+  def sinkStatus: SinkStatus\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws QueryException, if the query terminated by an exception.\n+   */\n+  def awaitTermination(): Unit\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws QueryException, if the query terminated by an exception before `timeoutMs` milliseconds\n+   */\n+  def awaitTermination(timeoutMs: Long): Boolean"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Added.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-04T02:24:59Z",
    "diffHunk": "@@ -17,11 +17,45 @@\n \n package org.apache.spark.sql\n \n+import org.apache.spark.annotation.Experimental\n+\n /**\n+ * :: Experimental ::\n  * A handle to a query that is executing continuously in the background as new data arrives.\n+ * @since 2.0.0\n  */\n+@Experimental\n trait ContinuousQuery {\n \n+  /** Returns the name of the query */\n+  def name: String\n+\n+  def sqlContext: SQLContext\n+\n+  /** Whether the query is currently active or not */\n+  def isActive: Boolean\n+\n+  /** Returns the [[QueryException]] if the query was terminated by an exception. */\n+  def exception: Option[QueryException]\n+\n+  /** Returns current status of all the sources. */\n+  def sourceStatuses: Array[SourceStatus]\n+\n+  /** Returns current status of the sink. */\n+  def sinkStatus: SinkStatus\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws QueryException, if the query terminated by an exception.\n+   */\n+  def awaitTermination(): Unit\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws QueryException, if the query terminated by an exception before `timeoutMs` milliseconds\n+   */\n+  def awaitTermination(timeoutMs: Long): Boolean"
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "thunterdb"
    },
    "body": "there is a typo in the doc. Also, could you document the kind of exceptions that are expected to be thrown by `stop()`?\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-08T17:57:31Z",
    "diffHunk": "@@ -17,11 +17,47 @@\n \n package org.apache.spark.sql\n \n+import org.apache.spark.annotation.Experimental\n+\n /**\n+ * :: Experimental ::\n  * A handle to a query that is executing continuously in the background as new data arrives.\n+ * @since 2.0.0\n  */\n+@Experimental\n trait ContinuousQuery {\n \n+  /** Returns the name of the query */\n+  def name: String\n+\n+  def sqlContext: SQLContext\n+\n+  /** Whether the query is currently active or not */\n+  def isActive: Boolean\n+\n+  /** Returns the [[ContinuousQueryException]] if the query was terminated by an exception. */\n+  def exception: Option[ContinuousQueryException]\n+\n+  /** Returns current status of all the sources. */\n+  def sourceStatuses: Array[SourceStatus]\n+\n+  /** Returns current status of the sink. */\n+  def sinkStatus: SinkStatus\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws ContinuousQueryException, if the query terminated by an exception.\n+   */\n+  def awaitTermination(): Unit\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * Returns whether the query has terminated or not.\n+   * @throws ContinuousQueryException, if the query terminated by an exception before\n+   *         `timeoutMs` milliseconds\n+   */\n+  def awaitTermination(timeoutMs: Long): Boolean\n+\n   /**\n    * Stops the execution of this query if it is running.  This method blocks until the threads"
  }, {
    "author": {
      "login": "thunterdb"
    },
    "body": "Also, can you document if the methods above are thread-safe? This is important for complex client applications.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-08T18:00:23Z",
    "diffHunk": "@@ -17,11 +17,47 @@\n \n package org.apache.spark.sql\n \n+import org.apache.spark.annotation.Experimental\n+\n /**\n+ * :: Experimental ::\n  * A handle to a query that is executing continuously in the background as new data arrives.\n+ * @since 2.0.0\n  */\n+@Experimental\n trait ContinuousQuery {\n \n+  /** Returns the name of the query */\n+  def name: String\n+\n+  def sqlContext: SQLContext\n+\n+  /** Whether the query is currently active or not */\n+  def isActive: Boolean\n+\n+  /** Returns the [[ContinuousQueryException]] if the query was terminated by an exception. */\n+  def exception: Option[ContinuousQueryException]\n+\n+  /** Returns current status of all the sources. */\n+  def sourceStatuses: Array[SourceStatus]\n+\n+  /** Returns current status of the sink. */\n+  def sinkStatus: SinkStatus\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws ContinuousQueryException, if the query terminated by an exception.\n+   */\n+  def awaitTermination(): Unit\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * Returns whether the query has terminated or not.\n+   * @throws ContinuousQueryException, if the query terminated by an exception before\n+   *         `timeoutMs` milliseconds\n+   */\n+  def awaitTermination(timeoutMs: Long): Boolean\n+\n   /**\n    * Stops the execution of this query if it is running.  This method blocks until the threads"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I mentioned that all these methods are thread-safe in the class docs. And, stop is not expected to throw any exception. We generally dont say anything in particular in the docs if no exception is expected.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-08T19:28:03Z",
    "diffHunk": "@@ -17,11 +17,47 @@\n \n package org.apache.spark.sql\n \n+import org.apache.spark.annotation.Experimental\n+\n /**\n+ * :: Experimental ::\n  * A handle to a query that is executing continuously in the background as new data arrives.\n+ * @since 2.0.0\n  */\n+@Experimental\n trait ContinuousQuery {\n \n+  /** Returns the name of the query */\n+  def name: String\n+\n+  def sqlContext: SQLContext\n+\n+  /** Whether the query is currently active or not */\n+  def isActive: Boolean\n+\n+  /** Returns the [[ContinuousQueryException]] if the query was terminated by an exception. */\n+  def exception: Option[ContinuousQueryException]\n+\n+  /** Returns current status of all the sources. */\n+  def sourceStatuses: Array[SourceStatus]\n+\n+  /** Returns current status of the sink. */\n+  def sinkStatus: SinkStatus\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * @throws ContinuousQueryException, if the query terminated by an exception.\n+   */\n+  def awaitTermination(): Unit\n+\n+  /**\n+   * Waits for the termination of this query, either by `stop` or by any exception.\n+   * Returns whether the query has terminated or not.\n+   * @throws ContinuousQueryException, if the query terminated by an exception before\n+   *         `timeoutMs` milliseconds\n+   */\n+  def awaitTermination(timeoutMs: Long): Boolean\n+\n   /**\n    * Stops the execution of this query if it is running.  This method blocks until the threads"
  }],
  "prId": 11030
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: this method doesn't return a Boolean.\n",
    "commit": "458199b3cb7acd3f57bcc425830ea219f92b91d8",
    "createdAt": "2016-02-09T20:32:24Z",
    "diffHunk": "@@ -17,14 +17,84 @@\n \n package org.apache.spark.sql\n \n+import org.apache.spark.annotation.Experimental\n+\n /**\n+ * :: Experimental ::\n  * A handle to a query that is executing continuously in the background as new data arrives.\n+ * All these methods are thread-safe.\n+ * @since 2.0.0\n  */\n+@Experimental\n trait ContinuousQuery {\n \n   /**\n-   * Stops the execution of this query if it is running.  This method blocks until the threads\n+   * Returns the name of the query.\n+   * @since 2.0.0\n+   */\n+  def name: String\n+\n+  /**\n+   * Returns the SQLContext associated with `this` query\n+   * @since 2.0.0\n+   */\n+  def sqlContext: SQLContext\n+\n+  /**\n+   * Whether the query is currently active or not\n+   * @since 2.0.0\n+   */\n+  def isActive: Boolean\n+\n+  /**\n+   * Returns the [[ContinuousQueryException]] if the query was terminated by an exception.\n+   * @since 2.0.0\n+   */\n+  def exception: Option[ContinuousQueryException]\n+\n+  /**\n+   * Returns current status of all the sources.\n+   * @since 2.0.0\n+   */\n+   def sourceStatuses: Array[SourceStatus]\n+\n+  /** Returns current status of the sink. */\n+  def sinkStatus: SinkStatus\n+\n+  /**\n+   * Waits for the termination of `this` query, either by `query.stop()` or by an exception.\n+   * If the query has terminated with an exception, then the exception will be thrown.\n+   *\n+   * If the query has terminated, then all subsequent calls to this method will either return\n+   * `true` immediately (if the query was terminated by `stop()`), or throw the exception"
  }],
  "prId": 11030
}]