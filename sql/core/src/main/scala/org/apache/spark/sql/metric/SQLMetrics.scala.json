[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "if i understand this correctly, this only works because the zero value of all these metrics are naturally 0 right?\n\n(since we set zero value while we deserialize data)\n",
    "commit": "14a5f0a5098ae36f9ee1217fdbc882f68e19488f",
    "createdAt": "2015-08-07T00:40:23Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql.metric\n+\n+import org.apache.spark.{Accumulable, AccumulableParam, SparkContext}\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ *\n+ * An implementation of SQLMetric should override `+=` and `add` to avoid boxing.\n+ */\n+private[sql] abstract class SQLMetric[R <: SQLMetricValue[T], T](\n+    name: String, val param: SQLMetricParam[R, T])",
    "line": 29
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Right. I think we don't need a different initial value for SQL metrics. So just avoid to add an initial value to SQLMetricParam.\n",
    "commit": "14a5f0a5098ae36f9ee1217fdbc882f68e19488f",
    "createdAt": "2015-08-07T00:45:02Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql.metric\n+\n+import org.apache.spark.{Accumulable, AccumulableParam, SparkContext}\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ *\n+ * An implementation of SQLMetric should override `+=` and `add` to avoid boxing.\n+ */\n+private[sql] abstract class SQLMetric[R <: SQLMetricValue[T], T](\n+    name: String, val param: SQLMetricParam[R, T])",
    "line": 29
  }],
  "prId": 7996
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "do we need int metric at all? seems like we only need long version.\n",
    "commit": "14a5f0a5098ae36f9ee1217fdbc882f68e19488f",
    "createdAt": "2015-08-07T00:41:16Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql.metric\n+\n+import org.apache.spark.{Accumulable, AccumulableParam, SparkContext}\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ *\n+ * An implementation of SQLMetric should override `+=` and `add` to avoid boxing.\n+ */\n+private[sql] abstract class SQLMetric[R <: SQLMetricValue[T], T](\n+    name: String, val param: SQLMetricParam[R, T])\n+  extends Accumulable[R, T](param.zero, param, Some(name), true)\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ */\n+private[sql] trait SQLMetricParam[R <: SQLMetricValue[T], T] extends AccumulableParam[R, T] {\n+\n+  def zero: R\n+}\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ */\n+private[sql] trait SQLMetricValue[T] extends Serializable {\n+\n+  def value: T\n+\n+  override def toString: String = value.toString\n+}\n+\n+/**\n+ * A wrapper of Long to avoid boxing and unboxing when using Accumulator\n+ */\n+private[sql] class LongSQLMetricValue(private var _value : Long) extends SQLMetricValue[Long] {\n+\n+  def add(incr: Long): LongSQLMetricValue = {\n+    _value += incr\n+    this\n+  }\n+\n+  // Although there is a boxing here, it's fine because it's only called in SQLListener\n+  override def value: Long = _value\n+}\n+\n+/**\n+ * A wrapper of Int to avoid boxing and unboxing when using Accumulator\n+ */\n+private[sql] class IntSQLMetricValue(private var _value: Int) extends SQLMetricValue[Int] {",
    "line": 69
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "No. Adding it so that we can see if it's easy to add another SQLMetric type.\n",
    "commit": "14a5f0a5098ae36f9ee1217fdbc882f68e19488f",
    "createdAt": "2015-08-07T00:45:42Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql.metric\n+\n+import org.apache.spark.{Accumulable, AccumulableParam, SparkContext}\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ *\n+ * An implementation of SQLMetric should override `+=` and `add` to avoid boxing.\n+ */\n+private[sql] abstract class SQLMetric[R <: SQLMetricValue[T], T](\n+    name: String, val param: SQLMetricParam[R, T])\n+  extends Accumulable[R, T](param.zero, param, Some(name), true)\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ */\n+private[sql] trait SQLMetricParam[R <: SQLMetricValue[T], T] extends AccumulableParam[R, T] {\n+\n+  def zero: R\n+}\n+\n+/**\n+ * Create a layer for specialized metric. We cannot add `@specialized` to\n+ * `Accumulable/AccumulableParam` because it will break Java source compatibility.\n+ */\n+private[sql] trait SQLMetricValue[T] extends Serializable {\n+\n+  def value: T\n+\n+  override def toString: String = value.toString\n+}\n+\n+/**\n+ * A wrapper of Long to avoid boxing and unboxing when using Accumulator\n+ */\n+private[sql] class LongSQLMetricValue(private var _value : Long) extends SQLMetricValue[Long] {\n+\n+  def add(incr: Long): LongSQLMetricValue = {\n+    _value += incr\n+    this\n+  }\n+\n+  // Although there is a boxing here, it's fine because it's only called in SQLListener\n+  override def value: Long = _value\n+}\n+\n+/**\n+ * A wrapper of Int to avoid boxing and unboxing when using Accumulator\n+ */\n+private[sql] class IntSQLMetricValue(private var _value: Int) extends SQLMetricValue[Int] {",
    "line": 69
  }],
  "prId": 7996
}]