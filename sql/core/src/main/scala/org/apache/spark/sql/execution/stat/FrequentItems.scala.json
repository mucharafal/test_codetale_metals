[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Since we still need to recompute `minCount` after each update, I think the code is simpler without tracking `minCount` in all cases. We can compute `minCount` directly in this branch.\n\n``` scala\nif (baseMap.contains(key)) {\n  baseMap(key) += count\n} else {\n  baseMap(key) = count\n  if (baseMap.size > size) {\n    val minCount = baseMap.values.min\n    baseMap.retain((_, v) => v > minCount)\n    baseMap.transform((_, v) => v - minCount)\n  }\n}\n```\n",
    "commit": "07fa001fc6b8cf234125ed018d391a05887cf7f5",
    "createdAt": "2015-08-05T15:04:55Z",
    "diffHunk": "@@ -38,13 +37,22 @@ private[sql] object FrequentItems extends Logging {\n     def add(key: Any, count: Long): this.type = {\n       if (baseMap.contains(key))  {\n         baseMap(key) += count\n+        if (baseMap(key) < minCount) minCount = baseMap(key)\n       } else {\n         if (baseMap.size < size) {\n           baseMap += key -> count\n+          if (count < minCount) minCount = count\n         } else {\n-          // TODO: Make this more efficient... A flatMap?\n-          baseMap.retain((k, v) => v > count)\n-          baseMap.transform((k, v) => v - count)\n+          val remainder = count - minCount\n+          if (remainder >= 0) {\n+            baseMap += key -> count // something will get kicked out, so we can add this\n+            baseMap.retain((k, v) => v > minCount)\n+            baseMap.transform((k, v) => v - minCount)\n+            minCount = baseMap.foldLeft(Long.MaxValue)((a, b) => math.min(a, b._2))"
  }],
  "prId": 7945
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor, this could happen after transforming exiting counts\n",
    "commit": "07fa001fc6b8cf234125ed018d391a05887cf7f5",
    "createdAt": "2015-08-05T20:35:14Z",
    "diffHunk": "@@ -42,9 +40,15 @@ private[sql] object FrequentItems extends Logging {\n         if (baseMap.size < size) {\n           baseMap += key -> count\n         } else {\n-          // TODO: Make this more efficient... A flatMap?\n-          baseMap.retain((k, v) => v > count)\n-          baseMap.transform((k, v) => v - count)\n+          val minCount = baseMap.values.min\n+          val remainder = count - minCount\n+          if (remainder >= 0) {\n+            baseMap += key -> count // something will get kicked out, so we can add this",
    "line": 29
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "the reason I had this up here, was so that this gets deleted if `count = minCount`, and that we don't add `key -> 0` to the map\n",
    "commit": "07fa001fc6b8cf234125ed018d391a05887cf7f5",
    "createdAt": "2015-08-05T21:36:29Z",
    "diffHunk": "@@ -42,9 +40,15 @@ private[sql] object FrequentItems extends Logging {\n         if (baseMap.size < size) {\n           baseMap += key -> count\n         } else {\n-          // TODO: Make this more efficient... A flatMap?\n-          baseMap.retain((k, v) => v > count)\n-          baseMap.transform((k, v) => v - count)\n+          val minCount = baseMap.values.min\n+          val remainder = count - minCount\n+          if (remainder >= 0) {\n+            baseMap += key -> count // something will get kicked out, so we can add this",
    "line": 29
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "okay, this is minor\n",
    "commit": "07fa001fc6b8cf234125ed018d391a05887cf7f5",
    "createdAt": "2015-08-05T23:55:03Z",
    "diffHunk": "@@ -42,9 +40,15 @@ private[sql] object FrequentItems extends Logging {\n         if (baseMap.size < size) {\n           baseMap += key -> count\n         } else {\n-          // TODO: Make this more efficient... A flatMap?\n-          baseMap.retain((k, v) => v > count)\n-          baseMap.transform((k, v) => v - count)\n+          val minCount = baseMap.values.min\n+          val remainder = count - minCount\n+          if (remainder >= 0) {\n+            baseMap += key -> count // something will get kicked out, so we can add this",
    "line": 29
  }],
  "prId": 7945
}]