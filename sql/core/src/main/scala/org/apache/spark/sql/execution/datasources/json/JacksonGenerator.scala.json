[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Inline both writeArray and writeArrayData?\n",
    "commit": "6570a9874e60ecb9366ea37a0e5dfe06b821dc62",
    "createdAt": "2016-07-07T16:08:19Z",
    "diffHunk": "@@ -17,74 +17,180 @@\n \n package org.apache.spark.sql.execution.datasources.json\n \n+import java.io.Writer\n+\n import com.fasterxml.jackson.core._\n \n import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.SpecializedGetters\n import org.apache.spark.sql.catalyst.util.{ArrayData, DateTimeUtils, MapData}\n import org.apache.spark.sql.types._\n \n-private[sql] object JacksonGenerator {\n-  /** Transforms a single InternalRow to JSON using Jackson\n-   *\n-   * TODO: make the code shared with the other apply method.\n-   *\n-   * @param rowSchema the schema object used for conversion\n-   * @param gen a JsonGenerator object\n-   * @param row The row to convert\n-   */\n-  def apply(rowSchema: StructType, gen: JsonGenerator)(row: InternalRow): Unit = {\n-    def valWriter: (DataType, Any) => Unit = {\n-      case (_, null) | (NullType, _) => gen.writeNull()\n-      case (StringType, v) => gen.writeString(v.toString)\n-      case (TimestampType, v: Long) => gen.writeString(DateTimeUtils.toJavaTimestamp(v).toString)\n-      case (IntegerType, v: Int) => gen.writeNumber(v)\n-      case (ShortType, v: Short) => gen.writeNumber(v)\n-      case (FloatType, v: Float) => gen.writeNumber(v)\n-      case (DoubleType, v: Double) => gen.writeNumber(v)\n-      case (LongType, v: Long) => gen.writeNumber(v)\n-      case (DecimalType(), v: Decimal) => gen.writeNumber(v.toJavaBigDecimal)\n-      case (ByteType, v: Byte) => gen.writeNumber(v.toInt)\n-      case (BinaryType, v: Array[Byte]) => gen.writeBinary(v)\n-      case (BooleanType, v: Boolean) => gen.writeBoolean(v)\n-      case (DateType, v: Int) => gen.writeString(DateTimeUtils.toJavaDate(v).toString)\n-      // For UDT values, they should be in the SQL type's corresponding value type.\n-      // We should not see values in the user-defined class at here.\n-      // For example, VectorUDT's SQL type is an array of double. So, we should expect that v is\n-      // an ArrayData at here, instead of a Vector.\n-      case (udt: UserDefinedType[_], v) => valWriter(udt.sqlType, v)\n-\n-      case (ArrayType(ty, _), v: ArrayData) =>\n-        gen.writeStartArray()\n-        v.foreach(ty, (_, value) => valWriter(ty, value))\n-        gen.writeEndArray()\n-\n-      case (MapType(kt, vt, _), v: MapData) =>\n-        gen.writeStartObject()\n-        v.foreach(kt, vt, { (k, v) =>\n-          gen.writeFieldName(k.toString)\n-          valWriter(vt, v)\n-        })\n-        gen.writeEndObject()\n-\n-      case (StructType(ty), v: InternalRow) =>\n-        gen.writeStartObject()\n-        var i = 0\n-        while (i < ty.length) {\n-          val field = ty(i)\n-          val value = v.get(i, field.dataType)\n-          if (value != null) {\n-            gen.writeFieldName(field.name)\n-            valWriter(field.dataType, value)\n-          }\n-          i += 1\n+private[sql] class JacksonGenerator(schema: StructType, writer: Writer) {\n+  // A `ValueWriter` is responsible for writing a field of an `InternalRow` to appropriate\n+  // JSON data. Here we are using `SpecializedGetters` rather than `InternalRow` so that\n+  // we can directly access data in `ArrayData` without the help of `SpecificMutableRow`.\n+  private type ValueWriter = (SpecializedGetters, Int) => Unit\n+\n+  // `ValueWriter`s for all fields of the schema\n+  private val rootFieldWriters: Seq[ValueWriter] = schema.map(_.dataType).map(makeWriter)\n+\n+  private val gen = new JsonFactory().createGenerator(writer).setRootValueSeparator(null)\n+\n+  private def makeWriter(dataType: DataType): ValueWriter = dataType match {\n+    case NullType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNull()\n+\n+    case BooleanType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeBoolean(row.getBoolean(ordinal))\n+\n+    case ByteType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getByte(ordinal))\n+\n+    case ShortType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getShort(ordinal))\n+\n+    case IntegerType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getInt(ordinal))\n+\n+    case LongType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getLong(ordinal))\n+\n+    case FloatType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getFloat(ordinal))\n+\n+    case DoubleType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getDouble(ordinal))\n+\n+    case StringType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeString(row.getUTF8String(ordinal).toString)\n+\n+    case TimestampType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeString(DateTimeUtils.toJavaTimestamp(row.getLong(ordinal)).toString)\n+\n+    case DateType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeString(DateTimeUtils.toJavaDate(row.getInt(ordinal)).toString)\n+\n+    case BinaryType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeBinary(row.getBinary(ordinal))\n+\n+    case dt: DecimalType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getDecimal(ordinal, dt.precision, dt.scale).toJavaBigDecimal)\n+\n+    case st: StructType =>\n+      val fieldWriters = st.map(_.dataType).map(makeWriter)\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        writeObject {\n+          writeFields(row.getStruct(ordinal, st.length), st, fieldWriters)\n+        }\n+\n+    case at: ArrayType =>\n+      val elementWriter = makeWriter(at.elementType)\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        writeArray {\n+          writeArrayData(row.getArray(ordinal), elementWriter)"
  }],
  "prId": 14028
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Inline this function?\n",
    "commit": "6570a9874e60ecb9366ea37a0e5dfe06b821dc62",
    "createdAt": "2016-07-07T16:08:21Z",
    "diffHunk": "@@ -17,74 +17,180 @@\n \n package org.apache.spark.sql.execution.datasources.json\n \n+import java.io.Writer\n+\n import com.fasterxml.jackson.core._\n \n import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.SpecializedGetters\n import org.apache.spark.sql.catalyst.util.{ArrayData, DateTimeUtils, MapData}\n import org.apache.spark.sql.types._\n \n-private[sql] object JacksonGenerator {\n-  /** Transforms a single InternalRow to JSON using Jackson\n-   *\n-   * TODO: make the code shared with the other apply method.\n-   *\n-   * @param rowSchema the schema object used for conversion\n-   * @param gen a JsonGenerator object\n-   * @param row The row to convert\n-   */\n-  def apply(rowSchema: StructType, gen: JsonGenerator)(row: InternalRow): Unit = {\n-    def valWriter: (DataType, Any) => Unit = {\n-      case (_, null) | (NullType, _) => gen.writeNull()\n-      case (StringType, v) => gen.writeString(v.toString)\n-      case (TimestampType, v: Long) => gen.writeString(DateTimeUtils.toJavaTimestamp(v).toString)\n-      case (IntegerType, v: Int) => gen.writeNumber(v)\n-      case (ShortType, v: Short) => gen.writeNumber(v)\n-      case (FloatType, v: Float) => gen.writeNumber(v)\n-      case (DoubleType, v: Double) => gen.writeNumber(v)\n-      case (LongType, v: Long) => gen.writeNumber(v)\n-      case (DecimalType(), v: Decimal) => gen.writeNumber(v.toJavaBigDecimal)\n-      case (ByteType, v: Byte) => gen.writeNumber(v.toInt)\n-      case (BinaryType, v: Array[Byte]) => gen.writeBinary(v)\n-      case (BooleanType, v: Boolean) => gen.writeBoolean(v)\n-      case (DateType, v: Int) => gen.writeString(DateTimeUtils.toJavaDate(v).toString)\n-      // For UDT values, they should be in the SQL type's corresponding value type.\n-      // We should not see values in the user-defined class at here.\n-      // For example, VectorUDT's SQL type is an array of double. So, we should expect that v is\n-      // an ArrayData at here, instead of a Vector.\n-      case (udt: UserDefinedType[_], v) => valWriter(udt.sqlType, v)\n-\n-      case (ArrayType(ty, _), v: ArrayData) =>\n-        gen.writeStartArray()\n-        v.foreach(ty, (_, value) => valWriter(ty, value))\n-        gen.writeEndArray()\n-\n-      case (MapType(kt, vt, _), v: MapData) =>\n-        gen.writeStartObject()\n-        v.foreach(kt, vt, { (k, v) =>\n-          gen.writeFieldName(k.toString)\n-          valWriter(vt, v)\n-        })\n-        gen.writeEndObject()\n-\n-      case (StructType(ty), v: InternalRow) =>\n-        gen.writeStartObject()\n-        var i = 0\n-        while (i < ty.length) {\n-          val field = ty(i)\n-          val value = v.get(i, field.dataType)\n-          if (value != null) {\n-            gen.writeFieldName(field.name)\n-            valWriter(field.dataType, value)\n-          }\n-          i += 1\n+private[sql] class JacksonGenerator(schema: StructType, writer: Writer) {\n+  // A `ValueWriter` is responsible for writing a field of an `InternalRow` to appropriate\n+  // JSON data. Here we are using `SpecializedGetters` rather than `InternalRow` so that\n+  // we can directly access data in `ArrayData` without the help of `SpecificMutableRow`.\n+  private type ValueWriter = (SpecializedGetters, Int) => Unit\n+\n+  // `ValueWriter`s for all fields of the schema\n+  private val rootFieldWriters: Seq[ValueWriter] = schema.map(_.dataType).map(makeWriter)\n+\n+  private val gen = new JsonFactory().createGenerator(writer).setRootValueSeparator(null)\n+\n+  private def makeWriter(dataType: DataType): ValueWriter = dataType match {\n+    case NullType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNull()\n+\n+    case BooleanType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeBoolean(row.getBoolean(ordinal))\n+\n+    case ByteType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getByte(ordinal))\n+\n+    case ShortType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getShort(ordinal))\n+\n+    case IntegerType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getInt(ordinal))\n+\n+    case LongType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getLong(ordinal))\n+\n+    case FloatType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getFloat(ordinal))\n+\n+    case DoubleType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getDouble(ordinal))\n+\n+    case StringType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeString(row.getUTF8String(ordinal).toString)\n+\n+    case TimestampType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeString(DateTimeUtils.toJavaTimestamp(row.getLong(ordinal)).toString)\n+\n+    case DateType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeString(DateTimeUtils.toJavaDate(row.getInt(ordinal)).toString)\n+\n+    case BinaryType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeBinary(row.getBinary(ordinal))\n+\n+    case dt: DecimalType =>\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        gen.writeNumber(row.getDecimal(ordinal, dt.precision, dt.scale).toJavaBigDecimal)\n+\n+    case st: StructType =>\n+      val fieldWriters = st.map(_.dataType).map(makeWriter)\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        writeObject {\n+          writeFields(row.getStruct(ordinal, st.length), st, fieldWriters)\n+        }\n+\n+    case at: ArrayType =>\n+      val elementWriter = makeWriter(at.elementType)\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        writeArray {\n+          writeArrayData(row.getArray(ordinal), elementWriter)\n         }\n-        gen.writeEndObject()\n \n-      case (dt, v) =>\n-        sys.error(\n-          s\"Failed to convert value $v (class of ${v.getClass}}) with the type of $dt to JSON.\")\n+    case mt: MapType =>\n+      val valueWriter = makeWriter(mt.valueType)\n+      (row: SpecializedGetters, ordinal: Int) =>\n+        writeObject {\n+          writeMapData(row.getMap(ordinal), mt, valueWriter)"
  }],
  "prId": 14028
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Let's use an array. \n",
    "commit": "6570a9874e60ecb9366ea37a0e5dfe06b821dc62",
    "createdAt": "2016-07-07T16:08:30Z",
    "diffHunk": "@@ -17,74 +17,180 @@\n \n package org.apache.spark.sql.execution.datasources.json\n \n+import java.io.Writer\n+\n import com.fasterxml.jackson.core._\n \n import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.SpecializedGetters\n import org.apache.spark.sql.catalyst.util.{ArrayData, DateTimeUtils, MapData}\n import org.apache.spark.sql.types._\n \n-private[sql] object JacksonGenerator {\n-  /** Transforms a single InternalRow to JSON using Jackson\n-   *\n-   * TODO: make the code shared with the other apply method.\n-   *\n-   * @param rowSchema the schema object used for conversion\n-   * @param gen a JsonGenerator object\n-   * @param row The row to convert\n-   */\n-  def apply(rowSchema: StructType, gen: JsonGenerator)(row: InternalRow): Unit = {\n-    def valWriter: (DataType, Any) => Unit = {\n-      case (_, null) | (NullType, _) => gen.writeNull()\n-      case (StringType, v) => gen.writeString(v.toString)\n-      case (TimestampType, v: Long) => gen.writeString(DateTimeUtils.toJavaTimestamp(v).toString)\n-      case (IntegerType, v: Int) => gen.writeNumber(v)\n-      case (ShortType, v: Short) => gen.writeNumber(v)\n-      case (FloatType, v: Float) => gen.writeNumber(v)\n-      case (DoubleType, v: Double) => gen.writeNumber(v)\n-      case (LongType, v: Long) => gen.writeNumber(v)\n-      case (DecimalType(), v: Decimal) => gen.writeNumber(v.toJavaBigDecimal)\n-      case (ByteType, v: Byte) => gen.writeNumber(v.toInt)\n-      case (BinaryType, v: Array[Byte]) => gen.writeBinary(v)\n-      case (BooleanType, v: Boolean) => gen.writeBoolean(v)\n-      case (DateType, v: Int) => gen.writeString(DateTimeUtils.toJavaDate(v).toString)\n-      // For UDT values, they should be in the SQL type's corresponding value type.\n-      // We should not see values in the user-defined class at here.\n-      // For example, VectorUDT's SQL type is an array of double. So, we should expect that v is\n-      // an ArrayData at here, instead of a Vector.\n-      case (udt: UserDefinedType[_], v) => valWriter(udt.sqlType, v)\n-\n-      case (ArrayType(ty, _), v: ArrayData) =>\n-        gen.writeStartArray()\n-        v.foreach(ty, (_, value) => valWriter(ty, value))\n-        gen.writeEndArray()\n-\n-      case (MapType(kt, vt, _), v: MapData) =>\n-        gen.writeStartObject()\n-        v.foreach(kt, vt, { (k, v) =>\n-          gen.writeFieldName(k.toString)\n-          valWriter(vt, v)\n-        })\n-        gen.writeEndObject()\n-\n-      case (StructType(ty), v: InternalRow) =>\n-        gen.writeStartObject()\n-        var i = 0\n-        while (i < ty.length) {\n-          val field = ty(i)\n-          val value = v.get(i, field.dataType)\n-          if (value != null) {\n-            gen.writeFieldName(field.name)\n-            valWriter(field.dataType, value)\n-          }\n-          i += 1\n+private[sql] class JacksonGenerator(schema: StructType, writer: Writer) {\n+  // A `ValueWriter` is responsible for writing a field of an `InternalRow` to appropriate\n+  // JSON data. Here we are using `SpecializedGetters` rather than `InternalRow` so that\n+  // we can directly access data in `ArrayData` without the help of `SpecificMutableRow`.\n+  private type ValueWriter = (SpecializedGetters, Int) => Unit\n+\n+  // `ValueWriter`s for all fields of the schema\n+  private val rootFieldWriters: Seq[ValueWriter] = schema.map(_.dataType).map(makeWriter)"
  }],
  "prId": 14028
}]