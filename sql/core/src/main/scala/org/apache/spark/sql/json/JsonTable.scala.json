[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "order the imports according to https://cwiki.apache.org/confluence/display/SPARK/Spark+Code+Style+Guide#SparkCodeStyleGuide-Imports\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:28:12Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "let's put this in a SchemaResolutionMode.scala ...\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:29:29Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "A separate file for 4 lines of code?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:24:38Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "u don't need the val for case class\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:30:15Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Also we don't use ALL_CAPS for class names.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:15:33Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think u can move this to the previous line without wrapping it\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:30:57Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Actually - it might make sense to just get rid of the Option. If sampleRatio == 1.0, then it doesn't need to do sample. \n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:41:48Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Good idea, I like that better than Option.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:25:12Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {"
  }, {
    "author": {
      "login": "ash211"
    },
    "body": "Be careful with floating point comparison though -- `0.3*3 + .1 != 1.0` for example.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-08T05:05:05Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "why does this need to be serializable?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:31:12Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "It was because I started writing this in the REPL and it kept getting pulled into jobs for no good reason.  Its possible that we could remove it now?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:16:26Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "it would be more obvious what this does if you write it out, i.e.\n\n``` scala\nval schemaData = if (sampleSchema.isDefined) json.sample(false, sampleSchema.get, 1) else json\n```\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:33:13Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "BTW sometimes sample is too expensive because sample isn't by blocks. It still requires reading all the data from disk. You might want to consider sampling by blocks here (or we can improve Spark's sample operator to do that).@mengxr any thoughts?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:33:55Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "We should definitely add a block level sample to Spark, though I wouldn't block this PR based on that.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:17:26Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Yup this shouldn't block on that.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-08T07:12:22Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "I think you can put this whole thing on one line too...\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:37:29Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan("
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "isn't this already defined in catalyst type system?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:37:53Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence ="
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Only in a Hive based Rule.  If this is the exact same ordering though we might consider pulling it out.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:18:17Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence ="
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "what's wrong with the java map/lists?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:39:03Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "We will use functions provided by Scala collections (e.g. map and flatMap). So, we explicitly convert the type from Java Map/Lists to Scala Map/List. \n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-10T15:45:32Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "why do we mark these as protected? the outer level is an object - are you going to extend the object?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:41:03Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "No, I think we will not extend this object. I was thinking to only expose `inferSchema` to users. Should we do that?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-09T21:43:43Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "value.asInstanceOf[Int].toLong\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T06:43:26Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {\n+    case map: java.util.Map[String, Object] =>\n+      // .map(identity) is used as a workaround of non-serializable Map\n+      // generated by .mapValues.\n+      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005\n+      map.toMap.mapValues(scalafy).map(identity)\n+    case list: java.util.List[Object] =>\n+      list.toList.map(scalafy)\n+    case atom => atom\n+  }\n+\n+  protected def parseJson(json: RDD[String]): RDD[Map[String, Any]] = {\n+    // According to [Jackson-72: https://jira.codehaus.org/browse/JACKSON-72],\n+    // ObjectMapper will not return BigDecimal when\n+    // \"DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS\" is disabled\n+    // (see NumberDeserializer.deserialize for the logic).\n+    // But, we do not want to enable this feature because it will use BigDecimal\n+    // for every float number, which will be slow.\n+    // So, right now, we will have Infinity for those BigDecimal number.\n+    // TODO: Support BigDecimal.\n+    json.mapPartitions(iter => {\n+      // When there is a key appearing multiple times (a duplicate key),\n+      // the ObjectMapper will take the last value associated with this duplicate key.\n+      // For example: for {\"key\": 1, \"key\":2}, we will get \"key\"->2.\n+      val mapper = new ObjectMapper()\n+      iter.map(record => mapper.readValue(record, classOf[Object]))\n+    }).map(scalafy).map(_.asInstanceOf[Map[String, Any]])\n+  }\n+\n+  protected def toLong(value: Any): Long = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Long]"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Should this still be commented out?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:30:06Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "These sorts of casts are only going to do what you want if the type of value isn't `Any`\n\n``` scala\nscala> 1L.asInstanceOf[Int]\nres0: Int = 1\n\nscala> (1L: Any).asInstanceOf[Int]\njava.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.Integer\n```\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:38:25Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {\n+    case map: java.util.Map[String, Object] =>\n+      // .map(identity) is used as a workaround of non-serializable Map\n+      // generated by .mapValues.\n+      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005\n+      map.toMap.mapValues(scalafy).map(identity)\n+    case list: java.util.List[Object] =>\n+      list.toList.map(scalafy)\n+    case atom => atom\n+  }\n+\n+  protected def parseJson(json: RDD[String]): RDD[Map[String, Any]] = {\n+    // According to [Jackson-72: https://jira.codehaus.org/browse/JACKSON-72],\n+    // ObjectMapper will not return BigDecimal when\n+    // \"DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS\" is disabled\n+    // (see NumberDeserializer.deserialize for the logic).\n+    // But, we do not want to enable this feature because it will use BigDecimal\n+    // for every float number, which will be slow.\n+    // So, right now, we will have Infinity for those BigDecimal number.\n+    // TODO: Support BigDecimal.\n+    json.mapPartitions(iter => {\n+      // When there is a key appearing multiple times (a duplicate key),\n+      // the ObjectMapper will take the last value associated with this duplicate key.\n+      // For example: for {\"key\": 1, \"key\":2}, we will get \"key\"->2.\n+      val mapper = new ObjectMapper()\n+      iter.map(record => mapper.readValue(record, classOf[Object]))\n+    }).map(scalafy).map(_.asInstanceOf[Map[String, Any]])\n+  }\n+\n+  protected def toLong(value: Any): Long = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Long]\n+      case value: java.lang.Long => value.asInstanceOf[Long]\n+    }\n+  }\n+\n+  protected def toDouble(value: Any): Double = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Double]\n+      case value: java.lang.Long => value.asInstanceOf[Long].asInstanceOf[Double]\n+      case value: java.lang.Double => value.asInstanceOf[Double]\n+    }\n+  }\n+\n+  protected def toDecimal(value: Any): BigDecimal = {\n+    value match {\n+      case value: java.lang.Integer => BigDecimal(value)\n+      case value: java.lang.Long => BigDecimal(value)\n+      case value: java.math.BigInteger => BigDecimal(value)\n+      case value: java.lang.Double => BigDecimal(value)\n+      case value: java.math.BigDecimal => BigDecimal(value)\n+    }\n+  }\n+\n+  protected def enforceCorrectType(value: Any, desiredType: DataType): Any ={\n+    if (value == null) {\n+      null\n+    } else {\n+      desiredType match {\n+        case ArrayType(elementType) =>\n+          value.asInstanceOf[Seq[Any]].map(enforceCorrectType(_, elementType))\n+        case StringType => value.toString\n+        case IntegerType => value.asInstanceOf[IntegerType.JvmType]"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Relatedly, can we add a few tests for type promotion?  @aarondav has been running into some issues with the current implementation.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:47:04Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {\n+    case map: java.util.Map[String, Object] =>\n+      // .map(identity) is used as a workaround of non-serializable Map\n+      // generated by .mapValues.\n+      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005\n+      map.toMap.mapValues(scalafy).map(identity)\n+    case list: java.util.List[Object] =>\n+      list.toList.map(scalafy)\n+    case atom => atom\n+  }\n+\n+  protected def parseJson(json: RDD[String]): RDD[Map[String, Any]] = {\n+    // According to [Jackson-72: https://jira.codehaus.org/browse/JACKSON-72],\n+    // ObjectMapper will not return BigDecimal when\n+    // \"DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS\" is disabled\n+    // (see NumberDeserializer.deserialize for the logic).\n+    // But, we do not want to enable this feature because it will use BigDecimal\n+    // for every float number, which will be slow.\n+    // So, right now, we will have Infinity for those BigDecimal number.\n+    // TODO: Support BigDecimal.\n+    json.mapPartitions(iter => {\n+      // When there is a key appearing multiple times (a duplicate key),\n+      // the ObjectMapper will take the last value associated with this duplicate key.\n+      // For example: for {\"key\": 1, \"key\":2}, we will get \"key\"->2.\n+      val mapper = new ObjectMapper()\n+      iter.map(record => mapper.readValue(record, classOf[Object]))\n+    }).map(scalafy).map(_.asInstanceOf[Map[String, Any]])\n+  }\n+\n+  protected def toLong(value: Any): Long = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Long]\n+      case value: java.lang.Long => value.asInstanceOf[Long]\n+    }\n+  }\n+\n+  protected def toDouble(value: Any): Double = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Double]\n+      case value: java.lang.Long => value.asInstanceOf[Long].asInstanceOf[Double]\n+      case value: java.lang.Double => value.asInstanceOf[Double]\n+    }\n+  }\n+\n+  protected def toDecimal(value: Any): BigDecimal = {\n+    value match {\n+      case value: java.lang.Integer => BigDecimal(value)\n+      case value: java.lang.Long => BigDecimal(value)\n+      case value: java.math.BigInteger => BigDecimal(value)\n+      case value: java.lang.Double => BigDecimal(value)\n+      case value: java.math.BigDecimal => BigDecimal(value)\n+    }\n+  }\n+\n+  protected def enforceCorrectType(value: Any, desiredType: DataType): Any ={\n+    if (value == null) {\n+      null\n+    } else {\n+      desiredType match {\n+        case ArrayType(elementType) =>\n+          value.asInstanceOf[Seq[Any]].map(enforceCorrectType(_, elementType))\n+        case StringType => value.toString\n+        case IntegerType => value.asInstanceOf[IntegerType.JvmType]"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "For this part, I think an exception means that we inferred the wrong data type for a column.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-10T16:39:53Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {\n+    case map: java.util.Map[String, Object] =>\n+      // .map(identity) is used as a workaround of non-serializable Map\n+      // generated by .mapValues.\n+      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005\n+      map.toMap.mapValues(scalafy).map(identity)\n+    case list: java.util.List[Object] =>\n+      list.toList.map(scalafy)\n+    case atom => atom\n+  }\n+\n+  protected def parseJson(json: RDD[String]): RDD[Map[String, Any]] = {\n+    // According to [Jackson-72: https://jira.codehaus.org/browse/JACKSON-72],\n+    // ObjectMapper will not return BigDecimal when\n+    // \"DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS\" is disabled\n+    // (see NumberDeserializer.deserialize for the logic).\n+    // But, we do not want to enable this feature because it will use BigDecimal\n+    // for every float number, which will be slow.\n+    // So, right now, we will have Infinity for those BigDecimal number.\n+    // TODO: Support BigDecimal.\n+    json.mapPartitions(iter => {\n+      // When there is a key appearing multiple times (a duplicate key),\n+      // the ObjectMapper will take the last value associated with this duplicate key.\n+      // For example: for {\"key\": 1, \"key\":2}, we will get \"key\"->2.\n+      val mapper = new ObjectMapper()\n+      iter.map(record => mapper.readValue(record, classOf[Object]))\n+    }).map(scalafy).map(_.asInstanceOf[Map[String, Any]])\n+  }\n+\n+  protected def toLong(value: Any): Long = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Long]\n+      case value: java.lang.Long => value.asInstanceOf[Long]\n+    }\n+  }\n+\n+  protected def toDouble(value: Any): Double = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Double]\n+      case value: java.lang.Long => value.asInstanceOf[Long].asInstanceOf[Double]\n+      case value: java.lang.Double => value.asInstanceOf[Double]\n+    }\n+  }\n+\n+  protected def toDecimal(value: Any): BigDecimal = {\n+    value match {\n+      case value: java.lang.Integer => BigDecimal(value)\n+      case value: java.lang.Long => BigDecimal(value)\n+      case value: java.math.BigInteger => BigDecimal(value)\n+      case value: java.lang.Double => BigDecimal(value)\n+      case value: java.math.BigDecimal => BigDecimal(value)\n+    }\n+  }\n+\n+  protected def enforceCorrectType(value: Any, desiredType: DataType): Any ={\n+    if (value == null) {\n+      null\n+    } else {\n+      desiredType match {\n+        case ArrayType(elementType) =>\n+          value.asInstanceOf[Seq[Any]].map(enforceCorrectType(_, elementType))\n+        case StringType => value.toString\n+        case IntegerType => value.asInstanceOf[IntegerType.JvmType]"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "I need to change this part. So, we can automatically update the type.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-11T01:11:11Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {\n+    case map: java.util.Map[String, Object] =>\n+      // .map(identity) is used as a workaround of non-serializable Map\n+      // generated by .mapValues.\n+      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005\n+      map.toMap.mapValues(scalafy).map(identity)\n+    case list: java.util.List[Object] =>\n+      list.toList.map(scalafy)\n+    case atom => atom\n+  }\n+\n+  protected def parseJson(json: RDD[String]): RDD[Map[String, Any]] = {\n+    // According to [Jackson-72: https://jira.codehaus.org/browse/JACKSON-72],\n+    // ObjectMapper will not return BigDecimal when\n+    // \"DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS\" is disabled\n+    // (see NumberDeserializer.deserialize for the logic).\n+    // But, we do not want to enable this feature because it will use BigDecimal\n+    // for every float number, which will be slow.\n+    // So, right now, we will have Infinity for those BigDecimal number.\n+    // TODO: Support BigDecimal.\n+    json.mapPartitions(iter => {\n+      // When there is a key appearing multiple times (a duplicate key),\n+      // the ObjectMapper will take the last value associated with this duplicate key.\n+      // For example: for {\"key\": 1, \"key\":2}, we will get \"key\"->2.\n+      val mapper = new ObjectMapper()\n+      iter.map(record => mapper.readValue(record, classOf[Object]))\n+    }).map(scalafy).map(_.asInstanceOf[Map[String, Any]])\n+  }\n+\n+  protected def toLong(value: Any): Long = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Long]\n+      case value: java.lang.Long => value.asInstanceOf[Long]\n+    }\n+  }\n+\n+  protected def toDouble(value: Any): Double = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Double]\n+      case value: java.lang.Long => value.asInstanceOf[Long].asInstanceOf[Double]\n+      case value: java.lang.Double => value.asInstanceOf[Double]\n+    }\n+  }\n+\n+  protected def toDecimal(value: Any): BigDecimal = {\n+    value match {\n+      case value: java.lang.Integer => BigDecimal(value)\n+      case value: java.lang.Long => BigDecimal(value)\n+      case value: java.math.BigInteger => BigDecimal(value)\n+      case value: java.lang.Double => BigDecimal(value)\n+      case value: java.math.BigDecimal => BigDecimal(value)\n+    }\n+  }\n+\n+  protected def enforceCorrectType(value: Any, desiredType: DataType): Any ={\n+    if (value == null) {\n+      null\n+    } else {\n+      desiredType match {\n+        case ArrayType(elementType) =>\n+          value.asInstanceOf[Seq[Any]].map(enforceCorrectType(_, elementType))\n+        case StringType => value.toString\n+        case IntegerType => value.asInstanceOf[IntegerType.JvmType]"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Minor note: #360 adds library functions to catalyst for doing these sorts of conversions.\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T17:43:01Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we\n+   * only use a placeholder for a struct type (StructType(Nil)) instead of getting\n+   * all fields of this struct because a field does not appear in this JSON object\n+   * can appear in other JSON objects.\n+   */\n+  protected def getAllKeysWithValueTypes(m: Map[String, Any]): Set[(String, DataType)] = {\n+    m.map{\n+      // Quote the key with backticks to handle cases which have dots\n+      // in the field name.\n+      case (key, dataType) => (s\"`$key`\", dataType)\n+    }.flatMap {\n+      case (key: String, struct: Map[String, Any]) => {\n+        // The value associted with the key is an JSON object.\n+        getAllKeysWithValueTypes(struct).map {\n+          case (k, dataType) => (s\"$key.$k\", dataType)\n+        } ++ Set((key, StructType(Nil)))\n+      }\n+      case (key: String, array: List[Any]) => {\n+        // The value associted with the key is an array.\n+        getTypeOfArray(array) match {\n+          case ArrayType(StructType(Nil)) => {\n+            // The elements of this arrays are structs.\n+            array.asInstanceOf[List[Map[String, Any]]].flatMap {\n+              element => getAllKeysWithValueTypes(element)\n+            }.map {\n+              case (k, dataType) => (s\"$key.$k\", dataType)\n+            } :+ (key, ArrayType(StructType(Nil)))\n+          }\n+          case ArrayType(elementType) => (key, ArrayType(elementType)) :: Nil\n+        }\n+      }\n+      case (key: String, value) => (key, getPrimitiveType(value)) :: Nil\n+    }.toSet\n+  }\n+\n+  /**\n+   * Converts a Java Map/List to a Scala Map/List.\n+   * We do not use Jackson's scala module at here because\n+   * DefaultScalaModule in jackson-module-scala will make\n+   * the parsing very slow.\n+   */\n+  protected def scalafy(obj: Any): Any = obj match {\n+    case map: java.util.Map[String, Object] =>\n+      // .map(identity) is used as a workaround of non-serializable Map\n+      // generated by .mapValues.\n+      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005\n+      map.toMap.mapValues(scalafy).map(identity)\n+    case list: java.util.List[Object] =>\n+      list.toList.map(scalafy)\n+    case atom => atom\n+  }\n+\n+  protected def parseJson(json: RDD[String]): RDD[Map[String, Any]] = {\n+    // According to [Jackson-72: https://jira.codehaus.org/browse/JACKSON-72],\n+    // ObjectMapper will not return BigDecimal when\n+    // \"DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS\" is disabled\n+    // (see NumberDeserializer.deserialize for the logic).\n+    // But, we do not want to enable this feature because it will use BigDecimal\n+    // for every float number, which will be slow.\n+    // So, right now, we will have Infinity for those BigDecimal number.\n+    // TODO: Support BigDecimal.\n+    json.mapPartitions(iter => {\n+      // When there is a key appearing multiple times (a duplicate key),\n+      // the ObjectMapper will take the last value associated with this duplicate key.\n+      // For example: for {\"key\": 1, \"key\":2}, we will get \"key\"->2.\n+      val mapper = new ObjectMapper()\n+      iter.map(record => mapper.readValue(record, classOf[Object]))\n+    }).map(scalafy).map(_.asInstanceOf[Map[String, Any]])\n+  }\n+\n+  protected def toLong(value: Any): Long = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Long]\n+      case value: java.lang.Long => value.asInstanceOf[Long]\n+    }\n+  }\n+\n+  protected def toDouble(value: Any): Double = {\n+    value match {\n+      case value: java.lang.Integer => value.asInstanceOf[Int].asInstanceOf[Double]\n+      case value: java.lang.Long => value.asInstanceOf[Long].asInstanceOf[Double]\n+      case value: java.lang.Double => value.asInstanceOf[Double]\n+    }\n+  }\n+\n+  protected def toDecimal(value: Any): BigDecimal = {\n+    value match {\n+      case value: java.lang.Integer => BigDecimal(value)\n+      case value: java.lang.Long => BigDecimal(value)\n+      case value: java.math.BigInteger => BigDecimal(value)\n+      case value: java.lang.Double => BigDecimal(value)\n+      case value: java.math.BigDecimal => BigDecimal(value)\n+    }\n+  }\n+\n+  protected def enforceCorrectType(value: Any, desiredType: DataType): Any ={\n+    if (value == null) {\n+      null\n+    } else {\n+      desiredType match {\n+        case ArrayType(elementType) =>\n+          value.asInstanceOf[Seq[Any]].map(enforceCorrectType(_, elementType))\n+        case StringType => value.toString\n+        case IntegerType => value.asInstanceOf[IntegerType.JvmType]\n+        case LongType => toLong(value)\n+        case DoubleType => toDouble(value)\n+        case DecimalType => toDecimal(value)\n+        case BooleanType => value.asInstanceOf[BooleanType.JvmType]\n+        case NullType => null\n+      }\n+    }\n+  }\n+\n+  protected def asRow(json: Map[String,Any], schema: StructType): Row = {\n+    val row = new GenericMutableRow(schema.fields.length)\n+    schema.fields.zipWithIndex.foreach {\n+      // StructType\n+      case (StructField(name, fields: StructType, _), i) =>\n+        row.update(i, json.get(name).flatMap(v => Option(v)).map(\n+          v => asRow(v.asInstanceOf[Map[String, Any]], fields)).orNull)\n+\n+      // ArrayType(StructType)\n+      case (StructField(name, ArrayType(structType: StructType), _), i) =>\n+        row.update(i,\n+          json.get(name).flatMap(v => Option(v)).map(\n+            v => v.asInstanceOf[Seq[Any]].map(\n+              e => asRow(e.asInstanceOf[Map[String, Any]], structType))).orNull)\n+\n+      // Other cases\n+      case (StructField(name, dataType, _), i) =>\n+        row.update(i, json.get(name).flatMap(v => Option(v)).map(\n+          enforceCorrectType(_, dataType)).getOrElse(null))\n+    }\n+\n+    row\n+  }\n+\n+  protected def asAttributes(struct: StructType): Seq[AttributeReference] = {"
  }],
  "prId": 999
}, {
  "comments": [{
    "author": {
      "login": "markhamstra"
    },
    "body": "typo\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-07T18:47:17Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.json\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.{ExistingRdd, SparkLogicalPlan}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.types._\n+import org.apache.spark.sql.SchemaRDD\n+import org.apache.spark.sql.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, GetField}\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+\n+import scala.collection.JavaConversions._\n+import scala.math.BigDecimal\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.types.StructField\n+import org.apache.spark.sql.catalyst.types.StructType\n+import org.apache.spark.sql.catalyst.types.ArrayType\n+import org.apache.spark.sql.catalyst.expressions.GetField\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.execution.SparkLogicalPlan\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+\n+sealed trait SchemaResolutionMode\n+\n+case object EAGER_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+case class EAGER_SCHEMA_RESOLUTION_WITH_SAMPLING(val fraction: Double) extends SchemaResolutionMode\n+case object LAZY_SCHEMA_RESOLUTION extends SchemaResolutionMode\n+\n+/**\n+ * :: Experimental ::\n+ * Converts a JSON file to a SparkSQL logical query plan.  This implementation is only designed to\n+ * work on JSON files that have mostly uniform schema.  The conversion suffers from the following\n+ * limitation:\n+ *  - The data is optionally sampled to determine all of the possible fields. Any fields that do\n+ *    not appear in this sample will not be included in the final output.\n+ */\n+@Experimental\n+object JsonTable extends Serializable with Logging {\n+  def inferSchema(\n+      json: RDD[String], sampleSchema: Option[Double] = None): LogicalPlan = {\n+    val schemaData = sampleSchema.map(json.sample(false, _, 1)).getOrElse(json)\n+    val allKeys = parseJson(schemaData).map(getAllKeysWithValueTypes).reduce(_ ++ _)\n+\n+    // Resolve type conflicts\n+    val resolved = allKeys.groupBy {\n+      case (key, dataType) => key\n+    }.map {\n+      // Now, keys and types are organized in the format of\n+      // key -> Set(type1, type2, ...).\n+      case (key, typeSet) => {\n+        val fieldName = key.substring(1, key.length - 1).split(\"`.`\").toSeq\n+        val dataType = typeSet.map {\n+          case (_, dataType) => dataType\n+        }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+        // Finally, we replace all NullType to StringType. We do not need to take care\n+        // StructType because all fields with a StructType are represented by a placeholder\n+        // StructType(Nil).\n+        dataType match {\n+          case NullType => (fieldName, StringType)\n+          case ArrayType(NullType) => (fieldName, ArrayType(StringType))\n+          case other => (fieldName, other)\n+        }\n+      }\n+    }\n+\n+    def makeStruct(values: Seq[Seq[String]], prefix: Seq[String]): StructType = {\n+      val (topLevel, structLike) = values.partition(_.size == 1)\n+      val topLevelFields = topLevel.filter {\n+        name => resolved.get(prefix ++ name).get match {\n+          case ArrayType(StructType(Nil)) => false\n+          case ArrayType(_) => true\n+          case struct: StructType => false\n+          case _ => true\n+        }\n+      }.map {\n+        a => StructField(a.head, resolved.get(prefix ++ a).get, nullable = true)\n+      }.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      val structFields: Seq[StructField] = structLike.groupBy(_(0)).map {\n+        case (name, fields) => {\n+          val nestedFields = fields.map(_.tail)\n+          val structType = makeStruct(nestedFields, prefix :+ name)\n+          val dataType = resolved.get(prefix :+ name).get\n+          dataType match {\n+            case array: ArrayType => Some(StructField(name, ArrayType(structType), nullable = true))\n+            case struct: StructType => Some(StructField(name, structType, nullable = true))\n+            // dataType is StringType means that we have resolved type conflicts involving\n+            // primitive types and complex types. So, the type of name has been relaxed to\n+            // StringType. Also, this field should have already been put in topLevelFields.\n+            case StringType => None\n+          }\n+        }\n+      }.flatMap(field => field).toSeq.sortBy {\n+        case StructField(name, _, _) => name\n+      }\n+\n+      StructType(topLevelFields ++ structFields)\n+    }\n+\n+    val schema = makeStruct(resolved.keySet.toSeq, Nil)\n+\n+    SparkLogicalPlan(\n+      ExistingRdd(\n+        asAttributes(schema),\n+        parseJson(json).map(asRow(_, schema))))\n+  }\n+\n+  // numericPrecedence and booleanPrecedence are from WidenTypes.\n+  // A widening conversion of a value with IntegerType and LongType to FloatType,\n+  // or of a value with LongType to DoubleType, may result in loss of precision\n+  // (some of the least significant bits of the value).\n+  val numericPrecedence =\n+    Seq(NullType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType, DecimalType)\n+  // Boolean is only wider than Void\n+  val booleanPrecedence = Seq(NullType, BooleanType)\n+  val allPromotions: Seq[Seq[DataType]] = numericPrecedence :: booleanPrecedence :: Nil\n+\n+  /**\n+   * Returns the most general data type for two given data types.\n+   */\n+  protected def getCompatibleType(t1: DataType, t2: DataType): DataType = {\n+    // Try and find a promotion rule that contains both types in question.\n+    val applicableConversion = allPromotions.find(p => p.contains(t1) && p.contains(t2))\n+\n+    // If found return the widest common type, otherwise None\n+    val returnType = applicableConversion.map(_.filter(t => t == t1 || t == t2).last)\n+\n+    if (returnType.isDefined) {\n+      returnType.get\n+    } else {\n+      // t1 or t2 is a StructType, ArrayType, or an unexpected type.\n+      (t1, t2) match {\n+        case (other: DataType, NullType) => other\n+        case (NullType, other: DataType) => other\n+        // TODO: Returns the union of fields1 and fields2?\n+        case (StructType(fields1), StructType(fields2))\n+          if (fields1 == fields2) => StructType(fields1)\n+        case (ArrayType(elementType1), ArrayType(elementType2)) =>\n+          ArrayType(getCompatibleType(elementType1, elementType2))\n+        case (_, _) => StringType\n+      }\n+    }\n+  }\n+\n+  protected def getPrimitiveType(value: Any): DataType = {\n+    value match {\n+      case value: java.lang.String => StringType\n+      case value: java.lang.Integer => IntegerType\n+      case value: java.lang.Long => LongType\n+      // Since we do not have a data type backed by BigInteger,\n+      // when we see a Java BigInteger, we use DecimalType.\n+      case value: java.math.BigInteger => DecimalType\n+      case value: java.lang.Double => DoubleType\n+      case value: java.math.BigDecimal => DecimalType\n+      case value: java.lang.Boolean => BooleanType\n+      case null => NullType\n+      // We comment out the following line in the development to catch bugs.\n+      // We need to enable this line in future to handle\n+      // unexpected data type.\n+      // case _ => StringType\n+    }\n+  }\n+\n+  /**\n+   * Returns the element type of an JSON array. We go through all elements of this array\n+   * to detect any possible type conflict. We use [[getCompatibleType]] to resolve\n+   * type conflicts. Right now, when the element of an array is another array, we\n+   * treat the element as String.\n+   */\n+  protected def getTypeOfArray(l: Seq[Any]): ArrayType = {\n+    val elements = l.flatMap(v => Option(v))\n+    if (elements.isEmpty) {\n+      // If this JSON array is empty, we use NullType as a placeholder.\n+      // If this array is not empty in other JSON objects, we can resolve\n+      // the type after we have passed through all JSON objects.\n+      ArrayType(NullType)\n+    } else {\n+      val elementType = elements.map {\n+        e => e match {\n+          case map: Map[_, _] => StructType(Nil)\n+          // We have an array of arrays. If those element arrays do not have the same\n+          // element types, we will return ArrayType[StringType].\n+          case seq: Seq[_] =>  getTypeOfArray(seq)\n+          case value => getPrimitiveType(value)\n+        }\n+      }.reduce((type1: DataType, type2: DataType) => getCompatibleType(type1, type2))\n+\n+      ArrayType(elementType)\n+    }\n+  }\n+\n+  /**\n+   * Figures out all key names and data types of values from a parsed JSON object\n+   * (in the format of Map[Stirng, Any]). When a value of a key is an object, we"
  }],
  "prId": 999
}]