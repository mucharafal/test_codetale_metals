[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Shall we just `require` here too?",
    "commit": "d3d28aa852dc90acc898df5b7a4e38135b0daf10",
    "createdAt": "2018-03-31T08:59:44Z",
    "diffHunk": "@@ -41,13 +41,16 @@ private[text] class TextOptions(@transient private val parameters: CaseInsensiti\n    */\n   val wholeText = parameters.getOrElse(WHOLETEXT, \"false\").toBoolean\n \n-  private val lineSeparator: Option[String] = parameters.get(LINE_SEPARATOR).map { sep =>\n-    require(sep.nonEmpty, s\"'$LINE_SEPARATOR' cannot be an empty string.\")\n-    sep\n+  val charset: Option[String] = Some(\"UTF-8\")\n+\n+  val lineSeparator: Option[Array[Byte]] = parameters.get(\"lineSep\").map { lineSep =>\n+    require(lineSep.nonEmpty, s\"'$LINE_SEPARATOR' cannot be an empty string.\")\n+    lineSep.getBytes(charset.getOrElse("
  }],
  "prId": 20937
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we have the same signature with JSON one too? `String`?",
    "commit": "d3d28aa852dc90acc898df5b7a4e38135b0daf10",
    "createdAt": "2018-04-02T02:33:35Z",
    "diffHunk": "@@ -41,19 +41,23 @@ private[text] class TextOptions(@transient private val parameters: CaseInsensiti\n    */\n   val wholeText = parameters.getOrElse(WHOLETEXT, \"false\").toBoolean\n \n-  private val lineSeparator: Option[String] = parameters.get(LINE_SEPARATOR).map { sep =>\n-    require(sep.nonEmpty, s\"'$LINE_SEPARATOR' cannot be an empty string.\")\n-    sep\n+  val encoding: Option[String] = parameters.get(ENCODING)\n+\n+  val lineSeparator: Option[Array[Byte]] = parameters.get(LINE_SEPARATOR).map { lineSep =>"
  }],
  "prId": 20937
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "not a big deal at all but was just wondering if there was a reason to choose `\"UTF-8\"` over `StandardCharsets.UTF_8` because I was thinking `StandardCharsets.UTF_8` is slightly better. ",
    "commit": "d3d28aa852dc90acc898df5b7a4e38135b0daf10",
    "createdAt": "2018-04-22T06:53:01Z",
    "diffHunk": "@@ -41,19 +41,25 @@ private[text] class TextOptions(@transient private val parameters: CaseInsensiti\n    */\n   val wholeText = parameters.getOrElse(WHOLETEXT, \"false\").toBoolean\n \n-  private val lineSeparator: Option[String] = parameters.get(LINE_SEPARATOR).map { sep =>\n-    require(sep.nonEmpty, s\"'$LINE_SEPARATOR' cannot be an empty string.\")\n-    sep\n+  val encoding: Option[String] = parameters.get(ENCODING)\n+\n+  val lineSeparator: Option[String] = parameters.get(LINE_SEPARATOR).map { lineSep =>\n+    require(lineSep.nonEmpty, s\"'$LINE_SEPARATOR' cannot be an empty string.\")\n+\n+    lineSep\n   }\n+\n   // Note that the option 'lineSep' uses a different default value in read and write.\n-  val lineSeparatorInRead: Option[Array[Byte]] =\n-    lineSeparator.map(_.getBytes(StandardCharsets.UTF_8))\n+  val lineSeparatorInRead: Option[Array[Byte]] = lineSeparator.map { lineSep =>\n+    lineSep.getBytes(encoding.getOrElse(\"UTF-8\"))\n+  }\n   val lineSeparatorInWrite: Array[Byte] =\n-    lineSeparatorInRead.getOrElse(\"\\n\".getBytes(StandardCharsets.UTF_8))\n+    lineSeparatorInRead.getOrElse(\"\\n\".getBytes(\"UTF-8\"))"
  }],
  "prId": 20937
}]