[{
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "nit: getOption ...",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T07:19:46Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`."
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "It's better to disallow this case. Otherwise, the user may happen to send a null by mistake and we just hide the error.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T22:36:42Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {\n+ *   // Check if state exists\n+ *   if (state.exists) {\n+ *     val existingState = state.get  // Get the existing state\n+ *     val shouldRemove = ...         // Decide whether to remove the state\n+ *     if (shouldRemove) {\n+ *       state.remove()     // Remove the state\n+ *     } else {\n+ *       val newState = ...\n+ *       state.update(newState)    // Set the new state\n+ *     }\n+ *   } else {\n+ *     val initialState = ...\n+ *     state.update(initialState)  // Set the initial state\n+ *   }\n+ *   ... // return something\n+ * }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `KeyedState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * MapGroupsWithStateFunction<String, Integer, Integer, String> mappingFunction =\n+ *    new MapGroupsWithStateFunction<String, Integer, Integer, String>() {\n+ *\n+ *      @Override\n+ *      public String call(String key, Optional<Integer> value, KeyedState<Integer> state) {\n+ *        if (state.exists()) {\n+ *          int existingState = state.get(); // Get the existing state\n+ *          boolean shouldRemove = ...; // Decide whether to remove the state\n+ *          if (shouldRemove) {\n+ *            state.remove(); // Remove the state\n+ *          } else {\n+ *            int newState = ...;\n+ *            state.update(newState); // Set the new state\n+ *          }\n+ *        } else {\n+ *          int initialState = ...; // Set the initial state\n+ *          state.update(initialState);\n+ *        }\n+ *        ... // return something\n+ *      }\n+ *    };\n+ * }}}\n+ *\n+ * @tparam S User-defined type of the state to be stored for each key. Must be encodable into\n+ *           Spark SQL types (see [[Encoder]] for more details).\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait KeyedState[S] extends LogicalKeyedState[S] {\n+\n+  /** Whether state exists or not. */\n+  def exists: Boolean\n+\n+  /** Get the state object if it exists, or null. */\n+  def get: S\n+\n+  /**\n+   * Update the value of the state. Note that null is not a valid value, and `update(null)` is\n+   * same as `remove()`"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "@marmbrus any thoughts on this?",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-03T00:40:47Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {\n+ *   // Check if state exists\n+ *   if (state.exists) {\n+ *     val existingState = state.get  // Get the existing state\n+ *     val shouldRemove = ...         // Decide whether to remove the state\n+ *     if (shouldRemove) {\n+ *       state.remove()     // Remove the state\n+ *     } else {\n+ *       val newState = ...\n+ *       state.update(newState)    // Set the new state\n+ *     }\n+ *   } else {\n+ *     val initialState = ...\n+ *     state.update(initialState)  // Set the initial state\n+ *   }\n+ *   ... // return something\n+ * }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `KeyedState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * MapGroupsWithStateFunction<String, Integer, Integer, String> mappingFunction =\n+ *    new MapGroupsWithStateFunction<String, Integer, Integer, String>() {\n+ *\n+ *      @Override\n+ *      public String call(String key, Optional<Integer> value, KeyedState<Integer> state) {\n+ *        if (state.exists()) {\n+ *          int existingState = state.get(); // Get the existing state\n+ *          boolean shouldRemove = ...; // Decide whether to remove the state\n+ *          if (shouldRemove) {\n+ *            state.remove(); // Remove the state\n+ *          } else {\n+ *            int newState = ...;\n+ *            state.update(newState); // Set the new state\n+ *          }\n+ *        } else {\n+ *          int initialState = ...; // Set the initial state\n+ *          state.update(initialState);\n+ *        }\n+ *        ... // return something\n+ *      }\n+ *    };\n+ * }}}\n+ *\n+ * @tparam S User-defined type of the state to be stored for each key. Must be encodable into\n+ *           Spark SQL types (see [[Encoder]] for more details).\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait KeyedState[S] extends LogicalKeyedState[S] {\n+\n+  /** Whether state exists or not. */\n+  def exists: Boolean\n+\n+  /** Get the state object if it exists, or null. */\n+  def get: S\n+\n+  /**\n+   * Update the value of the state. Note that null is not a valid value, and `update(null)` is\n+   * same as `remove()`"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "if get for a non-existent key returns `null` then I think its reasonable that `remove(key)` and `put(key, null)` are the same.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-03T00:43:08Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {\n+ *   // Check if state exists\n+ *   if (state.exists) {\n+ *     val existingState = state.get  // Get the existing state\n+ *     val shouldRemove = ...         // Decide whether to remove the state\n+ *     if (shouldRemove) {\n+ *       state.remove()     // Remove the state\n+ *     } else {\n+ *       val newState = ...\n+ *       state.update(newState)    // Set the new state\n+ *     }\n+ *   } else {\n+ *     val initialState = ...\n+ *     state.update(initialState)  // Set the initial state\n+ *   }\n+ *   ... // return something\n+ * }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `KeyedState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * MapGroupsWithStateFunction<String, Integer, Integer, String> mappingFunction =\n+ *    new MapGroupsWithStateFunction<String, Integer, Integer, String>() {\n+ *\n+ *      @Override\n+ *      public String call(String key, Optional<Integer> value, KeyedState<Integer> state) {\n+ *        if (state.exists()) {\n+ *          int existingState = state.get(); // Get the existing state\n+ *          boolean shouldRemove = ...; // Decide whether to remove the state\n+ *          if (shouldRemove) {\n+ *            state.remove(); // Remove the state\n+ *          } else {\n+ *            int newState = ...;\n+ *            state.update(newState); // Set the new state\n+ *          }\n+ *        } else {\n+ *          int initialState = ...; // Set the initial state\n+ *          state.update(initialState);\n+ *        }\n+ *        ... // return something\n+ *      }\n+ *    };\n+ * }}}\n+ *\n+ * @tparam S User-defined type of the state to be stored for each key. Must be encodable into\n+ *           Spark SQL types (see [[Encoder]] for more details).\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait KeyedState[S] extends LogicalKeyedState[S] {\n+\n+  /** Whether state exists or not. */\n+  def exists: Boolean\n+\n+  /** Get the state object if it exists, or null. */\n+  def get: S\n+\n+  /**\n+   * Update the value of the state. Note that null is not a valid value, and `update(null)` is\n+   * same as `remove()`"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "@marmbrus The user may pass a null by mistake (e.g., just call some method that may return null but not be aware of it). It's pretty hard to debug such silent mistake.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-03T00:46:50Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {\n+ *   // Check if state exists\n+ *   if (state.exists) {\n+ *     val existingState = state.get  // Get the existing state\n+ *     val shouldRemove = ...         // Decide whether to remove the state\n+ *     if (shouldRemove) {\n+ *       state.remove()     // Remove the state\n+ *     } else {\n+ *       val newState = ...\n+ *       state.update(newState)    // Set the new state\n+ *     }\n+ *   } else {\n+ *     val initialState = ...\n+ *     state.update(initialState)  // Set the initial state\n+ *   }\n+ *   ... // return something\n+ * }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `KeyedState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * MapGroupsWithStateFunction<String, Integer, Integer, String> mappingFunction =\n+ *    new MapGroupsWithStateFunction<String, Integer, Integer, String>() {\n+ *\n+ *      @Override\n+ *      public String call(String key, Optional<Integer> value, KeyedState<Integer> state) {\n+ *        if (state.exists()) {\n+ *          int existingState = state.get(); // Get the existing state\n+ *          boolean shouldRemove = ...; // Decide whether to remove the state\n+ *          if (shouldRemove) {\n+ *            state.remove(); // Remove the state\n+ *          } else {\n+ *            int newState = ...;\n+ *            state.update(newState); // Set the new state\n+ *          }\n+ *        } else {\n+ *          int initialState = ...; // Set the initial state\n+ *          state.update(initialState);\n+ *        }\n+ *        ... // return something\n+ *      }\n+ *    };\n+ * }}}\n+ *\n+ * @tparam S User-defined type of the state to be stored for each key. Must be encodable into\n+ *           Spark SQL types (see [[Encoder]] for more details).\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait KeyedState[S] extends LogicalKeyedState[S] {\n+\n+  /** Whether state exists or not. */\n+  def exists: Boolean\n+\n+  /** Get the state object if it exists, or null. */\n+  def get: S\n+\n+  /**\n+   * Update the value of the state. Note that null is not a valid value, and `update(null)` is\n+   * same as `remove()`"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: only **one** invocation",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T22:38:10Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:33:01Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit `get` will return `null`.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T22:39:12Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`."
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:32:47Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`."
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nits\r\n- `Option[String]=` -> `String = `.\r\n- `Iterable` -> `Iterator`.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T22:40:39Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:34:46Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: `Optional<Integer>` -> `Iterator<Integer>`",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-02T22:43:20Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {\n+ *   // Check if state exists\n+ *   if (state.exists) {\n+ *     val existingState = state.get  // Get the existing state\n+ *     val shouldRemove = ...         // Decide whether to remove the state\n+ *     if (shouldRemove) {\n+ *       state.remove()     // Remove the state\n+ *     } else {\n+ *       val newState = ...\n+ *       state.update(newState)    // Set the new state\n+ *     }\n+ *   } else {\n+ *     val initialState = ...\n+ *     state.update(initialState)  // Set the initial state\n+ *   }\n+ *   ... // return something\n+ * }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `KeyedState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * MapGroupsWithStateFunction<String, Integer, Integer, String> mappingFunction =\n+ *    new MapGroupsWithStateFunction<String, Integer, Integer, String>() {\n+ *\n+ *      @Override\n+ *      public String call(String key, Optional<Integer> value, KeyedState<Integer> state) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:34:43Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and\n+ *    `getOption()` will return `None`.\n+ *  - After that `update(newState)` is called, then `exists()` will return `true`,\n+ *    and `getOption()` will return `Some(...)`.\n+ *\n+ * Scala example of using `KeyedState` in `mapGroupsWithState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * def mappingFunction(key: String, value: Iterable[Int], state: KeyedState[Int]): Option[String]= {\n+ *   // Check if state exists\n+ *   if (state.exists) {\n+ *     val existingState = state.get  // Get the existing state\n+ *     val shouldRemove = ...         // Decide whether to remove the state\n+ *     if (shouldRemove) {\n+ *       state.remove()     // Remove the state\n+ *     } else {\n+ *       val newState = ...\n+ *       state.update(newState)    // Set the new state\n+ *     }\n+ *   } else {\n+ *     val initialState = ...\n+ *     state.update(initialState)  // Set the initial state\n+ *   }\n+ *   ... // return something\n+ * }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `KeyedState`:\n+ * {{{\n+ * // A mapping function that maintains an integer state for string keys and returns a string.\n+ * MapGroupsWithStateFunction<String, Integer, Integer, String> mappingFunction =\n+ *    new MapGroupsWithStateFunction<String, Integer, Integer, String>() {\n+ *\n+ *      @Override\n+ *      public String call(String key, Optional<Integer> value, KeyedState<Integer> state) {"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "nit: `If ``remove`` is called`. Remove `the`",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-03T00:47:33Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-02-07T05:40:21Z",
    "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalKeyedState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with keyed state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[KeyValueGroupedDataset]].\n+ *\n+ * Detail description on `[map/flatMap]GroupsWithState` operation\n+ * ------------------------------------------------------------\n+ * Both, `mapGroupsWithState` and `flatMapGroupsWithState` in [[KeyValueGroupedDataset]]\n+ * will invoke the user-given function on each group (defined by the grouping function in\n+ * `Dataset.groupByKey()`) while maintaining user-defined per-group state between invocations.\n+ * For a static batch Dataset, the function will be invoked once per group. For a streaming\n+ * Dataset, the function will be invoked for each group repeatedly in every trigger.\n+ * That is, in every batch of the [[streaming.StreamingQuery StreamingQuery]],\n+ * the function will be invoked once for each group that has data in the batch.\n+ *\n+ * The function is invoked with following parameters.\n+ *  - The key of the group.\n+ *  - An iterator containing all the values for this key.\n+ *  - A user-defined state object set by previous invocations of the given function.\n+ * In case of a batch Dataset, there is only invocation and state object will be empty as\n+ * there is no prior state. Essentially, for batch Datasets, `[map/flatMap]GroupsWithState`\n+ * is equivalent to `[map/flatMap]Groups`.\n+ *\n+ * Important points to note about the function.\n+ *  - In a trigger, the function will be called only the groups present in the batch. So do not\n+ *    assume that the function will be called in every trigger for every group that has state.\n+ *  - There is no guaranteed ordering of values in the iterator in the function, neither with\n+ *    batch, nor with streaming Datasets.\n+ *  - All the data will be shuffled before applying the function.\n+ *\n+ * Important points to note about using KeyedState.\n+ *  - The value of the state cannot be null. So updating state with null is same as removing it.\n+ *  - Operations on `KeyedState` are not thread-safe. This is to avoid memory barriers.\n+ *  - If the `remove()` is called, then `exists()` will return `false`, and"
  }],
  "prId": 16758
}]