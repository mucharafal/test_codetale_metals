[{
  "comments": [{
    "author": {
      "login": "xuanyuanking"
    },
    "body": "nit: If we need the rename here, how about other messages name and comments? \r\nhttps://github.com/apache/spark/pull/21428/files#diff-4072457048f805637bfce2c779608756R29\r\nhttps://github.com/apache/spark/pull/21428/files#diff-4072457048f805637bfce2c779608756R35\r\n",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-05-30T12:32:44Z",
    "diffHunk": "@@ -48,7 +46,7 @@ private[shuffle] case class ReceiverEpochMarker(writerId: Int) extends UnsafeRow\n  * TODO: Support multiple source tasks. We need to output a single epoch marker once all\n  * source tasks have sent one.\n  */\n-private[shuffle] class UnsafeRowReceiver(\n+private[shuffle] class RPCContinuousShuffleReader(",
    "line": 36
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "Good point. Caught what I think are the rest.",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-05-31T22:48:00Z",
    "diffHunk": "@@ -48,7 +46,7 @@ private[shuffle] case class ReceiverEpochMarker(writerId: Int) extends UnsafeRow\n  * TODO: Support multiple source tasks. We need to output a single epoch marker once all\n  * source tasks have sent one.\n  */\n-private[shuffle] class UnsafeRowReceiver(\n+private[shuffle] class RPCContinuousShuffleReader(",
    "line": 36
  }],
  "prId": 21428
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "This line may block PRC threads and cause some critical RPC messages delayed. In addition, if the reader fails, this line may block forever if the queue is full.\r\n\r\nI'm okey with this right now since it's an experimental feature. Could you create a SPARK ticket and add a TODO here to comment the potential issue so that we won't forget this issue?",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-06-12T22:16:25Z",
    "diffHunk": "@@ -68,7 +66,7 @@ private[shuffle] class UnsafeRowReceiver(\n   }\n \n   override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n-    case r: UnsafeRowReceiverMessage =>\n+    case r: RPCContinuousShuffleMessage =>\n       queues(r.writerId).put(r)"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "I'm not sure what a critical RPC message is in this context. This line is intended to block forever if the queue is full; the receiver should not take any action or accept any other messages until the queue stops being full.",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-06-13T04:19:00Z",
    "diffHunk": "@@ -68,7 +66,7 @@ private[shuffle] class UnsafeRowReceiver(\n   }\n \n   override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n-    case r: UnsafeRowReceiverMessage =>\n+    case r: RPCContinuousShuffleMessage =>\n       queues(r.writerId).put(r)"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "All RPC messages inside Spark are processed in [a shared fixed thread pool](https://github.com/apache/spark/blob/v2.3.1/core/src/main/scala/org/apache/spark/rpc/netty/Dispatcher.scala#L197), hence we cannot run blocking calls inside a RPC thread.\r\n\r\nI think we need to design a backpressure mechanism in future fundamentally because a receiver cannot block a sender sending data. For example, even if we block here, we still cannot prevent the sender sending data and they will finally fulfill the TCP buffer. We cannot just count on TCP backpressure here as we need to use the same TCP connection in order to support thousands of machines.\r\n\r\n",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-06-13T05:15:42Z",
    "diffHunk": "@@ -68,7 +66,7 @@ private[shuffle] class UnsafeRowReceiver(\n   }\n \n   override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n-    case r: UnsafeRowReceiverMessage =>\n+    case r: RPCContinuousShuffleMessage =>\n       queues(r.writerId).put(r)"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "That's a very strange characteristic for an RPC framework.\r\n\r\nI don't know what backpressure could mean other than a receiver blocking a sender from sending more data. In any case, the final shuffle mechanism isn't going to use the RPC framework, so I added a reference to it. (We can discuss in a later PR whether we want to leave this mechanism lying around or remove it once we're confident the TCP-based one is working.)",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-06-13T05:51:54Z",
    "diffHunk": "@@ -68,7 +66,7 @@ private[shuffle] class UnsafeRowReceiver(\n   }\n \n   override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n-    case r: UnsafeRowReceiverMessage =>\n+    case r: RPCContinuousShuffleMessage =>\n       queues(r.writerId).put(r)"
  }],
  "prId": 21428
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Are you planning to implement round-robin here? Otherwise, using an array of queries + a thread pool can be just replaced with a blocking queue.",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-06-12T23:14:42Z",
    "diffHunk": "@@ -79,10 +77,10 @@ private[shuffle] class UnsafeRowReceiver(\n       private val writerEpochMarkersReceived = Array.fill(numShuffleWriters)(false)\n \n       private val executor = Executors.newFixedThreadPool(numShuffleWriters)\n-      private val completion = new ExecutorCompletionService[UnsafeRowReceiverMessage](executor)\n+      private val completion = new ExecutorCompletionService[RPCContinuousShuffleMessage](executor)",
    "line": 65
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "It cannot be. There's a deadlock scenario where the queue is filled with records from epoch N before all writers have sent the marker for epoch N - 1.",
    "commit": "cff37c45f084d50a0844fbe8481565f6a9985302",
    "createdAt": "2018-06-13T04:01:41Z",
    "diffHunk": "@@ -79,10 +77,10 @@ private[shuffle] class UnsafeRowReceiver(\n       private val writerEpochMarkersReceived = Array.fill(numShuffleWriters)(false)\n \n       private val executor = Executors.newFixedThreadPool(numShuffleWriters)\n-      private val completion = new ExecutorCompletionService[UnsafeRowReceiverMessage](executor)\n+      private val completion = new ExecutorCompletionService[RPCContinuousShuffleMessage](executor)",
    "line": 65
  }],
  "prId": 21428
}]