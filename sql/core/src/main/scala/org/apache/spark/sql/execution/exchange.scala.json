[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think it's a good chance to create the \"exchange\" package and move everything in this file there as multiple files. we can do that later though.\n",
    "commit": "c8c175e91ad2896573a4d6efab9ee13d7f28103c",
    "createdAt": "2016-02-21T08:52:20Z",
    "diffHunk": "@@ -261,10 +266,71 @@ object Exchange {\n }\n \n /**\n+ * A [[BroadcastExchange]] collects, transforms and finally broadcasts the result of a transformed\n+ * SparkPlan.\n+ */\n+case class BroadcastExchange("
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Done.\n",
    "commit": "c8c175e91ad2896573a4d6efab9ee13d7f28103c",
    "createdAt": "2016-02-21T14:36:01Z",
    "diffHunk": "@@ -261,10 +266,71 @@ object Exchange {\n }\n \n /**\n+ * A [[BroadcastExchange]] collects, transforms and finally broadcasts the result of a transformed\n+ * SparkPlan.\n+ */\n+case class BroadcastExchange("
  }],
  "prId": 11083
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "transient private?\n",
    "commit": "c8c175e91ad2896573a4d6efab9ee13d7f28103c",
    "createdAt": "2016-02-21T08:54:24Z",
    "diffHunk": "@@ -261,10 +266,71 @@ object Exchange {\n }\n \n /**\n+ * A [[BroadcastExchange]] collects, transforms and finally broadcasts the result of a transformed\n+ * SparkPlan.\n+ */\n+case class BroadcastExchange(\n+    mode: BroadcastMode,\n+    child: SparkPlan) extends UnaryNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = BroadcastPartitioning(mode)\n+\n+  val timeout: Duration = {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Done.\n",
    "commit": "c8c175e91ad2896573a4d6efab9ee13d7f28103c",
    "createdAt": "2016-02-21T14:35:43Z",
    "diffHunk": "@@ -261,10 +266,71 @@ object Exchange {\n }\n \n /**\n+ * A [[BroadcastExchange]] collects, transforms and finally broadcasts the result of a transformed\n+ * SparkPlan.\n+ */\n+case class BroadcastExchange(\n+    mode: BroadcastMode,\n+    child: SparkPlan) extends UnaryNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = BroadcastPartitioning(mode)\n+\n+  val timeout: Duration = {"
  }],
  "prId": 11083
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "Broadcast -> BroadcastExchange, or maybe just use \n\n\"getClass.getName\"\n",
    "commit": "c8c175e91ad2896573a4d6efab9ee13d7f28103c",
    "createdAt": "2016-02-21T08:55:55Z",
    "diffHunk": "@@ -261,10 +266,71 @@ object Exchange {\n }\n \n /**\n+ * A [[BroadcastExchange]] collects, transforms and finally broadcasts the result of a transformed\n+ * SparkPlan.\n+ */\n+case class BroadcastExchange(\n+    mode: BroadcastMode,\n+    child: SparkPlan) extends UnaryNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = BroadcastPartitioning(mode)\n+\n+  val timeout: Duration = {\n+    val timeoutValue = sqlContext.conf.broadcastTimeout\n+    if (timeoutValue < 0) {\n+      Duration.Inf\n+    } else {\n+      timeoutValue.seconds\n+    }\n+  }\n+\n+  @transient\n+  private lazy val relationFuture: Future[broadcast.Broadcast[Any]] = {\n+    // broadcastFuture is used in \"doExecute\". Therefore we can get the execution id correctly here.\n+    val executionId = sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    Future {\n+      // This will run in another thread. Set the execution id so that we can connect these jobs\n+      // with the correct execution.\n+      SQLExecution.withExecutionId(sparkContext, executionId) {\n+        // Note that we use .execute().collect() because we don't want to convert data to Scala\n+        // types\n+        val input: Array[InternalRow] = child.execute().map { row =>\n+          row.copy()\n+        }.collect()\n+\n+        // Construct and broadcast the relation.\n+        sparkContext.broadcast(mode.transform(input))\n+      }\n+    }(BroadcastExchange.executionContext)\n+  }\n+\n+  override protected def doPrepare(): Unit = {\n+    // Materialize the future.\n+    relationFuture\n+  }\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    throw new UnsupportedOperationException(\"Broadcast does not support the execute() code path.\")"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Done.\n",
    "commit": "c8c175e91ad2896573a4d6efab9ee13d7f28103c",
    "createdAt": "2016-02-21T14:35:38Z",
    "diffHunk": "@@ -261,10 +266,71 @@ object Exchange {\n }\n \n /**\n+ * A [[BroadcastExchange]] collects, transforms and finally broadcasts the result of a transformed\n+ * SparkPlan.\n+ */\n+case class BroadcastExchange(\n+    mode: BroadcastMode,\n+    child: SparkPlan) extends UnaryNode {\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = BroadcastPartitioning(mode)\n+\n+  val timeout: Duration = {\n+    val timeoutValue = sqlContext.conf.broadcastTimeout\n+    if (timeoutValue < 0) {\n+      Duration.Inf\n+    } else {\n+      timeoutValue.seconds\n+    }\n+  }\n+\n+  @transient\n+  private lazy val relationFuture: Future[broadcast.Broadcast[Any]] = {\n+    // broadcastFuture is used in \"doExecute\". Therefore we can get the execution id correctly here.\n+    val executionId = sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    Future {\n+      // This will run in another thread. Set the execution id so that we can connect these jobs\n+      // with the correct execution.\n+      SQLExecution.withExecutionId(sparkContext, executionId) {\n+        // Note that we use .execute().collect() because we don't want to convert data to Scala\n+        // types\n+        val input: Array[InternalRow] = child.execute().map { row =>\n+          row.copy()\n+        }.collect()\n+\n+        // Construct and broadcast the relation.\n+        sparkContext.broadcast(mode.transform(input))\n+      }\n+    }(BroadcastExchange.executionContext)\n+  }\n+\n+  override protected def doPrepare(): Unit = {\n+    // Materialize the future.\n+    relationFuture\n+  }\n+\n+  override protected def doExecute(): RDD[InternalRow] = {\n+    throw new UnsupportedOperationException(\"Broadcast does not support the execute() code path.\")"
  }],
  "prId": 11083
}]