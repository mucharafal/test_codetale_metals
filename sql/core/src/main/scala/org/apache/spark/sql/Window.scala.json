[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "move Frame class and object into Window object. and remove private[sql] since users need to get this back\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:18:51Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)",
    "line": 26
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think about it more -- this is actually problematic for java because none partitionBy, orderBy won't become static methods due to conflicts with the Window class. Here's the fix.\n\nMove \"class Window\" into \"object Window\", and rename it to WindowSpec, and then just define the two partitionBy / orderBy top level methods in object Window. If we need another method for a window spec that doesn't have partitionBy/orderBy, we can add another one - I don't have a good name for it yet.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:26:08Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)\n+\n+/**\n+ * :: Experimental ::\n+ * An utility to specify the Window Frame Range.\n+ */\n+object Frame {\n+  val currentRow: Frame = new Frame(CurrentRow)\n+  val unbounded: Frame = new Frame()\n+  def preceding(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValuePreceding(n))\n+  }\n+\n+  def following(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValueFollowing(n))\n+  }\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * A Window object with everything unset. But can build new Window object\n+ * based on it.\n+ */\n+@Experimental\n+object Window extends Window()",
    "line": 54
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "@yhuai suggested \"allRows\"\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:34:51Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)\n+\n+/**\n+ * :: Experimental ::\n+ * An utility to specify the Window Frame Range.\n+ */\n+object Frame {\n+  val currentRow: Frame = new Frame(CurrentRow)\n+  val unbounded: Frame = new Frame()\n+  def preceding(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValuePreceding(n))\n+  }\n+\n+  def following(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValueFollowing(n))\n+  }\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * A Window object with everything unset. But can build new Window object\n+ * based on it.\n+ */\n+@Experimental\n+object Window extends Window()",
    "line": 54
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "this ctor is not necessary\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:32:21Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)\n+\n+/**\n+ * :: Experimental ::\n+ * An utility to specify the Window Frame Range.\n+ */\n+object Frame {\n+  val currentRow: Frame = new Frame(CurrentRow)\n+  val unbounded: Frame = new Frame()\n+  def preceding(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValuePreceding(n))\n+  }\n+\n+  def following(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValueFollowing(n))\n+  }\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * A Window object with everything unset. But can build new Window object\n+ * based on it.\n+ */\n+@Experimental\n+object Window extends Window()\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = Window.partitionBy(\"name\").orderBy(\"id\")\n+ *            .rowsBetween(Frame.unbounded, Frame.currentRow)\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *       .rowsBetween(Frame.unbounded, Frame.currentRow))\n+ *   )\n+ *\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *      .rowsBetween(Frame.preceding(50), Frame.following(10)))\n+ *   )\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class Window {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  private def this(",
    "line": 84
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "newColumn -> withAggregate\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:32:36Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)\n+\n+/**\n+ * :: Experimental ::\n+ * An utility to specify the Window Frame Range.\n+ */\n+object Frame {\n+  val currentRow: Frame = new Frame(CurrentRow)\n+  val unbounded: Frame = new Frame()\n+  def preceding(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValuePreceding(n))\n+  }\n+\n+  def following(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValueFollowing(n))\n+  }\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * A Window object with everything unset. But can build new Window object\n+ * based on it.\n+ */\n+@Experimental\n+object Window extends Window()\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = Window.partitionBy(\"name\").orderBy(\"id\")\n+ *            .rowsBetween(Frame.unbounded, Frame.currentRow)\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *       .rowsBetween(Frame.unbounded, Frame.currentRow))\n+ *   )\n+ *\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *      .rowsBetween(Frame.preceding(50), Frame.following(10)))\n+ *   )\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class Window {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  private def this(\n+      column: Column = null,\n+      partitionSpec: Seq[Expression] = Nil,\n+      orderSpec: Seq[SortOrder] = Nil,\n+      frame: WindowFrame = UnspecifiedFrame) {\n+    this()\n+    this.column = column\n+    this.partitionSpec = partitionSpec\n+    this.orderSpec = orderSpec\n+    this.frame     = frame\n+  }\n+\n+  private[sql] def newColumn(c: Column): Window = {",
    "line": 96
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "assert -> require\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:32:56Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)\n+\n+/**\n+ * :: Experimental ::\n+ * An utility to specify the Window Frame Range.\n+ */\n+object Frame {\n+  val currentRow: Frame = new Frame(CurrentRow)\n+  val unbounded: Frame = new Frame()\n+  def preceding(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValuePreceding(n))\n+  }\n+\n+  def following(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValueFollowing(n))\n+  }\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * A Window object with everything unset. But can build new Window object\n+ * based on it.\n+ */\n+@Experimental\n+object Window extends Window()\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = Window.partitionBy(\"name\").orderBy(\"id\")\n+ *            .rowsBetween(Frame.unbounded, Frame.currentRow)\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *       .rowsBetween(Frame.unbounded, Frame.currentRow))\n+ *   )\n+ *\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *      .rowsBetween(Frame.preceding(50), Frame.following(10)))\n+ *   )\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class Window {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  private def this(\n+      column: Column = null,\n+      partitionSpec: Seq[Expression] = Nil,\n+      orderSpec: Seq[SortOrder] = Nil,\n+      frame: WindowFrame = UnspecifiedFrame) {\n+    this()\n+    this.column = column\n+    this.partitionSpec = partitionSpec\n+    this.orderSpec = orderSpec\n+    this.frame     = frame\n+  }\n+\n+  private[sql] def newColumn(c: Column): Window = {\n+    new Window(c, partitionSpec, orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(Window.partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(Window.partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): Window = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(Window.partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): Window = {\n+    new Window(column, cols.map(_.expr), orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] sorted by the specified column within\n+   * the partition.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(Window.partitionBy(\"k1\").orderBy(\"k2\", \"k3\"))\n+   *   df.over(Window.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(colName: String, colNames: String*): Window = {\n+    orderBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] sorted by the specified column within\n+   * the partition. For example\n+   * {{{\n+   *   df.over(Window.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(cols: Column*): Window = {\n+    val sortOrder: Seq[SortOrder] = cols.map { col =>\n+      col.expr match {\n+        case expr: SortOrder =>\n+          expr\n+        case expr: Expression =>\n+          SortOrder(expr, Ascending)\n+      }\n+    }\n+    new Window(column, partitionSpec, sortOrder, frame)\n+  }\n+\n+  def rowsBetween(start: Frame, end: Frame): Window = {\n+    assert(start.boundary != UnboundedFollowing, \"Start can not be UnboundedFollowing\")",
    "line": 163
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "let's not make boundary nullable (i.e. always have UnboundedPreceding specified)\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-21T17:33:17Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+\n+sealed private[sql] class Frame(private[sql] var boundary: FrameBoundary = null)\n+\n+/**\n+ * :: Experimental ::\n+ * An utility to specify the Window Frame Range.\n+ */\n+object Frame {\n+  val currentRow: Frame = new Frame(CurrentRow)\n+  val unbounded: Frame = new Frame()\n+  def preceding(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValuePreceding(n))\n+  }\n+\n+  def following(n: Int): Frame = if (n == 0) {\n+    new Frame(CurrentRow)\n+  } else {\n+    new Frame(ValueFollowing(n))\n+  }\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * A Window object with everything unset. But can build new Window object\n+ * based on it.\n+ */\n+@Experimental\n+object Window extends Window()\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = Window.partitionBy(\"name\").orderBy(\"id\")\n+ *            .rowsBetween(Frame.unbounded, Frame.currentRow)\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *       .rowsBetween(Frame.unbounded, Frame.currentRow))\n+ *   )\n+ *\n+ *   df.select(\n+ *     avg(\"age\").over(Window.partitionBy(\"..\", \"..\").orderBy(\"..\", \"..\")\n+ *      .rowsBetween(Frame.preceding(50), Frame.following(10)))\n+ *   )\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class Window {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  private def this(\n+      column: Column = null,\n+      partitionSpec: Seq[Expression] = Nil,\n+      orderSpec: Seq[SortOrder] = Nil,\n+      frame: WindowFrame = UnspecifiedFrame) {\n+    this()\n+    this.column = column\n+    this.partitionSpec = partitionSpec\n+    this.orderSpec = orderSpec\n+    this.frame     = frame\n+  }\n+\n+  private[sql] def newColumn(c: Column): Window = {\n+    new Window(c, partitionSpec, orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(Window.partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(Window.partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): Window = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(Window.partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): Window = {\n+    new Window(column, cols.map(_.expr), orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] sorted by the specified column within\n+   * the partition.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(Window.partitionBy(\"k1\").orderBy(\"k2\", \"k3\"))\n+   *   df.over(Window.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(colName: String, colNames: String*): Window = {\n+    orderBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[Window]] sorted by the specified column within\n+   * the partition. For example\n+   * {{{\n+   *   df.over(Window.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(cols: Column*): Window = {\n+    val sortOrder: Seq[SortOrder] = cols.map { col =>\n+      col.expr match {\n+        case expr: SortOrder =>\n+          expr\n+        case expr: Expression =>\n+          SortOrder(expr, Ascending)\n+      }\n+    }\n+    new Window(column, partitionSpec, sortOrder, frame)\n+  }\n+\n+  def rowsBetween(start: Frame, end: Frame): Window = {\n+    assert(start.boundary != UnboundedFollowing, \"Start can not be UnboundedFollowing\")\n+    assert(end.boundary != UnboundedPreceding, \"End can not be UnboundedPreceding\")\n+\n+    val s = if (start.boundary == null) UnboundedPreceding else start.boundary",
    "line": 166
  }],
  "prId": 6104
}]