[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "> As an example, given a LIMIT has a FILTER child, you can't push down LIMIT if FILTER is not completely pushed down. When both are pushed down, the data source should execute FILTER before LIMIT.",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-04T21:42:14Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeMap, AttributeSet, Expression, ExpressionSet}\n+import org.apache.spark.sql.catalyst.planning.PhysicalOperation\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. We classify\n+ * operators into different layers, operators in the same layer are orderless, i.e. the query result\n+ * won't change if we switch the operators within a layer(e.g. we can switch the order of predicates\n+ * and required columns). The operators in layer N can only be pushed down if operators in layer N-1\n+ * that above the data source relation are all pushed down. As an example, you can't push down limit\n+ * if a filter below limit is not pushed down."
  }],
  "prId": 19424
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "This is an optimizer rule? The input is a `LogicalPlan` and the output is still a `LogicalPlan`?",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-04T22:13:02Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeMap, AttributeSet, Expression, ExpressionSet}\n+import org.apache.spark.sql.catalyst.planning.PhysicalOperation\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. We classify\n+ * operators into different layers, operators in the same layer are orderless, i.e. the query result\n+ * won't change if we switch the operators within a layer(e.g. we can switch the order of predicates\n+ * and required columns). The operators in layer N can only be pushed down if operators in layer N-1\n+ * that above the data source relation are all pushed down. As an example, you can't push down limit\n+ * if a filter below limit is not pushed down.\n+ *\n+ * Current operator push down layers:\n+ *   layer 1: predicates, required columns.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "yea it's an optimizer rule run before planner",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-05T02:56:58Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeMap, AttributeSet, Expression, ExpressionSet}\n+import org.apache.spark.sql.catalyst.planning.PhysicalOperation\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. We classify\n+ * operators into different layers, operators in the same layer are orderless, i.e. the query result\n+ * won't change if we switch the operators within a layer(e.g. we can switch the order of predicates\n+ * and required columns). The operators in layer N can only be pushed down if operators in layer N-1\n+ * that above the data source relation are all pushed down. As an example, you can't push down limit\n+ * if a filter below limit is not pushed down.\n+ *\n+ * Current operator push down layers:\n+ *   layer 1: predicates, required columns.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Can we add a test suite for the unit test cases of this rule?",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-05T22:25:44Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeMap, AttributeSet, Expression, ExpressionSet}\n+import org.apache.spark.sql.catalyst.planning.PhysicalOperation\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. We classify\n+ * operators into different layers, operators in the same layer are orderless, i.e. the query result\n+ * won't change if we switch the operators within a layer(e.g. we can switch the order of predicates\n+ * and required columns). The operators in layer N can only be pushed down if operators in layer N-1\n+ * that above the data source relation are all pushed down. As an example, you can't push down limit\n+ * if a filter below limit is not pushed down.\n+ *\n+ * Current operator push down layers:\n+ *   layer 1: predicates, required columns.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {"
  }],
  "prId": 19424
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "Why apply this rule one more time? Is there reason to suspect that predicates won't already be pushed and that one more run would be worth it?",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-09T22:27:25Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeMap, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.optimizer.{PushDownPredicate, RemoveRedundantProject}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. Operators are\n+ * being pushed down with a specific order. As an example, given a LIMIT has a FILTER child, you\n+ * can't push down LIMIT if FILTER is not completely pushed down. When both are pushed down, the\n+ * data source should execute FILTER before LIMIT. And required columns are calculated at the end,\n+ * because when more operators are pushed down, we may need less columns at Spark side.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] with PredicateHelper {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    // make sure filters are at very bottom.\n+    val prepared = PushDownPredicate(plan)"
  }],
  "prId": 19424
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "It isn't immediately clear why you would use `span` here instead of `partition`. I think it is because `span` will produce all deterministic predicates that would be run before the first non-deterministic predicate in an in-order traversal of teh condition, right? If so, then a comment would be really useful to make this clear. I'd also like to see a comment about why deterministic predicates \"after\" the first non-deterministic predicate shouldn't be pushed down. An example would really help, too.",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-09T22:41:06Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeMap, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.optimizer.{PushDownPredicate, RemoveRedundantProject}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. Operators are\n+ * being pushed down with a specific order. As an example, given a LIMIT has a FILTER child, you\n+ * can't push down LIMIT if FILTER is not completely pushed down. When both are pushed down, the\n+ * data source should execute FILTER before LIMIT. And required columns are calculated at the end,\n+ * because when more operators are pushed down, we may need less columns at Spark side.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] with PredicateHelper {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    // make sure filters are at very bottom.\n+    val prepared = PushDownPredicate(plan)\n+    val afterPushDown = prepared transformUp {\n+      case Filter(condition, r @ DataSourceV2Relation(_, reader)) =>\n+        val (candidates, containingNonDeterministic) =\n+          splitConjunctivePredicates(condition).span(_.deterministic)"
  }],
  "prId": 19424
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "Shouldn't this comment be on line 90? That's the purpose of looking up the required attributes in the set of attrs that was produced from the data source's schema right? That lookup happens by exprId, which was generated by the `DataSourceV2Relation` so we know we have a copy of the original attribute and case.",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-09T23:03:36Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeMap, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.optimizer.{PushDownPredicate, RemoveRedundantProject}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. Operators are\n+ * being pushed down with a specific order. As an example, given a LIMIT has a FILTER child, you\n+ * can't push down LIMIT if FILTER is not completely pushed down. When both are pushed down, the\n+ * data source should execute FILTER before LIMIT. And required columns are calculated at the end,\n+ * because when more operators are pushed down, we may need less columns at Spark side.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] with PredicateHelper {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    // make sure filters are at very bottom.\n+    val prepared = PushDownPredicate(plan)\n+    val afterPushDown = prepared transformUp {\n+      case Filter(condition, r @ DataSourceV2Relation(_, reader)) =>\n+        val (candidates, containingNonDeterministic) =\n+          splitConjunctivePredicates(condition).span(_.deterministic)\n+\n+        val stayUpFilters: Seq[Expression] = reader match {\n+          case r: SupportsPushDownCatalystFilters =>\n+            r.pushCatalystFilters(candidates.toArray)\n+\n+          case r: SupportsPushDownFilters =>\n+            // A map from original Catalyst expressions to corresponding translated data source\n+            // filters. If a predicate is not in this map, it means it cannot be pushed down.\n+            val translatedMap: Map[Expression, sources.Filter] = candidates.flatMap { p =>\n+              DataSourceStrategy.translateFilter(p).map(f => p -> f)\n+            }.toMap\n+\n+            // Catalyst predicate expressions that cannot be converted to data source filters.\n+            val nonConvertiblePredicates = candidates.filterNot(translatedMap.contains)\n+\n+            // Data source filters that cannot be pushed down. An unhandled filter means\n+            // the data source cannot guarantee the rows returned can pass the filter.\n+            // As a result we must return it so Spark can plan an extra filter operator.\n+            val unhandledFilters = r.pushFilters(translatedMap.values.toArray).toSet\n+            val unhandledPredicates = translatedMap.filter { case (_, f) =>\n+              unhandledFilters.contains(f)\n+            }.keys\n+\n+            nonConvertiblePredicates ++ unhandledPredicates\n+\n+          case _ => candidates\n+        }\n+\n+        val filterCondition = (stayUpFilters ++ containingNonDeterministic).reduceLeftOption(And)\n+        filterCondition.map(Filter(_, r)).getOrElse(r)\n+\n+      // TODO: add more push down rules.\n+    }\n+\n+    // TODO: nested fields pruning\n+    def pushDownRequiredColumns(plan: LogicalPlan, requiredByParent: Seq[Attribute]): Unit = {\n+      plan match {\n+        case Project(projectList, child) =>\n+          val required = projectList.filter(requiredByParent.contains).flatMap(_.references)\n+          pushDownRequiredColumns(child, required)\n+\n+        case Filter(condition, child) =>\n+          val required = requiredByParent ++ condition.references\n+          pushDownRequiredColumns(child, required)\n+\n+        case DataSourceV2Relation(fullOutput, reader) => reader match {\n+          case r: SupportsPushDownRequiredColumns =>\n+            val attrMap = AttributeMap(fullOutput.zip(fullOutput))\n+            val requiredColumns = requiredByParent.map(attrMap)\n+            // Match original case of attributes."
  }],
  "prId": 19424
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "How do we know that there aren't more cases that need to be supported?",
    "commit": "200cd204aa25c1571216047ba2da523fb14a612b",
    "createdAt": "2017-10-09T23:04:20Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeMap, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.optimizer.{PushDownPredicate, RemoveRedundantProject}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.execution.datasources.DataSourceStrategy\n+import org.apache.spark.sql.sources\n+import org.apache.spark.sql.sources.v2.reader._\n+\n+/**\n+ * Pushes down various operators to the underlying data source for better performance. Operators are\n+ * being pushed down with a specific order. As an example, given a LIMIT has a FILTER child, you\n+ * can't push down LIMIT if FILTER is not completely pushed down. When both are pushed down, the\n+ * data source should execute FILTER before LIMIT. And required columns are calculated at the end,\n+ * because when more operators are pushed down, we may need less columns at Spark side.\n+ */\n+object PushDownOperatorsToDataSource extends Rule[LogicalPlan] with PredicateHelper {\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    // make sure filters are at very bottom.\n+    val prepared = PushDownPredicate(plan)\n+    val afterPushDown = prepared transformUp {\n+      case Filter(condition, r @ DataSourceV2Relation(_, reader)) =>\n+        val (candidates, containingNonDeterministic) =\n+          splitConjunctivePredicates(condition).span(_.deterministic)\n+\n+        val stayUpFilters: Seq[Expression] = reader match {\n+          case r: SupportsPushDownCatalystFilters =>\n+            r.pushCatalystFilters(candidates.toArray)\n+\n+          case r: SupportsPushDownFilters =>\n+            // A map from original Catalyst expressions to corresponding translated data source\n+            // filters. If a predicate is not in this map, it means it cannot be pushed down.\n+            val translatedMap: Map[Expression, sources.Filter] = candidates.flatMap { p =>\n+              DataSourceStrategy.translateFilter(p).map(f => p -> f)\n+            }.toMap\n+\n+            // Catalyst predicate expressions that cannot be converted to data source filters.\n+            val nonConvertiblePredicates = candidates.filterNot(translatedMap.contains)\n+\n+            // Data source filters that cannot be pushed down. An unhandled filter means\n+            // the data source cannot guarantee the rows returned can pass the filter.\n+            // As a result we must return it so Spark can plan an extra filter operator.\n+            val unhandledFilters = r.pushFilters(translatedMap.values.toArray).toSet\n+            val unhandledPredicates = translatedMap.filter { case (_, f) =>\n+              unhandledFilters.contains(f)\n+            }.keys\n+\n+            nonConvertiblePredicates ++ unhandledPredicates\n+\n+          case _ => candidates\n+        }\n+\n+        val filterCondition = (stayUpFilters ++ containingNonDeterministic).reduceLeftOption(And)\n+        filterCondition.map(Filter(_, r)).getOrElse(r)\n+\n+      // TODO: add more push down rules.\n+    }\n+\n+    // TODO: nested fields pruning\n+    def pushDownRequiredColumns(plan: LogicalPlan, requiredByParent: Seq[Attribute]): Unit = {\n+      plan match {\n+        case Project(projectList, child) =>\n+          val required = projectList.filter(requiredByParent.contains).flatMap(_.references)\n+          pushDownRequiredColumns(child, required)\n+\n+        case Filter(condition, child) =>\n+          val required = requiredByParent ++ condition.references\n+          pushDownRequiredColumns(child, required)\n+\n+        case DataSourceV2Relation(fullOutput, reader) => reader match {\n+          case r: SupportsPushDownRequiredColumns =>\n+            val attrMap = AttributeMap(fullOutput.zip(fullOutput))\n+            val requiredColumns = requiredByParent.map(attrMap)\n+            // Match original case of attributes.\n+            r.pruneColumns(requiredColumns.toStructType)\n+          case _ =>\n+        }\n+\n+        case _ => plan.children.foreach(child => pushDownRequiredColumns(child, child.output))"
  }],
  "prId": 19424
}]