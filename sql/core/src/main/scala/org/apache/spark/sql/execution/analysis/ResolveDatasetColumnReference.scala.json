[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "How can a column reference point to more than one actual columns? A column reference is determined by dataset id and column position. It can't have more than one column positions or dataset ids.",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-24T05:45:15Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)\n+  }\n+\n+  private def stripColumnReferenceMetadata(a: AttributeReference): AttributeReference = {\n+    val metadataWithoutId = new MetadataBuilder()\n+      .withMetadata(a.metadata)\n+      .remove(Dataset.ID_PREFIX)\n+      .remove(Dataset.COL_POS_PREFIX)\n+      .build()\n+    a.withMetadata(metadataWithoutId)\n+  }\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.getConf(SQLConf.RESOLVE_DATASET_COLUMN_REFERENCE)) return plan\n+\n+    // We always remove the special metadata from `AttributeReference` at the end of this rule, so\n+    // Dataset column reference only exists in the root node via Dataset transformations like\n+    // `Dataset#select`.\n+    val colRefs = plan.expressions.flatMap(_.collect {\n+      case a: AttributeReference if isColumnReference(a) => toColumnReference(a)\n+    })\n+\n+    if (colRefs.isEmpty) {\n+      plan\n+    } else {\n+      // Keeps the mapping between the column reference and the actual column it points to. This\n+      // will be used to replace the column references with actual columns in the root node later.\n+      val colRefToActualCol = new mutable.HashMap[ColumnReference, AttributeReference]()\n+      // Keeps the column references that points to more than one actual columns. We will not\n+      // replace these ambiguous column references and leave them as they were.\n+      val ambiguousColRefs = new mutable.HashSet[ColumnReference]()"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "e.g. `df1.join(df1).select(df1(\"id\"))`",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-24T06:22:10Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)\n+  }\n+\n+  private def stripColumnReferenceMetadata(a: AttributeReference): AttributeReference = {\n+    val metadataWithoutId = new MetadataBuilder()\n+      .withMetadata(a.metadata)\n+      .remove(Dataset.ID_PREFIX)\n+      .remove(Dataset.COL_POS_PREFIX)\n+      .build()\n+    a.withMetadata(metadataWithoutId)\n+  }\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.getConf(SQLConf.RESOLVE_DATASET_COLUMN_REFERENCE)) return plan\n+\n+    // We always remove the special metadata from `AttributeReference` at the end of this rule, so\n+    // Dataset column reference only exists in the root node via Dataset transformations like\n+    // `Dataset#select`.\n+    val colRefs = plan.expressions.flatMap(_.collect {\n+      case a: AttributeReference if isColumnReference(a) => toColumnReference(a)\n+    })\n+\n+    if (colRefs.isEmpty) {\n+      plan\n+    } else {\n+      // Keeps the mapping between the column reference and the actual column it points to. This\n+      // will be used to replace the column references with actual columns in the root node later.\n+      val colRefToActualCol = new mutable.HashMap[ColumnReference, AttributeReference]()\n+      // Keeps the column references that points to more than one actual columns. We will not\n+      // replace these ambiguous column references and leave them as they were.\n+      val ambiguousColRefs = new mutable.HashSet[ColumnReference]()"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "It might point to multiple columns, but those columns are the same column. For example, `df1(\"id\")` points to columns in both left and right plans, but the pointed columns are the same. Can a column reference point to different columns? If not, this can work without `ambiguousColRefs`, and the code can be simplified?",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-24T13:01:22Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)\n+  }\n+\n+  private def stripColumnReferenceMetadata(a: AttributeReference): AttributeReference = {\n+    val metadataWithoutId = new MetadataBuilder()\n+      .withMetadata(a.metadata)\n+      .remove(Dataset.ID_PREFIX)\n+      .remove(Dataset.COL_POS_PREFIX)\n+      .build()\n+    a.withMetadata(metadataWithoutId)\n+  }\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.getConf(SQLConf.RESOLVE_DATASET_COLUMN_REFERENCE)) return plan\n+\n+    // We always remove the special metadata from `AttributeReference` at the end of this rule, so\n+    // Dataset column reference only exists in the root node via Dataset transformations like\n+    // `Dataset#select`.\n+    val colRefs = plan.expressions.flatMap(_.collect {\n+      case a: AttributeReference if isColumnReference(a) => toColumnReference(a)\n+    })\n+\n+    if (colRefs.isEmpty) {\n+      plan\n+    } else {\n+      // Keeps the mapping between the column reference and the actual column it points to. This\n+      // will be used to replace the column references with actual columns in the root node later.\n+      val colRefToActualCol = new mutable.HashMap[ColumnReference, AttributeReference]()\n+      // Keeps the column references that points to more than one actual columns. We will not\n+      // replace these ambiguous column references and leave them as they were.\n+      val ambiguousColRefs = new mutable.HashSet[ColumnReference]()"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "think about outer joins. Columns from different join sides are always different columns.",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-30T05:21:25Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)\n+  }\n+\n+  private def stripColumnReferenceMetadata(a: AttributeReference): AttributeReference = {\n+    val metadataWithoutId = new MetadataBuilder()\n+      .withMetadata(a.metadata)\n+      .remove(Dataset.ID_PREFIX)\n+      .remove(Dataset.COL_POS_PREFIX)\n+      .build()\n+    a.withMetadata(metadataWithoutId)\n+  }\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.getConf(SQLConf.RESOLVE_DATASET_COLUMN_REFERENCE)) return plan\n+\n+    // We always remove the special metadata from `AttributeReference` at the end of this rule, so\n+    // Dataset column reference only exists in the root node via Dataset transformations like\n+    // `Dataset#select`.\n+    val colRefs = plan.expressions.flatMap(_.collect {\n+      case a: AttributeReference if isColumnReference(a) => toColumnReference(a)\n+    })\n+\n+    if (colRefs.isEmpty) {\n+      plan\n+    } else {\n+      // Keeps the mapping between the column reference and the actual column it points to. This\n+      // will be used to replace the column references with actual columns in the root node later.\n+      val colRefToActualCol = new mutable.HashMap[ColumnReference, AttributeReference]()\n+      // Keeps the column references that points to more than one actual columns. We will not\n+      // replace these ambiguous column references and leave them as they were.\n+      val ambiguousColRefs = new mutable.HashSet[ColumnReference]()"
  }],
  "prId": 24442
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Can we check this between line 93 and 94? For the wrong `ref`, it seems that we don't need to keep it in `ambiguousColRefs`. The bug can hide due to `filterNot(ambiguousColRefs.contains)` without showing this warning.",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-29T22:57:13Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)\n+  }\n+\n+  private def stripColumnReferenceMetadata(a: AttributeReference): AttributeReference = {\n+    val metadataWithoutId = new MetadataBuilder()\n+      .withMetadata(a.metadata)\n+      .remove(Dataset.ID_PREFIX)\n+      .remove(Dataset.COL_POS_PREFIX)\n+      .build()\n+    a.withMetadata(metadataWithoutId)\n+  }\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.getConf(SQLConf.RESOLVE_DATASET_COLUMN_REFERENCE)) return plan\n+\n+    // We always remove the special metadata from `AttributeReference` at the end of this rule, so\n+    // Dataset column reference only exists in the root node via Dataset transformations like\n+    // `Dataset#select`.\n+    val colRefs = plan.expressions.flatMap(_.collect {\n+      case a: AttributeReference if isColumnReference(a) => toColumnReference(a)\n+    })\n+\n+    if (colRefs.isEmpty) {\n+      plan\n+    } else {\n+      // Keeps the mapping between the column reference and the actual column it points to. This\n+      // will be used to replace the column references with actual columns in the root node later.\n+      val colRefToActualCol = new mutable.HashMap[ColumnReference, AttributeReference]()\n+      // Keeps the column references that points to more than one actual columns. We will not\n+      // replace these ambiguous column references and leave them as they were.\n+      val ambiguousColRefs = new mutable.HashSet[ColumnReference]()\n+\n+      val dsIdSet = colRefs.map(_.datasetId).toSet\n+      plan.foreach {\n+        // We only add the special `SubqueryAlias` to attach the dataset id for self-join. After\n+        // self-join resolving, the child of `SubqueryAlias` should have generated new\n+        // `AttributeReference`, and we need to resolve column reference with them.\n+        case SubqueryAlias(DatasetIdAlias(id), child) if dsIdSet.contains(id) =>\n+          colRefs.filterNot(ambiguousColRefs.contains).foreach { ref =>\n+            if (id == ref.datasetId) {\n+              if (colRefToActualCol.contains(ref)) {\n+                ambiguousColRefs += ref\n+                colRefToActualCol.remove(ref)\n+              } else {\n+                if (ref.colPos < 0 || ref.colPos >= child.output.length) {"
  }],
  "prId": 24442
}]