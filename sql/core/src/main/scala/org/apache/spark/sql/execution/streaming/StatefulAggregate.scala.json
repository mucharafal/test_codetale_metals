[{
  "comments": [{
    "author": {
      "login": "koeninger"
    },
    "body": "I'm not clear on why the semantics of Update mean that watermarks shouldn't be used to remove state.\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T03:20:57Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }, {
    "author": {
      "login": "CodingCat"
    },
    "body": "@koeninger, Update shall allow the late data to correct the previous results even they are late than the threshold, the similar implementation is in http://cdn.oreillystatic.com/en/assets/1/event/160/Triggers%20in%20Apache%20Beam%20_incubating_%20Presentation.pdf (search `withLateFirings`)...correct me if I was wrong\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T05:24:11Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "To put it the other way, do the docs in this PR tell you as a user that for any output method other than Append, you are potentially keeping unlimited aggregate state in memory, regardless of whether you set a watermark?\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T05:40:22Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "The only output modes that are supported publicly are `Complete` and `Append` (update is only available internally for tests).  When we add support for `Update` (I'd like to do this soon), it should also evict tuples which can no longer be updated due to their group falling beneath the watermark.  I thought that it was fairly clear that `Complete` would need to retain the complete set of aggregate state, but I'm happy to make this more explicit if others are confused by this.\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T17:39:32Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }, {
    "author": {
      "login": "koeninger"
    },
    "body": "Yes, I think it's a good idea to explicitly say for each output mode whether watermarks affect emit and evict.  Just so I'm clear, the intention is\n\nAppend: affects emit, affects evict\nUpdate: doesn't affect emit, affects evict\nComplete: doesn't affect emit, no eviction\n\nIs that right?\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T17:51:24Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "That is correct.\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-02T17:54:12Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }, {
    "author": {
      "login": "amitsela"
    },
    "body": "Generally, updates should be able to take into account late arrivals (in respect to `EndOfWindow`) and allow to act upon a user defined strategy, such as: `update for each following element`.\n",
    "commit": "87d8618234a86d666a711a97080e2b014214b84a",
    "createdAt": "2016-11-13T14:03:00Z",
    "diffHunk": "@@ -104,85 +110,105 @@ case class StateStoreSaveExec(\n \n   override protected def doExecute(): RDD[InternalRow] = {\n     metrics // force lazy init at driver\n-    assert(returnAllStates.nonEmpty,\n-      \"Incorrect planning in IncrementalExecution, returnAllStates have not been set\")\n-    val saveAndReturnFunc = if (returnAllStates.get) saveAndReturnAll _ else saveAndReturnUpdated _\n+    assert(outputMode.nonEmpty,\n+      \"Incorrect planning in IncrementalExecution, outputMode has not been set\")\n+\n     child.execute().mapPartitionsWithStateStore(\n       getStateId.checkpointLocation,\n       operatorId = getStateId.operatorId,\n       storeVersion = getStateId.batchId,\n       keyExpressions.toStructType,\n       child.output.toStructType,\n       sqlContext.sessionState,\n-      Some(sqlContext.streams.stateStoreCoordinator)\n-    )(saveAndReturnFunc)\n+      Some(sqlContext.streams.stateStoreCoordinator)) { (store, iter) =>\n+        val getKey = GenerateUnsafeProjection.generate(keyExpressions, child.output)\n+        val numOutputRows = longMetric(\"numOutputRows\")\n+        val numTotalStateRows = longMetric(\"numTotalStateRows\")\n+        val numUpdatedStateRows = longMetric(\"numUpdatedStateRows\")\n+\n+        outputMode match {\n+          // Update and output all rows in the StateStore.\n+          case Some(Complete) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+            store.commit()\n+            numTotalStateRows += store.numKeys()\n+            store.iterator().map { case (k, v) =>\n+              numOutputRows += 1\n+              v.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output only rows being evicted from the StateStore\n+          case Some(Append) =>\n+            while (iter.hasNext) {\n+              val row = iter.next().asInstanceOf[UnsafeRow]\n+              val key = getKey(row)\n+              store.put(key.copy(), row.copy())\n+              numUpdatedStateRows += 1\n+            }\n+\n+            val watermarkAttribute =\n+              keyExpressions.find(_.metadata.contains(EventTimeWatermark.delayKey)).get\n+            // If we are evicting based on a window, use the end of the window.  Otherwise just\n+            // use the attribute itself.\n+            val evictionExpression =\n+              if (watermarkAttribute.dataType.isInstanceOf[StructType]) {\n+                LessThanOrEqual(\n+                  GetStructField(watermarkAttribute, 1),\n+                  Literal(eventTimeWatermark.get * 1000))\n+              } else {\n+                LessThanOrEqual(\n+                  watermarkAttribute,\n+                  Literal(eventTimeWatermark.get * 1000))\n+              }\n+\n+            logInfo(s\"Filtering state store on: $evictionExpression\")\n+            val predicate = newPredicate(evictionExpression, keyExpressions)\n+            store.remove(predicate)\n+\n+            store.commit()\n+\n+            numTotalStateRows += store.numKeys()\n+            store.updates().filter(_.isInstanceOf[ValueRemoved]).map { removed =>\n+              numOutputRows += 1\n+              removed.value.asInstanceOf[InternalRow]\n+            }\n+\n+          // Update and output modified rows from the StateStore.\n+          case Some(Update) =>",
    "line": 109
  }],
  "prId": 15702
}]