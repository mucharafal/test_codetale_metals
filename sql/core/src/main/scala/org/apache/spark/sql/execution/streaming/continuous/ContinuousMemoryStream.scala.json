[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Let's make all the memory streams consistently named (like Kafka has KafkaMicroBatchReader and KafkaContinuousReader)?",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T20:50:25Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Also, all the sources are in streaming/sources/ (or should be), not in streaming/continuous.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:08:31Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "I think the consistent naming makes sense for the sources where they're automatically injected in planning, since they both have the same .format() option and thus the same name in some sense.\r\n\r\nFor memory streams it's different; the user explicitly instantiates the reader. So I think that making the names look similar is confusing, and I don't think that \"MemoryStreamMicroBatchReader\" is a good name for something explicitly instantiated.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-06T17:05:30Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Fair point on explicit instantiation. ",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:24:09Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "However, I stand by the other point of all the sources being colocated in streaming/sources. You missed changing that.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:47:43Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "I would keep the main class (the MemoryStreamContinuousReader) at the top and add this comment as part of the Scala docs of that class. And also add docs on each of the classes to explain their purpose. This is taking me a whole lot of scrolling back and forth for me to understand, even if I roughly know what the organization should be. ",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:12:33Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: to poll from what? \r\n(and also clarify what is at the executor and what is at the driver)",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:15:05Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "To poll from \"partition-level ContinuousMemoryStreamDataReader instances\". I can say executor-side instead.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-06T16:53:56Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: I generally put such small-use generically-named classes inside a relevant object to avoid cluttering of the general class namespace. Example: this can be inside a object ContinuousMemoryStreamRecordBuffer as that is the only one using it. Then when someone searches for a different GetRecord-ish named class, then it would be less confusing.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:18:31Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Maybe make this 10ms. This directly affects how long tests will take.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:20:15Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A](\n+    stream: ContinuousMemoryStream[A],\n+    partitionBuffers: Seq[ListBuffer[A]]) extends ThreadSafeRpcEndpoint {\n+  override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+  override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+    case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) => stream.synchronized {\n+      val buf = partitionBuffers(part)\n+\n+      val record =\n+        if (buf.size <= index) {\n+          None\n+        } else {\n+          Some(buf(index))\n+        }\n+      context.reply(record.map(Row(_)))\n+    }\n+  }\n+}\n+\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+    extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer(this, records)\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  var endpointRef: RpcEndpointRef = _\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          new ContinuousMemoryStreamDataReaderFactory(id, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  // MemoryStreamBase implementation\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+}\n+\n+class ContinuousMemoryStreamDataReaderFactory(\n+    memoryStreamId: Int,\n+    partition: Int,\n+    startOffset: Int) extends DataReaderFactory[Row] {\n+  override def createDataReader: ContinuousMemoryStreamDataReader =\n+    new ContinuousMemoryStreamDataReader(memoryStreamId, partition, startOffset)\n+}\n+\n+class ContinuousMemoryStreamDataReader(\n+    memoryStreamId: Int,\n+    partition: Int,\n+    startOffset: Int) extends ContinuousDataReader[Row] {\n+  private val endpoint = RpcUtils.makeDriverRef(\n+    ContinuousMemoryStream.recordBufferName(memoryStreamId),\n+    SparkEnv.get.conf,\n+    SparkEnv.get.rpcEnv)\n+\n+  private var currentOffset = startOffset\n+  private var current: Option[Row] = None\n+\n+  override def next(): Boolean = {\n+    current = None\n+    while (current.isEmpty) {\n+      Thread.sleep(100)"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "super nit: this can be in a single line.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:24:16Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A](\n+    stream: ContinuousMemoryStream[A],\n+    partitionBuffers: Seq[ListBuffer[A]]) extends ThreadSafeRpcEndpoint {\n+  override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+  override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+    case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) => stream.synchronized {\n+      val buf = partitionBuffers(part)\n+\n+      val record =\n+        if (buf.size <= index) {"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "if the purpose of the memoryStreamId is only to generate the rpc endpoint name, then might as well pass just that.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T21:29:17Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A](\n+    stream: ContinuousMemoryStream[A],\n+    partitionBuffers: Seq[ListBuffer[A]]) extends ThreadSafeRpcEndpoint {\n+  override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+  override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+    case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) => stream.synchronized {\n+      val buf = partitionBuffers(part)\n+\n+      val record =\n+        if (buf.size <= index) {\n+          None\n+        } else {\n+          Some(buf(index))\n+        }\n+      context.reply(record.map(Row(_)))\n+    }\n+  }\n+}\n+\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+    extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer(this, records)\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  var endpointRef: RpcEndpointRef = _\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          new ContinuousMemoryStreamDataReaderFactory(id, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  // MemoryStreamBase implementation\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+}\n+\n+class ContinuousMemoryStreamDataReaderFactory(\n+    memoryStreamId: Int,\n+    partition: Int,\n+    startOffset: Int) extends DataReaderFactory[Row] {\n+  override def createDataReader: ContinuousMemoryStreamDataReader =\n+    new ContinuousMemoryStreamDataReader(memoryStreamId, partition, startOffset)\n+}\n+\n+class ContinuousMemoryStreamDataReader(\n+    memoryStreamId: Int,\n+    partition: Int,\n+    startOffset: Int) extends ContinuousDataReader[Row] {\n+  private val endpoint = RpcUtils.makeDriverRef(\n+    ContinuousMemoryStream.recordBufferName(memoryStreamId),"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This is not really a buffer as it only refers to buffers that are externally managed. Its only serves as an endpoint to fetch stuff from the buffer. I would prefer one way or the other - either all the buffer management and endpoint management should be inside the class (adding and fetching, synchronized by this class) OR this is an inner class of ContinuousMemoryStream whose only purpose is to be endpoint relaying fetch requests.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T22:22:49Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A]("
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "private.\r\nand volatile to avoid issues if stop is called from a different thread.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T22:24:32Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A](\n+    stream: ContinuousMemoryStream[A],\n+    partitionBuffers: Seq[ListBuffer[A]]) extends ThreadSafeRpcEndpoint {\n+  override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+  override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+    case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) => stream.synchronized {\n+      val buf = partitionBuffers(part)\n+\n+      val record =\n+        if (buf.size <= index) {\n+          None\n+        } else {\n+          Some(buf(index))\n+        }\n+      context.reply(record.map(Row(_)))\n+    }\n+  }\n+}\n+\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+    extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer(this, records)\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  var endpointRef: RpcEndpointRef = _"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "also its good programming practice to consolidate all the fields to a single location. ",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T22:25:07Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A](\n+    stream: ContinuousMemoryStream[A],\n+    partitionBuffers: Seq[ListBuffer[A]]) extends ThreadSafeRpcEndpoint {\n+  override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+  override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+    case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) => stream.synchronized {\n+      val buf = partitionBuffers(part)\n+\n+      val record =\n+        if (buf.size <= index) {\n+          None\n+        } else {\n+          Some(buf(index))\n+        }\n+      context.reply(record.map(Row(_)))\n+    }\n+  }\n+}\n+\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+    extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer(this, records)\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  var endpointRef: RpcEndpointRef = _"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: same comment as above, consolidate vals, unless there is a really good reason.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-05T22:30:27Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for partition-level\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+\n+private case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+\n+private class ContinuousMemoryStreamRecordBuffer[A](\n+    stream: ContinuousMemoryStream[A],\n+    partitionBuffers: Seq[ListBuffer[A]]) extends ThreadSafeRpcEndpoint {\n+  override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+  override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+    case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) => stream.synchronized {\n+      val buf = partitionBuffers(part)\n+\n+      val record =\n+        if (buf.size <= index) {\n+          None\n+        } else {\n+          Some(buf(index))\n+        }\n+      context.reply(record.map(Row(_)))\n+    }\n+  }\n+}\n+\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+    extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer(this, records)\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  var endpointRef: RpcEndpointRef = _\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          new ContinuousMemoryStreamDataReaderFactory(id, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  // MemoryStreamBase implementation\n+\n+  protected val logicalPlan ="
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "If set `setStartOffset` is synchronized then `getStartOffset` should also be synchronized.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:26:14Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This probably should be `GuardedBy(\"this\")` as well.\r\n",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:28:19Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "super nit: `SomeObject.apply(anotherObject)` is usually called with with `(...)` not `{...}`. Only when you are passing a function literal do we use `{...}`.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:30:15Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: I commented on this earlier, this class is not a buffer, its an endpoint. \r\n\r\nAlso, I approve moving this inside the `ContinuousMemoryStream` class. Though in that case, the name can be shortened by removing `ContinuousMemoryStream` prefix. ",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:35:41Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Actually, it is actually confusing to see `recordBuffer` at places like `recordBuffer.rpcEnv.setupEnpoint...`\r\nI would prefer it be named as an endpoint rather than a buffer.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:46:21Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: Can this be fit into a single line?\r\n`val record = if (buf.size <= index) None else Some(buf(index))` should fit.\r\nalso, extra line above.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:36:44Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {\n+    override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+      case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) =>\n+        ContinuousMemoryStream.this.synchronized {\n+          val buf = records(part)\n+\n+          val record ="
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: this term `ContinuousMemoryStreamRecordReceiver` does not seem to match with any class. neither does it have \"buffername\" in it.\r\n\r\nadd docs what it means.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:39:35Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {\n+    override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+      case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) =>\n+        ContinuousMemoryStream.this.synchronized {\n+          val buf = records(part)\n+\n+          val record =\n+            if (buf.size <= index) {\n+              None\n+            } else {\n+              Some(buf(index))\n+            }\n+          context.reply(record.map(Row(_)))\n+        }\n+    }\n+  }\n+}\n+\n+object ContinuousMemoryStream {\n+  def recordBufferName(memoryStreamId: Int): String =\n+    s\"ContinuousMemoryStreamRecordReceiver-$memoryStreamId\""
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "its only used inside `createDataReaderFactories()`, so why even have this a separate method.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:43:24Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {\n+    override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+      case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) =>\n+        ContinuousMemoryStream.this.synchronized {\n+          val buf = records(part)\n+\n+          val record =\n+            if (buf.size <= index) {\n+              None\n+            } else {\n+              Some(buf(index))\n+            }\n+          context.reply(record.map(Row(_)))\n+        }\n+    }\n+  }\n+}\n+\n+object ContinuousMemoryStream {\n+  def recordBufferName(memoryStreamId: Int): String =\n+    s\"ContinuousMemoryStreamRecordReceiver-$memoryStreamId\""
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "does the `endpoint` require closing  or cleaning up?",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:44:55Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {\n+    override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+      case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) =>\n+        ContinuousMemoryStream.this.synchronized {\n+          val buf = records(part)\n+\n+          val record =\n+            if (buf.size <= index) {\n+              None\n+            } else {\n+              Some(buf(index))\n+            }\n+          context.reply(record.map(Row(_)))\n+        }\n+    }\n+  }\n+}\n+\n+object ContinuousMemoryStream {\n+  def recordBufferName(memoryStreamId: Int): String =\n+    s\"ContinuousMemoryStreamRecordReceiver-$memoryStreamId\"\n+  case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+}\n+\n+/**\n+ * Data reader factory for continuous memory stream.\n+ */\n+class ContinuousMemoryStreamDataReaderFactory(\n+    driverEndpointName: String,\n+    partition: Int,\n+    startOffset: Int) extends DataReaderFactory[Row] {\n+  override def createDataReader: ContinuousMemoryStreamDataReader =\n+    new ContinuousMemoryStreamDataReader(driverEndpointName, partition, startOffset)\n+}\n+\n+/**\n+ * Data reader for continuous memory stream.\n+ *\n+ * Polls the driver endpoint for new records.\n+ */\n+class ContinuousMemoryStreamDataReader(\n+    driverEndpointName: String,\n+    partition: Int,\n+    startOffset: Int) extends ContinuousDataReader[Row] {\n+  private val endpoint = RpcUtils.makeDriverRef(\n+    driverEndpointName,\n+    SparkEnv.get.conf,\n+    SparkEnv.get.rpcEnv)\n+\n+  private var currentOffset = startOffset\n+  private var current: Option[Row] = None\n+\n+  override def next(): Boolean = {\n+    current = None\n+    while (current.isEmpty) {\n+      Thread.sleep(10)\n+      current = endpoint.askSync[Option[Row]](\n+          GetRecord(ContinuousMemoryStreamPartitionOffset(partition, currentOffset)))\n+    }\n+    currentOffset += 1\n+    true\n+  }\n+\n+  override def get(): Row = current.get\n+\n+  override def close(): Unit = {}"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "No - IIUC it's a stateless reference to the remote endpoint.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T17:35:07Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {\n+      endpointRef =\n+        recordBuffer.rpcEnv.setupEndpoint(ContinuousMemoryStream.recordBufferName(id), recordBuffer)\n+\n+      startOffset.partitionNums.map {\n+        case (part, index) =>\n+          val name = ContinuousMemoryStream.recordBufferName(id)\n+          new ContinuousMemoryStreamDataReaderFactory(name, part, index): DataReaderFactory[Row]\n+      }.toList.asJava\n+    }\n+  }\n+\n+  override def stop(): Unit = {\n+    if (endpointRef != null) recordBuffer.rpcEnv.stop(endpointRef)\n+  }\n+\n+  override def commit(end: Offset): Unit = {}\n+\n+  // ContinuousReadSupport implementation\n+  // This is necessary because of how StreamTest finds the source for AddDataMemory steps.\n+  def createContinuousReader(\n+      schema: Optional[StructType],\n+      checkpointLocation: String,\n+      options: DataSourceOptions): ContinuousReader = {\n+    this\n+  }\n+\n+  override def reset(): Unit = synchronized {\n+    records.foreach(_.clear())\n+    startOffset = ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+  }\n+\n+  /**\n+   * Endpoint for executors to poll for records.\n+   */\n+  private class ContinuousMemoryStreamRecordBuffer extends ThreadSafeRpcEndpoint {\n+    override val rpcEnv: RpcEnv = SparkEnv.get.rpcEnv\n+\n+    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = {\n+      case GetRecord(ContinuousMemoryStreamPartitionOffset(part, index)) =>\n+        ContinuousMemoryStream.this.synchronized {\n+          val buf = records(part)\n+\n+          val record =\n+            if (buf.size <= index) {\n+              None\n+            } else {\n+              Some(buf(index))\n+            }\n+          context.reply(record.map(Row(_)))\n+        }\n+    }\n+  }\n+}\n+\n+object ContinuousMemoryStream {\n+  def recordBufferName(memoryStreamId: Int): String =\n+    s\"ContinuousMemoryStreamRecordReceiver-$memoryStreamId\"\n+  case class GetRecord(offset: ContinuousMemoryStreamPartitionOffset)\n+}\n+\n+/**\n+ * Data reader factory for continuous memory stream.\n+ */\n+class ContinuousMemoryStreamDataReaderFactory(\n+    driverEndpointName: String,\n+    partition: Int,\n+    startOffset: Int) extends DataReaderFactory[Row] {\n+  override def createDataReader: ContinuousMemoryStreamDataReader =\n+    new ContinuousMemoryStreamDataReader(driverEndpointName, partition, startOffset)\n+}\n+\n+/**\n+ * Data reader for continuous memory stream.\n+ *\n+ * Polls the driver endpoint for new records.\n+ */\n+class ContinuousMemoryStreamDataReader(\n+    driverEndpointName: String,\n+    partition: Int,\n+    startOffset: Int) extends ContinuousDataReader[Row] {\n+  private val endpoint = RpcUtils.makeDriverRef(\n+    driverEndpointName,\n+    SparkEnv.get.conf,\n+    SparkEnv.get.rpcEnv)\n+\n+  private var currentOffset = startOffset\n+  private var current: Option[Row] = None\n+\n+  override def next(): Boolean = {\n+    current = None\n+    while (current.isEmpty) {\n+      Thread.sleep(10)\n+      current = endpoint.askSync[Option[Row]](\n+          GetRecord(ContinuousMemoryStreamPartitionOffset(partition, currentOffset)))\n+    }\n+    currentOffset += 1\n+    true\n+  }\n+\n+  override def get(): Row = current.get\n+\n+  override def close(): Unit = {}"
  }],
  "prId": 20828
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Why is this method synchronized? Its not accessing the buffer.",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T06:52:32Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "It has to be now that startOffset is GuardedBy(\"this\"). (I think it's correct that startOffset should have been guarded.)",
    "commit": "55e37a95069a66df668afb57ed009b7c64ff3543",
    "createdAt": "2018-04-12T17:36:05Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.{util => ju}\n+import java.util.Optional\n+import java.util.concurrent.ArrayBlockingQueue\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+import scala.reflect.ClassTag\n+\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+\n+import org.apache.spark.SparkEnv\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rpc.{RpcCallContext, RpcEndpointRef, RpcEnv, ThreadSafeRpcEndpoint}\n+import org.apache.spark.sql.{Dataset, Encoder, Row, SQLContext}\n+import org.apache.spark.sql.catalyst.encoders.encoderFor\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming._\n+import org.apache.spark.sql.execution.streaming.continuous.ContinuousMemoryStream.GetRecord\n+import org.apache.spark.sql.sources.v2.{ContinuousReadSupport, DataSourceOptions}\n+import org.apache.spark.sql.sources.v2.reader.{DataReader, DataReaderFactory, SupportsScanUnsafeRow}\n+import org.apache.spark.sql.sources.v2.reader.streaming.{ContinuousDataReader, ContinuousReader, Offset, PartitionOffset}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.RpcUtils\n+\n+/**\n+ * The overall strategy here is:\n+ *  * ContinuousMemoryStream maintains a list of records for each partition. addData() will\n+ *    distribute records evenly-ish across partitions.\n+ *  * ContinuousMemoryStreamRecordBuffer is set up as an endpoint for executor-side\n+ *    ContinuousMemoryStreamDataReader instances to poll. It returns the record at the specified\n+ *    offset within the list, or null if that offset doesn't yet have a record.\n+ */\n+class ContinuousMemoryStream[A : Encoder](id: Int, sqlContext: SQLContext)\n+  extends MemoryStreamBase[A](sqlContext) with ContinuousReader with ContinuousReadSupport {\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+  val NUM_PARTITIONS = 2\n+\n+  protected val logicalPlan =\n+    StreamingRelationV2(this, \"memory\", Map(), attributes, None)(sqlContext.sparkSession)\n+\n+  // ContinuousReader implementation\n+\n+  @GuardedBy(\"this\")\n+  private val records = Seq.fill(NUM_PARTITIONS)(new ListBuffer[A])\n+\n+  private val recordBuffer = new ContinuousMemoryStreamRecordBuffer()\n+\n+  private var startOffset: ContinuousMemoryStreamOffset = _\n+\n+  @volatile private var endpointRef: RpcEndpointRef = _\n+\n+  def addData(data: TraversableOnce[A]): Offset = synchronized {\n+    // Distribute data evenly among partition lists.\n+    data.toSeq.zipWithIndex.map {\n+      case (item, index) => records(index % NUM_PARTITIONS) += item\n+    }\n+\n+    // The new target offset is the offset where all records in all partitions have been processed.\n+    ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, records(i).size)).toMap)\n+  }\n+\n+  override def setStartOffset(start: Optional[Offset]): Unit = synchronized {\n+    // Inferred initial offset is position 0 in each partition.\n+    startOffset = start.orElse {\n+      ContinuousMemoryStreamOffset((0 until NUM_PARTITIONS).map(i => (i, 0)).toMap)\n+    }.asInstanceOf[ContinuousMemoryStreamOffset]\n+  }\n+\n+  override def getStartOffset: Offset = startOffset\n+\n+  override def deserializeOffset(json: String): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset(Serialization.read[Map[Int, Int]](json))\n+  }\n+\n+  override def mergeOffsets(offsets: Array[PartitionOffset]): ContinuousMemoryStreamOffset = {\n+    ContinuousMemoryStreamOffset {\n+      offsets.map {\n+        case ContinuousMemoryStreamPartitionOffset(part, num) => (part, num)\n+      }.toMap\n+    }\n+  }\n+\n+  override def createDataReaderFactories(): ju.List[DataReaderFactory[Row]] = {\n+    synchronized {"
  }],
  "prId": 20828
}]