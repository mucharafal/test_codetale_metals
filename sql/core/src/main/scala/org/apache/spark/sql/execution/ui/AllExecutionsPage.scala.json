[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: can we avoid wildcard imports? we usually avoid them unless there are a very large number of classes to import",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:06:35Z",
    "diffHunk": "@@ -17,16 +17,17 @@\n \n package org.apache.spark.sql.execution.ui\n \n+import java.net.URLEncoder\n import javax.servlet.http.HttpServletRequest\n \n+import scala.collection.JavaConverters._\n import scala.collection.mutable\n-import scala.xml.{Node, NodeSeq}\n-\n-import org.apache.commons.lang3.StringEscapeUtils\n+import scala.xml._\n \n import org.apache.spark.JobExecutionStatus\n import org.apache.spark.internal.Logging\n-import org.apache.spark.ui.{UIUtils, WebUIPage}\n+import org.apache.spark.ui._"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Yes. done. Thanks",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T19:02:43Z",
    "diffHunk": "@@ -17,16 +17,17 @@\n \n package org.apache.spark.sql.execution.ui\n \n+import java.net.URLEncoder\n import javax.servlet.http.HttpServletRequest\n \n+import scala.collection.JavaConverters._\n import scala.collection.mutable\n-import scala.xml.{Node, NodeSeq}\n-\n-import org.apache.commons.lang3.StringEscapeUtils\n+import scala.xml._\n \n import org.apache.spark.JobExecutionStatus\n import org.apache.spark.internal.Logging\n-import org.apache.spark.ui.{UIUtils, WebUIPage}\n+import org.apache.spark.ui._"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Trivial nit: you don't need the type here or an extra block",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:08:04Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Done. Thanks",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T19:03:02Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Can this be private? and how about using interpolation for the whole thing?",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:14:04Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Done. Thanks",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:01:52Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Here and below, how about interpolation consistently?",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:14:22Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\""
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Done. Thanks",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:02:04Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\""
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This might be worth using case expressions to clarify what _3 and _1 are.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:15:13Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\"\n \n-    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n-      executionUIData.jobs.flatMap { case (jobId, jobStatus) =>\n-        if (jobStatus == status) {\n-          <a href={jobURL(request, jobId)}>[{jobId.toString}]</a>\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n+\n+  override def prevPageSizeFormField: String = executionTag + \".prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = executionTag + \".pageSize\"\n+\n+  override def pageNumberFormField: String = executionTag + \".page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+\n+    if (!executionHeadersAndCssClasses.filter(_._3).map(_._1).contains(sortColumn)) {"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Thanks. Done.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:02:32Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\"\n \n-    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n-      executionUIData.jobs.flatMap { case (jobId, jobStatus) =>\n-        if (jobStatus == status) {\n-          <a href={jobURL(request, jobId)}>[{jobId.toString}]</a>\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n+\n+  override def prevPageSizeFormField: String = executionTag + \".prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = executionTag + \".pageSize\"\n+\n+  override def pageNumberFormField: String = executionTag + \".page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+\n+    if (!executionHeadersAndCssClasses.filter(_._3).map(_._1).contains(sortColumn)) {"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Might be a little more idiomatic to say...\r\n\r\n```\r\ncase (jobId, jobStatus) if jobStatus == status => ...\r\ncase _ => none\r\n```\r\n\r\nbut why not just filter first instead of flatMap?",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:16:23Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\"\n \n-    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n-      executionUIData.jobs.flatMap { case (jobId, jobStatus) =>\n-        if (jobStatus == status) {\n-          <a href={jobURL(request, jobId)}>[{jobId.toString}]</a>\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n+\n+  override def prevPageSizeFormField: String = executionTag + \".prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = executionTag + \".pageSize\"\n+\n+  override def pageNumberFormField: String = executionTag + \".page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+\n+    if (!executionHeadersAndCssClasses.filter(_._3).map(_._1).contains(sortColumn)) {\n+      throw new IllegalArgumentException(s\"Unknown column: $sortColumn\")\n+    }\n+\n+    val headerRow: Seq[Node] = {\n+      executionHeadersAndCssClasses.map { case (header, cssClass, sortable) =>\n+        if (header == sortColumn) {\n+          val headerLink = Unparsed(\n+            parameterPath +\n+              s\"&$executionTag.sort=${URLEncoder.encode(header, \"UTF-8\")}\" +\n+              s\"&$executionTag.desc=${!desc}\" +\n+              s\"&$executionTag.pageSize=$pageSize\" +\n+              s\"#$tableHeaderId\")\n+          val arrow = if (desc) \"&#x25BE;\" else \"&#x25B4;\" // UP or DOWN\n+\n+          <th class={cssClass}>\n+            <a href={headerLink}>\n+              {header}<span>\n+              &nbsp;{Unparsed(arrow)}\n+            </span>\n+            </a>\n+          </th>\n         } else {\n-          None\n+          if (sortable) {\n+            val headerLink = Unparsed(\n+              parameterPath +\n+                s\"&$executionTag.sort=${URLEncoder.encode(header, \"UTF-8\")}\" +\n+                s\"&$executionTag.pageSize=$pageSize\" +\n+                s\"#$tableHeaderId\")\n+\n+            <th class={cssClass}>\n+              <a href={headerLink}>\n+                {header}\n+              </a>\n+            </th>\n+          } else {\n+            <th class={cssClass}>\n+              {header}\n+            </th>\n+          }\n         }\n+      }\n+    }\n+    <thead>\n+      {headerRow}\n+    </thead>\n+  }\n+\n+  override def row(executionTableRow: ExecutionTableRowData): Seq[Node] = {\n+    val executionUIData = executionTableRow.executionUIData\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionTableRow.duration\n+\n+    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n+      executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Thanks. I have used filter and map",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T19:03:36Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\"\n \n-    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n-      executionUIData.jobs.flatMap { case (jobId, jobStatus) =>\n-        if (jobStatus == status) {\n-          <a href={jobURL(request, jobId)}>[{jobId.toString}]</a>\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n+\n+  override def prevPageSizeFormField: String = executionTag + \".prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = executionTag + \".pageSize\"\n+\n+  override def pageNumberFormField: String = executionTag + \".page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+\n+    if (!executionHeadersAndCssClasses.filter(_._3).map(_._1).contains(sortColumn)) {\n+      throw new IllegalArgumentException(s\"Unknown column: $sortColumn\")\n+    }\n+\n+    val headerRow: Seq[Node] = {\n+      executionHeadersAndCssClasses.map { case (header, cssClass, sortable) =>\n+        if (header == sortColumn) {\n+          val headerLink = Unparsed(\n+            parameterPath +\n+              s\"&$executionTag.sort=${URLEncoder.encode(header, \"UTF-8\")}\" +\n+              s\"&$executionTag.desc=${!desc}\" +\n+              s\"&$executionTag.pageSize=$pageSize\" +\n+              s\"#$tableHeaderId\")\n+          val arrow = if (desc) \"&#x25BE;\" else \"&#x25B4;\" // UP or DOWN\n+\n+          <th class={cssClass}>\n+            <a href={headerLink}>\n+              {header}<span>\n+              &nbsp;{Unparsed(arrow)}\n+            </span>\n+            </a>\n+          </th>\n         } else {\n-          None\n+          if (sortable) {\n+            val headerLink = Unparsed(\n+              parameterPath +\n+                s\"&$executionTag.sort=${URLEncoder.encode(header, \"UTF-8\")}\" +\n+                s\"&$executionTag.pageSize=$pageSize\" +\n+                s\"#$tableHeaderId\")\n+\n+            <th class={cssClass}>\n+              <a href={headerLink}>\n+                {header}\n+              </a>\n+            </th>\n+          } else {\n+            <th class={cssClass}>\n+              {header}\n+            </th>\n+          }\n         }\n+      }\n+    }\n+    <thead>\n+      {headerRow}\n+    </thead>\n+  }\n+\n+  override def row(executionTableRow: ExecutionTableRowData): Seq[Node] = {\n+    val executionUIData = executionTableRow.executionUIData\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionTableRow.duration\n+\n+    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n+      executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "`.filter { case (_, jobStatus) => jobStatus == status }`? I'm on the fence about whether it's worth it, but I generally like this clearer style. You can also omit `jobStatus` in the case statement for a little more conciseness.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:32:18Z",
    "diffHunk": "@@ -121,65 +122,247 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(executionTag + \".page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(executionTag + \".desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(executionTag + \".prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    val page: Int = {\n+      // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+      // IndexOutOfBoundsException.\n+      if (executionPageSize <= executionPrevPageSize) {\n+        executionPage\n+      } else {\n+        1\n+      }\n+    }\n+\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n \n-  protected def header: Seq[String]\n+  val parameterPath = basePath + s\"/$subPath/?\" + parameterOtherTable.mkString(\"&\")\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n-    val submissionTime = executionUIData.submissionTime\n-    val duration = executionUIData.completionTime.map(_.getTime()).getOrElse(currentTime) -\n-      submissionTime\n+  override def tableId: String = executionTag + \"-table\"\n \n-    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n-      executionUIData.jobs.flatMap { case (jobId, jobStatus) =>\n-        if (jobStatus == status) {\n-          <a href={jobURL(request, jobId)}>[{jobId.toString}]</a>\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n+\n+  override def prevPageSizeFormField: String = executionTag + \".prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = executionTag + \".pageSize\"\n+\n+  override def pageNumberFormField: String = executionTag + \".page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+\n+    if (!executionHeadersAndCssClasses.filter(_._3).map(_._1).contains(sortColumn)) {\n+      throw new IllegalArgumentException(s\"Unknown column: $sortColumn\")\n+    }\n+\n+    val headerRow: Seq[Node] = {\n+      executionHeadersAndCssClasses.map { case (header, cssClass, sortable) =>\n+        if (header == sortColumn) {\n+          val headerLink = Unparsed(\n+            parameterPath +\n+              s\"&$executionTag.sort=${URLEncoder.encode(header, \"UTF-8\")}\" +\n+              s\"&$executionTag.desc=${!desc}\" +\n+              s\"&$executionTag.pageSize=$pageSize\" +\n+              s\"#$tableHeaderId\")\n+          val arrow = if (desc) \"&#x25BE;\" else \"&#x25B4;\" // UP or DOWN\n+\n+          <th class={cssClass}>\n+            <a href={headerLink}>\n+              {header}<span>\n+              &nbsp;{Unparsed(arrow)}\n+            </span>\n+            </a>\n+          </th>\n         } else {\n-          None\n+          if (sortable) {\n+            val headerLink = Unparsed(\n+              parameterPath +\n+                s\"&$executionTag.sort=${URLEncoder.encode(header, \"UTF-8\")}\" +\n+                s\"&$executionTag.pageSize=$pageSize\" +\n+                s\"#$tableHeaderId\")\n+\n+            <th class={cssClass}>\n+              <a href={headerLink}>\n+                {header}\n+              </a>\n+            </th>\n+          } else {\n+            <th class={cssClass}>\n+              {header}\n+            </th>\n+          }\n         }\n+      }\n+    }\n+    <thead>\n+      {headerRow}\n+    </thead>\n+  }\n+\n+  override def row(executionTableRow: ExecutionTableRowData): Seq[Node] = {\n+    val executionUIData = executionTableRow.executionUIData\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionTableRow.duration\n+\n+    def jobLinks(status: JobExecutionStatus): Seq[Node] = {\n+      executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: pull this onto previous line? the indent is odd, at least",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:16:57Z",
    "diffHunk": "@@ -202,100 +385,127 @@ private[ui] abstract class ExecutionTable(\n         </td>\n       }}\n       {if (showSucceededJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.SUCCEEDED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.SUCCEEDED)}\n+      </td>\n+    }}\n       {if (showFailedJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.FAILED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.FAILED)}\n+      </td>\n+    }}\n     </tr>\n   }\n \n-  private def descriptionCell(\n-      request: HttpServletRequest,\n-      execution: SQLExecutionUIData): Seq[Node] = {\n+  private def descriptionCell(execution: SQLExecutionUIData): Seq[Node] = {\n     val details = if (execution.details != null && execution.details.nonEmpty) {\n-      <span onclick=\"clickDetail(this)\" class=\"expand-details\">\n+      <span onclick=\"this.parentNode.querySelector('.stage-details').\n+      classList.toggle('collapsed')\""
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Done. Thanks.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T19:04:29Z",
    "diffHunk": "@@ -202,100 +385,127 @@ private[ui] abstract class ExecutionTable(\n         </td>\n       }}\n       {if (showSucceededJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.SUCCEEDED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.SUCCEEDED)}\n+      </td>\n+    }}\n       {if (showFailedJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.FAILED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.FAILED)}\n+      </td>\n+    }}\n     </tr>\n   }\n \n-  private def descriptionCell(\n-      request: HttpServletRequest,\n-      execution: SQLExecutionUIData): Seq[Node] = {\n+  private def descriptionCell(execution: SQLExecutionUIData): Seq[Node] = {\n     val details = if (execution.details != null && execution.details.nonEmpty) {\n-      <span onclick=\"clickDetail(this)\" class=\"expand-details\">\n+      <span onclick=\"this.parentNode.querySelector('.stage-details').\n+      classList.toggle('collapsed')\""
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I believe this shouldn't be indented more",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:17:06Z",
    "diffHunk": "@@ -202,100 +385,127 @@ private[ui] abstract class ExecutionTable(\n         </td>\n       }}\n       {if (showSucceededJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.SUCCEEDED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.SUCCEEDED)}\n+      </td>\n+    }}\n       {if (showFailedJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.FAILED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.FAILED)}\n+      </td>\n+    }}\n     </tr>\n   }\n \n-  private def descriptionCell(\n-      request: HttpServletRequest,\n-      execution: SQLExecutionUIData): Seq[Node] = {\n+  private def descriptionCell(execution: SQLExecutionUIData): Seq[Node] = {\n     val details = if (execution.details != null && execution.details.nonEmpty) {\n-      <span onclick=\"clickDetail(this)\" class=\"expand-details\">\n+      <span onclick=\"this.parentNode.querySelector('.stage-details').\n+      classList.toggle('collapsed')\"\n+            class=\"expand-details\">\n         +details\n       </span> ++\n-      <div class=\"stage-details collapsed\">\n-        <pre>{execution.details}</pre>\n-      </div>\n+        <div class=\"stage-details collapsed\">"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Yes. I have used a different scalastyle and checkstyle xml in IJ it seems.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T19:05:13Z",
    "diffHunk": "@@ -202,100 +385,127 @@ private[ui] abstract class ExecutionTable(\n         </td>\n       }}\n       {if (showSucceededJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.SUCCEEDED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.SUCCEEDED)}\n+      </td>\n+    }}\n       {if (showFailedJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.FAILED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.FAILED)}\n+      </td>\n+    }}\n     </tr>\n   }\n \n-  private def descriptionCell(\n-      request: HttpServletRequest,\n-      execution: SQLExecutionUIData): Seq[Node] = {\n+  private def descriptionCell(execution: SQLExecutionUIData): Seq[Node] = {\n     val details = if (execution.details != null && execution.details.nonEmpty) {\n-      <span onclick=\"clickDetail(this)\" class=\"expand-details\">\n+      <span onclick=\"this.parentNode.querySelector('.stage-details').\n+      classList.toggle('collapsed')\"\n+            class=\"expand-details\">\n         +details\n       </span> ++\n-      <div class=\"stage-details collapsed\">\n-        <pre>{execution.details}</pre>\n-      </div>\n+        <div class=\"stage-details collapsed\">"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Same, here and around here do you really want to filter first instead of flatMap?",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T17:18:12Z",
    "diffHunk": "@@ -202,100 +385,127 @@ private[ui] abstract class ExecutionTable(\n         </td>\n       }}\n       {if (showSucceededJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.SUCCEEDED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.SUCCEEDED)}\n+      </td>\n+    }}\n       {if (showFailedJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.FAILED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.FAILED)}\n+      </td>\n+    }}\n     </tr>\n   }\n \n-  private def descriptionCell(\n-      request: HttpServletRequest,\n-      execution: SQLExecutionUIData): Seq[Node] = {\n+  private def descriptionCell(execution: SQLExecutionUIData): Seq[Node] = {\n     val details = if (execution.details != null && execution.details.nonEmpty) {\n-      <span onclick=\"clickDetail(this)\" class=\"expand-details\">\n+      <span onclick=\"this.parentNode.querySelector('.stage-details').\n+      classList.toggle('collapsed')\"\n+            class=\"expand-details\">\n         +details\n       </span> ++\n-      <div class=\"stage-details collapsed\">\n-        <pre>{execution.details}</pre>\n-      </div>\n+        <div class=\"stage-details collapsed\">\n+          <pre>{execution.details}</pre>\n+        </div>\n     } else {\n       Nil\n     }\n \n     val desc = if (execution.description != null && execution.description.nonEmpty) {\n-      <a href={executionURL(request, execution.executionId)}>{execution.description}</a>\n+      <a href={executionURL(execution.executionId)}>\n+        {execution.description}\n+      </a>\n     } else {\n-      <a href={executionURL(request, execution.executionId)}>{execution.executionId}</a>\n+      <a href={executionURL(execution.executionId)}>\n+        {execution.executionId}\n+      </a>\n     }\n \n-    <div>{desc} {details}</div>\n-  }\n-\n-  def toNodeSeq(request: HttpServletRequest): Seq[Node] = {\n-    UIUtils.listingTable[SQLExecutionUIData](\n-      header, row(request, currentTime, _), executionUIDatas, id = Some(tableId))\n+    <div>\n+      {desc}{details}\n+    </div>\n   }\n \n   private def jobURL(request: HttpServletRequest, jobId: Long): String =\n     \"%s/jobs/job/?id=%s\".format(UIUtils.prependBaseUri(request, parent.basePath), jobId)\n \n-  private def executionURL(request: HttpServletRequest, executionID: Long): String =\n+  private def executionURL(executionID: Long): String =\n     s\"${UIUtils.prependBaseUri(\n       request, parent.basePath)}/${parent.prefix}/execution/?id=$executionID\"\n }\n \n-private[ui] class RunningExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"running-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = true,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Running Job IDs\", \"Succeeded Job IDs\", \"Failed Job IDs\")\n-}\n+private[ui] class ExecutionTableRowData(\n+    val submissionTime: Long,\n+    val duration: Long,\n+    val executionUIData: SQLExecutionUIData)\n \n-private[ui] class CompletedExecutionTable(\n+\n+private[ui] class ExecutionDataSource(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n+    executionData: Seq[SQLExecutionUIData],\n+    basePath: String,\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"completed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = false) {\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean) extends PagedDataSource[ExecutionTableRowData](pageSize) {\n \n-  override protected def header: Seq[String] = baseHeader ++ Seq(\"Job IDs\")\n-}\n+  // Convert ExecutionData to ExecutionTableRowData which contains the final contents to show\n+  // in the table so that we can avoid creating duplicate contents during sorting the data\n+  private val data = executionData.map(executionRow).sorted(ordering(sortColumn, desc))\n \n-private[ui] class FailedExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"failed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n+  private var _slicedJobIds: Set[Int] = _\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Succeeded Job IDs\", \"Failed Job IDs\")\n+  override def dataSize: Int = data.size\n+\n+  override def sliceData(from: Int, to: Int): Seq[ExecutionTableRowData] = {\n+    val r = data.slice(from, to)\n+    _slicedJobIds = r.map(_.executionUIData.executionId.toInt).toSet\n+    r\n+  }\n+\n+  private def executionRow(executionUIData: SQLExecutionUIData): ExecutionTableRowData = {\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionUIData.completionTime.map(_.getTime())\n+      .getOrElse(currentTime) - submissionTime\n+\n+    new ExecutionTableRowData(\n+      submissionTime,\n+      duration,\n+      executionUIData)\n+  }\n+\n+  /**\n+    * Return Ordering according to sortColumn and desc\n+    */\n+  private def ordering(sortColumn: String, desc: Boolean): Ordering[ExecutionTableRowData] = {\n+    val ordering: Ordering[ExecutionTableRowData] = sortColumn match {\n+      case \"ID\" => Ordering.by(_.executionUIData.executionId)\n+      case \"Description\" => Ordering.by(_.executionUIData.description)\n+      case \"Submitted\" => Ordering.by(_.executionUIData.submissionTime)\n+      case \"Duration\" => Ordering.by(_.duration)\n+      case \"Job IDs\" | \"Succeeded Job IDs\" => Ordering.by(_.executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>\n+          if (jobStatus == JobExecutionStatus.SUCCEEDED) jobId.toString\n+          else \"\"\n+      }.toSeq.toString())\n+      case \"Running Job IDs\" => Ordering.by(_.executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Thanks. I have modified using filter",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T19:05:39Z",
    "diffHunk": "@@ -202,100 +385,127 @@ private[ui] abstract class ExecutionTable(\n         </td>\n       }}\n       {if (showSucceededJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.SUCCEEDED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.SUCCEEDED)}\n+      </td>\n+    }}\n       {if (showFailedJobs) {\n-        <td>\n-          {jobLinks(JobExecutionStatus.FAILED)}\n-        </td>\n-      }}\n+      <td>\n+        {jobLinks(JobExecutionStatus.FAILED)}\n+      </td>\n+    }}\n     </tr>\n   }\n \n-  private def descriptionCell(\n-      request: HttpServletRequest,\n-      execution: SQLExecutionUIData): Seq[Node] = {\n+  private def descriptionCell(execution: SQLExecutionUIData): Seq[Node] = {\n     val details = if (execution.details != null && execution.details.nonEmpty) {\n-      <span onclick=\"clickDetail(this)\" class=\"expand-details\">\n+      <span onclick=\"this.parentNode.querySelector('.stage-details').\n+      classList.toggle('collapsed')\"\n+            class=\"expand-details\">\n         +details\n       </span> ++\n-      <div class=\"stage-details collapsed\">\n-        <pre>{execution.details}</pre>\n-      </div>\n+        <div class=\"stage-details collapsed\">\n+          <pre>{execution.details}</pre>\n+        </div>\n     } else {\n       Nil\n     }\n \n     val desc = if (execution.description != null && execution.description.nonEmpty) {\n-      <a href={executionURL(request, execution.executionId)}>{execution.description}</a>\n+      <a href={executionURL(execution.executionId)}>\n+        {execution.description}\n+      </a>\n     } else {\n-      <a href={executionURL(request, execution.executionId)}>{execution.executionId}</a>\n+      <a href={executionURL(execution.executionId)}>\n+        {execution.executionId}\n+      </a>\n     }\n \n-    <div>{desc} {details}</div>\n-  }\n-\n-  def toNodeSeq(request: HttpServletRequest): Seq[Node] = {\n-    UIUtils.listingTable[SQLExecutionUIData](\n-      header, row(request, currentTime, _), executionUIDatas, id = Some(tableId))\n+    <div>\n+      {desc}{details}\n+    </div>\n   }\n \n   private def jobURL(request: HttpServletRequest, jobId: Long): String =\n     \"%s/jobs/job/?id=%s\".format(UIUtils.prependBaseUri(request, parent.basePath), jobId)\n \n-  private def executionURL(request: HttpServletRequest, executionID: Long): String =\n+  private def executionURL(executionID: Long): String =\n     s\"${UIUtils.prependBaseUri(\n       request, parent.basePath)}/${parent.prefix}/execution/?id=$executionID\"\n }\n \n-private[ui] class RunningExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"running-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = true,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Running Job IDs\", \"Succeeded Job IDs\", \"Failed Job IDs\")\n-}\n+private[ui] class ExecutionTableRowData(\n+    val submissionTime: Long,\n+    val duration: Long,\n+    val executionUIData: SQLExecutionUIData)\n \n-private[ui] class CompletedExecutionTable(\n+\n+private[ui] class ExecutionDataSource(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n+    executionData: Seq[SQLExecutionUIData],\n+    basePath: String,\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"completed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = false) {\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean) extends PagedDataSource[ExecutionTableRowData](pageSize) {\n \n-  override protected def header: Seq[String] = baseHeader ++ Seq(\"Job IDs\")\n-}\n+  // Convert ExecutionData to ExecutionTableRowData which contains the final contents to show\n+  // in the table so that we can avoid creating duplicate contents during sorting the data\n+  private val data = executionData.map(executionRow).sorted(ordering(sortColumn, desc))\n \n-private[ui] class FailedExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"failed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n+  private var _slicedJobIds: Set[Int] = _\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Succeeded Job IDs\", \"Failed Job IDs\")\n+  override def dataSize: Int = data.size\n+\n+  override def sliceData(from: Int, to: Int): Seq[ExecutionTableRowData] = {\n+    val r = data.slice(from, to)\n+    _slicedJobIds = r.map(_.executionUIData.executionId.toInt).toSet\n+    r\n+  }\n+\n+  private def executionRow(executionUIData: SQLExecutionUIData): ExecutionTableRowData = {\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionUIData.completionTime.map(_.getTime())\n+      .getOrElse(currentTime) - submissionTime\n+\n+    new ExecutionTableRowData(\n+      submissionTime,\n+      duration,\n+      executionUIData)\n+  }\n+\n+  /**\n+    * Return Ordering according to sortColumn and desc\n+    */\n+  private def ordering(sortColumn: String, desc: Boolean): Ordering[ExecutionTableRowData] = {\n+    val ordering: Ordering[ExecutionTableRowData] = sortColumn match {\n+      case \"ID\" => Ordering.by(_.executionUIData.executionId)\n+      case \"Description\" => Ordering.by(_.executionUIData.description)\n+      case \"Submitted\" => Ordering.by(_.executionUIData.submissionTime)\n+      case \"Duration\" => Ordering.by(_.duration)\n+      case \"Job IDs\" | \"Succeeded Job IDs\" => Ordering.by(_.executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>\n+          if (jobStatus == JobExecutionStatus.SUCCEEDED) jobId.toString\n+          else \"\"\n+      }.toSeq.toString())\n+      case \"Running Job IDs\" => Ordering.by(_.executionUIData.jobs.flatMap {\n+        case (jobId, jobStatus) =>"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This might be a good place to wrap these to line up the elements in the Seq, one one each line (?) to make it easier to read its contents. They all seem to have an empty string as the second element? can it be removed or did I overlook something? Also you don't need the type here.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:29:17Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Yes. I have modified based on your suggestions. Thanks.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T21:15:49Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: pull this onto previous line",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:29:26Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Done. Thanks",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T21:16:02Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: space after if. Really, maybe just use `require`",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:29:37Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+    \n+    val sortableColumnHeaders = executionHeadersAndCssClasses.filter {\n+      case (_, _, sortable) => sortable\n+    }.map(header => header._1)\n+\n+    if(!sortableColumnHeaders.contains(sortColumn)) {"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Done. used require. Thanks",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T21:16:28Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+    \n+    val sortableColumnHeaders = executionHeadersAndCssClasses.filter {\n+      case (_, _, sortable) => sortable\n+    }.map(header => header._1)\n+\n+    if(!sortableColumnHeaders.contains(sortColumn)) {"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`.map { case (title, _, _) => title }`? ",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:30:24Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+    \n+    val sortableColumnHeaders = executionHeadersAndCssClasses.filter {\n+      case (_, _, sortable) => sortable\n+    }.map(header => header._1)"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Updated. Thanks.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T21:16:42Z",
    "diffHunk": "@@ -121,65 +122,242 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.pageSize\"))\n+    val parameterExecutionPrevPageSize = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.prevPageSize\"))\n+\n+    val executionPage = Option(parameterExecutionPage).map(_.toInt).getOrElse(1)\n+    val executionSortColumn = Option(parameterExecutionSortColumn).map { sortColumn =>\n+      UIUtils.decodeURLParameter(sortColumn)\n+    }.getOrElse(\"ID\")\n+    val executionSortDesc = Option(parameterExecutionSortDesc).map(_.toBoolean).getOrElse(\n+      // New executions should be shown above old executions by default.\n+      executionSortColumn == \"ID\"\n+    )\n+    val executionPageSize = Option(parameterExecutionPageSize).map(_.toInt).getOrElse(100)\n+    val executionPrevPageSize = Option(parameterExecutionPrevPageSize).map(_.toInt).\n+      getOrElse(executionPageSize)\n+\n+    // If the user has changed to a larger page size, then go to page 1 in order to avoid\n+    // IndexOutOfBoundsException.\n+    val page: Int = if (executionPageSize <= executionPrevPageSize) {\n+      executionPage\n+    } else {\n+      1\n+    }\n+    val tableHeaderId = executionTag // \"running\", \"completed\" or \"failed\"\n+\n+    try {\n+      new ExecutionPagedTable(\n+        request,\n+        parent,\n+        executionData,\n+        tableHeaderId,\n+        executionTag,\n+        UIUtils.prependBaseUri(request, parent.basePath),\n+        \"SQL\", // subPath\n+        parameterOtherTable,\n+        currentTime,\n+        pageSize = executionPageSize,\n+        sortColumn = executionSortColumn,\n+        desc = executionSortDesc,\n+        showRunningJobs,\n+        showSucceededJobs,\n+        showFailedJobs).table(page)\n+    } catch {\n+      case e@(_: IllegalArgumentException | _: IndexOutOfBoundsException) =>\n+        <div class=\"alert alert-error\">\n+          <p>Error while rendering execution table:</p>\n+          <pre>\n+            {Utils.exceptionString(e)}\n+          </pre>\n+        </div>\n+    }\n+  }\n }\n \n-private[ui] abstract class ExecutionTable(\n+\n+private[ui] class ExecutionPagedTable(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n-    tableId: String,\n+    data: Seq[SQLExecutionUIData],\n+    tableHeaderId: String,\n+    executionTag: String,\n+    basePath: String,\n+    subPath: String,\n+    parameterOtherTable: Iterable[String],\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData],\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean,\n     showRunningJobs: Boolean,\n     showSucceededJobs: Boolean,\n-    showFailedJobs: Boolean) {\n+    showFailedJobs: Boolean) extends PagedTable[ExecutionTableRowData] {\n+\n+  override val dataSource = new ExecutionDataSource(\n+    request,\n+    parent,\n+    data,\n+    basePath,\n+    currentTime,\n+    pageSize,\n+    sortColumn,\n+    desc)\n+\n+  private val parameterPath = s\"$basePath/$subPath/?${parameterOtherTable.mkString(\"&\")}\"\n \n-  protected def baseHeader: Seq[String] = Seq(\n-    \"ID\",\n-    \"Description\",\n-    \"Submitted\",\n-    \"Duration\")\n+  override def tableId: String = s\"$executionTag-table\"\n \n-  protected def header: Seq[String]\n+  override def tableCssClass: String =\n+    \"table table-bordered table-condensed table-striped \" +\n+      \"table-head-clickable table-cell-width-limited\"\n \n-  protected def row(\n-      request: HttpServletRequest,\n-      currentTime: Long,\n-      executionUIData: SQLExecutionUIData): Seq[Node] = {\n+  override def prevPageSizeFormField: String = s\"$executionTag.prevPageSize\"\n+\n+  override def pageLink(page: Int): String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    parameterPath +\n+      s\"&$pageNumberFormField=$page\" +\n+      s\"&$executionTag.sort=$encodedSortColumn\" +\n+      s\"&$executionTag.desc=$desc\" +\n+      s\"&$pageSizeFormField=$pageSize\" +\n+      s\"#$tableHeaderId\"\n+  }\n+\n+  override def pageSizeFormField: String = s\"$executionTag.pageSize\"\n+\n+  override def pageNumberFormField: String = s\"$executionTag.page\"\n+\n+  override def goButtonFormPath: String = {\n+    val encodedSortColumn = URLEncoder.encode(sortColumn, \"UTF-8\")\n+    s\"$parameterPath&$executionTag.sort=$encodedSortColumn&$executionTag.desc=$desc#$tableHeaderId\"\n+  }\n+\n+  override def headers: Seq[Node] = {\n+    // Information for each header: title, cssClass, and sortable\n+    val executionHeadersAndCssClasses: Seq[(String, String, Boolean)] =\n+      Seq((\"ID\", \"\", true), (\"Description\", \"\", true), (\"Submitted\", \"\", true),\n+        (\"Duration\", \"\", true)) ++ {\n+        if (showRunningJobs && showSucceededJobs && showFailedJobs) {\n+          Seq((\"Running Job IDs\", \"\", true), (\"Succeeded Job IDs\", \"\", true),\n+            (\"Failed Job IDs\", \"\", true))\n+        } else if (showSucceededJobs && showFailedJobs) {\n+          Seq((\"Succeeded Job IDs\", \"\", true), (\"Failed Job IDs\", \"\", true))\n+        }\n+        else {\n+          Seq((\"Job IDs\", \"\", true))\n+        }\n+      }\n+    \n+    val sortableColumnHeaders = executionHeadersAndCssClasses.filter {\n+      case (_, _, sortable) => sortable\n+    }.map(header => header._1)"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "The expression here is still a little complex for my taste, but can't be simplified much. Maybe omit jobId in the case statement, and the second toString below it? the Seq[String] should already have the same ordering.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T20:37:18Z",
    "diffHunk": "@@ -229,73 +406,88 @@ private[ui] abstract class ExecutionTable(\n     }\n \n     val desc = if (execution.description != null && execution.description.nonEmpty) {\n-      <a href={executionURL(request, execution.executionId)}>{execution.description}</a>\n+      <a href={executionURL(execution.executionId)}>{execution.description}</a>\n     } else {\n-      <a href={executionURL(request, execution.executionId)}>{execution.executionId}</a>\n+      <a href={executionURL(execution.executionId)}>{execution.executionId}</a>\n     }\n \n-    <div>{desc} {details}</div>\n-  }\n-\n-  def toNodeSeq(request: HttpServletRequest): Seq[Node] = {\n-    UIUtils.listingTable[SQLExecutionUIData](\n-      header, row(request, currentTime, _), executionUIDatas, id = Some(tableId))\n+    <div>{desc}{details}</div>\n   }\n \n   private def jobURL(request: HttpServletRequest, jobId: Long): String =\n     \"%s/jobs/job/?id=%s\".format(UIUtils.prependBaseUri(request, parent.basePath), jobId)\n \n-  private def executionURL(request: HttpServletRequest, executionID: Long): String =\n+  private def executionURL(executionID: Long): String =\n     s\"${UIUtils.prependBaseUri(\n       request, parent.basePath)}/${parent.prefix}/execution/?id=$executionID\"\n }\n \n-private[ui] class RunningExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"running-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = true,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Running Job IDs\", \"Succeeded Job IDs\", \"Failed Job IDs\")\n-}\n+private[ui] class ExecutionTableRowData(\n+    val submissionTime: Long,\n+    val duration: Long,\n+    val executionUIData: SQLExecutionUIData)\n+\n \n-private[ui] class CompletedExecutionTable(\n+private[ui] class ExecutionDataSource(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n+    executionData: Seq[SQLExecutionUIData],\n+    basePath: String,\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"completed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = false) {\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean) extends PagedDataSource[ExecutionTableRowData](pageSize) {\n \n-  override protected def header: Seq[String] = baseHeader ++ Seq(\"Job IDs\")\n-}\n+  // Convert ExecutionData to ExecutionTableRowData which contains the final contents to show\n+  // in the table so that we can avoid creating duplicate contents during sorting the data\n+  private val data = executionData.map(executionRow).sorted(ordering(sortColumn, desc))\n \n-private[ui] class FailedExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"failed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n+  private var _slicedJobIds: Set[Int] = _\n+\n+  override def dataSize: Int = data.size\n+\n+  override def sliceData(from: Int, to: Int): Seq[ExecutionTableRowData] = {\n+    val r = data.slice(from, to)\n+    _slicedJobIds = r.map(_.executionUIData.executionId.toInt).toSet\n+    r\n+  }\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Succeeded Job IDs\", \"Failed Job IDs\")\n+  private def executionRow(executionUIData: SQLExecutionUIData): ExecutionTableRowData = {\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionUIData.completionTime.map(_.getTime())\n+      .getOrElse(currentTime) - submissionTime\n+\n+    new ExecutionTableRowData(\n+      submissionTime,\n+      duration,\n+      executionUIData)\n+  }\n+\n+  /**\n+    * Return Ordering according to sortColumn and desc\n+    */\n+  private def ordering(sortColumn: String, desc: Boolean): Ordering[ExecutionTableRowData] = {\n+    val ordering: Ordering[ExecutionTableRowData] = sortColumn match {\n+      case \"ID\" => Ordering.by(_.executionUIData.executionId)\n+      case \"Description\" => Ordering.by(_.executionUIData.description)\n+      case \"Submitted\" => Ordering.by(_.executionUIData.submissionTime)\n+      case \"Duration\" => Ordering.by(_.duration)\n+      case \"Job IDs\" | \"Succeeded Job IDs\" => Ordering by (_.executionUIData.jobs.filter {"
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "I have modified the code by pre computing the job data based on the status and put it in the 'ExecutionTableRowData'.\r\nNow from there, both 'ordering' and 'jobLinks' uses the job data.\r\nThanks you.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-06T22:05:14Z",
    "diffHunk": "@@ -229,73 +406,88 @@ private[ui] abstract class ExecutionTable(\n     }\n \n     val desc = if (execution.description != null && execution.description.nonEmpty) {\n-      <a href={executionURL(request, execution.executionId)}>{execution.description}</a>\n+      <a href={executionURL(execution.executionId)}>{execution.description}</a>\n     } else {\n-      <a href={executionURL(request, execution.executionId)}>{execution.executionId}</a>\n+      <a href={executionURL(execution.executionId)}>{execution.executionId}</a>\n     }\n \n-    <div>{desc} {details}</div>\n-  }\n-\n-  def toNodeSeq(request: HttpServletRequest): Seq[Node] = {\n-    UIUtils.listingTable[SQLExecutionUIData](\n-      header, row(request, currentTime, _), executionUIDatas, id = Some(tableId))\n+    <div>{desc}{details}</div>\n   }\n \n   private def jobURL(request: HttpServletRequest, jobId: Long): String =\n     \"%s/jobs/job/?id=%s\".format(UIUtils.prependBaseUri(request, parent.basePath), jobId)\n \n-  private def executionURL(request: HttpServletRequest, executionID: Long): String =\n+  private def executionURL(executionID: Long): String =\n     s\"${UIUtils.prependBaseUri(\n       request, parent.basePath)}/${parent.prefix}/execution/?id=$executionID\"\n }\n \n-private[ui] class RunningExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"running-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = true,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Running Job IDs\", \"Succeeded Job IDs\", \"Failed Job IDs\")\n-}\n+private[ui] class ExecutionTableRowData(\n+    val submissionTime: Long,\n+    val duration: Long,\n+    val executionUIData: SQLExecutionUIData)\n+\n \n-private[ui] class CompletedExecutionTable(\n+private[ui] class ExecutionDataSource(\n+    request: HttpServletRequest,\n     parent: SQLTab,\n+    executionData: Seq[SQLExecutionUIData],\n+    basePath: String,\n     currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"completed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = false) {\n+    pageSize: Int,\n+    sortColumn: String,\n+    desc: Boolean) extends PagedDataSource[ExecutionTableRowData](pageSize) {\n \n-  override protected def header: Seq[String] = baseHeader ++ Seq(\"Job IDs\")\n-}\n+  // Convert ExecutionData to ExecutionTableRowData which contains the final contents to show\n+  // in the table so that we can avoid creating duplicate contents during sorting the data\n+  private val data = executionData.map(executionRow).sorted(ordering(sortColumn, desc))\n \n-private[ui] class FailedExecutionTable(\n-    parent: SQLTab,\n-    currentTime: Long,\n-    executionUIDatas: Seq[SQLExecutionUIData])\n-  extends ExecutionTable(\n-    parent,\n-    \"failed-execution-table\",\n-    currentTime,\n-    executionUIDatas,\n-    showRunningJobs = false,\n-    showSucceededJobs = true,\n-    showFailedJobs = true) {\n+  private var _slicedJobIds: Set[Int] = _\n+\n+  override def dataSize: Int = data.size\n+\n+  override def sliceData(from: Int, to: Int): Seq[ExecutionTableRowData] = {\n+    val r = data.slice(from, to)\n+    _slicedJobIds = r.map(_.executionUIData.executionId.toInt).toSet\n+    r\n+  }\n \n-  override protected def header: Seq[String] =\n-    baseHeader ++ Seq(\"Succeeded Job IDs\", \"Failed Job IDs\")\n+  private def executionRow(executionUIData: SQLExecutionUIData): ExecutionTableRowData = {\n+    val submissionTime = executionUIData.submissionTime\n+    val duration = executionUIData.completionTime.map(_.getTime())\n+      .getOrElse(currentTime) - submissionTime\n+\n+    new ExecutionTableRowData(\n+      submissionTime,\n+      duration,\n+      executionUIData)\n+  }\n+\n+  /**\n+    * Return Ordering according to sortColumn and desc\n+    */\n+  private def ordering(sortColumn: String, desc: Boolean): Ordering[ExecutionTableRowData] = {\n+    val ordering: Ordering[ExecutionTableRowData] = sortColumn match {\n+      case \"ID\" => Ordering.by(_.executionUIData.executionId)\n+      case \"Description\" => Ordering.by(_.executionUIData.description)\n+      case \"Submitted\" => Ordering.by(_.executionUIData.submissionTime)\n+      case \"Duration\" => Ordering.by(_.duration)\n+      case \"Job IDs\" | \"Succeeded Job IDs\" => Ordering by (_.executionUIData.jobs.filter {"
  }],
  "prId": 22645
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "could you either have `.` last or first of the next line.\r\nfor example L172 is at the end and L166 is in front - let's do this consistently with other code in the file",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-07T01:23:13Z",
    "diffHunk": "@@ -121,74 +122,257 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request."
  }, {
    "author": {
      "login": "shahidki31"
    },
    "body": "Thank you @felixcheung . I have modified.",
    "commit": "2b5a724506266f243783fbfa7724a1e9f02c23ed",
    "createdAt": "2018-10-07T04:02:13Z",
    "diffHunk": "@@ -121,74 +122,257 @@ private[ui] class AllExecutionsPage(parent: SQLTab) extends WebUIPage(\"\") with L\n           {\n             if (running.nonEmpty) {\n               <li>\n-                <a href=\"#running-execution-table\"><strong>Running Queries:</strong></a>\n+                <a href=\"#running\"><strong>Running Queries:</strong></a>\n                 {running.size}\n               </li>\n             }\n           }\n           {\n             if (completed.nonEmpty) {\n               <li>\n-                <a href=\"#completed-execution-table\"><strong>Completed Queries:</strong></a>\n+                <a href=\"#completed\"><strong>Completed Queries:</strong></a>\n                 {completed.size}\n               </li>\n             }\n           }\n           {\n             if (failed.nonEmpty) {\n               <li>\n-                <a href=\"#failed-execution-table\"><strong>Failed Queries:</strong></a>\n+                <a href=\"#failed\"><strong>Failed Queries:</strong></a>\n                 {failed.size}\n               </li>\n             }\n           }\n         </ul>\n       </div>\n+\n     UIUtils.headerSparkPage(request, \"SQL\", summary ++ content, parent, Some(5000))\n   }\n+\n+  private def executionsTable(\n+    request: HttpServletRequest,\n+    executionTag: String,\n+    executionData: Seq[SQLExecutionUIData],\n+    currentTime: Long,\n+    showRunningJobs: Boolean,\n+    showSucceededJobs: Boolean,\n+    showFailedJobs: Boolean): Seq[Node] = {\n+\n+    // stripXSS is called to remove suspicious characters used in XSS attacks\n+    val allParameters = request.getParameterMap.asScala.toMap.map { case (k, v) =>\n+      UIUtils.stripXSS(k) -> v.map(UIUtils.stripXSS).toSeq\n+    }\n+    val parameterOtherTable = allParameters.filterNot(_._1.startsWith(executionTag))\n+      .map(para => para._1 + \"=\" + para._2(0))\n+\n+    val parameterExecutionPage = UIUtils.stripXSS(request.getParameter(s\"$executionTag.page\"))\n+    val parameterExecutionSortColumn = UIUtils.stripXSS(request.\n+      getParameter(s\"$executionTag.sort\"))\n+    val parameterExecutionSortDesc = UIUtils.stripXSS(request.getParameter(s\"$executionTag.desc\"))\n+    val parameterExecutionPageSize = UIUtils.stripXSS(request."
  }],
  "prId": 22645
}]