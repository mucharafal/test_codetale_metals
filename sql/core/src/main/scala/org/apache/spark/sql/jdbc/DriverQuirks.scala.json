[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Please add return type explicitly for all public methods.\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T08:50:36Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Same as above.\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T08:50:42Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) {"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Since `quirks` is always non-empty (we should add an assertion at the beginning of the constructor), we can do this:\n\n``` scala\nquirks.map(_.canHandle(url)).reduce(_ && _)\n```\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T08:59:51Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {\n-    if (url.substring(0, 10).equals(\"jdbc:mysql\")) {\n-      new MySQLQuirks()\n-    } else if (url.substring(0, 15).equals(\"jdbc:postgresql\")) {\n-      new PostgresQuirks()\n-    } else {\n-      new NoQuirks()\n+    val matchingQuirks = quirks.filter(_.canHandle(url))\n+    matchingQuirks.length match {\n+      case 0 => new NoQuirks()\n+      case 1 => matchingQuirks.head\n+      case _ => new AggregatedQuirks(matchingQuirks)\n     }\n   }\n }\n \n-private[sql] class NoQuirks extends DriverQuirks {\n+class AggregatedQuirks(quirks: List[DriverQuirks]) extends DriverQuirks {\n+  def canHandle(url : String): Boolean =\n+    quirks.foldLeft(true)((l,r) => l && r.canHandle(url))"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Add a newline after this line.\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T09:00:01Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {\n-    if (url.substring(0, 10).equals(\"jdbc:mysql\")) {\n-      new MySQLQuirks()\n-    } else if (url.substring(0, 15).equals(\"jdbc:postgresql\")) {\n-      new PostgresQuirks()\n-    } else {\n-      new NoQuirks()\n+    val matchingQuirks = quirks.filter(_.canHandle(url))\n+    matchingQuirks.length match {\n+      case 0 => new NoQuirks()\n+      case 1 => matchingQuirks.head\n+      case _ => new AggregatedQuirks(matchingQuirks)\n     }\n   }\n }\n \n-private[sql] class NoQuirks extends DriverQuirks {\n+class AggregatedQuirks(quirks: List[DriverQuirks]) extends DriverQuirks {\n+  def canHandle(url : String): Boolean =\n+    quirks.foldLeft(true)((l,r) => l && r.canHandle(url))"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Remove the space before the last `:`\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T09:00:19Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {\n-    if (url.substring(0, 10).equals(\"jdbc:mysql\")) {\n-      new MySQLQuirks()\n-    } else if (url.substring(0, 15).equals(\"jdbc:postgresql\")) {\n-      new PostgresQuirks()\n-    } else {\n-      new NoQuirks()\n+    val matchingQuirks = quirks.filter(_.canHandle(url))\n+    matchingQuirks.length match {\n+      case 0 => new NoQuirks()\n+      case 1 => matchingQuirks.head\n+      case _ => new AggregatedQuirks(matchingQuirks)\n     }\n   }\n }\n \n-private[sql] class NoQuirks extends DriverQuirks {\n+class AggregatedQuirks(quirks: List[DriverQuirks]) extends DriverQuirks {\n+  def canHandle(url : String): Boolean =\n+    quirks.foldLeft(true)((l,r) => l && r.canHandle(url))\n+  def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder) : DataType ="
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "How about this:\n\n``` scala\nquirks.map(_.getCatalystType(sqlType, typeName, size, md)).collectFirst {\n  case dataType if dataType != null => dataType\n}.orNull\n```\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T09:08:06Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {\n-    if (url.substring(0, 10).equals(\"jdbc:mysql\")) {\n-      new MySQLQuirks()\n-    } else if (url.substring(0, 15).equals(\"jdbc:postgresql\")) {\n-      new PostgresQuirks()\n-    } else {\n-      new NoQuirks()\n+    val matchingQuirks = quirks.filter(_.canHandle(url))\n+    matchingQuirks.length match {\n+      case 0 => new NoQuirks()\n+      case 1 => matchingQuirks.head\n+      case _ => new AggregatedQuirks(matchingQuirks)\n     }\n   }\n }\n \n-private[sql] class NoQuirks extends DriverQuirks {\n+class AggregatedQuirks(quirks: List[DriverQuirks]) extends DriverQuirks {\n+  def canHandle(url : String): Boolean =\n+    quirks.foldLeft(true)((l,r) => l && r.canHandle(url))\n+  def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder) : DataType =\n+    quirks.foldLeft(null.asInstanceOf[DataType])((l,r) =>\n+      if (l != null) {\n+        l\n+      } else {\n+        r.getCatalystType(sqlType, typeName, size, md)\n+      }\n+    )"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Both `l` and `r` are always non-null pairs. Only `l._1` and `r._1` are possible to be null.\n\n``` scala\nquirks.map(_.getJDBCType(dt)).collectFirst {\n  case p @ (typeName, _) if typeName != null => p\n}.getOrElse((null, None))\n```\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T09:08:08Z",
    "diffHunk": "@@ -39,33 +39,70 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {\n-    if (url.substring(0, 10).equals(\"jdbc:mysql\")) {\n-      new MySQLQuirks()\n-    } else if (url.substring(0, 15).equals(\"jdbc:postgresql\")) {\n-      new PostgresQuirks()\n-    } else {\n-      new NoQuirks()\n+    val matchingQuirks = quirks.filter(_.canHandle(url))\n+    matchingQuirks.length match {\n+      case 0 => new NoQuirks()\n+      case 1 => matchingQuirks.head\n+      case _ => new AggregatedQuirks(matchingQuirks)\n     }\n   }\n }\n \n-private[sql] class NoQuirks extends DriverQuirks {\n+class AggregatedQuirks(quirks: List[DriverQuirks]) extends DriverQuirks {\n+  def canHandle(url : String): Boolean =\n+    quirks.foldLeft(true)((l,r) => l && r.canHandle(url))\n+  def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder) : DataType =\n+    quirks.foldLeft(null.asInstanceOf[DataType])((l,r) =>\n+      if (l != null) {\n+        l\n+      } else {\n+        r.getCatalystType(sqlType, typeName, size, md)\n+      }\n+    )\n+  def getJDBCType(dt: DataType): (String, Option[Int]) =\n+    quirks.foldLeft(null.asInstanceOf[(String, Option[Int])])((l,r) =>\n+      if (l != null) {\n+        l\n+      } else {\n+        r.getJDBCType(dt)\n+      }\n+    )"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Add scala doc to describe the contract for each of these methods.\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T22:39:01Z",
    "diffHunk": "@@ -39,33 +39,68 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "scala doc here as well.  We should probably cover how president works if multiple implementations claim they `canHandle` a given URL.\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T22:40:17Z",
    "diffHunk": "@@ -39,33 +39,68 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) : Unit = {"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Should these be `case object`s?\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T22:40:44Z",
    "diffHunk": "@@ -39,33 +39,68 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) : Unit = {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) : Unit = {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {\n-    if (url.substring(0, 10).equals(\"jdbc:mysql\")) {\n-      new MySQLQuirks()\n-    } else if (url.substring(0, 15).equals(\"jdbc:postgresql\")) {\n-      new PostgresQuirks()\n-    } else {\n-      new NoQuirks()\n+    val matchingQuirks = quirks.filter(_.canHandle(url))\n+    matchingQuirks.length match {\n+      case 0 => new NoQuirks()\n+      case 1 => matchingQuirks.head\n+      case _ => new AggregatedQuirks(matchingQuirks)\n     }\n   }\n }\n \n-private[sql] class NoQuirks extends DriverQuirks {\n+class AggregatedQuirks(quirks: List[DriverQuirks]) extends DriverQuirks {\n+\n+  require(!quirks.isEmpty)\n+\n+  def canHandle(url : String): Boolean =\n+    quirks.map(_.canHandle(url)).reduce(_ && _)\n+\n+  def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType =\n+    quirks.map(_.getCatalystType(sqlType, typeName, size, md)).collectFirst {\n+      case dataType if dataType != null => dataType\n+    }.orNull\n+\n+  def getJDBCType(dt: DataType): (String, Option[Int]) =\n+    quirks.map(_.getJDBCType(dt)).collectFirst {\n+      case t @ (typeName,sqlType) if typeName != null || sqlType.isDefined => t\n+    }.getOrElse((null, None))\n+\n+}\n+\n+class NoQuirks extends DriverQuirks {\n+  def canHandle(url : String): Boolean = true\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType =\n     null\n   def getJDBCType(dt: DataType): (String, Option[Int]) = (null, None)\n }\n \n-private[sql] class PostgresQuirks extends DriverQuirks {\n+class PostgresQuirks extends DriverQuirks {"
  }],
  "prId": 5498
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Does this need to be public?\n",
    "commit": "22d65cac9bb22a9cdda5019042acca0c66e46270",
    "createdAt": "2015-04-15T22:41:17Z",
    "diffHunk": "@@ -39,33 +39,68 @@ import java.sql.Types\n  * if `getJDBCType` returns `(null, None)`, the default type handling is used\n  * for the given Catalyst type.\n  */\n-private[sql] abstract class DriverQuirks {\n+abstract class DriverQuirks {\n+  def canHandle(url : String): Boolean\n   def getCatalystType(sqlType: Int, typeName: String, size: Int, md: MetadataBuilder): DataType\n   def getJDBCType(dt: DataType): (String, Option[Int])\n }\n \n-private[sql] object DriverQuirks {\n+object DriverQuirks {\n+\n+  private var quirks = List[DriverQuirks]()\n+\n+  def registerQuirks(quirk: DriverQuirks) : Unit = {\n+    quirks = quirk :: quirks\n+  }\n+\n+  def unregisterQuirks(quirk : DriverQuirks) : Unit = {\n+    quirks = quirks.filterNot(_ == quirk)\n+  }\n+\n+  registerQuirks(new MySQLQuirks())\n+  registerQuirks(new PostgresQuirks())\n+\n   /**\n    * Fetch the DriverQuirks class corresponding to a given database url.\n    */\n   def get(url: String): DriverQuirks = {"
  }],
  "prId": 5498
}]