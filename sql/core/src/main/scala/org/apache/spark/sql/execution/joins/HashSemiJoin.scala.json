[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Nit: extra space.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-20T22:32:24Z",
    "diffHunk": "@@ -32,34 +32,33 @@ trait HashSemiJoin {\n \n   override def output: Seq[Attribute] = left.output\n \n-  @transient protected lazy val rightKeyGenerator: Projection =\n-    newProjection(rightKeys, right.output)\n-\n-  @transient protected lazy val leftKeyGenerator: () => MutableProjection =\n-    newMutableProjection(leftKeys, left.output)\n+  @transient protected lazy val leftKeyGenerator: Projection =\n+    if (canUseUnsafeRow) {\n+      UnsafeProjection.create(leftKeys, left.output)\n+    } else {\n+      newMutableProjection(leftKeys, left.output)()\n+    }\n \n   @transient private lazy val boundCondition =\n     newPredicate(condition.getOrElse(Literal(true)), left.output ++ right.output)\n \n-  protected def buildKeyHashSet(\n-      buildIter: Iterator[InternalRow],\n-      copy: Boolean): java.util.Set[InternalRow] = {\n+  protected def buildKeyHashSet( buildIter: Iterator[InternalRow]): java.util.Set[InternalRow] = {"
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This looks good to me since it doesn't matter whether we look at `left` or `right` since both should be guaranteed to have the same value of `outputUnsafeRows` by the time that we plan conversions for this operator.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-21T21:16:41Z",
    "diffHunk": "@@ -32,34 +32,45 @@ trait HashSemiJoin {\n \n   override def output: Seq[Attribute] = left.output\n \n-  @transient protected lazy val rightKeyGenerator: Projection =\n-    newProjection(rightKeys, right.output)\n+  protected[this] def supportUnsafe: Boolean = {\n+    (self.codegenEnabled && UnsafeProjection.canSupport(leftKeys)\n+      && UnsafeProjection.canSupport(rightKeys)\n+      && UnsafeProjection.canSupport(left.schema))\n+  }\n+\n+  override def outputsUnsafeRows: Boolean = right.outputsUnsafeRows",
    "line": 12
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Even we can support that the children can have different Row representation, this still correct. Because SemiJoin is kind of filter on `right`.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-21T21:36:43Z",
    "diffHunk": "@@ -32,34 +32,45 @@ trait HashSemiJoin {\n \n   override def output: Seq[Attribute] = left.output\n \n-  @transient protected lazy val rightKeyGenerator: Projection =\n-    newProjection(rightKeys, right.output)\n+  protected[this] def supportUnsafe: Boolean = {\n+    (self.codegenEnabled && UnsafeProjection.canSupport(leftKeys)\n+      && UnsafeProjection.canSupport(rightKeys)\n+      && UnsafeProjection.canSupport(left.schema))\n+  }\n+\n+  override def outputsUnsafeRows: Boolean = right.outputsUnsafeRows",
    "line": 12
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Actually, one question: in the cases where we support UnsafeRows do we always want to force this to use the Unsafe execution path even if the inputs are both safe rows?  If so, I think that we may want to override `canProcessSafeRows` and set it to `!supportUnsafe` in order to force the unsafe path to be taken whenever it can be taken.\n\nAs the code exists now, I think that it will choose the Unsafe path as long as either `left` or `right` already happens to output Unsafe before converters have been applied.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-21T21:19:42Z",
    "diffHunk": "@@ -32,34 +32,45 @@ trait HashSemiJoin {\n \n   override def output: Seq[Attribute] = left.output\n \n-  @transient protected lazy val rightKeyGenerator: Projection =\n-    newProjection(rightKeys, right.output)\n+  protected[this] def supportUnsafe: Boolean = {\n+    (self.codegenEnabled && UnsafeProjection.canSupport(leftKeys)\n+      && UnsafeProjection.canSupport(rightKeys)\n+      && UnsafeProjection.canSupport(left.schema))\n+  }\n+\n+  override def outputsUnsafeRows: Boolean = right.outputsUnsafeRows\n+  override def canProcessUnsafeRows: Boolean = supportUnsafe",
    "line": 13
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Inside this Join, it can handle both safe row and unsafe row, so it's fine to having the children with safe row, and working in Unsafe mode. \n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-21T21:39:21Z",
    "diffHunk": "@@ -32,34 +32,45 @@ trait HashSemiJoin {\n \n   override def output: Seq[Attribute] = left.output\n \n-  @transient protected lazy val rightKeyGenerator: Projection =\n-    newProjection(rightKeys, right.output)\n+  protected[this] def supportUnsafe: Boolean = {\n+    (self.codegenEnabled && UnsafeProjection.canSupport(leftKeys)\n+      && UnsafeProjection.canSupport(rightKeys)\n+      && UnsafeProjection.canSupport(left.schema))\n+  }\n+\n+  override def outputsUnsafeRows: Boolean = right.outputsUnsafeRows\n+  override def canProcessUnsafeRows: Boolean = supportUnsafe",
    "line": 13
  }, {
    "author": {
      "login": "davies"
    },
    "body": "For example, it's possible that there some columns in the right table that are not support by unsafe, but it still can use UnsafeRow for left table (generate hash table and lookup).\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-21T21:41:12Z",
    "diffHunk": "@@ -32,34 +32,45 @@ trait HashSemiJoin {\n \n   override def output: Seq[Attribute] = left.output\n \n-  @transient protected lazy val rightKeyGenerator: Projection =\n-    newProjection(rightKeys, right.output)\n+  protected[this] def supportUnsafe: Boolean = {\n+    (self.codegenEnabled && UnsafeProjection.canSupport(leftKeys)\n+      && UnsafeProjection.canSupport(rightKeys)\n+      && UnsafeProjection.canSupport(left.schema))\n+  }\n+\n+  override def outputsUnsafeRows: Boolean = right.outputsUnsafeRows\n+  override def canProcessUnsafeRows: Boolean = supportUnsafe",
    "line": 13
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Minor style nit, but as long as you're changing this could you update it so that `filter` uses `{` brackets, e.g. `.filter { current =>`?\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-21T21:21:54Z",
    "diffHunk": "@@ -67,25 +78,34 @@ trait HashSemiJoin {\n   }\n \n   protected def hashSemiJoin(\n-      streamIter: Iterator[InternalRow],\n-      hashedRelation: HashedRelation): Iterator[InternalRow] = {\n-    val joinKeys = leftKeyGenerator()\n-    val joinedRow = new JoinedRow\n+    streamIter: Iterator[InternalRow],\n+    hashSet: java.util.Set[InternalRow]): Iterator[InternalRow] = {\n+    val joinKeys = leftKeyGenerator\n     streamIter.filter(current => {\n-      lazy val rowBuffer = hashedRelation.get(joinKeys.currentValue)\n-      !joinKeys(current).anyNull && rowBuffer != null && rowBuffer.exists {\n-        (build: InternalRow) => boundCondition(joinedRow(current, build))\n-      }\n+      val key = joinKeys(current)\n+      !key.anyNull && hashSet.contains(key)\n     })\n   }\n \n+  protected def buildHashRelation(buildIter: Iterator[InternalRow]): HashedRelation = {\n+    if (supportUnsafe) {\n+      UnsafeHashedRelation(buildIter, rightKeys, right)\n+    } else {\n+      HashedRelation(buildIter, newProjection(rightKeys, right.output))\n+    }\n+  }\n+\n   protected def hashSemiJoin(\n       streamIter: Iterator[InternalRow],\n-      hashSet: java.util.Set[InternalRow]): Iterator[InternalRow] = {\n-    val joinKeys = leftKeyGenerator()\n+      hashedRelation: HashedRelation): Iterator[InternalRow] = {\n+    val joinKeys = leftKeyGenerator\n     val joinedRow = new JoinedRow\n     streamIter.filter(current => {"
  }],
  "prId": 7480
}]