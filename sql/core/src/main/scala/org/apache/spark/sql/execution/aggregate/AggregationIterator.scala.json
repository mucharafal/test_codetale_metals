[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "`notExistsFilter` is `predicates.isEmpty`?",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-14T08:13:38Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "Good suggestion!",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-15T07:33:25Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Can you use `val` for `isFinalOrMerge` like this?\r\n```\r\n val isFinalOrMerge = functions.exists(....)\r\n```",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-14T08:15:06Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "`isFinalOrMerge` is related to `expressions`.",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-15T07:39:16Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "If you want to check if they have PartialMerge or Final;\r\n```\r\n      val isFinalOrMerge = expressions.map(_.mode)\r\n        .collect { case PartialMerge | Final => true }.nonEmpty\r\n```",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:04:52Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Then,  plz move this variable to line 223.",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:06:48Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "good idea",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:52:49Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "like this?\r\n```\r\nif (notExistsFilter || isFinalOrMerge) {\r\n  (currentBuffer: InternalRow, row: InternalRow) => {...}\r\n} else {\r\n  (currentBuffer: InternalRow, row: InternalRow) => {...}\r\n}\r\n```",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-14T08:19:25Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>\n               (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n       (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+        if (notExistsFilter || isFinalOrMerge) {"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "Good idea!",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-15T07:51:49Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>\n               (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n       (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+        if (notExistsFilter || isFinalOrMerge) {"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Could you explain about what you do in this code block? Also, plz leave some comments about that.",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-14T08:22:07Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>\n               (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n       (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+        if (notExistsFilter || isFinalOrMerge) {\n+          updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+        } else {\n+          val dynamicMergeExpressions = new ArrayBuffer[Expression]\n+          for (i <- 0 until expressions.length) {\n+            if ((expressions(i).mode == Partial || expressions(i).mode == Complete)) {\n+              if (filterExpressions(i).isDefined) {\n+                if (predicates(i).eval(row)) {\n+                  dynamicMergeExpressions ++= mergeExpressions(i)\n+                } else {\n+                  dynamicMergeExpressions ++= Seq(NoOp)\n+                }\n+              } else {\n+                dynamicMergeExpressions ++= mergeExpressions(i)\n+              }\n+            }\n+          }\n+          if (!dynamicMergeExpressions.isEmpty) {\n+            val dynamicUpdateProjection = newMutableProjection(\n+              dynamicMergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+            dynamicUpdateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+          }"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "```\r\n        // In the list of aggregate expressions, if a filter predicate is specified for at least one\r\n        // aggregate expression and aggregate expressions are in partial or complete mode,\r\n        // then the filter will be used.\r\n        // Suppose there is a list of aggregate expressions, such as exprA with filterA, exprB, exprC with filterC,\r\n        // then the specific implementation process is as follows:\r\n        // 1. Accept data row.\r\n        // 2. Execute multiple aggregate expressions in sequence.\r\n        // 2-1. Filter the data row using filter predicate filterA. If the filter predicate filterA is met,\r\n        //      then calculate using aggregate expression exprA.\r\n        // 2-2. Calculate using aggregate expression exprB.\r\n        // 2-3. Filter the data row using filter predicate filterC. If the filter predicate filterC is met,\r\n        //      then calculate using aggregate expression exprC.\r\n```",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-15T08:27:30Z",
    "diffHunk": "@@ -157,31 +159,61 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      val notExistsFilter = !filterExpressions.exists(_ != None)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>\n               (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n       (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+        if (notExistsFilter || isFinalOrMerge) {\n+          updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+        } else {\n+          val dynamicMergeExpressions = new ArrayBuffer[Expression]\n+          for (i <- 0 until expressions.length) {\n+            if ((expressions(i).mode == Partial || expressions(i).mode == Complete)) {\n+              if (filterExpressions(i).isDefined) {\n+                if (predicates(i).eval(row)) {\n+                  dynamicMergeExpressions ++= mergeExpressions(i)\n+                } else {\n+                  dynamicMergeExpressions ++= Seq(NoOp)\n+                }\n+              } else {\n+                dynamicMergeExpressions ++= mergeExpressions(i)\n+              }\n+            }\n+          }\n+          if (!dynamicMergeExpressions.isEmpty) {\n+            val dynamicUpdateProjection = newMutableProjection(\n+              dynamicMergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+            dynamicUpdateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+          }"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "`Map` instead of `HashMap`?",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-14T08:34:09Z",
    "diffHunk": "@@ -40,6 +41,7 @@ abstract class AggregationIterator(\n     aggregateAttributes: Seq[Attribute],\n     initialInputBufferOffset: Int,\n     resultExpressions: Seq[NamedExpression],\n+    predicates: HashMap[Int, GenPredicate],"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "OK.",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-15T07:33:34Z",
    "diffHunk": "@@ -40,6 +41,7 @@ abstract class AggregationIterator(\n     aggregateAttributes: Seq[Attribute],\n     initialInputBufferOffset: Int,\n     resultExpressions: Seq[NamedExpression],\n+    predicates: HashMap[Int, GenPredicate],"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Why did you use the two variables `predicates` and `filterExpressions` for filter?",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T08:18:51Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "OK. I will use predicates only.",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:36:31Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "I'm a bit worrid that this cloure can cause some performance overhead when processing regular non-filter aggregate functions. cc: @cloud-fan ",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:08:52Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>\n               (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n-      (currentBuffer: InternalRow, row: InternalRow) => {\n-        // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+      val processImperative = (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all imperative aggregate functions.\n         var i = 0\n         while (i < updateFunctions.length) {\n           updateFunctions(i)(currentBuffer, row)\n           i += 1\n         }\n       }\n+\n+      // The following two situations will adopt a common implementation:\n+      // First, no filter predicate is specified for any aggregate expression.\n+      // Second, aggregate expressions are in merge or final mode.\n+      if (predicates.isEmpty || isFinalOrMerge) {\n+        (currentBuffer: InternalRow, row: InternalRow) => {\n+          updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+          processImperative(currentBuffer, row)"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Why did you change `functions.zip(expressions).flatMap` to `functions.zipWithIndex.collect` here?",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:20:43Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "Line 248 and 250 will use the index，so I make this change",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:53:17Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "nit: like this?\r\n```\r\n            case Partial | Complete =>\r\n              if (predicateOptions(i).isDefined) {\r\n                (buffer: InternalRow, row: InternalRow) =>\r\n                  if (predicateOptions(i).get.eval(row)) { ae.update(buffer, row) }\r\n              } else {\r\n                (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\r\n              }\r\n```",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:27:43Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "I have improved in another way",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:55:08Z",
    "diffHunk": "@@ -157,38 +180,89 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      val filterExpressions = expressions.map(_.filter)\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n-            case Partial | Complete =>\n+            case Partial | Complete if filterExpressions(i).isDefined =>\n+              (buffer: InternalRow, row: InternalRow) =>\n+                if (predicates(i).eval(row)) { ae.update(buffer, row) }\n+            case Partial | Complete if filterExpressions(i).isEmpty =>"
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "I think we don't need this variable outside generateProcessRow, so can you move this variable inside it like this?\r\n```\r\n  // Initializing functions used to process a row.\r\n  protected def generateProcessRow(\r\n      expressions: Seq[AggregateExpression],\r\n      functions: Seq[AggregateFunction],\r\n      inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\r\n    val joinedRow = new JoinedRow\r\n    if (expressions.nonEmpty) {\r\n      // Initialize predicates for aggregate functions if necessary\r\n      val predicateOptions = expressions.map {\r\n        case AggregateExpression(_, mode, _, Some(filter), _) =>\r\n          mode match {\r\n            case Partial | Complete =>\r\n              val filterAttrs = filter.references.toSeq\r\n              val predicate = Predicate.create(filter, inputAttributes ++ filterAttrs)\r\n              predicate.initialize(partIndex)\r\n              Some(predicate)\r\n            case _ =>\r\n              None\r\n          }\r\n        case _ =>\r\n          None\r\n      }\r\n      ....\r\n```",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:43:25Z",
    "diffHunk": "@@ -116,12 +116,35 @@ abstract class AggregationIterator(\n   protected val aggregateFunctions: Array[AggregateFunction] =\n     initializeAggregateFunctions(aggregateExpressions, initialInputBufferOffset)\n \n+  protected def initializeFilterPredicates(\n+      expressions: Seq[AggregateExpression]): mutable.Map[Int, BasePredicate] = {\n+    val filterPredicates = new mutable.HashMap[Int, BasePredicate]\n+    expressions.zipWithIndex.foreach {\n+      case (ae: AggregateExpression, i) =>\n+        ae.mode match {\n+          case Partial | Complete =>\n+            ae.filter.foreach { filterExpr =>\n+              val filterAttrs = filterExpr.references.toSeq\n+              val predicate = Predicate.create(filterExpr, inputAttributes ++ filterAttrs)\n+              predicate.initialize(partIndex)\n+              filterPredicates(i) = predicate\n+            }\n+          case _ =>\n+        }\n+      case _ =>\n+    }\n+    filterPredicates\n+  }\n+\n+  protected val predicates: mutable.Map[Int, BasePredicate] ="
  }],
  "prId": 26420
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Can you move the `predicate` process for expression-based agg functions outside this row-by-row loop? The current code can cause overkilling overhead when processing rows....",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T09:48:23Z",
    "diffHunk": "@@ -157,38 +180,87 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n             case Partial | Complete =>\n-              (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n+              Option(predicates(i)) match {\n+                case Some(predicate) =>\n+                  (buffer: InternalRow, row: InternalRow) =>\n+                    if (predicate.eval(row)) { ae.update(buffer, row) }\n+                case _ => (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n+              }\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n-      (currentBuffer: InternalRow, row: InternalRow) => {\n-        // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+      val processImperative = (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all imperative aggregate functions.\n         var i = 0\n         while (i < updateFunctions.length) {\n           updateFunctions(i)(currentBuffer, row)\n           i += 1\n         }\n       }\n+\n+      // The following two situations will adopt a common implementation:\n+      // First, no filter predicate is specified for any aggregate expression.\n+      // Second, aggregate expressions are in merge or final mode.\n+      if (predicates.isEmpty || isFinalOrMerge) {\n+        (currentBuffer: InternalRow, row: InternalRow) => {\n+          updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+          processImperative(currentBuffer, row)\n+        }\n+      } else {\n+        // In the list of aggregate expressions, if a filter predicate is specified for at least one\n+        // aggregate expression and aggregate expressions are in partial or complete mode,\n+        // then the filter will be used.\n+        // Suppose there is a list of aggregate expressions, such as exprA with filterA, exprB,\n+        // exprC with filterC, then the specific implementation process is as follows:\n+        // 1. Accept data row.\n+        // 2. Execute multiple aggregate expressions in sequence.\n+        // 2-1. Filter the data row using filter predicate filterA. If the filter predicate\n+        //      filterA is met, then calculate using aggregate expression exprA.\n+        // 2-2. Calculate using aggregate expression exprB.\n+        // 2-3. Filter the data row using filter predicate filterC. If the filter predicate\n+        //      filterC is met, then calculate using aggregate expression exprC.\n+        (currentBuffer: InternalRow, row: InternalRow) => {\n+          val dynamicMergeExpressions = new mutable.ArrayBuffer[Expression]"
  }, {
    "author": {
      "login": "beliefer"
    },
    "body": "I need some time to think about it.",
    "commit": "43b15aed468b19efb32c33d43061d7f562e42339",
    "createdAt": "2019-11-23T11:02:46Z",
    "diffHunk": "@@ -157,38 +180,87 @@ abstract class AggregationIterator(\n       inputAttributes: Seq[Attribute]): (InternalRow, InternalRow) => Unit = {\n     val joinedRow = new JoinedRow\n     if (expressions.nonEmpty) {\n-      val mergeExpressions = functions.zip(expressions).flatMap {\n-        case (ae: DeclarativeAggregate, expression) =>\n-          expression.mode match {\n+      var isFinalOrMerge = false\n+      val mergeExpressions = functions.zipWithIndex.collect {\n+        case (ae: DeclarativeAggregate, i) =>\n+          expressions(i).mode match {\n             case Partial | Complete => ae.updateExpressions\n-            case PartialMerge | Final => ae.mergeExpressions\n+            case PartialMerge | Final =>\n+              isFinalOrMerge = true\n+              ae.mergeExpressions\n           }\n         case (agg: AggregateFunction, _) => Seq.fill(agg.aggBufferAttributes.length)(NoOp)\n       }\n       val updateFunctions = functions.zipWithIndex.collect {\n         case (ae: ImperativeAggregate, i) =>\n           expressions(i).mode match {\n             case Partial | Complete =>\n-              (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n+              Option(predicates(i)) match {\n+                case Some(predicate) =>\n+                  (buffer: InternalRow, row: InternalRow) =>\n+                    if (predicate.eval(row)) { ae.update(buffer, row) }\n+                case _ => (buffer: InternalRow, row: InternalRow) => ae.update(buffer, row)\n+              }\n             case PartialMerge | Final =>\n               (buffer: InternalRow, row: InternalRow) => ae.merge(buffer, row)\n           }\n       }.toArray\n       // This projection is used to merge buffer values for all expression-based aggregates.\n       val aggregationBufferSchema = functions.flatMap(_.aggBufferAttributes)\n-      val updateProjection =\n-        newMutableProjection(mergeExpressions, aggregationBufferSchema ++ inputAttributes)\n+      val updateProjection = newMutableProjection(\n+        mergeExpressions.flatMap(_.seq), aggregationBufferSchema ++ inputAttributes)\n \n-      (currentBuffer: InternalRow, row: InternalRow) => {\n-        // Process all expression-based aggregate functions.\n-        updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+      val processImperative = (currentBuffer: InternalRow, row: InternalRow) => {\n         // Process all imperative aggregate functions.\n         var i = 0\n         while (i < updateFunctions.length) {\n           updateFunctions(i)(currentBuffer, row)\n           i += 1\n         }\n       }\n+\n+      // The following two situations will adopt a common implementation:\n+      // First, no filter predicate is specified for any aggregate expression.\n+      // Second, aggregate expressions are in merge or final mode.\n+      if (predicates.isEmpty || isFinalOrMerge) {\n+        (currentBuffer: InternalRow, row: InternalRow) => {\n+          updateProjection.target(currentBuffer)(joinedRow(currentBuffer, row))\n+          processImperative(currentBuffer, row)\n+        }\n+      } else {\n+        // In the list of aggregate expressions, if a filter predicate is specified for at least one\n+        // aggregate expression and aggregate expressions are in partial or complete mode,\n+        // then the filter will be used.\n+        // Suppose there is a list of aggregate expressions, such as exprA with filterA, exprB,\n+        // exprC with filterC, then the specific implementation process is as follows:\n+        // 1. Accept data row.\n+        // 2. Execute multiple aggregate expressions in sequence.\n+        // 2-1. Filter the data row using filter predicate filterA. If the filter predicate\n+        //      filterA is met, then calculate using aggregate expression exprA.\n+        // 2-2. Calculate using aggregate expression exprB.\n+        // 2-3. Filter the data row using filter predicate filterC. If the filter predicate\n+        //      filterC is met, then calculate using aggregate expression exprC.\n+        (currentBuffer: InternalRow, row: InternalRow) => {\n+          val dynamicMergeExpressions = new mutable.ArrayBuffer[Expression]"
  }],
  "prId": 26420
}]