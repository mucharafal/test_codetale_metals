[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "We should be using SQLConf and create a special setting for external aggregation.\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-08T18:05:33Z",
    "diffHunk": "@@ -45,6 +46,8 @@ case class Aggregate(\n     child: SparkPlan)\n   extends UnaryNode {\n \n+  private val externalSorting = SparkEnv.get.conf.getBoolean(\"spark.shuffle.spill\", false)"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Instead of doing the if check here, what do you think about this:\n- Create a trait called `Aggregate` that contains shared code.\n- Create two operators `OnHeapAggregation` and `ExternalAggregation`.\n- Choose which one to use in the planner based on the above configuration.\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-08T18:06:54Z",
    "diffHunk": "@@ -148,53 +151,121 @@ case class Aggregate(\n         Iterator(resultProjection(aggregateResults))\n       }\n     } else {\n-      child.execute().mapPartitions { iter =>\n-        val hashTable = new HashMap[Row, Array[AggregateFunction]]\n-        val groupingProjection = new InterpretedMutableProjection(groupingExpressions, childOutput)\n+      if (!externalSorting) {"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "How about we add something like `Concrete subclasses of this trait must implement the following abstract members:`  and then use [wiki syntax](https://wiki.scala-lang.org/display/SW/Syntax) to make the items into a list.\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-13T18:47:57Z",
    "diffHunk": "@@ -20,30 +20,31 @@ package org.apache.spark.sql.execution\n import java.util.HashMap\n \n import org.apache.spark.annotation.DeveloperApi\n-import org.apache.spark.SparkContext\n+import org.apache.spark.{SparkEnv, SparkContext}\n import org.apache.spark.sql.catalyst.errors._\n import org.apache.spark.sql.catalyst.expressions._\n import org.apache.spark.sql.catalyst.plans.physical._\n import org.apache.spark.sql.SQLContext\n+import org.apache.spark.util.collection.ExternalAppendOnlyMap\n \n /**\n- * :: DeveloperApi ::\n  * Groups input data by `groupingExpressions` and computes the `aggregateExpressions` for each\n  * group.\n  *\n- * @param partial if true then aggregation is done partially on local data without shuffling to\n+ * partial if true then aggregation is done partially on local data without shuffling to"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "`protected` instead of making this public.\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-13T18:48:47Z",
    "diffHunk": "@@ -58,7 +59,7 @@ case class Aggregate(\n \n   // HACK: Generators don't correctly preserve their output through serializations so we grab\n   // out child's output attributes statically here.\n-  private[this] val childOutput = child.output\n+  val childOutput = child.output"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "`protected`\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-13T18:48:57Z",
    "diffHunk": "@@ -90,7 +91,7 @@ case class Aggregate(\n   private[this] val computedSchema = computedAggregates.map(_.resultAttribute)\n \n   /** Creates a new aggregate buffer for a group. */\n-  private[this] def newAggregateBuffer(): Array[AggregateFunction] = {\n+  def newAggregateBuffer(): Array[AggregateFunction] = {"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Probably could be `protected`.\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-13T18:51:31Z",
    "diffHunk": "@@ -123,34 +124,73 @@ case class Aggregate(\n     }\n   }\n \n-  override def execute() = attachTree(this, \"execute\") {\n-    if (groupingExpressions.isEmpty) {\n-      child.execute().mapPartitions { iter =>\n-        val buffer = newAggregateBuffer()\n-        var currentRow: Row = null\n-        while (iter.hasNext) {\n-          currentRow = iter.next()\n-          var i = 0\n-          while (i < buffer.length) {\n-            buffer(i).update(currentRow)\n-            i += 1\n-          }\n-        }\n-        val resultProjection = new InterpretedProjection(resultExpressions, computedSchema)\n-        val aggregateResults = new GenericMutableRow(computedAggregates.length)\n-\n+  def aggregateNoGrouping() = {"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Can you add some scala doc to explain whats going on here?\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-13T18:52:18Z",
    "diffHunk": "@@ -123,34 +124,73 @@ case class Aggregate(\n     }\n   }\n \n-  override def execute() = attachTree(this, \"execute\") {\n-    if (groupingExpressions.isEmpty) {\n-      child.execute().mapPartitions { iter =>\n-        val buffer = newAggregateBuffer()\n-        var currentRow: Row = null\n-        while (iter.hasNext) {\n-          currentRow = iter.next()\n-          var i = 0\n-          while (i < buffer.length) {\n-            buffer(i).update(currentRow)\n-            i += 1\n-          }\n-        }\n-        val resultProjection = new InterpretedProjection(resultExpressions, computedSchema)\n-        val aggregateResults = new GenericMutableRow(computedAggregates.length)\n-\n+  def aggregateNoGrouping() = {\n+    child.execute().mapPartitions { iter =>\n+      val buffer = newAggregateBuffer()\n+      var currentRow: Row = null\n+      while (iter.hasNext) {\n+        currentRow = iter.next()\n         var i = 0\n         while (i < buffer.length) {\n-          aggregateResults(i) = buffer(i).eval(EmptyRow)\n+          buffer(i).update(currentRow)\n           i += 1\n         }\n+      }\n+      val resultProjection = new InterpretedProjection(resultExpressions, computedSchema)\n+      val aggregateResults = new GenericMutableRow(computedAggregates.length)\n \n-        Iterator(resultProjection(aggregateResults))\n+      var i = 0\n+      while (i < buffer.length) {\n+        aggregateResults(i) = buffer(i).eval(EmptyRow)\n+        i += 1\n       }\n+\n+      Iterator(resultProjection(aggregateResults))\n+    }\n+  }\n+\n+  def resultRow(iter: Iterator[(Row,Array[AggregateFunction])]) = {"
  }],
  "prId": 1822
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "I am a little concerned about the addition of an extra tuple object allocation here.  This may not be a problem, but we'll want to run some benchmarks and make sure that we are not slowing down the on-heap version here.\n",
    "commit": "03dea6b8c004275f8a295cf3ba8f4a57f78e647e",
    "createdAt": "2014-08-13T18:55:33Z",
    "diffHunk": "@@ -168,32 +208,68 @@ case class Aggregate(\n             i += 1\n           }\n         }\n-\n-        new Iterator[Row] {\n+        val iterPair = new Iterator[(Row, Array[AggregateFunction])] {\n           private[this] val hashTableIter = hashTable.entrySet().iterator()\n-          private[this] val aggregateResults = new GenericMutableRow(computedAggregates.length)\n-          private[this] val resultProjection =\n-            new InterpretedMutableProjection(\n-              resultExpressions, computedSchema ++ namedGroups.map(_._2))\n-          private[this] val joinedRow = new JoinedRow\n-\n           override final def hasNext: Boolean = hashTableIter.hasNext\n \n-          override final def next(): Row = {\n+          override final def next(): (Row, Array[AggregateFunction]) = {"
  }],
  "prId": 1822
}]