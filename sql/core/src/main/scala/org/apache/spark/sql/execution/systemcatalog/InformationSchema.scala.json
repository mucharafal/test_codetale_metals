[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "I was thinking having sparksession.catalog calling these commands, but I guess it is ok this way too ...\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T21:10:15Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {\n+    val plan = LogicalRelation(relation).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names)\n+      sparkSession.sessionState.catalog.createTempView(name, plan, overrideIfExists = true)\n+  }\n+\n+  def build(sparkSession: SparkSession) {\n+    // Create database\n+    val informationSchemaDb = new CatalogDatabase(\n+      \"information_schema\",\n+      \"Spark information schema\",\n+      locationUri = \"/tmp/\",\n+      Map())\n+    sparkSession.sessionState.catalog.createDatabase(informationSchemaDb, ignoreIfExists = true)\n+\n+    // Create tables\n+    register(sparkSession, new DatabasesRelation(sparkSession), Seq(\"schemata\", \"databases\"))\n+    register(sparkSession, new TablesRelation(sparkSession), Seq(\"tables\"))\n+    register(sparkSession, new ViewsRelation(sparkSession), Seq(\"views\"))\n+    register(sparkSession, new ColumnsRelation(sparkSession), Seq(\"columns\"))\n+    register(sparkSession, new SessionVariablesRelation(sparkSession), Seq(\"session_variables\"))\n+  }\n+}\n+\n+class DatabasesSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    DatabasesRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class DatabasesRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"CATALOG_NAME\", StringType, false),\n+    StructField(\"SCHEMA_NAME\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listDatabases()"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can we rename this SessionVariablesRelationProvider and then inline SessionVariablesRelation in here?\n\ne.g.\n\n```\ndef createRelation(...) = {\n  new BaseRelation with PrunedFilteredScan {\n\n  }\n}\n```\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T21:12:15Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {\n+    val plan = LogicalRelation(relation).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names)\n+      sparkSession.sessionState.catalog.createTempView(name, plan, overrideIfExists = true)\n+  }\n+\n+  def build(sparkSession: SparkSession) {\n+    // Create database\n+    val informationSchemaDb = new CatalogDatabase(\n+      \"information_schema\",\n+      \"Spark information schema\",\n+      locationUri = \"/tmp/\",\n+      Map())\n+    sparkSession.sessionState.catalog.createDatabase(informationSchemaDb, ignoreIfExists = true)\n+\n+    // Create tables\n+    register(sparkSession, new DatabasesRelation(sparkSession), Seq(\"schemata\", \"databases\"))\n+    register(sparkSession, new TablesRelation(sparkSession), Seq(\"tables\"))\n+    register(sparkSession, new ViewsRelation(sparkSession), Seq(\"views\"))\n+    register(sparkSession, new ColumnsRelation(sparkSession), Seq(\"columns\"))\n+    register(sparkSession, new SessionVariablesRelation(sparkSession), Seq(\"session_variables\"))\n+  }\n+}\n+\n+class DatabasesSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    DatabasesRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class DatabasesRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"CATALOG_NAME\", StringType, false),\n+    StructField(\"SCHEMA_NAME\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listDatabases()\n+      .selectExpr(\n+        \"'default' as CATALOG_NAME\",\n+        \"name as SCHEMA_NAME\")\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class TablesSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    TablesRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class TablesRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"TABLE_CATALOG\", StringType, false),\n+    StructField(\"TABLE_SCHEMA\", StringType, false),\n+    StructField(\"TABLE_NAME\", StringType, false),\n+    StructField(\"TABLE_TYPE\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listTables()\n+      .selectExpr(\n+        \"'default' as TABLE_CATALOG\",\n+        \"IFNULL(database, 'default') as TABLE_SCHEMA\",\n+        \"name as TABLE_NAME\",\n+        \"IF(isTemporary,'VIEW','TABLE') as TABLE_TYPE\")\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class ViewsSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    ViewsRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class ViewsRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"TABLE_CATALOG\", StringType, false),\n+    StructField(\"TABLE_SCHEMA\", StringType, false),\n+    StructField(\"TABLE_NAME\", StringType, false),\n+    StructField(\"VIEW_DEFINITION\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listTables()\n+      .where(\"isTemporary\")\n+      .selectExpr(\n+        \"'default' as TABLE_CATALOG\",\n+        \"IFNULL(database, 'default') as TABLE_SCHEMA\",\n+        \"name as TABLE_NAME\",\n+        \"IFNULL(description,'VIEW') as VIEW_DEFINITION\") // TODO\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class ColumnsSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    ColumnsRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class ColumnsRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"TABLE_CATALOG\", StringType, false),\n+    StructField(\"TABLE_SCHEMA\", StringType, false),\n+    StructField(\"TABLE_NAME\", StringType, false),\n+    StructField(\"COLUMN_NAME\", StringType, false),\n+    StructField(\"ORDINAL_POSITION\", LongType, false),\n+    StructField(\"IS_NULLABLE\", BooleanType, false),\n+    StructField(\"DATA_TYPE\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    val tables = sparkSession.catalog.listTables().collect()\n+    val result = new ArrayBuffer[Row]\n+    for (t <- tables) {\n+      val database = t.database\n+      val table = t.name\n+      if (t.database == null) {\n+        // TODO: SPARK-16458\n+      } else {\n+        result ++= sparkSession.catalog.listColumns(t.database, t.name).rdd.zipWithIndex.map {\n+          case (col, index) =>\n+            Row(\"default\", database, table, col.name, index, col.nullable, col.dataType)\n+        }.collect()\n+      }\n+    }\n+    sparkSession\n+      .createDataFrame(sparkSession.sparkContext.parallelize(result), schema)\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class SessionVariablesSource extends SchemaRelationProvider {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Is this inline advice for all other Providers and Relations?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T23:04:53Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {\n+    val plan = LogicalRelation(relation).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names)\n+      sparkSession.sessionState.catalog.createTempView(name, plan, overrideIfExists = true)\n+  }\n+\n+  def build(sparkSession: SparkSession) {\n+    // Create database\n+    val informationSchemaDb = new CatalogDatabase(\n+      \"information_schema\",\n+      \"Spark information schema\",\n+      locationUri = \"/tmp/\",\n+      Map())\n+    sparkSession.sessionState.catalog.createDatabase(informationSchemaDb, ignoreIfExists = true)\n+\n+    // Create tables\n+    register(sparkSession, new DatabasesRelation(sparkSession), Seq(\"schemata\", \"databases\"))\n+    register(sparkSession, new TablesRelation(sparkSession), Seq(\"tables\"))\n+    register(sparkSession, new ViewsRelation(sparkSession), Seq(\"views\"))\n+    register(sparkSession, new ColumnsRelation(sparkSession), Seq(\"columns\"))\n+    register(sparkSession, new SessionVariablesRelation(sparkSession), Seq(\"session_variables\"))\n+  }\n+}\n+\n+class DatabasesSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    DatabasesRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class DatabasesRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"CATALOG_NAME\", StringType, false),\n+    StructField(\"SCHEMA_NAME\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listDatabases()\n+      .selectExpr(\n+        \"'default' as CATALOG_NAME\",\n+        \"name as SCHEMA_NAME\")\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class TablesSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    TablesRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class TablesRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"TABLE_CATALOG\", StringType, false),\n+    StructField(\"TABLE_SCHEMA\", StringType, false),\n+    StructField(\"TABLE_NAME\", StringType, false),\n+    StructField(\"TABLE_TYPE\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listTables()\n+      .selectExpr(\n+        \"'default' as TABLE_CATALOG\",\n+        \"IFNULL(database, 'default') as TABLE_SCHEMA\",\n+        \"name as TABLE_NAME\",\n+        \"IF(isTemporary,'VIEW','TABLE') as TABLE_TYPE\")\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class ViewsSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    ViewsRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class ViewsRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"TABLE_CATALOG\", StringType, false),\n+    StructField(\"TABLE_SCHEMA\", StringType, false),\n+    StructField(\"TABLE_NAME\", StringType, false),\n+    StructField(\"VIEW_DEFINITION\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    sparkSession.catalog.listTables()\n+      .where(\"isTemporary\")\n+      .selectExpr(\n+        \"'default' as TABLE_CATALOG\",\n+        \"IFNULL(database, 'default') as TABLE_SCHEMA\",\n+        \"name as TABLE_NAME\",\n+        \"IFNULL(description,'VIEW') as VIEW_DEFINITION\") // TODO\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class ColumnsSource extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    ColumnsRelation(sqlContext.sparkSession)\n+  }\n+}\n+\n+case class ColumnsRelation(@transient sparkSession: SparkSession)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  override def sqlContext: SQLContext = sparkSession.sqlContext\n+\n+  override def schema: StructType = StructType(Seq(\n+    StructField(\"TABLE_CATALOG\", StringType, false),\n+    StructField(\"TABLE_SCHEMA\", StringType, false),\n+    StructField(\"TABLE_NAME\", StringType, false),\n+    StructField(\"COLUMN_NAME\", StringType, false),\n+    StructField(\"ORDINAL_POSITION\", LongType, false),\n+    StructField(\"IS_NULLABLE\", BooleanType, false),\n+    StructField(\"DATA_TYPE\", StringType, false)\n+  ))\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    val tables = sparkSession.catalog.listTables().collect()\n+    val result = new ArrayBuffer[Row]\n+    for (t <- tables) {\n+      val database = t.database\n+      val table = t.name\n+      if (t.database == null) {\n+        // TODO: SPARK-16458\n+      } else {\n+        result ++= sparkSession.catalog.listColumns(t.database, t.name).rdd.zipWithIndex.map {\n+          case (col, index) =>\n+            Row(\"default\", database, table, col.name, index, col.nullable, col.dataType)\n+        }.collect()\n+      }\n+    }\n+    sparkSession\n+      .createDataFrame(sparkSession.sparkContext.parallelize(result), schema)\n+      .select(requiredColumns.head, requiredColumns.tail: _*).rdd\n+  }\n+}\n+\n+class SessionVariablesSource extends SchemaRelationProvider {"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "private? \n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T21:14:39Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "and setupTable or registerTable\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T21:15:31Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I used `registerTable`.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T23:37:12Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "build is a weird term - i'd name it something like registerInformationSchema or setupInformationSchema.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T21:15:19Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {\n+    val plan = LogicalRelation(relation).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names)\n+      sparkSession.sessionState.catalog.createTempView(name, plan, overrideIfExists = true)\n+  }\n+\n+  def build(sparkSession: SparkSession) {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Here, `registerInformationSchema`.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-09T23:37:21Z",
    "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.CatalogDatabase\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+object InformationSchema extends Logging {\n+  def register(sparkSession: SparkSession, relation: BaseRelation, names: Seq[String]) {\n+    val plan = LogicalRelation(relation).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names)\n+      sparkSession.sessionState.catalog.createTempView(name, plan, overrideIfExists = true)\n+  }\n+\n+  def build(sparkSession: SparkSession) {"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "`val` maybe?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T06:49:27Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  var INFORMATION_SCHEMA = \"information_schema\""
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oh, thank you for review! Right.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T07:00:47Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  var INFORMATION_SCHEMA = \"information_schema\""
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "`s\"CREATE DATABASE IF NOT EXISTS ${INFORMATION_SCHEMA}\"` ?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T06:52:18Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  var INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession) {\n+    sparkSession.sql(\"CREATE DATABASE IF NOT EXISTS information_schema\")"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T07:02:17Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  var INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession) {\n+    sparkSession.sql(\"CREATE DATABASE IF NOT EXISTS information_schema\")"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "`def registerInformationSchema(sparkSession: SparkSession): Unit = {` maybe? Public methods usually should have explicit return types.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T06:56:52Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  var INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession) {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Right.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T07:02:34Z",
    "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  var INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession) {"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "lw-lin"
    },
    "body": "This whole function does have great merit, but I feel @liancheng had implemented something similar before? @liancheng could you confirm? Thanks!\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T07:28:45Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "This one comes from JDBC module. I intentionally copy the code, not calling them.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T08:12:29Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "Oh I see. Then if we won't dedup this for now, let's leave some comments saying if we should change some piece of code please don't forget to change the other? What do you think?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T08:26:06Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Definitely, it would be good. This PR is still waiting some dependency PRs. While discussing, we can refactoring `compileFilter` into some `Utils` functions, too. @rxin , any advices for this?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T08:40:02Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "@lw-lin The one you referred to is probably `ParquetFilters.createFilter()`, which is another story.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T11:29:27Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "@liancheng Oh I was thinking about https://github.com/apache/spark/pull/10541,which also is another story :-) Thanks for the information!\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T11:55:11Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Sorry I'm pretty confused. Why do we need this at all?\n\nI was thinking just doing some very basic predicate pushdown, e.g. when calling list tables, if the database name is specified, then we don't need to get all the tables that are not part of the database out of the catalog. Same thing with basic pattern matching.\n\nI didn't look very closely, but the way this is working is very complicated and does not actually push anything into the catalog. It is basically doing no-op.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T19:47:06Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oh, I see. You meant simply pushdown by choosing `listTable()` or `listTable(database, table)`.\nI overrided `unhandledFilters` and tried to handle all filters generally in this layer in a wrong way.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T19:57:31Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Yea the current way of doing it has no real benefit.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T19:59:25Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. I cleaned up. By the way, may I replace `PrunedFilteredScan` with `CatalystScan`, too?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T20:06:23Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "it might make it easier to implement catalystscan\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T20:11:09Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep, right.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T20:14:03Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "We could also use CatalystScan here. That could save us little trouble.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T13:11:21Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {\n+    Option(f match {\n+      case EqualTo(attr, value) => s\"$attr = ${compileValue(value)}\"\n+      case EqualNullSafe(attr, value) =>\n+        s\"(NOT ($attr != ${compileValue(value)} OR $attr IS NULL OR \" +\n+          s\"${compileValue(value)} IS NULL) OR \" +\n+          s\"($attr IS NULL AND ${compileValue(value)} IS NULL))\"\n+      case LessThan(attr, value) => s\"$attr < ${compileValue(value)}\"\n+      case GreaterThan(attr, value) => s\"$attr > ${compileValue(value)}\"\n+      case LessThanOrEqual(attr, value) => s\"$attr <= ${compileValue(value)}\"\n+      case GreaterThanOrEqual(attr, value) => s\"$attr >= ${compileValue(value)}\"\n+      case IsNull(attr) => s\"$attr IS NULL\"\n+      case IsNotNull(attr) => s\"$attr IS NOT NULL\"\n+      case StringStartsWith(attr, value) => s\"${attr} LIKE '${value}%'\"\n+      case StringEndsWith(attr, value) => s\"${attr} LIKE '%${value}'\"\n+      case StringContains(attr, value) => s\"${attr} LIKE '%${value}%'\"\n+      case In(attr, value) => s\"$attr IN (${compileValue(value)})\"\n+      case Not(f) => compileFilter(f).map(p => s\"(NOT ($p))\").orNull\n+      case Or(f1, f2) =>\n+        val or = Seq(f1, f2).flatMap(compileFilter(_))\n+        if (or.size == 2) {\n+          or.map(p => s\"($p)\").mkString(\" OR \")\n+        } else {\n+          null\n+        }\n+      case And(f1, f2) =>\n+        val and = Seq(f1, f2).flatMap(compileFilter(_))\n+        if (and.size == 2) {\n+          and.map(p => s\"($p)\").mkString(\" AND \")\n+        } else {\n+          null\n+        }\n+      case _ => null\n+    })\n+  }\n+\n+  /**\n+   * Converts value into string expression.\n+   */\n+  private[systemcatalog] def compileValue(value: Any): Any = value match {\n+    case s: String =>\n+      val escapedValue = if (s == null) null else StringUtils.replace(s, \"'\", \"''\")\n+      s\"'$escapedValue'\"\n+    case t: Timestamp => \"'\" + t + \"'\"\n+    case d: Date => \"'\" + d + \"'\"\n+    case a: Array[Any] => a.map(compileValue).mkString(\", \")\n+    case _ => value\n+  }\n+}\n+\n+/**\n+ * Provides DATABASES relation consisting all databases.\n+ */\n+private class DatabasesRelationProvider extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    val sparkSession = sqlContext.sparkSession\n+\n+    new BaseRelation with PrunedFilteredScan {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ur, actually, I used `PrunedFilteredScan` because I thought`CatalystScan` is annotated Experimental and no classes extends that trait. Is there any know troubles with `PrunedFilteredScan`?\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-11T19:42:58Z",
    "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import java.sql.{Date, Timestamp}\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.commons.lang3.StringUtils\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ */\n+object InformationSchema {\n+  val INFORMATION_SCHEMA = \"information_schema\"\n+  /**\n+   * Register INFORMATION_SCHEMA database.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register a INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+    for (name <- names) {\n+      // TODO(dongjoon): This is a hack to give a database concept for Spark temporary views.\n+      // We should generalize this later.\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Compile filter array into single string condition.\n+   */\n+  private[systemcatalog] def getConditionExpressionString(filters: Array[Filter]): String = {\n+    val str = filters.flatMap(InformationSchema.compileFilter).map(p => s\"($p)\").mkString(\" AND \")\n+    if (str.length == 0) \"TRUE\" else str\n+  }\n+\n+  /**\n+   * Convert filter into string expression.\n+   */\n+  private[systemcatalog] def compileFilter(f: Filter): Option[String] = {\n+    Option(f match {\n+      case EqualTo(attr, value) => s\"$attr = ${compileValue(value)}\"\n+      case EqualNullSafe(attr, value) =>\n+        s\"(NOT ($attr != ${compileValue(value)} OR $attr IS NULL OR \" +\n+          s\"${compileValue(value)} IS NULL) OR \" +\n+          s\"($attr IS NULL AND ${compileValue(value)} IS NULL))\"\n+      case LessThan(attr, value) => s\"$attr < ${compileValue(value)}\"\n+      case GreaterThan(attr, value) => s\"$attr > ${compileValue(value)}\"\n+      case LessThanOrEqual(attr, value) => s\"$attr <= ${compileValue(value)}\"\n+      case GreaterThanOrEqual(attr, value) => s\"$attr >= ${compileValue(value)}\"\n+      case IsNull(attr) => s\"$attr IS NULL\"\n+      case IsNotNull(attr) => s\"$attr IS NOT NULL\"\n+      case StringStartsWith(attr, value) => s\"${attr} LIKE '${value}%'\"\n+      case StringEndsWith(attr, value) => s\"${attr} LIKE '%${value}'\"\n+      case StringContains(attr, value) => s\"${attr} LIKE '%${value}%'\"\n+      case In(attr, value) => s\"$attr IN (${compileValue(value)})\"\n+      case Not(f) => compileFilter(f).map(p => s\"(NOT ($p))\").orNull\n+      case Or(f1, f2) =>\n+        val or = Seq(f1, f2).flatMap(compileFilter(_))\n+        if (or.size == 2) {\n+          or.map(p => s\"($p)\").mkString(\" OR \")\n+        } else {\n+          null\n+        }\n+      case And(f1, f2) =>\n+        val and = Seq(f1, f2).flatMap(compileFilter(_))\n+        if (and.size == 2) {\n+          and.map(p => s\"($p)\").mkString(\" AND \")\n+        } else {\n+          null\n+        }\n+      case _ => null\n+    })\n+  }\n+\n+  /**\n+   * Converts value into string expression.\n+   */\n+  private[systemcatalog] def compileValue(value: Any): Any = value match {\n+    case s: String =>\n+      val escapedValue = if (s == null) null else StringUtils.replace(s, \"'\", \"''\")\n+      s\"'$escapedValue'\"\n+    case t: Timestamp => \"'\" + t + \"'\"\n+    case d: Date => \"'\" + d + \"'\"\n+    case a: Array[Any] => a.map(compileValue).mkString(\", \")\n+    case _ => value\n+  }\n+}\n+\n+/**\n+ * Provides DATABASES relation consisting all databases.\n+ */\n+private class DatabasesRelationProvider extends SchemaRelationProvider {\n+  override def createRelation(\n+      sqlContext: SQLContext,\n+      parameters: Map[String, String],\n+      schema: StructType): BaseRelation = {\n+    val sparkSession = sqlContext.sparkSession\n+\n+    new BaseRelation with PrunedFilteredScan {"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "I am lost. A database `INFORMATION_SCHEMA_DATABASE` is created through a SQL command, but the function `databaseExists` always returns true for the database for `INFORMATION_SCHEMA_DATABASE`.\n\nSee the code:\nhttps://github.com/dongjoon-hyun/spark/blob/b04f70127760dde5700a63e7dad4100cf407b863/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/catalog/SessionCatalog.scala#L177-L184\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-18T05:52:42Z",
    "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.SessionCatalog.{DEFAULT_DATABASE, INFORMATION_SCHEMA_DATABASE}\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.internal.CatalogImpl\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ *\n+ * These views are designed to be populated by this package in order to be independent from\n+ * Spark catalog. To keep minimal dependency, currently INFORMATION_SCHEMA views are implemented as\n+ * Spark temporary views with a database prefix: `SessionCatalog.INFORMATION_SCHEMA_DATABASE`.\n+ *\n+ * The following is the class hierarchy in this package rooted at InformationSchemaRelationProvider.\n+ *\n+ * InformationSchemaRelationProvider\n+ *  -> DatabasesRelationProvider\n+ *  -> TablesRelationProvider\n+ *  -> ViewsRelationProvider\n+ *  -> ColumnsRelationProvider\n+ *  -> SessionVariablesRelationProvider\n+ */\n+\n+/**\n+ * InformationSchema object provides bootstrap and utility functions.\n+ */\n+object InformationSchema {\n+\n+  /**\n+   * Register INFORMATION_SCHEMA database. SessionCatalog.catalog invokes this function.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA_DATABASE\")",
    "line": 60
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "`null, null` -> `parameters = null, schema = null`\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-18T06:00:28Z",
    "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.SessionCatalog.{DEFAULT_DATABASE, INFORMATION_SCHEMA_DATABASE}\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.internal.CatalogImpl\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ *\n+ * These views are designed to be populated by this package in order to be independent from\n+ * Spark catalog. To keep minimal dependency, currently INFORMATION_SCHEMA views are implemented as\n+ * Spark temporary views with a database prefix: `SessionCatalog.INFORMATION_SCHEMA_DATABASE`.\n+ *\n+ * The following is the class hierarchy in this package rooted at InformationSchemaRelationProvider.\n+ *\n+ * InformationSchemaRelationProvider\n+ *  -> DatabasesRelationProvider\n+ *  -> TablesRelationProvider\n+ *  -> ViewsRelationProvider\n+ *  -> ColumnsRelationProvider\n+ *  -> SessionVariablesRelationProvider\n+ */\n+\n+/**\n+ * InformationSchema object provides bootstrap and utility functions.\n+ */\n+object InformationSchema {\n+\n+  /**\n+   * Register INFORMATION_SCHEMA database. SessionCatalog.catalog invokes this function.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA_DATABASE\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register an INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-22T06:57:21Z",
    "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.SessionCatalog.{DEFAULT_DATABASE, INFORMATION_SCHEMA_DATABASE}\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.internal.CatalogImpl\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ *\n+ * These views are designed to be populated by this package in order to be independent from\n+ * Spark catalog. To keep minimal dependency, currently INFORMATION_SCHEMA views are implemented as\n+ * Spark temporary views with a database prefix: `SessionCatalog.INFORMATION_SCHEMA_DATABASE`.\n+ *\n+ * The following is the class hierarchy in this package rooted at InformationSchemaRelationProvider.\n+ *\n+ * InformationSchemaRelationProvider\n+ *  -> DatabasesRelationProvider\n+ *  -> TablesRelationProvider\n+ *  -> ViewsRelationProvider\n+ *  -> ColumnsRelationProvider\n+ *  -> SessionVariablesRelationProvider\n+ */\n+\n+/**\n+ * InformationSchema object provides bootstrap and utility functions.\n+ */\n+object InformationSchema {\n+\n+  /**\n+   * Register INFORMATION_SCHEMA database. SessionCatalog.catalog invokes this function.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA_DATABASE\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register an INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze"
  }],
  "prId": 14116
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "It sounds like you are not passing schema to build the `BaseRelation`. Why are you extending `SchemaRelationProvider`? \n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-18T06:19:15Z",
    "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.SessionCatalog.{DEFAULT_DATABASE, INFORMATION_SCHEMA_DATABASE}\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.internal.CatalogImpl\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ *\n+ * These views are designed to be populated by this package in order to be independent from\n+ * Spark catalog. To keep minimal dependency, currently INFORMATION_SCHEMA views are implemented as\n+ * Spark temporary views with a database prefix: `SessionCatalog.INFORMATION_SCHEMA_DATABASE`.\n+ *\n+ * The following is the class hierarchy in this package rooted at InformationSchemaRelationProvider.\n+ *\n+ * InformationSchemaRelationProvider\n+ *  -> DatabasesRelationProvider\n+ *  -> TablesRelationProvider\n+ *  -> ViewsRelationProvider\n+ *  -> ColumnsRelationProvider\n+ *  -> SessionVariablesRelationProvider\n+ */\n+\n+/**\n+ * InformationSchema object provides bootstrap and utility functions.\n+ */\n+object InformationSchema {\n+\n+  /**\n+   * Register INFORMATION_SCHEMA database. SessionCatalog.catalog invokes this function.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA_DATABASE\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register an INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+\n+    for (name <- names) {\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA_DATABASE.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Only EqualTo filters are handled in INFORMATION_SCHEMA data sources.\n+   */\n+  def unhandledFilters(filters: Array[Filter], columnName: String): Array[Filter] = {\n+    import org.apache.spark.sql.sources.EqualTo\n+    filters.filter {\n+      case EqualTo(attribute, _) if attribute.equalsIgnoreCase(columnName) => false\n+      case _ => true\n+    }\n+  }\n+\n+  /**\n+   * Return `EqualTo` filtered DataFrame.\n+   */\n+  def getFilteredTables(sparkSession: SparkSession, filters: Seq[Expression], columnName: String)\n+      : DataFrame = {\n+    import org.apache.spark.sql.catalyst.expressions.EqualTo\n+    val database = filters.filter {\n+      case EqualTo(AttributeReference(name, _, _, _), Literal(_, StringType))\n+        if name.equalsIgnoreCase(columnName) => true\n+      case _ => false\n+    }.map(_.asInstanceOf[EqualTo].right.asInstanceOf[Literal].eval().toString()).headOption\n+\n+    val tableList = if (database.nonEmpty) {\n+      sparkSession.catalog.listTables(database.get)\n+    } else {\n+      // Lookup the all table information from all databases.\n+      val allTables = new ArrayBuffer[org.apache.spark.sql.catalog.Table]\n+      val nonSystemDBs = sparkSession.catalog.listDatabases()\n+        .filter(_.name != INFORMATION_SCHEMA_DATABASE).collect()\n+      for (db <- nonSystemDBs)\n+        allTables ++= sparkSession.catalog.listTables(db.name).collect()\n+      CatalogImpl.makeDataset(allTables, sparkSession)\n+    }\n+\n+    tableList.selectExpr(\"'default'\", s\"IFNULL(database, '$DEFAULT_DATABASE')\", \"name\",\n+      \"IF(tableType='VIEW', 'VIEW', IF(isTemporary, 'VIEW', 'TABLE'))\",\n+      \"IFNULL(description, 'VIEW')\", \"isTemporary\"\n+    ).toDF(\"TABLE_CATALOG\", \"TABLE_SCHEMA\", \"TABLE_NAME\", \"TABLE_TYPE\", \"VIEW_DEFINITION\",\n+      \"isTemporary\")\n+  }\n+}\n+\n+/**\n+ * A base class for all INFORMATION_SCHEMA relation providers.\n+ */\n+private abstract class InformationSchemaRelationProvider extends SchemaRelationProvider {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Right, I changed from `SchemaRelationProvider` into `RelationProvider`.\n",
    "commit": "e832f5ba8be965e75107697fcfacc623572eb751",
    "createdAt": "2016-07-22T06:58:15Z",
    "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.systemcatalog\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.catalyst.catalog.SessionCatalog.{DEFAULT_DATABASE, INFORMATION_SCHEMA_DATABASE}\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.execution.datasources._\n+import org.apache.spark.sql.internal.CatalogImpl\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * INFORMATION_SCHEMA is a database consisting views which provide information about all of the\n+ * tables, views, columns in a database.\n+ *\n+ * These views are designed to be populated by this package in order to be independent from\n+ * Spark catalog. To keep minimal dependency, currently INFORMATION_SCHEMA views are implemented as\n+ * Spark temporary views with a database prefix: `SessionCatalog.INFORMATION_SCHEMA_DATABASE`.\n+ *\n+ * The following is the class hierarchy in this package rooted at InformationSchemaRelationProvider.\n+ *\n+ * InformationSchemaRelationProvider\n+ *  -> DatabasesRelationProvider\n+ *  -> TablesRelationProvider\n+ *  -> ViewsRelationProvider\n+ *  -> ColumnsRelationProvider\n+ *  -> SessionVariablesRelationProvider\n+ */\n+\n+/**\n+ * InformationSchema object provides bootstrap and utility functions.\n+ */\n+object InformationSchema {\n+\n+  /**\n+   * Register INFORMATION_SCHEMA database. SessionCatalog.catalog invokes this function.\n+   */\n+  def registerInformationSchema(sparkSession: SparkSession): Unit = {\n+    sparkSession.sql(s\"CREATE DATABASE IF NOT EXISTS $INFORMATION_SCHEMA_DATABASE\")\n+    registerView(sparkSession, new DatabasesRelationProvider, Seq(\"schemata\", \"databases\"))\n+    registerView(sparkSession, new TablesRelationProvider, Seq(\"tables\"))\n+    registerView(sparkSession, new ViewsRelationProvider, Seq(\"views\"))\n+    registerView(sparkSession, new ColumnsRelationProvider, Seq(\"columns\"))\n+    registerView(sparkSession, new SessionVariablesRelationProvider, Seq(\"session_variables\"))\n+  }\n+\n+  /**\n+   * Register an INFORMATION_SCHEMA relation provider as a temporary view of Spark Catalog.\n+   */\n+  private def registerView(\n+      sparkSession: SparkSession,\n+      relationProvider: SchemaRelationProvider,\n+      names: Seq[String]) {\n+    val plan =\n+      LogicalRelation(relationProvider.createRelation(sparkSession.sqlContext, null, null)).analyze\n+    val projectList = plan.output.zip(plan.schema).map {\n+      case (attr, col) => Alias(attr, col.name)()\n+    }\n+    sparkSession.sessionState.executePlan(Project(projectList, plan))\n+\n+    for (name <- names) {\n+      sparkSession.sessionState.catalog.createTempView(s\"$INFORMATION_SCHEMA_DATABASE.$name\",\n+        plan, overrideIfExists = true)\n+    }\n+  }\n+\n+  /**\n+   * Only EqualTo filters are handled in INFORMATION_SCHEMA data sources.\n+   */\n+  def unhandledFilters(filters: Array[Filter], columnName: String): Array[Filter] = {\n+    import org.apache.spark.sql.sources.EqualTo\n+    filters.filter {\n+      case EqualTo(attribute, _) if attribute.equalsIgnoreCase(columnName) => false\n+      case _ => true\n+    }\n+  }\n+\n+  /**\n+   * Return `EqualTo` filtered DataFrame.\n+   */\n+  def getFilteredTables(sparkSession: SparkSession, filters: Seq[Expression], columnName: String)\n+      : DataFrame = {\n+    import org.apache.spark.sql.catalyst.expressions.EqualTo\n+    val database = filters.filter {\n+      case EqualTo(AttributeReference(name, _, _, _), Literal(_, StringType))\n+        if name.equalsIgnoreCase(columnName) => true\n+      case _ => false\n+    }.map(_.asInstanceOf[EqualTo].right.asInstanceOf[Literal].eval().toString()).headOption\n+\n+    val tableList = if (database.nonEmpty) {\n+      sparkSession.catalog.listTables(database.get)\n+    } else {\n+      // Lookup the all table information from all databases.\n+      val allTables = new ArrayBuffer[org.apache.spark.sql.catalog.Table]\n+      val nonSystemDBs = sparkSession.catalog.listDatabases()\n+        .filter(_.name != INFORMATION_SCHEMA_DATABASE).collect()\n+      for (db <- nonSystemDBs)\n+        allTables ++= sparkSession.catalog.listTables(db.name).collect()\n+      CatalogImpl.makeDataset(allTables, sparkSession)\n+    }\n+\n+    tableList.selectExpr(\"'default'\", s\"IFNULL(database, '$DEFAULT_DATABASE')\", \"name\",\n+      \"IF(tableType='VIEW', 'VIEW', IF(isTemporary, 'VIEW', 'TABLE'))\",\n+      \"IFNULL(description, 'VIEW')\", \"isTemporary\"\n+    ).toDF(\"TABLE_CATALOG\", \"TABLE_SCHEMA\", \"TABLE_NAME\", \"TABLE_TYPE\", \"VIEW_DEFINITION\",\n+      \"isTemporary\")\n+  }\n+}\n+\n+/**\n+ * A base class for all INFORMATION_SCHEMA relation providers.\n+ */\n+private abstract class InformationSchemaRelationProvider extends SchemaRelationProvider {"
  }],
  "prId": 14116
}]