[{
  "comments": [{
    "author": {
      "login": "xuanyuanking"
    },
    "body": "Here we also have another choice, which is to separate file listing time and partition pruning time, I just followed the original method of adding them together as file listing time.",
    "commit": "169a6d7ff3b68a0cbacf70bf65207c54ebd67443",
    "createdAt": "2018-12-15T15:17:21Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.metric\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.sql.catalyst.QueryPlanningTracker\n+\n+/**\n+ * It is a helper object for the metrics which is traced by [[QueryPlanningTracker]].\n+ */\n+object QueryPlanningMetricsSupport {\n+  import QueryPlanningTracker._\n+\n+  val FILE_LISTING_TIME = FILE_LISTING + \"Time\"\n+  private def startTimestampMetric(prefix: String) = prefix + \"Start\"\n+  private def endTimestampMetric(prefix: String) = prefix + \"End\"\n+\n+  /**\n+   * Create all file listing relative metrics and return the Map.\n+   */\n+  def createFileListingMetrics(sc: SparkContext): Map[String, SQLMetric] = Map(\n+    FILE_LISTING_TIME -> SQLMetrics.createMetric(sc, \"total file listing time (ms)\"),\n+    startTimestampMetric(FILE_LISTING) ->\n+      SQLMetrics.createTimestampMetric(sc, \"file listing start\"),\n+    startTimestampMetric(PARTITION_PRUNING) ->\n+      SQLMetrics.createTimestampMetric(sc, \"partition pruning start\"),\n+    endTimestampMetric(PARTITION_PRUNING) ->\n+      SQLMetrics.createTimestampMetric(sc, \"partition pruning end\"),\n+    endTimestampMetric(FILE_LISTING) ->\n+      SQLMetrics.createTimestampMetric(sc, \"file listing end\"))\n+\n+  /**\n+   * Get updated file listing relative metrics from QueryPlanningTracker phases.\n+   */\n+  def getUpdatedFileListingMetrics(metrics: Map[String, SQLMetric]): Seq[SQLMetric] = {\n+    val updatedMetrics = new ArrayBuffer[SQLMetric]()\n+\n+    // Update all metrics relative with file listing phase.\n+    def phaseMetricsUpdate(phase: String): Unit = {\n+      val phaseSummary = QueryPlanningTracker.get.phases.get(phase)\n+      if (phaseSummary.isDefined) {\n+        metrics(FILE_LISTING_TIME).add(phaseSummary.get.durationMs)",
    "line": 59
  }],
  "prId": 23298
}]