[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Should we put !shouldStop() into the end of the while-loop to avoid performance degradation?\n",
    "commit": "303312c2a37ee47803a67812a96f271533fa5325",
    "createdAt": "2016-03-31T22:51:04Z",
    "diffHunk": "@@ -318,25 +292,32 @@ private[sql] case class DataSourceScan(\n         |   }\n         | }\"\"\".stripMargin)\n \n-      val value = ctx.freshName(\"value\")\n       s\"\"\"\n          | if ($batch != null) {\n          |   $scanBatches();\n-         | } else if ($input.hasNext()) {\n-         |   Object $value = $input.next();\n-         |   if ($value instanceof $columnarBatchClz) {\n-         |     $batch = ($columnarBatchClz)$value;\n+         | } else {\n+         |   long $getBatchStart = System.nanoTime();\n+         |   if ($input.hasNext()) {\n+         |     $batch = ($columnarBatchClz)$input.next();\n+         |     $scanTimeTotalNs += System.nanoTime() - $getBatchStart;\n          |     $scanBatches();\n-         |   } else {\n-         |     $scanRows((InternalRow) $value);\n          |   }\n          | }\n        \"\"\".stripMargin\n     } else {\n+      val row = ctx.freshName(\"row\")\n+      val exprRows =\n+        output.zipWithIndex.map(x => new BoundReference(x._2, x._1.dataType, x._1.nullable))\n+      ctx.INPUT_ROW = row\n+      ctx.currentVars = null\n+      val columnsRowInput = exprRows.map(_.gen(ctx))\n+      val inputRow = if (outputUnsafeRows) row else null\n       s\"\"\"\n-         |if ($input.hasNext()) {\n-         |  $scanRows((InternalRow) $input.next());\n-         |}\n+         | while (!shouldStop() && $input.hasNext()) {",
    "line": 126
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "I tried a few variants and didn't see a difference. I think only the batched scan is fast enough to be sensitive to this.\n",
    "commit": "303312c2a37ee47803a67812a96f271533fa5325",
    "createdAt": "2016-04-01T18:49:52Z",
    "diffHunk": "@@ -318,25 +292,32 @@ private[sql] case class DataSourceScan(\n         |   }\n         | }\"\"\".stripMargin)\n \n-      val value = ctx.freshName(\"value\")\n       s\"\"\"\n          | if ($batch != null) {\n          |   $scanBatches();\n-         | } else if ($input.hasNext()) {\n-         |   Object $value = $input.next();\n-         |   if ($value instanceof $columnarBatchClz) {\n-         |     $batch = ($columnarBatchClz)$value;\n+         | } else {\n+         |   long $getBatchStart = System.nanoTime();\n+         |   if ($input.hasNext()) {\n+         |     $batch = ($columnarBatchClz)$input.next();\n+         |     $scanTimeTotalNs += System.nanoTime() - $getBatchStart;\n          |     $scanBatches();\n-         |   } else {\n-         |     $scanRows((InternalRow) $value);\n          |   }\n          | }\n        \"\"\".stripMargin\n     } else {\n+      val row = ctx.freshName(\"row\")\n+      val exprRows =\n+        output.zipWithIndex.map(x => new BoundReference(x._2, x._1.dataType, x._1.nullable))\n+      ctx.INPUT_ROW = row\n+      ctx.currentVars = null\n+      val columnsRowInput = exprRows.map(_.gen(ctx))\n+      val inputRow = if (outputUnsafeRows) row else null\n       s\"\"\"\n-         |if ($input.hasNext()) {\n-         |  $scanRows((InternalRow) $input.next());\n-         |}\n+         | while (!shouldStop() && $input.hasNext()) {",
    "line": 126
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see. Thank you for your information. A result of the experiments is useful. It may be good to leave the result in a comment.\n",
    "commit": "303312c2a37ee47803a67812a96f271533fa5325",
    "createdAt": "2016-04-02T00:54:36Z",
    "diffHunk": "@@ -318,25 +292,32 @@ private[sql] case class DataSourceScan(\n         |   }\n         | }\"\"\".stripMargin)\n \n-      val value = ctx.freshName(\"value\")\n       s\"\"\"\n          | if ($batch != null) {\n          |   $scanBatches();\n-         | } else if ($input.hasNext()) {\n-         |   Object $value = $input.next();\n-         |   if ($value instanceof $columnarBatchClz) {\n-         |     $batch = ($columnarBatchClz)$value;\n+         | } else {\n+         |   long $getBatchStart = System.nanoTime();\n+         |   if ($input.hasNext()) {\n+         |     $batch = ($columnarBatchClz)$input.next();\n+         |     $scanTimeTotalNs += System.nanoTime() - $getBatchStart;\n          |     $scanBatches();\n-         |   } else {\n-         |     $scanRows((InternalRow) $value);\n          |   }\n          | }\n        \"\"\".stripMargin\n     } else {\n+      val row = ctx.freshName(\"row\")\n+      val exprRows =\n+        output.zipWithIndex.map(x => new BoundReference(x._2, x._1.dataType, x._1.nullable))\n+      ctx.INPUT_ROW = row\n+      ctx.currentVars = null\n+      val columnsRowInput = exprRows.map(_.gen(ctx))\n+      val inputRow = if (outputUnsafeRows) row else null\n       s\"\"\"\n-         |if ($input.hasNext()) {\n-         |  $scanRows((InternalRow) $input.next());\n-         |}\n+         | while (!shouldStop() && $input.hasNext()) {",
    "line": 126
  }],
  "prId": 12098
}]