[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Do we need this `do { } while (false);`?",
    "commit": "5baa928d758eaf4c6711c4a8d67611995ca3af25",
    "createdAt": "2017-03-10T14:15:41Z",
    "diffHunk": "@@ -106,6 +105,126 @@ case class SortAggregateExec(\n     }\n   }\n \n+  override def supportCodegen: Boolean = {\n+    val aggregationBufferSchema = StructType.fromAttributes(aggregateBufferAttributes)\n+    aggregationBufferSchema.forall(f => UnsafeRow.isMutable(f.dataType)) &&\n+      // ImperativeAggregate is not supported right now\n+      !aggregateExpressions.exists(_.aggregateFunction.isInstanceOf[ImperativeAggregate])\n+  }\n+\n+  override def inputRDDs(): Seq[RDD[InternalRow]] = {\n+    child.asInstanceOf[CodegenSupport].inputRDDs()\n+  }\n+\n+  override protected def doProduce(ctx: CodegenContext): String = {\n+    if (groupingExpressions.isEmpty) {\n+      doProduceWithoutKeys(ctx)\n+    } else {\n+      doProduceWithKeys(ctx)\n+    }\n+  }\n+\n+  override def doConsume(ctx: CodegenContext, input: Seq[ExprCode], row: ExprCode): String = {\n+    if (groupingExpressions.isEmpty) {\n+      doConsumeWithoutKeys(ctx, input)\n+    } else {\n+      doConsumeWithKeys(ctx, input)\n+    }\n+  }\n+\n+  private def doProduceWithoutKeys(ctx: CodegenContext): String = {\n+    generateBufVarsEvalCode(ctx)\n+  }\n+\n+  private def doConsumeWithoutKeys(ctx: CodegenContext, input: Seq[ExprCode]): String = {\n+    generateBufVarsUpdateCode(ctx, input)\n+  }\n+\n+  // The grouping keys of a current partition\n+  private var currentGroupingKeyTerm: String = _\n+\n+  // The output code for a single partition\n+  private var outputCode: String = _\n+\n+  private def generateOutputCode(ctx: CodegenContext): String = {\n+    ctx.currentVars = bufVars\n+    val bufferEv = GenerateUnsafeProjection.createCode(\n+      ctx, aggregateBufferAttributes.map(\n+        BindReferences.bindReference[Expression](_, aggregateBufferAttributes)))\n+    val sortAggregate = ctx.addReferenceObj(\"sortAggregate\", this)\n+    s\"\"\"\n+       |${bufferEv.code}\n+       |${generateResultCode(ctx, currentGroupingKeyTerm, bufferEv.value, sortAggregate)}\n+     \"\"\".stripMargin\n+  }\n+\n+  private def doProduceWithKeys(ctx: CodegenContext): String = {\n+    val numOutput = metricTerm(ctx, \"numOutputRows\")\n+    s\"\"\"\n+      |${child.asInstanceOf[CodegenSupport].produce(ctx, this)}\n+      |\n+      |if ($currentGroupingKeyTerm != null) {\n+      |  // for the last aggregation\n+      |  do {\n+      |    $numOutput.add(1);\n+      |    $outputCode\n+      |    $currentGroupingKeyTerm = null;\n+      |\n+      |    if (shouldStop()) return;\n+      |  } while (false);",
    "line": 106
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "ditto.",
    "commit": "5baa928d758eaf4c6711c4a8d67611995ca3af25",
    "createdAt": "2017-03-10T14:16:48Z",
    "diffHunk": "@@ -106,6 +105,126 @@ case class SortAggregateExec(\n     }\n   }\n \n+  override def supportCodegen: Boolean = {\n+    val aggregationBufferSchema = StructType.fromAttributes(aggregateBufferAttributes)\n+    aggregationBufferSchema.forall(f => UnsafeRow.isMutable(f.dataType)) &&\n+      // ImperativeAggregate is not supported right now\n+      !aggregateExpressions.exists(_.aggregateFunction.isInstanceOf[ImperativeAggregate])\n+  }\n+\n+  override def inputRDDs(): Seq[RDD[InternalRow]] = {\n+    child.asInstanceOf[CodegenSupport].inputRDDs()\n+  }\n+\n+  override protected def doProduce(ctx: CodegenContext): String = {\n+    if (groupingExpressions.isEmpty) {\n+      doProduceWithoutKeys(ctx)\n+    } else {\n+      doProduceWithKeys(ctx)\n+    }\n+  }\n+\n+  override def doConsume(ctx: CodegenContext, input: Seq[ExprCode], row: ExprCode): String = {\n+    if (groupingExpressions.isEmpty) {\n+      doConsumeWithoutKeys(ctx, input)\n+    } else {\n+      doConsumeWithKeys(ctx, input)\n+    }\n+  }\n+\n+  private def doProduceWithoutKeys(ctx: CodegenContext): String = {\n+    generateBufVarsEvalCode(ctx)\n+  }\n+\n+  private def doConsumeWithoutKeys(ctx: CodegenContext, input: Seq[ExprCode]): String = {\n+    generateBufVarsUpdateCode(ctx, input)\n+  }\n+\n+  // The grouping keys of a current partition\n+  private var currentGroupingKeyTerm: String = _\n+\n+  // The output code for a single partition\n+  private var outputCode: String = _\n+\n+  private def generateOutputCode(ctx: CodegenContext): String = {\n+    ctx.currentVars = bufVars\n+    val bufferEv = GenerateUnsafeProjection.createCode(\n+      ctx, aggregateBufferAttributes.map(\n+        BindReferences.bindReference[Expression](_, aggregateBufferAttributes)))\n+    val sortAggregate = ctx.addReferenceObj(\"sortAggregate\", this)\n+    s\"\"\"\n+       |${bufferEv.code}\n+       |${generateResultCode(ctx, currentGroupingKeyTerm, bufferEv.value, sortAggregate)}\n+     \"\"\".stripMargin\n+  }\n+\n+  private def doProduceWithKeys(ctx: CodegenContext): String = {\n+    val numOutput = metricTerm(ctx, \"numOutputRows\")\n+    s\"\"\"\n+      |${child.asInstanceOf[CodegenSupport].produce(ctx, this)}\n+      |\n+      |if ($currentGroupingKeyTerm != null) {\n+      |  // for the last aggregation\n+      |  do {\n+      |    $numOutput.add(1);\n+      |    $outputCode\n+      |    $currentGroupingKeyTerm = null;\n+      |\n+      |    if (shouldStop()) return;\n+      |  } while (false);",
    "line": 106
  }],
  "prId": 17164
}]