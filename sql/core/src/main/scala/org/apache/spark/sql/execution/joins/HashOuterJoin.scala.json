[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Since this code is now in `HashOuterJoin` instead of `BroadcastHashOuterJoin`, I think we should update this error message to reference the new class.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-20T21:36:07Z",
    "diffHunk": "@@ -59,6 +59,31 @@ override def outputPartitioning: Partitioning = joinType match {\n     }\n   }\n \n+  protected[this] lazy val (buildPlan, streamedPlan) = joinType match {\n+    case RightOuter => (left, right)\n+    case LeftOuter => (right, left)\n+    case x =>\n+      throw new IllegalArgumentException(\n+        s\"BroadcastHashOuterJoin should not take $x as the JoinType\")"
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "I think that you can use `List.empty` here, which, as far as I know, returns an immutable singleton.  Not sure if `List()` creates a new instance or not...\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-20T21:37:45Z",
    "diffHunk": "@@ -76,8 +101,12 @@ override def outputPartitioning: Partitioning = joinType match {\n       rightIter: Iterable[InternalRow]): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n       if (!key.anyNull) {\n-        val temp = rightIter.collect {\n-          case r if boundCondition(joinedRow.withRight(r)) => joinedRow.copy()\n+        val temp = if (rightIter != null) {\n+          rightIter.collect {\n+            case r if boundCondition(joinedRow.withRight(r)) => joinedRow.copy()\n+          }\n+        } else {\n+          List()"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Given that the old code seemed to make a special point of using an `EMPTY_LIST` constant I'm thinking that it may be  important to make sure we're not creating new objects here.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-20T22:09:37Z",
    "diffHunk": "@@ -76,8 +101,12 @@ override def outputPartitioning: Partitioning = joinType match {\n       rightIter: Iterable[InternalRow]): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n       if (!key.anyNull) {\n-        val temp = rightIter.collect {\n-          case r if boundCondition(joinedRow.withRight(r)) => joinedRow.copy()\n+        val temp = if (rightIter != null) {\n+          rightIter.collect {\n+            case r if boundCondition(joinedRow.withRight(r)) => joinedRow.copy()\n+          }\n+        } else {\n+          List()"
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Same style nit RE: wrapping first argument onto separate line.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-20T21:38:15Z",
    "diffHunk": "@@ -178,4 +211,14 @@ override def outputPartitioning: Partitioning = joinType match {\n \n     hashTable\n   }\n+\n+  protected[this] def buildHashRelation(buildIter: Iterator[InternalRow]): HashedRelation = {\n+    if (self.codegenEnabled && buildKeys.map(_.dataType).forall(UnsafeColumnWriter.canEmbed(_))) {\n+      UnsafeHashedRelation(buildIter,"
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "I wonder whether we should add a `canEmbed` method to the `UnsafeProjection` object which implements this logic.  Might be helpful if you think that we'll end up repeating this pattern elsewhere.\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-20T21:40:27Z",
    "diffHunk": "@@ -59,6 +59,31 @@ override def outputPartitioning: Partitioning = joinType match {\n     }\n   }\n \n+  protected[this] lazy val (buildPlan, streamedPlan) = joinType match {\n+    case RightOuter => (left, right)\n+    case LeftOuter => (right, left)\n+    case x =>\n+      throw new IllegalArgumentException(\n+        s\"BroadcastHashOuterJoin should not take $x as the JoinType\")\n+  }\n+\n+  protected[this] lazy val (buildKeys, streamedKeys) = joinType match {\n+    case RightOuter => (leftKeys, rightKeys)\n+    case LeftOuter => (rightKeys, leftKeys)\n+    case x =>\n+      throw new IllegalArgumentException(\n+        s\"BroadcastHashOuterJoin should not take $x as the JoinType\")\n+  }\n+\n+  protected[this] def streamedKeyGenerator(): Projection = {\n+    if (self.codegenEnabled &&\n+        streamedKeys.map(_.dataType).forall(UnsafeColumnWriter.canEmbed(_))) {"
  }],
  "prId": 7480
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think you just want scala's \"identity\" here\n",
    "commit": "6294b1e3de357c94646c323eba2d4bde80971c45",
    "createdAt": "2015-07-22T20:08:51Z",
    "diffHunk": "@@ -59,6 +59,49 @@ override def outputPartitioning: Partitioning = joinType match {\n     }\n   }\n \n+  protected[this] lazy val (buildPlan, streamedPlan) = joinType match {\n+    case RightOuter => (left, right)\n+    case LeftOuter => (right, left)\n+    case x =>\n+      throw new IllegalArgumentException(\n+        s\"HashOuterJoin should not take $x as the JoinType\")\n+  }\n+\n+  protected[this] lazy val (buildKeys, streamedKeys) = joinType match {\n+    case RightOuter => (leftKeys, rightKeys)\n+    case LeftOuter => (rightKeys, leftKeys)\n+    case x =>\n+      throw new IllegalArgumentException(\n+        s\"HashOuterJoin should not take $x as the JoinType\")\n+  }\n+\n+  protected[this] def supportUnsafe: Boolean = {\n+    (self.codegenEnabled && joinType != FullOuter\n+      && UnsafeProjection.canSupport(buildKeys)\n+      && UnsafeProjection.canSupport(self.schema))\n+  }\n+\n+  override def outputsUnsafeRows: Boolean = supportUnsafe\n+  override def canProcessUnsafeRows: Boolean = supportUnsafe\n+\n+  protected[this] def streamedKeyGenerator(): Projection = {\n+    if (supportUnsafe) {\n+      UnsafeProjection.create(streamedKeys, streamedPlan.output)\n+    } else {\n+      newProjection(streamedKeys, streamedPlan.output)\n+    }\n+  }\n+\n+  @transient private[this] lazy val resultProjection: Projection = {\n+    if (supportUnsafe) {\n+      UnsafeProjection.create(self.schema)\n+    } else {\n+      new Projection {",
    "line": 59
  }],
  "prId": 7480
}]