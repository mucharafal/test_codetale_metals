[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "This is dangerous, the user has to consume all data for a group before he can process next group, which is out of our control.\nImage a user call `mapGroups` but do nothing to the iterator, then this `GroupedIterator` will never end.\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-27T11:19:41Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateOrdering}\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder, Ascending, Expression}\n+\n+object GroupedIterator {\n+  def apply(\n+      input: Iterator[InternalRow],\n+      keyExpressions: Seq[Expression],\n+      inputSchema: Seq[Attribute]): Iterator[(InternalRow, Iterator[InternalRow])] = {\n+    if (input.hasNext) {\n+      new GroupedIterator(input, keyExpressions, inputSchema)\n+    } else {\n+      Iterator.empty\n+    }\n+  }\n+}\n+\n+/**\n+ * Iterates over a presorted set of rows, chunking it up by the grouping expression.  Each call to\n+ * next will return a pair containing the current group and an iterator that will return all the\n+ * elements of that group.  Iterators for each group are lazily constructed by extracting rows\n+ * from the input iterator.  As such, full groups are never materialized by this class.\n+ *\n+ * Example input:\n+ * {{{\n+ *   Input: [a, 1], [b, 2], [b, 3]\n+ *   Grouping: x#1\n+ *   InputSchema: x#1, y#2\n+ * }}}\n+ *\n+ * Result:\n+ * {{{\n+ *   First call to next():  ([a], Iterator([a, 1])\n+ *   Second call to next(): ([b], Iterator([b, 2], [b, 3])\n+ * }}}\n+ *\n+ * Note, the class does not handle the case of an empty input for simplicity of implementation.\n+ * Use the factory to construct a new instance.\n+ *\n+ * @param input An iterator of rows.  This iterator must be ordered by the groupingExpressions or\n+ *              it is possible for the same group to appear more than once.\n+ * @param groupingExpressions The set of expressions used to do grouping.  The result of evaluating\n+ *                            these expressions will be returned as the first part of each call\n+ *                            to `next()`.\n+ * @param inputSchema The schema of the rows in the `input` iterator.\n+ */\n+class GroupedIterator private(\n+    input: Iterator[InternalRow],\n+    groupingExpressions: Seq[Expression],\n+    inputSchema: Seq[Attribute])\n+  extends Iterator[(InternalRow, Iterator[InternalRow])] {\n+\n+  /** Compares two input rows and returns 0 if they are in the same group. */\n+  val sortOrder = groupingExpressions.map(SortOrder(_, Ascending))\n+  val keyOrdering = GenerateOrdering.generate(sortOrder, inputSchema)\n+\n+  /** Creates a row containing only the key for a given input row. */\n+  val keyProjection = GenerateUnsafeProjection.generate(groupingExpressions, inputSchema)\n+\n+  /**\n+   * Holds null or the row that will be returned on next call to `next()` in the inner iterator.\n+   */\n+  var currentRow = input.next()\n+\n+  /** Holds a copy of an input row that is in the current group. */\n+  var currentGroup = currentRow.copy()\n+  var currentIterator: Iterator[InternalRow] = null\n+  assert(keyOrdering.compare(currentGroup, currentRow) == 0)\n+\n+  // Return true if we already have the next iterator or fetching a new iterator is successful.\n+  def hasNext: Boolean = currentIterator != null || fetchNextGroupIterator\n+\n+  def next(): (InternalRow, Iterator[InternalRow]) = {\n+    assert(hasNext) // Ensure we have fetched the next iterator.\n+    val ret = (keyProjection(currentGroup), currentIterator)\n+    currentIterator = null\n+    ret\n+  }\n+\n+  def fetchNextGroupIterator(): Boolean = {\n+    if (currentRow != null || input.hasNext) {\n+      val inputIterator = new Iterator[InternalRow] {",
    "line": 101
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Thats a good catch.  We can just advance the internal iterator all the way to the next group if they call `next` on the outer iterator before exhausting the inner iterator (and add documentation that you can't use two inner iterators concurrently).\n\nCould you open a PR to unit test this class and fix the problem?\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-27T12:11:43Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateOrdering}\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder, Ascending, Expression}\n+\n+object GroupedIterator {\n+  def apply(\n+      input: Iterator[InternalRow],\n+      keyExpressions: Seq[Expression],\n+      inputSchema: Seq[Attribute]): Iterator[(InternalRow, Iterator[InternalRow])] = {\n+    if (input.hasNext) {\n+      new GroupedIterator(input, keyExpressions, inputSchema)\n+    } else {\n+      Iterator.empty\n+    }\n+  }\n+}\n+\n+/**\n+ * Iterates over a presorted set of rows, chunking it up by the grouping expression.  Each call to\n+ * next will return a pair containing the current group and an iterator that will return all the\n+ * elements of that group.  Iterators for each group are lazily constructed by extracting rows\n+ * from the input iterator.  As such, full groups are never materialized by this class.\n+ *\n+ * Example input:\n+ * {{{\n+ *   Input: [a, 1], [b, 2], [b, 3]\n+ *   Grouping: x#1\n+ *   InputSchema: x#1, y#2\n+ * }}}\n+ *\n+ * Result:\n+ * {{{\n+ *   First call to next():  ([a], Iterator([a, 1])\n+ *   Second call to next(): ([b], Iterator([b, 2], [b, 3])\n+ * }}}\n+ *\n+ * Note, the class does not handle the case of an empty input for simplicity of implementation.\n+ * Use the factory to construct a new instance.\n+ *\n+ * @param input An iterator of rows.  This iterator must be ordered by the groupingExpressions or\n+ *              it is possible for the same group to appear more than once.\n+ * @param groupingExpressions The set of expressions used to do grouping.  The result of evaluating\n+ *                            these expressions will be returned as the first part of each call\n+ *                            to `next()`.\n+ * @param inputSchema The schema of the rows in the `input` iterator.\n+ */\n+class GroupedIterator private(\n+    input: Iterator[InternalRow],\n+    groupingExpressions: Seq[Expression],\n+    inputSchema: Seq[Attribute])\n+  extends Iterator[(InternalRow, Iterator[InternalRow])] {\n+\n+  /** Compares two input rows and returns 0 if they are in the same group. */\n+  val sortOrder = groupingExpressions.map(SortOrder(_, Ascending))\n+  val keyOrdering = GenerateOrdering.generate(sortOrder, inputSchema)\n+\n+  /** Creates a row containing only the key for a given input row. */\n+  val keyProjection = GenerateUnsafeProjection.generate(groupingExpressions, inputSchema)\n+\n+  /**\n+   * Holds null or the row that will be returned on next call to `next()` in the inner iterator.\n+   */\n+  var currentRow = input.next()\n+\n+  /** Holds a copy of an input row that is in the current group. */\n+  var currentGroup = currentRow.copy()\n+  var currentIterator: Iterator[InternalRow] = null\n+  assert(keyOrdering.compare(currentGroup, currentRow) == 0)\n+\n+  // Return true if we already have the next iterator or fetching a new iterator is successful.\n+  def hasNext: Boolean = currentIterator != null || fetchNextGroupIterator\n+\n+  def next(): (InternalRow, Iterator[InternalRow]) = {\n+    assert(hasNext) // Ensure we have fetched the next iterator.\n+    val ret = (keyProjection(currentGroup), currentIterator)\n+    currentIterator = null\n+    ret\n+  }\n+\n+  def fetchNextGroupIterator(): Boolean = {\n+    if (currentRow != null || input.hasNext) {\n+      val inputIterator = new Iterator[InternalRow] {",
    "line": 101
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "yea, sure\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-27T13:30:35Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateUnsafeProjection, GenerateOrdering}\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, SortOrder, Ascending, Expression}\n+\n+object GroupedIterator {\n+  def apply(\n+      input: Iterator[InternalRow],\n+      keyExpressions: Seq[Expression],\n+      inputSchema: Seq[Attribute]): Iterator[(InternalRow, Iterator[InternalRow])] = {\n+    if (input.hasNext) {\n+      new GroupedIterator(input, keyExpressions, inputSchema)\n+    } else {\n+      Iterator.empty\n+    }\n+  }\n+}\n+\n+/**\n+ * Iterates over a presorted set of rows, chunking it up by the grouping expression.  Each call to\n+ * next will return a pair containing the current group and an iterator that will return all the\n+ * elements of that group.  Iterators for each group are lazily constructed by extracting rows\n+ * from the input iterator.  As such, full groups are never materialized by this class.\n+ *\n+ * Example input:\n+ * {{{\n+ *   Input: [a, 1], [b, 2], [b, 3]\n+ *   Grouping: x#1\n+ *   InputSchema: x#1, y#2\n+ * }}}\n+ *\n+ * Result:\n+ * {{{\n+ *   First call to next():  ([a], Iterator([a, 1])\n+ *   Second call to next(): ([b], Iterator([b, 2], [b, 3])\n+ * }}}\n+ *\n+ * Note, the class does not handle the case of an empty input for simplicity of implementation.\n+ * Use the factory to construct a new instance.\n+ *\n+ * @param input An iterator of rows.  This iterator must be ordered by the groupingExpressions or\n+ *              it is possible for the same group to appear more than once.\n+ * @param groupingExpressions The set of expressions used to do grouping.  The result of evaluating\n+ *                            these expressions will be returned as the first part of each call\n+ *                            to `next()`.\n+ * @param inputSchema The schema of the rows in the `input` iterator.\n+ */\n+class GroupedIterator private(\n+    input: Iterator[InternalRow],\n+    groupingExpressions: Seq[Expression],\n+    inputSchema: Seq[Attribute])\n+  extends Iterator[(InternalRow, Iterator[InternalRow])] {\n+\n+  /** Compares two input rows and returns 0 if they are in the same group. */\n+  val sortOrder = groupingExpressions.map(SortOrder(_, Ascending))\n+  val keyOrdering = GenerateOrdering.generate(sortOrder, inputSchema)\n+\n+  /** Creates a row containing only the key for a given input row. */\n+  val keyProjection = GenerateUnsafeProjection.generate(groupingExpressions, inputSchema)\n+\n+  /**\n+   * Holds null or the row that will be returned on next call to `next()` in the inner iterator.\n+   */\n+  var currentRow = input.next()\n+\n+  /** Holds a copy of an input row that is in the current group. */\n+  var currentGroup = currentRow.copy()\n+  var currentIterator: Iterator[InternalRow] = null\n+  assert(keyOrdering.compare(currentGroup, currentRow) == 0)\n+\n+  // Return true if we already have the next iterator or fetching a new iterator is successful.\n+  def hasNext: Boolean = currentIterator != null || fetchNextGroupIterator\n+\n+  def next(): (InternalRow, Iterator[InternalRow]) = {\n+    assert(hasNext) // Ensure we have fetched the next iterator.\n+    val ret = (keyProjection(currentGroup), currentIterator)\n+    currentIterator = null\n+    ret\n+  }\n+\n+  def fetchNextGroupIterator(): Boolean = {\n+    if (currentRow != null || input.hasNext) {\n+      val inputIterator = new Iterator[InternalRow] {",
    "line": 101
  }],
  "prId": 9190
}]