[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we should take this iterator out as a named iterator\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T07:29:25Z",
    "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.errors._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate2._\n+import org.apache.spark.sql.catalyst.plans.physical.{AllTuples, ClusteredDistribution, Distribution, UnspecifiedDistribution}\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryNode}\n+import org.apache.spark.sql.types.NullType\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+case class Aggregate2Sort(\n+    groupingExpressions: Seq[NamedExpression],\n+    aggregateExpressions: Seq[AggregateExpression2],\n+    aggregateAttributes: Seq[Attribute],\n+    resultExpressions: Seq[NamedExpression],\n+    child: SparkPlan)\n+  extends UnaryNode {\n+\n+  /** Indicates if this operator is for partial aggregations. */\n+  val partialAggregation: Boolean = {\n+    aggregateExpressions.map(_.mode).distinct.toList match {\n+      case Partial :: Nil => true\n+      case Final :: Nil => false\n+      case other =>\n+        sys.error(\n+          s\"Could not evaluate ${aggregateExpressions} because we do not support evaluate \" +\n+          s\"modes $other in this operator.\")\n+    }\n+  }\n+\n+  override def requiredChildDistribution: List[Distribution] = {\n+    if (partialAggregation) {\n+      UnspecifiedDistribution :: Nil\n+    } else {\n+      if (groupingExpressions == Nil) {\n+        AllTuples :: Nil\n+      } else {\n+        ClusteredDistribution(groupingExpressions) :: Nil\n+      }\n+    }\n+  }\n+\n+  override def requiredChildOrdering: Seq[Seq[SortOrder]] =\n+    groupingExpressions.map(SortOrder(_, Ascending)) :: Nil\n+\n+  override def output: Seq[Attribute] = resultExpressions.map(_.toAttribute)\n+\n+  protected override def doExecute(): RDD[InternalRow] = attachTree(this, \"execute\") {\n+    child.execute().mapPartitions { iter =>\n+\n+      new Iterator[InternalRow] {"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Probably we'd better split the partial / final aggregation Iterator into different class. As the partial aggregation(pre-shuffle) can be followed by hash/sort aggregation(post-shuffle) for the further improvement.\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T10:53:45Z",
    "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.errors._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate2._\n+import org.apache.spark.sql.catalyst.plans.physical.{AllTuples, ClusteredDistribution, Distribution, UnspecifiedDistribution}\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryNode}\n+import org.apache.spark.sql.types.NullType\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+case class Aggregate2Sort(\n+    groupingExpressions: Seq[NamedExpression],\n+    aggregateExpressions: Seq[AggregateExpression2],\n+    aggregateAttributes: Seq[Attribute],\n+    resultExpressions: Seq[NamedExpression],\n+    child: SparkPlan)\n+  extends UnaryNode {\n+\n+  /** Indicates if this operator is for partial aggregations. */\n+  val partialAggregation: Boolean = {\n+    aggregateExpressions.map(_.mode).distinct.toList match {\n+      case Partial :: Nil => true\n+      case Final :: Nil => false\n+      case other =>\n+        sys.error(\n+          s\"Could not evaluate ${aggregateExpressions} because we do not support evaluate \" +\n+          s\"modes $other in this operator.\")\n+    }\n+  }\n+\n+  override def requiredChildDistribution: List[Distribution] = {\n+    if (partialAggregation) {\n+      UnspecifiedDistribution :: Nil\n+    } else {\n+      if (groupingExpressions == Nil) {\n+        AllTuples :: Nil\n+      } else {\n+        ClusteredDistribution(groupingExpressions) :: Nil\n+      }\n+    }\n+  }\n+\n+  override def requiredChildOrdering: Seq[Seq[SortOrder]] =\n+    groupingExpressions.map(SortOrder(_, Ascending)) :: Nil\n+\n+  override def output: Seq[Attribute] = resultExpressions.map(_.toAttribute)\n+\n+  protected override def doExecute(): RDD[InternalRow] = attachTree(this, \"execute\") {\n+    child.execute().mapPartitions { iter =>\n+\n+      new Iterator[InternalRow] {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "@chenghao-intel Yeah, that's a good idea.\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-20T04:53:27Z",
    "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.errors._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate2._\n+import org.apache.spark.sql.catalyst.plans.physical.{AllTuples, ClusteredDistribution, Distribution, UnspecifiedDistribution}\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryNode}\n+import org.apache.spark.sql.types.NullType\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+case class Aggregate2Sort(\n+    groupingExpressions: Seq[NamedExpression],\n+    aggregateExpressions: Seq[AggregateExpression2],\n+    aggregateAttributes: Seq[Attribute],\n+    resultExpressions: Seq[NamedExpression],\n+    child: SparkPlan)\n+  extends UnaryNode {\n+\n+  /** Indicates if this operator is for partial aggregations. */\n+  val partialAggregation: Boolean = {\n+    aggregateExpressions.map(_.mode).distinct.toList match {\n+      case Partial :: Nil => true\n+      case Final :: Nil => false\n+      case other =>\n+        sys.error(\n+          s\"Could not evaluate ${aggregateExpressions} because we do not support evaluate \" +\n+          s\"modes $other in this operator.\")\n+    }\n+  }\n+\n+  override def requiredChildDistribution: List[Distribution] = {\n+    if (partialAggregation) {\n+      UnspecifiedDistribution :: Nil\n+    } else {\n+      if (groupingExpressions == Nil) {\n+        AllTuples :: Nil\n+      } else {\n+        ClusteredDistribution(groupingExpressions) :: Nil\n+      }\n+    }\n+  }\n+\n+  override def requiredChildOrdering: Seq[Seq[SortOrder]] =\n+    groupingExpressions.map(SortOrder(_, Ascending)) :: Nil\n+\n+  override def output: Seq[Attribute] = resultExpressions.map(_.toAttribute)\n+\n+  protected override def doExecute(): RDD[InternalRow] = attachTree(this, \"execute\") {\n+    child.execute().mapPartitions { iter =>\n+\n+      new Iterator[InternalRow] {"
  }],
  "prId": 7458
}, {
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Is there any consideration that we don't use the `partialAggregation` passed from `SparkStrategies`?\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T10:44:28Z",
    "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.errors._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate2._\n+import org.apache.spark.sql.catalyst.plans.physical.{AllTuples, ClusteredDistribution, Distribution, UnspecifiedDistribution}\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryNode}\n+import org.apache.spark.sql.types.NullType\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+case class Aggregate2Sort(\n+    groupingExpressions: Seq[NamedExpression],\n+    aggregateExpressions: Seq[AggregateExpression2],\n+    aggregateAttributes: Seq[Attribute],\n+    resultExpressions: Seq[NamedExpression],\n+    child: SparkPlan)\n+  extends UnaryNode {\n+\n+  /** Indicates if this operator is for partial aggregations. */\n+  val partialAggregation: Boolean = {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "The planner does not need to pass in `partialAggregation`. The operator will figure it out based on modes of those functions. \n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T17:13:19Z",
    "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.aggregate2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.errors._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate2._\n+import org.apache.spark.sql.catalyst.plans.physical.{AllTuples, ClusteredDistribution, Distribution, UnspecifiedDistribution}\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryNode}\n+import org.apache.spark.sql.types.NullType\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+case class Aggregate2Sort(\n+    groupingExpressions: Seq[NamedExpression],\n+    aggregateExpressions: Seq[AggregateExpression2],\n+    aggregateAttributes: Seq[Attribute],\n+    resultExpressions: Seq[NamedExpression],\n+    child: SparkPlan)\n+  extends UnaryNode {\n+\n+  /** Indicates if this operator is for partial aggregations. */\n+  val partialAggregation: Boolean = {"
  }],
  "prId": 7458
}]