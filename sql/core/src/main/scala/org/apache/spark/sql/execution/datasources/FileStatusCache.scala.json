[{
  "comments": [{
    "author": {
      "login": "mallman"
    },
    "body": "It looks like this can be a singleton object instead of a class.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T01:56:04Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+/**\n+ * An implementation that caches all partition file statuses in memory forever.\n+ */\n+class InMemoryCache extends FileStatusCache {\n+  private val cache = new ConcurrentHashMap[Path, Array[FileStatus]]()\n+\n+  override def getLeafFiles(path: Path): Option[Array[FileStatus]] = {\n+    Option(cache.get(path))\n+  }\n+\n+  override def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit = {\n+    cache.put(path, leafFiles.toArray)\n+  }\n+\n+  override def invalidateAll(): Unit = {\n+    cache.clear()\n+  }\n+}\n+\n+/**\n+ * A non-caching implementation used when partition file status caching is disabled.\n+ */\n+class NoopCache extends FileStatusCache {"
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "good idea\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T02:11:54Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+/**\n+ * An implementation that caches all partition file statuses in memory forever.\n+ */\n+class InMemoryCache extends FileStatusCache {\n+  private val cache = new ConcurrentHashMap[Path, Array[FileStatus]]()\n+\n+  override def getLeafFiles(path: Path): Option[Array[FileStatus]] = {\n+    Option(cache.get(path))\n+  }\n+\n+  override def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit = {\n+    cache.put(path, leafFiles.toArray)\n+  }\n+\n+  override def invalidateAll(): Unit = {\n+    cache.clear()\n+  }\n+}\n+\n+/**\n+ * A non-caching implementation used when partition file status caching is disabled.\n+ */\n+class NoopCache extends FileStatusCache {"
  }],
  "prId": 15539
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why not just make `NoopCache` an object?\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T03:03:20Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+/**\n+ * An implementation that caches all partition file statuses in memory forever.\n+ */\n+class InMemoryCache extends FileStatusCache {\n+  private val cache = new ConcurrentHashMap[Path, Array[FileStatus]]()\n+\n+  override def getLeafFiles(path: Path): Option[Array[FileStatus]] = {\n+    Option(cache.get(path))\n+  }\n+\n+  override def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit = {\n+    cache.put(path, leafFiles.toArray)\n+  }\n+\n+  override def invalidateAll(): Unit = {\n+    cache.clear()\n+  }\n+}\n+\n+/**\n+ * A non-caching implementation used when partition file status caching is disabled.\n+ */\n+private class NoopCache extends FileStatusCache {\n+  override def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+  override def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit = {}\n+  override def invalidateAll(): Unit = {}\n+}\n+\n+object FileStatusCache {\n+  val noop: FileStatusCache = new NoopCache"
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "I ran into some compilation issues there, but I guess I just had to do a clean.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T19:52:10Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+/**\n+ * An implementation that caches all partition file statuses in memory forever.\n+ */\n+class InMemoryCache extends FileStatusCache {\n+  private val cache = new ConcurrentHashMap[Path, Array[FileStatus]]()\n+\n+  override def getLeafFiles(path: Path): Option[Array[FileStatus]] = {\n+    Option(cache.get(path))\n+  }\n+\n+  override def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit = {\n+    cache.put(path, leafFiles.toArray)\n+  }\n+\n+  override def invalidateAll(): Unit = {\n+    cache.clear()\n+  }\n+}\n+\n+/**\n+ * A non-caching implementation used when partition file status caching is disabled.\n+ */\n+private class NoopCache extends FileStatusCache {\n+  override def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+  override def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit = {}\n+  override def invalidateAll(): Unit = {}\n+}\n+\n+object FileStatusCache {\n+  val noop: FileStatusCache = new NoopCache"
  }],
  "prId": 15539
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "should we have a limit for max cache entries?\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T03:07:07Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "I have similar concerns. I think that the proposed, simple solution may suffice for a single-user or short-lived spark session. On the other hand, an unbounded cache here will probable lead to trouble for some users in a multi-user or long-running Spark app such as the thriftserver.\n\nRight now I'm thinking the `InMemoryCache` is okay as-is because this feature is behind a configuration flag, but I think we'll need a resource-sensitive solution in order to support this cache in the thriftserver.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T03:18:28Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "There's some extra complexity here since each table has its own cache, so you could still exceed the amount of available memory if there were multiple tables.\n\nSome options here:\n1) A large shared cache that includes table name in the key\n2) Pick an arbitrary size limit for each table cache\n3) Do nothing\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T20:25:35Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "A single shared cache with some kind of upper limit on entries (or memory, the configuration of which is worth another discussion) and automatic eviction would simplify global resource management. I think we will need something like this to support the thriftserver.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T20:39:49Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "It turns out a global cache is fairly complicated if you want to correctly garbage-collect entries with their owning tables. I opted for a simpler per-table max cache size, defaulting to 50MB per table. This should fit a few tens of thousands of partitions (1 filestatus object is ~1k in size).\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T22:17:54Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "Sounds like a plan.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T22:21:51Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "hm this is pretty risky, because the number of tables in a real environment can be very large.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-20T06:56:41Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "That's a good point.\n\n@ericl, do you want to have a go at a global cache and push something for review?\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-20T16:41:55Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "This is already better than what we have in 2.0 - which is caching everything with no limit.\n\nA global cache is really fairly complicated since we can no longer rely on the Java GC to manage the lifetime of the cache entries. Unless we want to do this manual GC in a finalizer, I don't think it is worth it.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-20T18:54:55Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "What about using the cache's built-in eviction process? That would enforce an upper limit on memory usage.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-20T19:13:31Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "That's a good idea. I've pushed a change that implements this with a global cache size limit of 250MB.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-20T21:29:20Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.SerializableConfiguration\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {",
    "line": 41
  }],
  "prId": 15539
}, {
  "comments": [{
    "author": {
      "login": "mallman"
    },
    "body": "This comment is out of date.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T22:22:21Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+/**\n+ * An implementation that caches all partition file statuses in memory forever."
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "Updated\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-19T22:53:09Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+/**\n+ * An implementation that caches all partition file statuses in memory forever."
  }],
  "prId": 15539
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Why do we need a client id? It looks to me that if a client refers to a same path of another client, it won't hit the cache. Is it an expected behaviour?\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-21T02:16:57Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  // Opaque object that uniquely identifies a shared cache user\n+  type ClientId = Object"
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "I think it's better to err on the side of isolation here. Otherwise, it is harder to reason about what is actually invalidated when a table is refreshed.\n",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2016-10-21T06:27:07Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  // Opaque object that uniquely identifies a shared cache user\n+  type ClientId = Object"
  }],
  "prId": 15539
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "These two conf have to be global and static; otherwise, we might face weird behaviors when different sessions are using/changing different values. Let me submit a PR to improve it.",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2017-01-08T07:19:41Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  private var sharedCache: SharedInMemoryCache = null\n+\n+  /**\n+   * @return a new FileStatusCache based on session configuration. Cache memory quota is\n+   *         shared across all clients.\n+   */\n+  def newCache(session: SparkSession): FileStatusCache = {\n+    synchronized {\n+      if (session.sqlContext.conf.filesourcePartitionPruning &&\n+          session.sqlContext.conf.filesourcePartitionFileCacheSize > 0) {",
    "line": 68
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "Sounds good, as long as you can still change it at runtime.",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2017-01-08T07:37:57Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  private var sharedCache: SharedInMemoryCache = null\n+\n+  /**\n+   * @return a new FileStatusCache based on session configuration. Cache memory quota is\n+   *         shared across all clients.\n+   */\n+  def newCache(session: SparkSession): FileStatusCache = {\n+    synchronized {\n+      if (session.sqlContext.conf.filesourcePartitionPruning &&\n+          session.sqlContext.conf.filesourcePartitionFileCacheSize > 0) {",
    "line": 68
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "If we allow users to change it at runtime, users might get strange results due to the global sharing cache. Some sessions might skip cache to directly change the metastore, some sessions are still using the cached values. Even in a single session, we might still face similar issues if we allow users to change it at runtime. ",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2017-01-08T07:45:28Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  private var sharedCache: SharedInMemoryCache = null\n+\n+  /**\n+   * @return a new FileStatusCache based on session configuration. Cache memory quota is\n+   *         shared across all clients.\n+   */\n+  def newCache(session: SparkSession): FileStatusCache = {\n+    synchronized {\n+      if (session.sqlContext.conf.filesourcePartitionPruning &&\n+          session.sqlContext.conf.filesourcePartitionFileCacheSize > 0) {",
    "line": 68
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Or can we make the cache session-specific? ",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2017-01-08T07:46:00Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  private var sharedCache: SharedInMemoryCache = null\n+\n+  /**\n+   * @return a new FileStatusCache based on session configuration. Cache memory quota is\n+   *         shared across all clients.\n+   */\n+  def newCache(session: SparkSession): FileStatusCache = {\n+    synchronized {\n+      if (session.sqlContext.conf.filesourcePartitionPruning &&\n+          session.sqlContext.conf.filesourcePartitionFileCacheSize > 0) {",
    "line": 68
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "Oh I see, the sizing can be problematic. I find it sometimes useful for debugging to turn it off at runtime by setting it to zero though -- it will take effect after a refresh table.\r\n\r\nPerhaps we can just add in the documentation that adjusting the value at runtime may produce unexpected behavior when there are multiple sessions (or just that it should not be adjusted at runtime)?",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2017-01-08T08:27:04Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  private var sharedCache: SharedInMemoryCache = null\n+\n+  /**\n+   * @return a new FileStatusCache based on session configuration. Cache memory quota is\n+   *         shared across all clients.\n+   */\n+  def newCache(session: SparkSession): FileStatusCache = {\n+    synchronized {\n+      if (session.sqlContext.conf.filesourcePartitionPruning &&\n+          session.sqlContext.conf.filesourcePartitionFileCacheSize > 0) {",
    "line": 68
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "How about `HIVE_MANAGE_FILESOURCE_PARTITIONS`? ",
    "commit": "2a965377258d4d77db5a3f00d4257bbacc4a0adb",
    "createdAt": "2017-01-08T17:32:13Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources\n+\n+import java.util.concurrent.ConcurrentHashMap\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import scala.collection.JavaConverters._\n+\n+import com.google.common.cache._\n+import org.apache.hadoop.fs.{FileStatus, Path}\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.metrics.source.HiveCatalogMetrics\n+import org.apache.spark.sql.SparkSession\n+import org.apache.spark.util.{SerializableConfiguration, SizeEstimator}\n+\n+/**\n+ * A cache of the leaf files of partition directories. We cache these files in order to speed\n+ * up iterated queries over the same set of partitions. Otherwise, each query would have to\n+ * hit remote storage in order to gather file statistics for physical planning.\n+ *\n+ * Each resolved catalog table has its own FileStatusCache. When the backing relation for the\n+ * table is refreshed via refreshTable() or refreshByPath(), this cache will be invalidated.\n+ */\n+abstract class FileStatusCache {\n+  /**\n+   * @return the leaf files for the specified path from this cache, or None if not cached.\n+   */\n+  def getLeafFiles(path: Path): Option[Array[FileStatus]] = None\n+\n+  /**\n+   * Saves the given set of leaf files for a path in this cache.\n+   */\n+  def putLeafFiles(path: Path, leafFiles: Array[FileStatus]): Unit\n+\n+  /**\n+   * Invalidates all data held by this cache.\n+   */\n+  def invalidateAll(): Unit\n+}\n+\n+object FileStatusCache {\n+  private var sharedCache: SharedInMemoryCache = null\n+\n+  /**\n+   * @return a new FileStatusCache based on session configuration. Cache memory quota is\n+   *         shared across all clients.\n+   */\n+  def newCache(session: SparkSession): FileStatusCache = {\n+    synchronized {\n+      if (session.sqlContext.conf.filesourcePartitionPruning &&\n+          session.sqlContext.conf.filesourcePartitionFileCacheSize > 0) {",
    "line": 68
  }],
  "prId": 15539
}]