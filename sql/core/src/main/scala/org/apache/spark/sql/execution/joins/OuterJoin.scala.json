[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Pretty sure there's a bug here (see above comment): if unsafe is disabled then we should never generate unsafe projections.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-05T09:12:19Z",
    "diffHunk": "@@ -63,10 +74,12 @@ trait HashOuterJoin {\n     case LeftOuter => (rightKeys, leftKeys)\n     case x =>\n       throw new IllegalArgumentException(\n-        s\"HashOuterJoin should not take $x as the JoinType\")\n+        s\"${getClass.getSimpleName} should not take $x as the JoinType\")\n   }\n \n   protected[this] def isUnsafeMode: Boolean = {\n+    // TODO(josh): there is an existing bug here: this should also check whether unsafe mode\n+    // is enabled. also, the default for self.codegenEnabled looks inconsistent to me.\n     (self.codegenEnabled && joinType != FullOuter"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "This will be addressed by @davies' patch to consolidate the Unsafe and Codegen configurations.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T02:25:18Z",
    "diffHunk": "@@ -63,10 +74,12 @@ trait HashOuterJoin {\n     case LeftOuter => (rightKeys, leftKeys)\n     case x =>\n       throw new IllegalArgumentException(\n-        s\"HashOuterJoin should not take $x as the JoinType\")\n+        s\"${getClass.getSimpleName} should not take $x as the JoinType\")\n   }\n \n   protected[this] def isUnsafeMode: Boolean = {\n+    // TODO(josh): there is an existing bug here: this should also check whether unsafe mode\n+    // is enabled. also, the default for self.codegenEnabled looks inconsistent to me.\n     (self.codegenEnabled && joinType != FullOuter"
  }],
  "prId": 7904
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Here, I just moved this check one level higher so that we're not required to pass the key in. The assumption here is that if the key is null then `leftIter` will be either null or empty.  I can add comments to clarify this.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-05T09:16:11Z",
    "diffHunk": "@@ -111,51 +124,41 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow]): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()\n-          }\n-        } else {\n-          List.empty\n-        }\n-        if (temp.isEmpty) {\n-          resultProjection(joinedRow.withRight(rightNullRow)).copy :: Nil\n-        } else {\n-          temp\n+      val temp = if (rightIter != null) {\n+        rightIter.collect {\n+          case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()\n         }\n       } else {\n+        List.empty\n+      }\n+      if (temp.isEmpty) {\n         resultProjection(joinedRow.withRight(rightNullRow)).copy :: Nil\n+      } else {\n+        temp\n       }\n     }\n     ret.iterator\n   }\n \n   protected[this] def rightOuterIterator(\n-      key: InternalRow,\n       leftIter: Iterable[InternalRow],\n       joinedRow: JoinedRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {"
  }],
  "prId": 7904
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Constructing an `Iterable` only to turn around and call `.iterator` doesn't make a lot of sense to me, especially since it forces us to defensively copy in the `collect`.  Instead, I think this should accept and return iterators.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-05T09:20:11Z",
    "diffHunk": "@@ -111,51 +124,41 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow]): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()\n-          }\n-        } else {\n-          List.empty\n-        }\n-        if (temp.isEmpty) {\n-          resultProjection(joinedRow.withRight(rightNullRow)).copy :: Nil\n-        } else {\n-          temp\n+      val temp = if (rightIter != null) {\n+        rightIter.collect {\n+          case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()\n         }\n       } else {\n+        List.empty\n+      }\n+      if (temp.isEmpty) {\n         resultProjection(joinedRow.withRight(rightNullRow)).copy :: Nil\n+      } else {\n+        temp\n       }\n     }\n     ret.iterator\n   }\n \n   protected[this] def rightOuterIterator(\n-      key: InternalRow,\n       leftIter: Iterable[InternalRow],\n       joinedRow: JoinedRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {"
  }],
  "prId": 7904
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "This problem existed in the old code, but I should fix it here: I don't think that we need to perform this `copy()` here.\n\nAlso, I don't see why we need to construct `val ret: Iterable[InternalRow]` here only to turn around and immediately call `ret.iterator` on it.  This seems like it will cause a lot of inefficient copying and materialization.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T07:10:18Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Because of the `collect`, it will hold the Row, so we need this `copy`, I hit this yesterday.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T07:19:59Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()"
  }, {
    "author": {
      "login": "adrian-wang"
    },
    "body": "Actually I have tried to remove it, ended up in failure\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T07:22:01Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Yeah, just noticed the same thing :(\n\nThis is one reason why I like some of the new internal iterator-like interfaces that we have, which fuse together the `hasNext()` and `getNext()` calls into a single `next()` method that returns a Boolean. Short of using our own iterator implementations throughout Spark SQL I think that we're going to be stuck performing this copy here.\n\nHowever, we still might be able to improve efficiency by avoiding the `collect()` and the use of partial functions here.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T07:59:48Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "In fact, re-using the iterator itself and removing a layer of `flatMap` using our own imperative code would probably make more sense here, since that would avoid the creation of a new `Iterator` object for every left row.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T08:11:31Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()"
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "Just pushed an update which removes this use of `flatMap`, `collect` and partial functions for SMJ outer join.  Since SMJ outer join no longer relies on these changes in OuterJoin I'm going to back out all of the other now-unrelated changes to the other outer join operators. We can pursue optimization of those other joins as part of a followup patch.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T20:55:03Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()"
  }],
  "prId": 7904
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we shouldn't use collect and partial function. this is really inefficient and also requires copy.\n",
    "commit": "eabacca9864e609a1b085a2acbe10907929700a4",
    "createdAt": "2015-08-07T07:22:30Z",
    "diffHunk": "@@ -111,52 +122,43 @@ trait HashOuterJoin {\n   // iterator for performance purpose.\n \n   protected[this] def leftOuterIterator(\n-      key: InternalRow,\n       joinedRow: JoinedRow,\n       rightIter: Iterable[InternalRow],\n       resultProjection: InternalRow => InternalRow): Iterator[InternalRow] = {\n     val ret: Iterable[InternalRow] = {\n-      if (!key.anyNull) {\n-        val temp = if (rightIter != null) {\n-          rightIter.collect {\n-            case r if boundCondition(joinedRow.withRight(r)) => resultProjection(joinedRow).copy()\n-          }\n-        } else {\n-          List.empty\n-        }\n-        if (temp.isEmpty) {\n-          resultProjection(joinedRow.withRight(rightNullRow)) :: Nil\n-        } else {\n-          temp\n+      val temp = if (rightIter != null) {\n+        rightIter.collect {"
  }],
  "prId": 7904
}]