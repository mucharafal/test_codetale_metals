[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Will this be easier to understand if we use fullname instead of `A`/`O`? \n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-08T23:33:55Z",
    "diffHunk": "@@ -156,36 +165,90 @@ case class Window(\n    * @param frame boundaries.\n    * @param functions to process in the frame.\n    * @param ordinal at which the processor starts writing to the output.\n+   * @param target to which the processor will write.\n    * @return a frame processor.\n    */\n   private[this] def createFrameProcessor(\n-      frame: WindowFrame,\n-      functions: Array[WindowFunction],\n-      ordinal: Int): WindowFunctionFrame = frame match {\n-    // Growing Frame.\n-    case SpecifiedWindowFrame(frameType, UnboundedPreceding, FrameBoundaryExtractor(high)) =>\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new UnboundedPrecedingWindowFunctionFrame(ordinal, functions, uBoundOrdering)\n-\n-    // Shrinking Frame.\n-    case SpecifiedWindowFrame(frameType, FrameBoundaryExtractor(low), UnboundedFollowing) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      new UnboundedFollowingWindowFunctionFrame(ordinal, functions, lBoundOrdering)\n-\n-    // Moving Frame.\n-    case SpecifiedWindowFrame(frameType,\n-        FrameBoundaryExtractor(low), FrameBoundaryExtractor(high)) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new SlidingWindowFunctionFrame(ordinal, functions, lBoundOrdering, uBoundOrdering)\n-\n-    // Entire Partition Frame.\n-    case SpecifiedWindowFrame(_, UnboundedPreceding, UnboundedFollowing) =>\n-      new UnboundedWindowFunctionFrame(ordinal, functions)\n-\n-    // Error\n-    case fr =>\n-      sys.error(s\"Unsupported Frame $fr for functions: $functions\")\n+    frame: (Char, WindowFrame),\n+    functions: Array[Expression],\n+    ordinal: Int,\n+    target: MutableRow): WindowFunctionFrame = {\n+\n+    // Construct an aggregate processor if we have to.\n+    def processor = {\n+      val prepared = functions.map(_.asInstanceOf[AggregateFunction])\n+      AggregateProcessor(prepared, ordinal, child.output, newMutableProjection)\n+    }\n+\n+    // Create the frame processor.\n+    frame match {\n+      // Offset Frame\n+      case ('O', SpecifiedWindowFrame(RowFrame,\n+                  FrameBoundaryExtractor(l),\n+                  FrameBoundaryExtractor(h)))\n+        if l == h =>\n+        new OffsetWindowFunctionFrame(target, ordinal, functions, child.output,\n+          newMutableProjection, l)\n+\n+      // Growing Frame.\n+      case ('A', SpecifiedWindowFrame(frameType,\n+                  UnboundedPreceding,\n+                  FrameBoundaryExtractor(high))) =>\n+        val uBoundOrdering = createBoundOrdering(frameType, high)\n+        new UnboundedPrecedingWindowFunctionFrame(target, processor, uBoundOrdering)\n+\n+      // Shrinking Frame.\n+      case ('A', SpecifiedWindowFrame(frameType,\n+                  FrameBoundaryExtractor(low),\n+                  UnboundedFollowing)) =>\n+        val lBoundOrdering = createBoundOrdering(frameType, low)\n+        new UnboundedFollowingWindowFunctionFrame(target, processor, lBoundOrdering)\n+\n+      // Moving Frame.\n+      case ('A', SpecifiedWindowFrame(frameType,\n+                  FrameBoundaryExtractor(l),\n+                  FrameBoundaryExtractor(h))) =>\n+        val lBoundOrdering = createBoundOrdering(frameType, l)\n+        val uBoundOrdering = createBoundOrdering(frameType, h)\n+        new SlidingWindowFunctionFrame(target, processor, lBoundOrdering, uBoundOrdering)\n+\n+      // Entire Partition Frame.\n+      case ('A', SpecifiedWindowFrame(_,\n+                  UnboundedPreceding,\n+                  UnboundedFollowing)) =>\n+        new UnboundedWindowFunctionFrame(target, processor)\n+    }\n+  }\n+\n+  /** Map of window expressions and functions by their key. */\n+  private[this] lazy val windowFunctionMap: FunctionMap = {\n+    val functions: FunctionMap = mutable.Map.empty\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: Char, frame: WindowFrame, e: Expression, f: Expression): Unit = {\n+      val (es, fs) = functions.getOrElseUpdate(\n+        (tpe, frame), (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es.append(e)\n+      fs.append(f)\n+    }\n+\n+    // Collect all valid window functions.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification\n+          function match {\n+            case AggregateExpression(f, _, _) => collect('A', frame, e, f)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "It'll help. I am not really happy with this entire code block; further suggestions are welcome.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T00:06:45Z",
    "diffHunk": "@@ -156,36 +165,90 @@ case class Window(\n    * @param frame boundaries.\n    * @param functions to process in the frame.\n    * @param ordinal at which the processor starts writing to the output.\n+   * @param target to which the processor will write.\n    * @return a frame processor.\n    */\n   private[this] def createFrameProcessor(\n-      frame: WindowFrame,\n-      functions: Array[WindowFunction],\n-      ordinal: Int): WindowFunctionFrame = frame match {\n-    // Growing Frame.\n-    case SpecifiedWindowFrame(frameType, UnboundedPreceding, FrameBoundaryExtractor(high)) =>\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new UnboundedPrecedingWindowFunctionFrame(ordinal, functions, uBoundOrdering)\n-\n-    // Shrinking Frame.\n-    case SpecifiedWindowFrame(frameType, FrameBoundaryExtractor(low), UnboundedFollowing) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      new UnboundedFollowingWindowFunctionFrame(ordinal, functions, lBoundOrdering)\n-\n-    // Moving Frame.\n-    case SpecifiedWindowFrame(frameType,\n-        FrameBoundaryExtractor(low), FrameBoundaryExtractor(high)) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new SlidingWindowFunctionFrame(ordinal, functions, lBoundOrdering, uBoundOrdering)\n-\n-    // Entire Partition Frame.\n-    case SpecifiedWindowFrame(_, UnboundedPreceding, UnboundedFollowing) =>\n-      new UnboundedWindowFunctionFrame(ordinal, functions)\n-\n-    // Error\n-    case fr =>\n-      sys.error(s\"Unsupported Frame $fr for functions: $functions\")\n+    frame: (Char, WindowFrame),\n+    functions: Array[Expression],\n+    ordinal: Int,\n+    target: MutableRow): WindowFunctionFrame = {\n+\n+    // Construct an aggregate processor if we have to.\n+    def processor = {\n+      val prepared = functions.map(_.asInstanceOf[AggregateFunction])\n+      AggregateProcessor(prepared, ordinal, child.output, newMutableProjection)\n+    }\n+\n+    // Create the frame processor.\n+    frame match {\n+      // Offset Frame\n+      case ('O', SpecifiedWindowFrame(RowFrame,\n+                  FrameBoundaryExtractor(l),\n+                  FrameBoundaryExtractor(h)))\n+        if l == h =>\n+        new OffsetWindowFunctionFrame(target, ordinal, functions, child.output,\n+          newMutableProjection, l)\n+\n+      // Growing Frame.\n+      case ('A', SpecifiedWindowFrame(frameType,\n+                  UnboundedPreceding,\n+                  FrameBoundaryExtractor(high))) =>\n+        val uBoundOrdering = createBoundOrdering(frameType, high)\n+        new UnboundedPrecedingWindowFunctionFrame(target, processor, uBoundOrdering)\n+\n+      // Shrinking Frame.\n+      case ('A', SpecifiedWindowFrame(frameType,\n+                  FrameBoundaryExtractor(low),\n+                  UnboundedFollowing)) =>\n+        val lBoundOrdering = createBoundOrdering(frameType, low)\n+        new UnboundedFollowingWindowFunctionFrame(target, processor, lBoundOrdering)\n+\n+      // Moving Frame.\n+      case ('A', SpecifiedWindowFrame(frameType,\n+                  FrameBoundaryExtractor(l),\n+                  FrameBoundaryExtractor(h))) =>\n+        val lBoundOrdering = createBoundOrdering(frameType, l)\n+        val uBoundOrdering = createBoundOrdering(frameType, h)\n+        new SlidingWindowFunctionFrame(target, processor, lBoundOrdering, uBoundOrdering)\n+\n+      // Entire Partition Frame.\n+      case ('A', SpecifiedWindowFrame(_,\n+                  UnboundedPreceding,\n+                  UnboundedFollowing)) =>\n+        new UnboundedWindowFunctionFrame(target, processor)\n+    }\n+  }\n+\n+  /** Map of window expressions and functions by their key. */\n+  private[this] lazy val windowFunctionMap: FunctionMap = {\n+    val functions: FunctionMap = mutable.Map.empty\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: Char, frame: WindowFrame, e: Expression, f: Expression): Unit = {\n+      val (es, fs) = functions.getOrElseUpdate(\n+        (tpe, frame), (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es.append(e)\n+      fs.append(f)\n+    }\n+\n+    // Collect all valid window functions.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification\n+          function match {\n+            case AggregateExpression(f, _, _) => collect('A', frame, e, f)"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "After adding `wf.size` into `aggBufferAttributes`, do we still need to call `wf.withSize`?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:44:21Z",
    "diffHunk": "@@ -736,15 +691,156 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):\n+    AggregateProcessor = {\n+    val aggBufferAttributes = mutable.Buffer.empty[AttributeReference]\n+    val initialValues = mutable.Buffer.empty[Expression]\n+    val updateExpressions = mutable.Buffer.empty[Expression]\n+    val evaluateExpressions = mutable.Buffer.fill[Expression](ordinal)(NoOp)\n+    val imperatives = mutable.Buffer.empty[ImperativeAggregate]\n+\n+    // Create and add a size reference to SizeBasedWindowFunction.\n+    var sizeOrdinal = -1\n+    var size: BoundReference = null\n+    val addSize = (f: Expression) => f match {\n+      case wf: SizeBasedWindowFunction =>\n+        if (size == null) {\n+          sizeOrdinal = aggBufferAttributes.size\n+          size = BoundReference(sizeOrdinal, IntegerType, false)\n+          aggBufferAttributes += wf.size\n+          initialValues += NoOp\n+          updateExpressions += NoOp\n+        }\n+        wf.withSize(size)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "We - unfortunately - do `wf.size` is ref 'owned' by one of the `SizeBasedWindowFunction`s, all other size expressions have different `size` properties, so they won't bind to this one.\n\nI'll try to see if we can make this work in a more transparant way, by sharing the `size` propery (or its id).\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T22:06:42Z",
    "diffHunk": "@@ -736,15 +691,156 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):\n+    AggregateProcessor = {\n+    val aggBufferAttributes = mutable.Buffer.empty[AttributeReference]\n+    val initialValues = mutable.Buffer.empty[Expression]\n+    val updateExpressions = mutable.Buffer.empty[Expression]\n+    val evaluateExpressions = mutable.Buffer.fill[Expression](ordinal)(NoOp)\n+    val imperatives = mutable.Buffer.empty[ImperativeAggregate]\n+\n+    // Create and add a size reference to SizeBasedWindowFunction.\n+    var sizeOrdinal = -1\n+    var size: BoundReference = null\n+    val addSize = (f: Expression) => f match {\n+      case wf: SizeBasedWindowFunction =>\n+        if (size == null) {\n+          sizeOrdinal = aggBufferAttributes.size\n+          size = BoundReference(sizeOrdinal, IntegerType, false)\n+          aggBufferAttributes += wf.size\n+          initialValues += NoOp\n+          updateExpressions += NoOp\n+        }\n+        wf.withSize(size)"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "It could fail to bound for ImperativeAggregate\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:48:40Z",
    "diffHunk": "@@ -736,15 +691,156 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):\n+    AggregateProcessor = {\n+    val aggBufferAttributes = mutable.Buffer.empty[AttributeReference]\n+    val initialValues = mutable.Buffer.empty[Expression]\n+    val updateExpressions = mutable.Buffer.empty[Expression]\n+    val evaluateExpressions = mutable.Buffer.fill[Expression](ordinal)(NoOp)\n+    val imperatives = mutable.Buffer.empty[ImperativeAggregate]\n+\n+    // Create and add a size reference to SizeBasedWindowFunction.\n+    var sizeOrdinal = -1\n+    var size: BoundReference = null\n+    val addSize = (f: Expression) => f match {\n+      case wf: SizeBasedWindowFunction =>\n+        if (size == null) {\n+          sizeOrdinal = aggBufferAttributes.size\n+          size = BoundReference(sizeOrdinal, IntegerType, false)\n+          aggBufferAttributes += wf.size\n+          initialValues += NoOp\n+          updateExpressions += NoOp\n+        }\n+        wf.withSize(size)\n+      case e => e\n+    }\n+\n+    // Add an AggregateFunction to the AggregateProcessor.\n+    val addToProcessor = (f: Expression) => f match {\n+      case agg: DeclarativeAggregate =>\n+        aggBufferAttributes ++= agg.aggBufferAttributes\n+        initialValues ++= agg.initialValues\n+        updateExpressions ++= agg.updateExpressions\n+        evaluateExpressions += agg.evaluateExpression\n+      case agg: ImperativeAggregate =>\n+        val offset = aggBufferAttributes.size\n+        val imperative = BindReferences.bindReference(agg\n+          .withNewInputAggBufferOffset(offset)\n+          .withNewMutableAggBufferOffset(offset),\n+          inputAttributes)\n+        imperatives += imperative\n+        aggBufferAttributes ++= imperative.aggBufferAttributes\n+        val noOps = Seq.fill(imperative.aggBufferAttributes.size)(NoOp)\n+        initialValues ++= noOps\n+        updateExpressions ++= noOps\n+        evaluateExpressions += imperative\n+      case other =>\n+        sys.error(s\"Unsupported Aggregate Function: $f\")\n+    }\n+\n+    // Process the functions.\n+    functions.foreach(addSize.andThen(addToProcessor))\n+\n+    // Create the projections.\n+    val initialProjection = newMutableProjection(initialValues, Nil)()\n+    val updateProjection = newMutableProjection(\n+      updateExpressions,\n+      aggBufferAttributes ++ inputAttributes)()\n+    val evaluateProjection = newMutableProjection(\n+      evaluateExpressions,\n+      aggBufferAttributes)()",
    "line": 825
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I have added the bound `ImperativeAggregate` to the `evaluateExpressions`, so there is (should be) nothing left to bind. The `ImperativeAggregate` is being bound on line https://github.com/hvanhovell/spark/blob/SPARK-8641-2/sql/core/src/main/scala/org/apache/spark/sql/execution/Window.scala#L753\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:55:50Z",
    "diffHunk": "@@ -736,15 +691,156 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):\n+    AggregateProcessor = {\n+    val aggBufferAttributes = mutable.Buffer.empty[AttributeReference]\n+    val initialValues = mutable.Buffer.empty[Expression]\n+    val updateExpressions = mutable.Buffer.empty[Expression]\n+    val evaluateExpressions = mutable.Buffer.fill[Expression](ordinal)(NoOp)\n+    val imperatives = mutable.Buffer.empty[ImperativeAggregate]\n+\n+    // Create and add a size reference to SizeBasedWindowFunction.\n+    var sizeOrdinal = -1\n+    var size: BoundReference = null\n+    val addSize = (f: Expression) => f match {\n+      case wf: SizeBasedWindowFunction =>\n+        if (size == null) {\n+          sizeOrdinal = aggBufferAttributes.size\n+          size = BoundReference(sizeOrdinal, IntegerType, false)\n+          aggBufferAttributes += wf.size\n+          initialValues += NoOp\n+          updateExpressions += NoOp\n+        }\n+        wf.withSize(size)\n+      case e => e\n+    }\n+\n+    // Add an AggregateFunction to the AggregateProcessor.\n+    val addToProcessor = (f: Expression) => f match {\n+      case agg: DeclarativeAggregate =>\n+        aggBufferAttributes ++= agg.aggBufferAttributes\n+        initialValues ++= agg.initialValues\n+        updateExpressions ++= agg.updateExpressions\n+        evaluateExpressions += agg.evaluateExpression\n+      case agg: ImperativeAggregate =>\n+        val offset = aggBufferAttributes.size\n+        val imperative = BindReferences.bindReference(agg\n+          .withNewInputAggBufferOffset(offset)\n+          .withNewMutableAggBufferOffset(offset),\n+          inputAttributes)\n+        imperatives += imperative\n+        aggBufferAttributes ++= imperative.aggBufferAttributes\n+        val noOps = Seq.fill(imperative.aggBufferAttributes.size)(NoOp)\n+        initialValues ++= noOps\n+        updateExpressions ++= noOps\n+        evaluateExpressions += imperative\n+      case other =>\n+        sys.error(s\"Unsupported Aggregate Function: $f\")\n+    }\n+\n+    // Process the functions.\n+    functions.foreach(addSize.andThen(addToProcessor))\n+\n+    // Create the projections.\n+    val initialProjection = newMutableProjection(initialValues, Nil)()\n+    val updateProjection = newMutableProjection(\n+      updateExpressions,\n+      aggBufferAttributes ++ inputAttributes)()\n+    val evaluateProjection = newMutableProjection(\n+      evaluateExpressions,\n+      aggBufferAttributes)()",
    "line": 825
  }, {
    "author": {
      "login": "davies"
    },
    "body": "I see, thanks!\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T06:18:34Z",
    "diffHunk": "@@ -736,15 +691,156 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):\n+    AggregateProcessor = {\n+    val aggBufferAttributes = mutable.Buffer.empty[AttributeReference]\n+    val initialValues = mutable.Buffer.empty[Expression]\n+    val updateExpressions = mutable.Buffer.empty[Expression]\n+    val evaluateExpressions = mutable.Buffer.fill[Expression](ordinal)(NoOp)\n+    val imperatives = mutable.Buffer.empty[ImperativeAggregate]\n+\n+    // Create and add a size reference to SizeBasedWindowFunction.\n+    var sizeOrdinal = -1\n+    var size: BoundReference = null\n+    val addSize = (f: Expression) => f match {\n+      case wf: SizeBasedWindowFunction =>\n+        if (size == null) {\n+          sizeOrdinal = aggBufferAttributes.size\n+          size = BoundReference(sizeOrdinal, IntegerType, false)\n+          aggBufferAttributes += wf.size\n+          initialValues += NoOp\n+          updateExpressions += NoOp\n+        }\n+        wf.withSize(size)\n+      case e => e\n+    }\n+\n+    // Add an AggregateFunction to the AggregateProcessor.\n+    val addToProcessor = (f: Expression) => f match {\n+      case agg: DeclarativeAggregate =>\n+        aggBufferAttributes ++= agg.aggBufferAttributes\n+        initialValues ++= agg.initialValues\n+        updateExpressions ++= agg.updateExpressions\n+        evaluateExpressions += agg.evaluateExpression\n+      case agg: ImperativeAggregate =>\n+        val offset = aggBufferAttributes.size\n+        val imperative = BindReferences.bindReference(agg\n+          .withNewInputAggBufferOffset(offset)\n+          .withNewMutableAggBufferOffset(offset),\n+          inputAttributes)\n+        imperatives += imperative\n+        aggBufferAttributes ++= imperative.aggBufferAttributes\n+        val noOps = Seq.fill(imperative.aggBufferAttributes.size)(NoOp)\n+        initialValues ++= noOps\n+        updateExpressions ++= noOps\n+        evaluateExpressions += imperative\n+      case other =>\n+        sys.error(s\"Unsupported Aggregate Function: $f\")\n+    }\n+\n+    // Process the functions.\n+    functions.foreach(addSize.andThen(addToProcessor))\n+\n+    // Create the projections.\n+    val initialProjection = newMutableProjection(initialValues, Nil)()\n+    val updateProjection = newMutableProjection(\n+      updateExpressions,\n+      aggBufferAttributes ++ inputAttributes)()\n+    val evaluateProjection = newMutableProjection(\n+      evaluateExpressions,\n+      aggBufferAttributes)()",
    "line": 825
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "This is a list of Tuple, not Map\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:54:38Z",
    "diffHunk": "@@ -149,43 +152,102 @@ case class Window(\n   }\n \n   /**\n-   * Create a frame processor.\n-   *\n-   * This method uses Code Generation. It can only be used on the executor side.\n-   *\n-   * @param frame boundaries.\n-   * @param functions to process in the frame.\n-   * @param ordinal at which the processor starts writing to the output.\n-   * @return a frame processor.\n+   * Collection containing an entry for each window frame to process. Each entry contains a frames'\n+   * WindowExpressions and factory function for the WindowFrameFunction.\n    */\n-  private[this] def createFrameProcessor(\n-      frame: WindowFrame,\n-      functions: Array[WindowFunction],\n-      ordinal: Int): WindowFunctionFrame = frame match {\n-    // Growing Frame.\n-    case SpecifiedWindowFrame(frameType, UnboundedPreceding, FrameBoundaryExtractor(high)) =>\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new UnboundedPrecedingWindowFunctionFrame(ordinal, functions, uBoundOrdering)\n-\n-    // Shrinking Frame.\n-    case SpecifiedWindowFrame(frameType, FrameBoundaryExtractor(low), UnboundedFollowing) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      new UnboundedFollowingWindowFunctionFrame(ordinal, functions, lBoundOrdering)\n-\n-    // Moving Frame.\n-    case SpecifiedWindowFrame(frameType,\n-        FrameBoundaryExtractor(low), FrameBoundaryExtractor(high)) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new SlidingWindowFunctionFrame(ordinal, functions, lBoundOrdering, uBoundOrdering)\n-\n-    // Entire Partition Frame.\n-    case SpecifiedWindowFrame(_, UnboundedPreceding, UnboundedFollowing) =>\n-      new UnboundedWindowFunctionFrame(ordinal, functions)\n-\n-    // Error\n-    case fr =>\n-      sys.error(s\"Unsupported Frame $fr for functions: $functions\")\n+  private[this] lazy val windowFrameFactoryMap = {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "`windowFrameFactoryPairs`? I could extract the two components in a pattern match, but then I would also have to make this `transient`.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:58:09Z",
    "diffHunk": "@@ -149,43 +152,102 @@ case class Window(\n   }\n \n   /**\n-   * Create a frame processor.\n-   *\n-   * This method uses Code Generation. It can only be used on the executor side.\n-   *\n-   * @param frame boundaries.\n-   * @param functions to process in the frame.\n-   * @param ordinal at which the processor starts writing to the output.\n-   * @return a frame processor.\n+   * Collection containing an entry for each window frame to process. Each entry contains a frames'\n+   * WindowExpressions and factory function for the WindowFrameFunction.\n    */\n-  private[this] def createFrameProcessor(\n-      frame: WindowFrame,\n-      functions: Array[WindowFunction],\n-      ordinal: Int): WindowFunctionFrame = frame match {\n-    // Growing Frame.\n-    case SpecifiedWindowFrame(frameType, UnboundedPreceding, FrameBoundaryExtractor(high)) =>\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new UnboundedPrecedingWindowFunctionFrame(ordinal, functions, uBoundOrdering)\n-\n-    // Shrinking Frame.\n-    case SpecifiedWindowFrame(frameType, FrameBoundaryExtractor(low), UnboundedFollowing) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      new UnboundedFollowingWindowFunctionFrame(ordinal, functions, lBoundOrdering)\n-\n-    // Moving Frame.\n-    case SpecifiedWindowFrame(frameType,\n-        FrameBoundaryExtractor(low), FrameBoundaryExtractor(high)) =>\n-      val lBoundOrdering = createBoundOrdering(frameType, low)\n-      val uBoundOrdering = createBoundOrdering(frameType, high)\n-      new SlidingWindowFunctionFrame(ordinal, functions, lBoundOrdering, uBoundOrdering)\n-\n-    // Entire Partition Frame.\n-    case SpecifiedWindowFrame(_, UnboundedPreceding, UnboundedFollowing) =>\n-      new UnboundedWindowFunctionFrame(ordinal, functions)\n-\n-    // Error\n-    case fr =>\n-      sys.error(s\"Unsupported Frame $fr for functions: $functions\")\n+  private[this] lazy val windowFrameFactoryMap = {"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "order imports\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:33:59Z",
    "diffHunk": "@@ -19,10 +19,13 @@ package org.apache.spark.sql.execution\n \n import org.apache.spark.sql.catalyst.InternalRow\n import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate._\n import org.apache.spark.sql.catalyst.plans.physical._\n import org.apache.spark.sql.types.IntegerType\n import org.apache.spark.rdd.RDD\n-import org.apache.spark.util.collection.CompactBuffer\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "format\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T00:06:17Z",
    "diffHunk": "@@ -736,15 +691,148 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "4 spaces? Or the colon without a result?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T06:58:44Z",
    "diffHunk": "@@ -736,15 +691,148 @@ private[execution] final class UnboundedFollowingWindowFunctionFrame(\n \n     // Only recalculate and update when the buffer changes.\n     if (bufferUpdated) {\n-      evaluatePrepared(buffer, inputIndex, buffer.length)\n-      fill(target, outputIndex)\n+      processor.initialize(input.size)\n+      processor.update(input, inputIndex, input.size)\n+      processor.evaluate(target)\n     }\n \n     // Move to the next row.\n     outputIndex += 1\n   }\n+}\n+\n+/**\n+ * This class prepares and manages the processing of a number of aggregate functions.\n+ *\n+ * This implementation only supports evaluation in [[Complete]] mode. This is enough for\n+ * Window processing.\n+ *\n+ * Processing of distinct aggregates is currently not supported.\n+ *\n+ * The implementation is split into an object which takes care of construction, and a the actual\n+ * processor class. Construction might be expensive and could be separated into a 'driver' and a\n+ * 'executor' part.\n+ */\n+private[execution] object AggregateProcessor {\n+  def apply(functions: Array[Expression],\n+    ordinal: Int,\n+    inputAttributes: Seq[Attribute],\n+    newMutableProjection: (Seq[Expression], Seq[Attribute]) => () => MutableProjection):"
  }],
  "prId": 9819
}]