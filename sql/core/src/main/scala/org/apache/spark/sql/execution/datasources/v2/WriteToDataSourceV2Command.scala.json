[{
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "I know similar tasks do the same, but this should not implement `RunnableCommand`. I'm not sure the original intent for it, but I think `RunnableCommand` should be used for small tasks that are carried out on the driver, like DDL. \r\n\r\nUsing `RunnableCommand` in cases like this where a job needs to run ends up effectively linking a logical plan into a physical plan, which has caused a few messy issues. For example, the problem where the Spark SQL tab doesn't show the entire operation and only shows the outer command without metrics.",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-09-19T23:14:59Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "RunnableCommand simply means it's both a logical plan and a physical plan.\r\n\r\nWe should fix the UI issue separately (which on its own is super annoying).\r\n",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-09-20T07:05:38Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "It isn't just the UI though. I've seen cases where InsertIntoHadoopFsRelationCommand is run inside a CreateDatasourceTableAsSelectCommand, and their enforcement of write modes depend on one another. Our internal S3 committer updates partition information and handles partition-level conflicts, but that requires that the table exists before the write (to check what partitions already exist). When we moved table creation in the CTAS command, it broke the insert into command, when these two should be separate.\r\n\r\nWhile it's convenient to have a logical plan and a physical plan together, I think this ends up getting misused. That's why I'm advocating to change how we use RunnableCommand. To fix it, we should introduce a node with a command and logical plan, so we can optimize the entire plan and run the command at the right time.\r\n\r\nClearly, this isn't a blocker for this PR, I just want to mention that I see this pattern causing a lot of problems every time we pull in a new Spark version.",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-09-20T16:07:49Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {"
  }, {
    "author": {
      "login": "ash211"
    },
    "body": "I've also observed this issue where the explain output of commands behaves differently than from logical plans, and have a repro at https://issues.apache.org/jira/browse/SPARK-22204",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-10-18T01:12:35Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {"
  }],
  "prId": 19269
}, {
  "comments": [{
    "author": {
      "login": "steveloughran"
    },
    "body": "this may raise an exception too...better to use `Utils.tryWithSafeFinallyAndFailureCallbacks()`",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-09-30T12:09:32Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {\n+  override def children: Seq[LogicalPlan] = query :: Nil\n+\n+  override def run(sparkSession: SparkSession, children: Seq[SparkPlan]): Seq[Row] = {\n+    assert(children.length == 1)\n+\n+    val writeTask = writer match {\n+      case w: SupportsWriteInternalRow => w.createInternalRowWriterFactory()\n+      case _ => new RowToInternalRowDataWriteFactory(writer.createWriterFactory(), query.schema)\n+    }\n+\n+    val rdd = children.head.execute()\n+    val messages = new Array[WriterCommitMessage](rdd.partitions.length)\n+\n+    logInfo(s\"Start processing data source writer: $writer\")\n+\n+    try {\n+      sparkSession.sparkContext.runJob(\n+        rdd,\n+        (context: TaskContext, iter: Iterator[InternalRow]) =>\n+          DataWritingSparkTask.run(writeTask, context, iter),\n+        rdd.partitions.indices,\n+        (index, message: WriterCommitMessage) => messages(index) = message\n+      )\n+\n+      writer.commit(messages)\n+      logInfo(s\"Data source writer $writer committed.\")\n+    } catch {\n+      case cause: Throwable =>\n+        writer.abort()"
  }],
  "prId": 19269
}, {
  "comments": [{
    "author": {
      "login": "steveloughran"
    },
    "body": "maybe add #of partitions in the log, helps provide a hint of how long it's going to take. If a job hangs, this'll be the last entry in the log, so it's good to be informative",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-09-30T12:22:39Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {\n+  override def children: Seq[LogicalPlan] = query :: Nil\n+\n+  override def run(sparkSession: SparkSession, children: Seq[SparkPlan]): Seq[Row] = {\n+    assert(children.length == 1)\n+\n+    val writeTask = writer match {\n+      case w: SupportsWriteInternalRow => w.createInternalRowWriterFactory()\n+      case _ => new RowToInternalRowDataWriteFactory(writer.createWriterFactory(), query.schema)\n+    }\n+\n+    val rdd = children.head.execute()\n+    val messages = new Array[WriterCommitMessage](rdd.partitions.length)\n+\n+    logInfo(s\"Start processing data source writer: $writer\")"
  }],
  "prId": 19269
}, {
  "comments": [{
    "author": {
      "login": "steveloughran"
    },
    "body": "good to log something here, at least @ debug",
    "commit": "7eeb3b0bd15644d3facddefcdd2a218316573953",
    "createdAt": "2017-09-30T12:26:25Z",
    "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.{SparkException, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{Row, SparkSession}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.{ExpressionEncoder, RowEncoder}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.command.RunnableCommand\n+import org.apache.spark.sql.sources.v2.writer._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.util.Utils\n+\n+case class WriteToDataSourceV2Command(writer: DataSourceV2Writer, query: LogicalPlan)\n+  extends RunnableCommand {\n+  override def children: Seq[LogicalPlan] = query :: Nil\n+\n+  override def run(sparkSession: SparkSession, children: Seq[SparkPlan]): Seq[Row] = {\n+    assert(children.length == 1)\n+\n+    val writeTask = writer match {\n+      case w: SupportsWriteInternalRow => w.createInternalRowWriterFactory()\n+      case _ => new RowToInternalRowDataWriteFactory(writer.createWriterFactory(), query.schema)\n+    }\n+\n+    val rdd = children.head.execute()\n+    val messages = new Array[WriterCommitMessage](rdd.partitions.length)\n+\n+    logInfo(s\"Start processing data source writer: $writer\")\n+\n+    try {\n+      sparkSession.sparkContext.runJob(\n+        rdd,\n+        (context: TaskContext, iter: Iterator[InternalRow]) =>\n+          DataWritingSparkTask.run(writeTask, context, iter),\n+        rdd.partitions.indices,\n+        (index, message: WriterCommitMessage) => messages(index) = message\n+      )\n+\n+      writer.commit(messages)\n+      logInfo(s\"Data source writer $writer committed.\")\n+    } catch {\n+      case cause: Throwable =>\n+        writer.abort()\n+        logError(s\"Data source writer $writer aborted.\")\n+        throw new SparkException(\"Writing job aborted.\", cause)\n+\n+    }\n+\n+    Nil\n+  }\n+}\n+\n+object DataWritingSparkTask extends Logging {\n+  def run(\n+      writeTask: DataWriteFactory[InternalRow],\n+      context: TaskContext,\n+      iter: Iterator[InternalRow]): WriterCommitMessage = {\n+    val dataWriter =\n+      writeTask.createWriter(context.stageId(), context.partitionId(), context.attemptNumber())\n+\n+    // write the data and commit this writer.\n+    Utils.tryWithSafeFinallyAndFailureCallbacks(block = {\n+      iter.foreach(dataWriter.write)\n+      dataWriter.commit()"
  }],
  "prId": 19269
}]