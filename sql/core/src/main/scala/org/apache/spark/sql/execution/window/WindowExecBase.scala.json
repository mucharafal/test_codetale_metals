[{
  "comments": [{
    "author": {
      "login": "icexelloss"
    },
    "body": "This bit is new",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-09-17T22:09:21Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+private[sql] abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a== b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF if PythonUDF.isGroupedAggPandasUDF(f) =>"
  }],
  "prId": 22305
}, {
  "comments": [{
    "author": {
      "login": "icexelloss"
    },
    "body": "This is changed to have process == null for python UDF case",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-09-17T22:09:59Z",
    "diffHunk": "@@ -0,0 +1,228 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+private[sql] abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a== b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF if PythonUDF.isGroupedAggPandasUDF(f) =>\n+              collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor ="
  }],
  "prId": 22305
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit .. :-) .. `exists{`",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-11T09:35:52Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+private[sql] abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a== b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF => collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor = if (functions.exists{ f => f.isInstanceOf[PythonUDF]}) {"
  }, {
    "author": {
      "login": "icexelloss"
    },
    "body": "Fixed (If I understand you correctly :)",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-11T16:30:22Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+private[sql] abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a== b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF => collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor = if (functions.exists{ f => f.isInstanceOf[PythonUDF]}) {"
  }],
  "prId": 22305
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "(previously existing .. ) nit: `a==`",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-11T09:37:30Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+private[sql] abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a== b => Add(expr, boundOffset)"
  }, {
    "author": {
      "login": "icexelloss"
    },
    "body": "Fixed",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-11T16:29:42Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+private[sql] abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a== b => Add(expr, boundOffset)"
  }],
  "prId": 22305
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit: seems it can be private.",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-15T08:44:48Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering("
  }, {
    "author": {
      "login": "icexelloss"
    },
    "body": "Fixed",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-17T20:07:59Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering("
  }],
  "prId": 22305
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Nit: `functions.exists(_.isInstanceOf[PythonUDF])`",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-15T08:55:16Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a == b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF => collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor = if (functions.exists{f => f.isInstanceOf[PythonUDF]}) {"
  }, {
    "author": {
      "login": "icexelloss"
    },
    "body": "Fixed.",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-17T20:22:50Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a == b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF => collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor = if (functions.exists{f => f.isInstanceOf[PythonUDF]}) {"
  }],
  "prId": 22305
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@icexelloss, Looks there's no case that one implementation of `WindowExecBase` mixes both pandas udf and other aggregate functions together. I understand you did in this way to minimise the diff, which should be fine I guess but shell we leave some comments here? It looks potentially both can be mixed in one implementation of `WindowExecBase`.",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-15T09:21:41Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a == b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF => collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor = if (functions.exists{f => f.isInstanceOf[PythonUDF]}) {\n+          null",
    "line": 163
  }, {
    "author": {
      "login": "icexelloss"
    },
    "body": "I added some comments here to explain",
    "commit": "03702d450a0a9da7bb50057b3bab35bdec7d4584",
    "createdAt": "2018-12-17T20:22:46Z",
    "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.window\n+\n+import scala.collection.mutable\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+import org.apache.spark.sql.types.{CalendarIntervalType, DateType, IntegerType, TimestampType}\n+\n+abstract class WindowExecBase(\n+    windowExpression: Seq[NamedExpression],\n+    partitionSpec: Seq[Expression],\n+    orderSpec: Seq[SortOrder],\n+    child: SparkPlan) extends UnaryExecNode {\n+\n+  /**\n+   * Create the resulting projection.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param expressions unbound ordered function expressions.\n+   * @return the final resulting projection.\n+   */\n+  protected def createResultProjection(expressions: Seq[Expression]): UnsafeProjection = {\n+    val references = expressions.zipWithIndex.map { case (e, i) =>\n+      // Results of window expressions will be on the right side of child's output\n+      BoundReference(child.output.size + i, e.dataType, e.nullable)\n+    }\n+    val unboundToRefMap = expressions.zip(references).toMap\n+    val patchedWindowExpression = windowExpression.map(_.transform(unboundToRefMap))\n+    UnsafeProjection.create(\n+      child.output ++ patchedWindowExpression,\n+      child.output)\n+  }\n+\n+  /**\n+   * Create a bound ordering object for a given frame type and offset. A bound ordering object is\n+   * used to determine which input row lies within the frame boundaries of an output row.\n+   *\n+   * This method uses Code Generation. It can only be used on the executor side.\n+   *\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n+   * @param timeZone the session local timezone for time related calculations.\n+   * @return a bound ordering object.\n+   */\n+  protected def createBoundOrdering(\n+      frame: FrameType, bound: Expression, timeZone: String): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)\n+          case (TimestampType, CalendarIntervalType) =>\n+            TimeAdd(expr, boundOffset, Some(timeZone))\n+          case (a, b) if a == b => Add(expr, boundOffset)\n+        }\n+        val bound = newMutableProjection(boundExpr :: Nil, child.output)\n+\n+        // Construct the ordering. This is used to compare the result of current value projection\n+        // to the result of bound value projection. This is done manually because we want to use\n+        // Code Generation (if it is enabled).\n+        val boundSortExprs = sortExpr.copy(BoundReference(0, expr.dataType, expr.nullable)) :: Nil\n+        val ordering = newOrdering(boundSortExprs, Nil)\n+        RangeBoundOrdering(ordering, current, bound)\n+\n+      case (RangeFrame, _) =>\n+        sys.error(\"Non-Zero range offsets are not supported for windows \" +\n+          \"with multiple order expressions.\")\n+    }\n+  }\n+\n+  /**\n+   * Collection containing an entry for each window frame to process. Each entry contains a frame's\n+   * [[WindowExpression]]s and factory function for the WindowFrameFunction.\n+   */\n+  protected lazy val windowFrameExpressionFactoryPairs = {\n+    type FrameKey = (String, FrameType, Expression, Expression)\n+    type ExpressionBuffer = mutable.Buffer[Expression]\n+    val framedFunctions = mutable.Map.empty[FrameKey, (ExpressionBuffer, ExpressionBuffer)]\n+\n+    // Add a function and its function to the map for a given frame.\n+    def collect(tpe: String, fr: SpecifiedWindowFrame, e: Expression, fn: Expression): Unit = {\n+      val key = (tpe, fr.frameType, fr.lower, fr.upper)\n+      val (es, fns) = framedFunctions.getOrElseUpdate(\n+        key, (ArrayBuffer.empty[Expression], ArrayBuffer.empty[Expression]))\n+      es += e\n+      fns += fn\n+    }\n+\n+    // Collect all valid window functions and group them by their frame.\n+    windowExpression.foreach { x =>\n+      x.foreach {\n+        case e @ WindowExpression(function, spec) =>\n+          val frame = spec.frameSpecification.asInstanceOf[SpecifiedWindowFrame]\n+          function match {\n+            case AggregateExpression(f, _, _, _) => collect(\"AGGREGATE\", frame, e, f)\n+            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)\n+            case f: OffsetWindowFunction => collect(\"OFFSET\", frame, e, f)\n+            case f: PythonUDF => collect(\"AGGREGATE\", frame, e, f)\n+            case f => sys.error(s\"Unsupported window function: $f\")\n+          }\n+        case _ =>\n+      }\n+    }\n+\n+    // Map the groups to a (unbound) expression and frame factory pair.\n+    var numExpressions = 0\n+    val timeZone = conf.sessionLocalTimeZone\n+    framedFunctions.toSeq.map {\n+      case (key, (expressions, functionSeq)) =>\n+        val ordinal = numExpressions\n+        val functions = functionSeq.toArray\n+\n+        // Construct an aggregate processor if we need one.\n+        def processor = if (functions.exists{f => f.isInstanceOf[PythonUDF]}) {\n+          null",
    "line": 163
  }],
  "prId": 22305
}]