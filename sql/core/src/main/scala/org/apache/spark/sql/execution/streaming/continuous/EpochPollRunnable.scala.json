[{
  "comments": [{
    "author": {
      "login": "arunmahadevan"
    },
    "body": "Can the diff between \"new\" and \"current\" epoch be more than one ? This means the reader missed some epochs and maybe then it should trigger a recovery?",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-01T00:41:48Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable(\n+    queue: BlockingQueue[(UnsafeRow, PartitionOffset)],\n+    context: TaskContext,\n+    failedFlag: AtomicBoolean)\n+  extends Thread with Logging {\n+  private[continuous] var failureReason: Throwable = _\n+\n+  private val epochEndpoint = EpochCoordinatorRef.get(\n+    context.getLocalProperty(ContinuousExecution.EPOCH_COORDINATOR_ID_KEY), SparkEnv.get)\n+  // Note that this is *not* the same as the currentEpoch in [[ContinuousDataQueuedReader]]! That\n+  // field represents the epoch wrt the data being processed. The currentEpoch here is just a\n+  // counter to ensure we send the appropriate number of markers if we fall behind the driver.\n+  private var currentEpoch = context.getLocalProperty(ContinuousExecution.START_EPOCH_KEY).toLong\n+\n+  override def run(): Unit = {\n+    try {\n+      val newEpoch = epochEndpoint.askSync[Long](GetCurrentEpoch)\n+      for (i <- currentEpoch to newEpoch - 1) {"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "I don't think there's any need to trigger a recovery. The reader can (and currently will) just treat the epochs it missed as empty.",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-01T01:43:36Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable(\n+    queue: BlockingQueue[(UnsafeRow, PartitionOffset)],\n+    context: TaskContext,\n+    failedFlag: AtomicBoolean)\n+  extends Thread with Logging {\n+  private[continuous] var failureReason: Throwable = _\n+\n+  private val epochEndpoint = EpochCoordinatorRef.get(\n+    context.getLocalProperty(ContinuousExecution.EPOCH_COORDINATOR_ID_KEY), SparkEnv.get)\n+  // Note that this is *not* the same as the currentEpoch in [[ContinuousDataQueuedReader]]! That\n+  // field represents the epoch wrt the data being processed. The currentEpoch here is just a\n+  // counter to ensure we send the appropriate number of markers if we fall behind the driver.\n+  private var currentEpoch = context.getLocalProperty(ContinuousExecution.START_EPOCH_KEY).toLong\n+\n+  override def run(): Unit = {\n+    try {\n+      val newEpoch = epochEndpoint.askSync[Long](GetCurrentEpoch)\n+      for (i <- currentEpoch to newEpoch - 1) {"
  }, {
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Please correct me if I'm missing. My understanding is that the situation (gap bigger than 1) should only occur when array queue gets full and blocks epoch thread to put marker more than trigger interval. Any other situations (error cases) should just crash the whole query so that recovery happens from the scratch: that's why we can ignore the missing case.",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-01T10:37:34Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable(\n+    queue: BlockingQueue[(UnsafeRow, PartitionOffset)],\n+    context: TaskContext,\n+    failedFlag: AtomicBoolean)\n+  extends Thread with Logging {\n+  private[continuous] var failureReason: Throwable = _\n+\n+  private val epochEndpoint = EpochCoordinatorRef.get(\n+    context.getLocalProperty(ContinuousExecution.EPOCH_COORDINATOR_ID_KEY), SparkEnv.get)\n+  // Note that this is *not* the same as the currentEpoch in [[ContinuousDataQueuedReader]]! That\n+  // field represents the epoch wrt the data being processed. The currentEpoch here is just a\n+  // counter to ensure we send the appropriate number of markers if we fall behind the driver.\n+  private var currentEpoch = context.getLocalProperty(ContinuousExecution.START_EPOCH_KEY).toLong\n+\n+  override def run(): Unit = {\n+    try {\n+      val newEpoch = epochEndpoint.askSync[Long](GetCurrentEpoch)\n+      for (i <- currentEpoch to newEpoch - 1) {"
  }, {
    "author": {
      "login": "arunmahadevan"
    },
    "body": "yes the queue getting full can be one, I think trigger interval < executorPollIntervalMs could be another. Anyways I guess it would just cause the reader to report the same offsets for multiple epochs which may be ok (but not desirable) since it will cause the epoch coordinator to block the other epochs from committing and commit one after the other when the commit message arrives for the missing partition.\r\n\r\nNot sure if there are any checks to ensure trigger interval > executorPollIntervalMs. Maybe this this should be added or executorPollIntervalMs should be calculated based on trigger interval.\r\n\r\nI don't know the flow enough to understand what happens when an executor crashes - how the epoch gets reset and the newly launched tasks continue from the last successful commit.",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-01T16:08:06Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable(\n+    queue: BlockingQueue[(UnsafeRow, PartitionOffset)],\n+    context: TaskContext,\n+    failedFlag: AtomicBoolean)\n+  extends Thread with Logging {\n+  private[continuous] var failureReason: Throwable = _\n+\n+  private val epochEndpoint = EpochCoordinatorRef.get(\n+    context.getLocalProperty(ContinuousExecution.EPOCH_COORDINATOR_ID_KEY), SparkEnv.get)\n+  // Note that this is *not* the same as the currentEpoch in [[ContinuousDataQueuedReader]]! That\n+  // field represents the epoch wrt the data being processed. The currentEpoch here is just a\n+  // counter to ensure we send the appropriate number of markers if we fall behind the driver.\n+  private var currentEpoch = context.getLocalProperty(ContinuousExecution.START_EPOCH_KEY).toLong\n+\n+  override def run(): Unit = {\n+    try {\n+      val newEpoch = epochEndpoint.askSync[Long](GetCurrentEpoch)\n+      for (i <- currentEpoch to newEpoch - 1) {"
  }, {
    "author": {
      "login": "jose-torres"
    },
    "body": "It can also happen if GetCurrentEpoch just takes a long time for some reason.\r\n\r\nI agree it'd make sense to add a check to ensure trigger interval is greater than executorPollIntervalMs. I'd even argue for some small multiplier on top of that poll interval.",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-01T16:26:22Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable(\n+    queue: BlockingQueue[(UnsafeRow, PartitionOffset)],\n+    context: TaskContext,\n+    failedFlag: AtomicBoolean)\n+  extends Thread with Logging {\n+  private[continuous] var failureReason: Throwable = _\n+\n+  private val epochEndpoint = EpochCoordinatorRef.get(\n+    context.getLocalProperty(ContinuousExecution.EPOCH_COORDINATOR_ID_KEY), SparkEnv.get)\n+  // Note that this is *not* the same as the currentEpoch in [[ContinuousDataQueuedReader]]! That\n+  // field represents the epoch wrt the data being processed. The currentEpoch here is just a\n+  // counter to ensure we send the appropriate number of markers if we fall behind the driver.\n+  private var currentEpoch = context.getLocalProperty(ContinuousExecution.START_EPOCH_KEY).toLong\n+\n+  override def run(): Unit = {\n+    try {\n+      val newEpoch = epochEndpoint.askSync[Long](GetCurrentEpoch)\n+      for (i <- currentEpoch to newEpoch - 1) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I strongly suggest adding more docs here to explain this logic. ",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-02T00:34:15Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable(\n+    queue: BlockingQueue[(UnsafeRow, PartitionOffset)],\n+    context: TaskContext,\n+    failedFlag: AtomicBoolean)\n+  extends Thread with Logging {\n+  private[continuous] var failureReason: Throwable = _\n+\n+  private val epochEndpoint = EpochCoordinatorRef.get(\n+    context.getLocalProperty(ContinuousExecution.EPOCH_COORDINATOR_ID_KEY), SparkEnv.get)\n+  // Note that this is *not* the same as the currentEpoch in [[ContinuousDataQueuedReader]]! That\n+  // field represents the epoch wrt the data being processed. The currentEpoch here is just a\n+  // counter to ensure we send the appropriate number of markers if we fall behind the driver.\n+  private var currentEpoch = context.getLocalProperty(ContinuousExecution.START_EPOCH_KEY).toLong\n+\n+  override def run(): Unit = {\n+    try {\n+      val newEpoch = epochEndpoint.askSync[Long](GetCurrentEpoch)\n+      for (i <- currentEpoch to newEpoch - 1) {"
  }],
  "prId": 21200
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Its hard to understand what \"EpochPollRunnable\" means. Rather how about \"EpochMarkerGenerator\"?",
    "commit": "75c0b78f924d9c2f70b737c105e6f3cbc85d3b6e",
    "createdAt": "2018-05-02T00:32:16Z",
    "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.continuous\n+\n+import java.util.concurrent.BlockingQueue\n+import java.util.concurrent.atomic.AtomicBoolean\n+\n+import org.apache.spark.{SparkEnv, TaskContext}\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.sources.v2.reader.streaming.PartitionOffset\n+\n+/**\n+ * The epoch marker component of [[ContinuousQueuedDataReader]]. Populates the queue with\n+ * (null, null) when a new epoch marker arrives.\n+ */\n+class EpochPollRunnable("
  }],
  "prId": 21200
}]