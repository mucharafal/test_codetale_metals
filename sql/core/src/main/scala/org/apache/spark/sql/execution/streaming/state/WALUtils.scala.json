[{
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "what is this for?",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:33:45Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+                               compressedStream: DataOutputStream,\n+                               rawStream: CancellableFSDataOutputStream): Unit = {\n+    try {\n+      if (rawStream != null) rawStream.cancel()\n+      IOUtils.closeQuietly(compressedStream)\n+    } catch {\n+      case e: FSError if e.getCause.isInstanceOf[IOException] =>\n+      // Closing the compressedStream causes the stream to write/flush flush data into the\n+      // rawStream. Since the rawStream is already closed, there may be errors.\n+      // Usually its an IOException. However, Hadoop's RawLocalFileSystem wraps\n+      // IOException into FSError.\n+    }\n+  }\n+\n+  def uploadFile(fm: CheckpointFileManager,\n+                 sourceFile: Path,\n+                 targetFile: Path,\n+                 sparkConf: SparkConf): Unit = {\n+    var output: CancellableFSDataOutputStream = null\n+    var in: BufferedInputStream = null\n+    try {\n+      in = new BufferedInputStream(new FileInputStream(sourceFile.toString))\n+      output = fm.createAtomic(targetFile, overwriteIfPossible = true)\n+      // output = compressStream(rawOutput, sparkConf)\n+      val buffer = new Array[ Byte ](1024)\n+      var len = in.read(buffer)\n+      while (len > 0) {\n+        output.write(buffer, 0, len)\n+        len = in.read(buffer)\n+      }\n+      output.close()\n+    } catch {\n+      case e: Throwable =>\n+        if (output != null) output.cancel()\n+        throw e\n+    } finally {\n+      if ( in != null ) {\n+        in.close()\n+      }\n+    }\n+  }\n+\n+  def downloadFile(fm: CheckpointFileManager,\n+                 sourceFile: Path,\n+                 targetFile: Path,\n+                 sparkConf: SparkConf): Boolean = {\n+    var in: FSDataInputStream = null\n+    var output: BufferedOutputStream = null\n+    try {\n+      in = fm.open(sourceFile)\n+      // in = decompressStream(fm.open(sourceFile), sparkConf)"
  }, {
    "author": {
      "login": "itsvikramagr"
    },
    "body": "removed",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:47:41Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+                               compressedStream: DataOutputStream,\n+                               rawStream: CancellableFSDataOutputStream): Unit = {\n+    try {\n+      if (rawStream != null) rawStream.cancel()\n+      IOUtils.closeQuietly(compressedStream)\n+    } catch {\n+      case e: FSError if e.getCause.isInstanceOf[IOException] =>\n+      // Closing the compressedStream causes the stream to write/flush flush data into the\n+      // rawStream. Since the rawStream is already closed, there may be errors.\n+      // Usually its an IOException. However, Hadoop's RawLocalFileSystem wraps\n+      // IOException into FSError.\n+    }\n+  }\n+\n+  def uploadFile(fm: CheckpointFileManager,\n+                 sourceFile: Path,\n+                 targetFile: Path,\n+                 sparkConf: SparkConf): Unit = {\n+    var output: CancellableFSDataOutputStream = null\n+    var in: BufferedInputStream = null\n+    try {\n+      in = new BufferedInputStream(new FileInputStream(sourceFile.toString))\n+      output = fm.createAtomic(targetFile, overwriteIfPossible = true)\n+      // output = compressStream(rawOutput, sparkConf)\n+      val buffer = new Array[ Byte ](1024)\n+      var len = in.read(buffer)\n+      while (len > 0) {\n+        output.write(buffer, 0, len)\n+        len = in.read(buffer)\n+      }\n+      output.close()\n+    } catch {\n+      case e: Throwable =>\n+        if (output != null) output.cancel()\n+        throw e\n+    } finally {\n+      if ( in != null ) {\n+        in.close()\n+      }\n+    }\n+  }\n+\n+  def downloadFile(fm: CheckpointFileManager,\n+                 sourceFile: Path,\n+                 targetFile: Path,\n+                 sparkConf: SparkConf): Boolean = {\n+    var in: FSDataInputStream = null\n+    var output: BufferedOutputStream = null\n+    try {\n+      in = fm.open(sourceFile)\n+      // in = decompressStream(fm.open(sourceFile), sparkConf)"
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "remove?",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:33:54Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+                               compressedStream: DataOutputStream,\n+                               rawStream: CancellableFSDataOutputStream): Unit = {\n+    try {\n+      if (rawStream != null) rawStream.cancel()\n+      IOUtils.closeQuietly(compressedStream)\n+    } catch {\n+      case e: FSError if e.getCause.isInstanceOf[IOException] =>\n+      // Closing the compressedStream causes the stream to write/flush flush data into the\n+      // rawStream. Since the rawStream is already closed, there may be errors.\n+      // Usually its an IOException. However, Hadoop's RawLocalFileSystem wraps\n+      // IOException into FSError.\n+    }\n+  }\n+\n+  def uploadFile(fm: CheckpointFileManager,\n+                 sourceFile: Path,\n+                 targetFile: Path,\n+                 sparkConf: SparkConf): Unit = {\n+    var output: CancellableFSDataOutputStream = null\n+    var in: BufferedInputStream = null\n+    try {\n+      in = new BufferedInputStream(new FileInputStream(sourceFile.toString))\n+      output = fm.createAtomic(targetFile, overwriteIfPossible = true)\n+      // output = compressStream(rawOutput, sparkConf)"
  }, {
    "author": {
      "login": "itsvikramagr"
    },
    "body": "done",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:48:33Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+                               compressedStream: DataOutputStream,\n+                               rawStream: CancellableFSDataOutputStream): Unit = {\n+    try {\n+      if (rawStream != null) rawStream.cancel()\n+      IOUtils.closeQuietly(compressedStream)\n+    } catch {\n+      case e: FSError if e.getCause.isInstanceOf[IOException] =>\n+      // Closing the compressedStream causes the stream to write/flush flush data into the\n+      // rawStream. Since the rawStream is already closed, there may be errors.\n+      // Usually its an IOException. However, Hadoop's RawLocalFileSystem wraps\n+      // IOException into FSError.\n+    }\n+  }\n+\n+  def uploadFile(fm: CheckpointFileManager,\n+                 sourceFile: Path,\n+                 targetFile: Path,\n+                 sparkConf: SparkConf): Unit = {\n+    var output: CancellableFSDataOutputStream = null\n+    var in: BufferedInputStream = null\n+    try {\n+      in = new BufferedInputStream(new FileInputStream(sourceFile.toString))\n+      output = fm.createAtomic(targetFile, overwriteIfPossible = true)\n+      // output = compressStream(rawOutput, sparkConf)"
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "please fix the indentation",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:34:16Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+                               compressedStream: DataOutputStream,"
  }, {
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Ran ./dev/scalafmt now to fix all indentation issues. Missed to run it before raising the PR",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:49:28Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+                               compressedStream: DataOutputStream,"
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "same for indentation",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:38:42Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,"
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "is there a JIRA on this?",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T04:39:05Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data",
    "line": 173
  }, {
    "author": {
      "login": "itsvikramagr"
    },
    "body": "https://issues.apache.org/jira/browse/SPARK-21271\r\n\r\nI have abstracted out utils related to WAL from the class [HDFSBackedStateStoreProvider](https://github.com/apache/spark/blob/f0f2f8d3ce8b0a4aa62134090ba90bcf39d97dc8/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala#L549) so that it can be used elsewhere.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-06-25T05:10:36Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\"\n+        )\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+            // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    // logDebug(s\"Current set of files for $this: ${storeFiles.mkString(\", \")}\")\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+\n+  def writeUpdateToDeltaFile(\n+                                      output: DataOutputStream,\n+                                      key: UnsafeRow,\n+                                      value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1)  // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile( fm: CheckpointFileManager,\n+                           fileToRead: Path,\n+                           keySchema: StructType,\n+                           valueSchema: StructType,\n+                           newRocksDb: OptimisticTransactionDbInstance,\n+                           sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\", f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while(!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == -1) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data",
    "line": 173
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Please leave self-commenting to determine which code blocks are copied from where, and which code is new. And I think this class is to deduplicate between HDFS state store provider and RocksDB state store provider, but HDFS state store provider is not leveraging this, ends up with duplicated code.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-01T00:32:40Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+/*",
    "line": 1
  }, {
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Good point on self-review. \r\n\r\nI have abstracted out a lot of code from HDFS state store to create WALUtils. I didn't make any change in HDFS state store provider to reduce the scope of this PR. I can either start a new PR for the refactoring or I can do it once the rest of the code is reviewed. ",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-01T04:08:00Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+/*",
    "line": 1
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "gaborgsomogyi"
    },
    "body": "Then maybe can be something like: `val EOF_MARKER = -1`?",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-05T15:08:06Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+  def writeUpdateToDeltaFile(output: DataOutputStream, key: UnsafeRow, value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1) // Write this magic number to signify end of file"
  }, {
    "author": {
      "login": "itsvikramagr"
    },
    "body": "will make the change.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-08T10:34:13Z",
    "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+  def writeUpdateToDeltaFile(output: DataOutputStream, key: UnsafeRow, value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(-1)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(-1) // Write this magic number to signify end of file"
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "HeartSaVioR"
    },
    "body": "Let's set it `private` unless if we access it from outside.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-09T13:05:25Z",
    "diffHunk": "@@ -35,6 +35,7 @@ import org.apache.spark.sql.types.StructType\n object WALUtils {\n \n   case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  val EOF_MARKER = -1"
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "This is a new util Function. Here we are fetching delta file from the checkpointed location and apply it in the rocksdb instance.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T09:54:53Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+  def writeUpdateToDeltaFile(output: DataOutputStream, key: UnsafeRow, value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(EOF_MARKER)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(EOF_MARKER) // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile(",
    "line": 127
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Same as https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala#L654\r\n\r\nThe difference is that CheckpointFileManager is added in the signature of the function.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T09:58:23Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {",
    "line": 66
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Same as https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala#L627",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T09:58:46Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {",
    "line": 41
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Same as https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala#L685",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T09:59:06Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {",
    "line": 96
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Same as https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala#L396",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T09:59:45Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+  def writeUpdateToDeltaFile(output: DataOutputStream, key: UnsafeRow, value: UnsafeRow): Unit = {",
    "line": 106
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "Same as https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala#L503",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T10:01:39Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+  def writeUpdateToDeltaFile(output: DataOutputStream, key: UnsafeRow, value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(EOF_MARKER)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(EOF_MARKER) // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile(\n+      fm: CheckpointFileManager,\n+      fileToRead: Path,\n+      keySchema: StructType,\n+      valueSchema: StructType,\n+      newRocksDb: OptimisticTransactionDbInstance,\n+      sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\",\n+          f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while (!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == EOF_MARKER) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(",
    "line": 190
  }],
  "prId": 24922
}, {
  "comments": [{
    "author": {
      "login": "itsvikramagr"
    },
    "body": "`uploadFile` and `downloadFile` are new util function used by RocksDBStateStore.",
    "commit": "45e0d054a38958ac9e1b7c6a9429a3a3df9b8ff1",
    "createdAt": "2019-07-31T10:02:54Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming.state\n+\n+import java.io._\n+import java.util.Locale\n+\n+import com.google.common.io.ByteStreams\n+import org.apache.commons.io.IOUtils\n+import org.apache.hadoop.fs.{FileStatus, FSDataInputStream, FSError, Path}\n+import scala.collection.mutable\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.io.LZ4CompressionCodec\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager\n+import org.apache.spark.sql.execution.streaming.CheckpointFileManager.CancellableFSDataOutputStream\n+import org.apache.spark.sql.types.StructType\n+\n+object WALUtils {\n+\n+  case class StoreFile(version: Long, path: Path, isSnapshot: Boolean)\n+  private val EOF_MARKER = -1\n+\n+  /** Files needed to recover the given version of the store */\n+  def filesForVersion(allFiles: Seq[StoreFile], version: Long): Seq[StoreFile] = {\n+    require(version >= 0)\n+    require(allFiles.exists(_.version == version))\n+\n+    val latestSnapshotFileBeforeVersion = allFiles\n+      .filter(_.isSnapshot == true)\n+      .takeWhile(_.version <= version)\n+      .lastOption\n+    val deltaBatchFiles = latestSnapshotFileBeforeVersion match {\n+      case Some(snapshotFile) =>\n+        val deltaFiles = allFiles.filter { file =>\n+          file.version > snapshotFile.version && file.version <= version\n+        }.toList\n+        verify(\n+          deltaFiles.size == version - snapshotFile.version,\n+          s\"Unexpected list of delta files for version $version for $this: $deltaFiles\")\n+        deltaFiles\n+\n+      case None =>\n+        allFiles.takeWhile(_.version <= version)\n+    }\n+    latestSnapshotFileBeforeVersion.toSeq ++ deltaBatchFiles\n+  }\n+\n+  /** Fetch all the files that back the store */\n+  def fetchFiles(fm: CheckpointFileManager, baseDir: Path): Seq[StoreFile] = {\n+    val files: Seq[FileStatus] = try {\n+      fm.list(baseDir)\n+    } catch {\n+      case _: java.io.FileNotFoundException =>\n+        Seq.empty\n+    }\n+    val versionToFiles = new mutable.HashMap[Long, StoreFile]\n+    files.foreach { status =>\n+      val path = status.getPath\n+      val nameParts = path.getName.split(\"\\\\.\")\n+      if (nameParts.size == 2) {\n+        val version = nameParts(0).toLong\n+        nameParts(1).toLowerCase(Locale.ROOT) match {\n+          case \"delta\" =>\n+            // ignore the file otherwise, snapshot file already exists for that batch id\n+            if (!versionToFiles.contains(version)) {\n+              versionToFiles.put(version, StoreFile(version, path, isSnapshot = false))\n+            }\n+          case \"snapshot\" =>\n+            versionToFiles.put(version, StoreFile(version, path, isSnapshot = true))\n+          case _ =>\n+          // logWarning(s\"Could not identify file $path for $this\")\n+        }\n+      }\n+    }\n+    val storeFiles = versionToFiles.values.toSeq.sortBy(_.version)\n+    storeFiles\n+  }\n+\n+  def compressStream(outputStream: DataOutputStream, sparkConf: SparkConf): DataOutputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedOutputStream(outputStream)\n+    new DataOutputStream(compressed)\n+  }\n+\n+  def decompressStream(inputStream: DataInputStream, sparkConf: SparkConf): DataInputStream = {\n+    val compressed = new LZ4CompressionCodec(sparkConf).compressedInputStream(inputStream)\n+    new DataInputStream(compressed)\n+  }\n+\n+  def writeUpdateToDeltaFile(output: DataOutputStream, key: UnsafeRow, value: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    val valueBytes = value.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(valueBytes.size)\n+    output.write(valueBytes)\n+  }\n+\n+  def writeRemoveToDeltaFile(output: DataOutputStream, key: UnsafeRow): Unit = {\n+    val keyBytes = key.getBytes()\n+    output.writeInt(keyBytes.size)\n+    output.write(keyBytes)\n+    output.writeInt(EOF_MARKER)\n+  }\n+\n+  def finalizeDeltaFile(output: DataOutputStream): Unit = {\n+    output.writeInt(EOF_MARKER) // Write this magic number to signify end of file\n+    output.close()\n+  }\n+\n+  def updateFromDeltaFile(\n+      fm: CheckpointFileManager,\n+      fileToRead: Path,\n+      keySchema: StructType,\n+      valueSchema: StructType,\n+      newRocksDb: OptimisticTransactionDbInstance,\n+      sparkConf: SparkConf): Unit = {\n+    var input: DataInputStream = null\n+    val sourceStream = try {\n+      fm.open(fileToRead)\n+    } catch {\n+      case f: FileNotFoundException =>\n+        throw new IllegalStateException(\n+          s\"Error reading delta file $fileToRead of $this: $fileToRead does not exist\",\n+          f)\n+    }\n+    try {\n+      input = decompressStream(sourceStream, sparkConf)\n+      var eof = false\n+\n+      while (!eof) {\n+        val keySize = input.readInt()\n+        if (keySize == EOF_MARKER) {\n+          eof = true\n+        } else if (keySize < 0) {\n+          newRocksDb.abort\n+          newRocksDb.close()\n+          throw new IOException(\n+            s\"Error reading delta file $fileToRead of $this: key size cannot be $keySize\")\n+        } else {\n+          val keyRowBuffer = new Array[Byte](keySize)\n+          ByteStreams.readFully(input, keyRowBuffer, 0, keySize)\n+\n+          val keyRow = new UnsafeRow(keySchema.fields.length)\n+          keyRow.pointTo(keyRowBuffer, keySize)\n+\n+          val valueSize = input.readInt()\n+          if (valueSize < 0) {\n+            newRocksDb.remove(key = keyRow)\n+          } else {\n+            val valueRowBuffer = new Array[Byte](valueSize)\n+            ByteStreams.readFully(input, valueRowBuffer, 0, valueSize)\n+            val valueRow = new UnsafeRow(valueSchema.fields.length)\n+            // If valueSize in existing file is not multiple of 8, floor it to multiple of 8.\n+            // This is a workaround for the following:\n+            // Prior to Spark 2.3 mistakenly append 4 bytes to the value row in\n+            // `RowBasedKeyValueBatch`, which gets persisted into the checkpoint data\n+            valueRow.pointTo(valueRowBuffer, (valueSize / 8) * 8)\n+            newRocksDb.put(keyRow, valueRow)\n+          }\n+        }\n+      }\n+    } finally {\n+      if (input != null) input.close()\n+    }\n+  }\n+\n+  /*\n+   * Try to cancel the underlying stream and safely close the compressed stream.\n+   *\n+   * @param compressedStream the compressed stream.\n+   * @param rawStream the underlying stream which needs to be cancelled.\n+   */\n+  def cancelDeltaFile(\n+      compressedStream: DataOutputStream,\n+      rawStream: CancellableFSDataOutputStream): Unit = {\n+    try {\n+      if (rawStream != null) rawStream.cancel()\n+      IOUtils.closeQuietly(compressedStream)\n+    } catch {\n+      case e: FSError if e.getCause.isInstanceOf[IOException] =>\n+      // Closing the compressedStream causes the stream to write/flush flush data into the\n+      // rawStream. Since the rawStream is already closed, there may be errors.\n+      // Usually its an IOException. However, Hadoop's RawLocalFileSystem wraps\n+      // IOException into FSError.\n+    }\n+  }\n+\n+  def uploadFile(",
    "line": 205
  }],
  "prId": 24922
}]