[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "no infix notation\n",
    "commit": "463f68a9f9a30f5676e5365fc3e56ffa360a9775",
    "createdAt": "2016-01-28T08:04:17Z",
    "diffHunk": "@@ -374,21 +366,27 @@ final class DataFrameStatFunctions private[sql](df: DataFrame) {\n     val singleCol = df.select(col)\n     val colType = singleCol.schema.head.dataType\n \n-    require(\n-      colType == StringType || colType.isInstanceOf[IntegralType],\n-      s\"Count-min Sketch only supports string type and integral types, \" +\n-        s\"and does not support type $colType.\"\n-    )\n+    val updater: (CountMinSketch, InternalRow) => Unit = colType match {\n+      // For string type, we can get bytes of our `UTF8String` directly, and call the `addBinary`\n+      // instead of `addString` to avoid unnecessary conversion.\n+      case StringType => (sketch, row) => sketch.addBinary(row.getUTF8String(0).getBytes)\n+      case ByteType => (sketch, row) => sketch.addLong(row.getByte(0))\n+      case ShortType => (sketch, row) => sketch.addLong(row.getShort(0))\n+      case IntegerType => (sketch, row) => sketch.addLong(row.getInt(0))\n+      case LongType => (sketch, row) => sketch.addLong(row.getLong(0))\n+      case _ =>\n+        throw new IllegalArgumentException(\n+          s\"Count-min Sketch only supports string type and integral types, \" +\n+            s\"and does not support type $colType.\"\n+        )\n+    }\n \n-    singleCol.rdd.aggregate(zero)(\n-      (sketch: CountMinSketch, row: Row) => {\n-        sketch.add(row.get(0))\n+    singleCol.queryExecution.toRdd.aggregate(zero)(\n+      (sketch: CountMinSketch, row: InternalRow) => {\n+        updater(sketch, row)\n         sketch\n       },\n-\n-      (sketch1: CountMinSketch, sketch2: CountMinSketch) => {\n-        sketch1.mergeInPlace(sketch2)\n-      }\n+      _ mergeInPlace _"
  }],
  "prId": 10968
}]