[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Can't we get rid of strategy entirely and just have this single line added to `BasicOperators`.  That was kind of my goal with this refactoring. \n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-16T20:17:30Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "I will try, maybe we can add a rule to translate logical.XXXCommand to RunnableCommand in analyzer.\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-16T23:37:40Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "I don think it needs to be in the `Analyzer`.  I think just this single line in the `BasicOperators` `Strategy` should be sufficient.\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-16T23:39:06Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "But for set command,  catalyst first parse it as logical.SetCommand, when to make it as execution.SetCommand (RunnableCommand)? \n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-16T23:49:12Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "We can not avoid this step to translate logical.XXXCommand to RunnableCommand, so keep CommandStrategy here.\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-17T11:39:32Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Okay, I see the problem now.  These commands still live inside of catalyst and thus cannot be `RunnableCommands`.  I would argue that that should be changed.  My whole goal here was to eliminate boilerplate from the planner and this still seems to have a bunch of it.  That said, this could be done in a follow up PR.\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-17T23:20:35Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "yes, i think we can parse command in sql/core instead of parsing in catalyst in the follow up PR\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-18T01:02:37Z",
    "diffHunk": "@@ -306,13 +306,16 @@ private[sql] abstract class SparkStrategies extends QueryPlanner[SparkPlan] {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n       case r: RunnableCommand => ExecutedCommand(r) :: Nil",
    "line": 7
  }],
  "prId": 3712
}]