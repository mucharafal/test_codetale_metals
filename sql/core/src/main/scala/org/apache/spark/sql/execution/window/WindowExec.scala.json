[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Both `DateType` and `TimestampType` expressions are going to need a time zone. I was wondering if we can use a `GMT` because these are just offset calculation? cc @ueshin \r\n\r\nIf we can't then we either need to thread through the session local timezone, or it might be easier to put the entire offset calculation in the frame.",
    "commit": "38b04df792caf298da63be565d1b46a4eae93d98",
    "createdAt": "2017-07-05T10:01:08Z",
    "diffHunk": "@@ -109,46 +109,54 @@ case class WindowExec(\n    *\n    * This method uses Code Generation. It can only be used on the executor side.\n    *\n-   * @param frameType to evaluate. This can either be Row or Range based.\n-   * @param offset with respect to the row.\n+   * @param frame to evaluate. This can either be a Row or Range frame.\n+   * @param bound with respect to the row.\n    * @return a bound ordering object.\n    */\n-  private[this] def createBoundOrdering(frameType: FrameType, offset: Int): BoundOrdering = {\n-    frameType match {\n-      case RangeFrame =>\n-        val (exprs, current, bound) = if (offset == 0) {\n-          // Use the entire order expression when the offset is 0.\n-          val exprs = orderSpec.map(_.child)\n-          val buildProjection = () => newMutableProjection(exprs, child.output)\n-          (orderSpec, buildProjection(), buildProjection())\n-        } else if (orderSpec.size == 1) {\n-          // Use only the first order expression when the offset is non-null.\n-          val sortExpr = orderSpec.head\n-          val expr = sortExpr.child\n-          // Create the projection which returns the current 'value'.\n-          val current = newMutableProjection(expr :: Nil, child.output)\n-          // Flip the sign of the offset when processing the order is descending\n-          val boundOffset = sortExpr.direction match {\n-            case Descending => -offset\n-            case Ascending => offset\n-          }\n-          // Create the projection which returns the current 'value' modified by adding the offset.\n-          val boundExpr = Add(expr, Cast(Literal.create(boundOffset, IntegerType), expr.dataType))\n-          val bound = newMutableProjection(boundExpr :: Nil, child.output)\n-          (sortExpr :: Nil, current, bound)\n-        } else {\n-          sys.error(\"Non-Zero range offsets are not supported for windows \" +\n-            \"with multiple order expressions.\")\n+  private[this] def createBoundOrdering(frame: FrameType, bound: AnyRef): BoundOrdering = {\n+    (frame, bound) match {\n+      case (RowFrame, CurrentRow) =>\n+        RowBoundOrdering(0)\n+\n+      case (RowFrame, IntegerLiteral(offset)) =>\n+        RowBoundOrdering(offset)\n+\n+      case (RangeFrame, CurrentRow) =>\n+        val ordering = newOrdering(orderSpec, child.output)\n+        RangeBoundOrdering(ordering, IdentityProjection, IdentityProjection)\n+\n+      case (RangeFrame, offset: Expression) if orderSpec.size == 1 =>\n+        // Use only the first order expression when the offset is non-null.\n+        val sortExpr = orderSpec.head\n+        val expr = sortExpr.child\n+\n+        // Create the projection which returns the current 'value'.\n+        val current = newMutableProjection(expr :: Nil, child.output)\n+\n+        // Flip the sign of the offset when processing the order is descending\n+        val boundOffset = sortExpr.direction match {\n+          case Descending => UnaryMinus(offset)\n+          case Ascending => offset\n+        }\n+\n+        // Create the projection which returns the current 'value' modified by adding the offset.\n+        val boundExpr = (expr.dataType, boundOffset.dataType) match {\n+          case (DateType, IntegerType) => DateAdd(expr, boundOffset)"
  }],
  "prId": 18540
}]