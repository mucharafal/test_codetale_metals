[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do you mean view here? otherwise the physical plan doesn't match.",
    "commit": "47a8f71b8358e9775d012dcbab6f2f03057aed94",
    "createdAt": "2019-02-11T07:57:51Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.sql.catalyst.analysis.CleanupAliases\n+import org.apache.spark.sql.catalyst.expressions.{Alias, Expression, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, PartitioningCollection, UnknownPartitioning}\n+\n+/**\n+ * Trait for plans which can produce an output partitioned by aliased attributes of their child.\n+ * It rewrites the partitioning attributes of the child with the corresponding new ones which are\n+ * exposed in the output of this plan. It can avoid the presence of redundant shuffles in queries\n+ * caused by the rename of an attribute among the partitioning ones, eg.\n+ *\n+ * spark.range(10).selectExpr(\"id AS key\", \"0\").repartition($\"key\").write.saveAsTable(\"df1\")\n+ * spark.range(10).selectExpr(\"id AS key\", \"0\").repartition($\"key\").write.saveAsTable(\"df2\")"
  }],
  "prId": 22957
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can you explain what's going on here? The code is a little hard to follow.",
    "commit": "47a8f71b8358e9775d012dcbab6f2f03057aed94",
    "createdAt": "2019-02-11T08:29:20Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.sql.catalyst.analysis.CleanupAliases\n+import org.apache.spark.sql.catalyst.expressions.{Alias, Expression, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, PartitioningCollection, UnknownPartitioning}\n+\n+/**\n+ * Trait for plans which can produce an output partitioned by aliased attributes of their child.\n+ * It rewrites the partitioning attributes of the child with the corresponding new ones which are\n+ * exposed in the output of this plan. It can avoid the presence of redundant shuffles in queries\n+ * caused by the rename of an attribute among the partitioning ones, eg.\n+ *\n+ * spark.range(10).selectExpr(\"id AS key\", \"0\").repartition($\"key\").write.saveAsTable(\"df1\")\n+ * spark.range(10).selectExpr(\"id AS key\", \"0\").repartition($\"key\").write.saveAsTable(\"df2\")\n+ * sql(\"\"\"\n+ *   SELECT * FROM\n+ *     (SELECT key AS k from df1) t1\n+ *   INNER JOIN\n+ *     (SELECT key AS k from df2) t2\n+ *   ON t1.k = t2.k\n+ * \"\"\").explain\n+ *\n+ * == Physical Plan ==\n+ * *SortMergeJoin [k#56L], [k#57L], Inner\n+ * :- *Sort [k#56L ASC NULLS FIRST], false, 0\n+ * :  +- Exchange hashpartitioning(k#56L, 200) // <--- Unnecessary shuffle operation\n+ * :     +- *Project [key#39L AS k#56L]\n+ * :        +- Exchange hashpartitioning(key#39L, 200)\n+ * :           +- *Project [id#36L AS key#39L]\n+ * :              +- *Range (0, 10, step=1, splits=Some(4))\n+ * +- *Sort [k#57L ASC NULLS FIRST], false, 0\n+ *    +- ReusedExchange [k#57L], Exchange hashpartitioning(k#56L, 200)\n+ */\n+trait AliasAwareOutputPartitioning extends UnaryExecNode {\n+\n+  /**\n+   * `Seq` of `Expression`s which define the ouput of the node.\n+   */\n+  protected def outputExpressions: Seq[NamedExpression]\n+\n+  /**\n+   * Returns the valid `Partitioning`s for the node w.r.t its output and its expressions.\n+   */\n+  final override def outputPartitioning: Partitioning = {\n+    child.outputPartitioning match {\n+      case partitioning: Expression =>\n+        val exprToEquiv = partitioning.references.map { attr =>",
    "line": 73
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "sure, let me add some comments. Thanks.",
    "commit": "47a8f71b8358e9775d012dcbab6f2f03057aed94",
    "createdAt": "2019-02-11T08:31:34Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution\n+\n+import org.apache.spark.sql.catalyst.analysis.CleanupAliases\n+import org.apache.spark.sql.catalyst.expressions.{Alias, Expression, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.physical.{Partitioning, PartitioningCollection, UnknownPartitioning}\n+\n+/**\n+ * Trait for plans which can produce an output partitioned by aliased attributes of their child.\n+ * It rewrites the partitioning attributes of the child with the corresponding new ones which are\n+ * exposed in the output of this plan. It can avoid the presence of redundant shuffles in queries\n+ * caused by the rename of an attribute among the partitioning ones, eg.\n+ *\n+ * spark.range(10).selectExpr(\"id AS key\", \"0\").repartition($\"key\").write.saveAsTable(\"df1\")\n+ * spark.range(10).selectExpr(\"id AS key\", \"0\").repartition($\"key\").write.saveAsTable(\"df2\")\n+ * sql(\"\"\"\n+ *   SELECT * FROM\n+ *     (SELECT key AS k from df1) t1\n+ *   INNER JOIN\n+ *     (SELECT key AS k from df2) t2\n+ *   ON t1.k = t2.k\n+ * \"\"\").explain\n+ *\n+ * == Physical Plan ==\n+ * *SortMergeJoin [k#56L], [k#57L], Inner\n+ * :- *Sort [k#56L ASC NULLS FIRST], false, 0\n+ * :  +- Exchange hashpartitioning(k#56L, 200) // <--- Unnecessary shuffle operation\n+ * :     +- *Project [key#39L AS k#56L]\n+ * :        +- Exchange hashpartitioning(key#39L, 200)\n+ * :           +- *Project [id#36L AS key#39L]\n+ * :              +- *Range (0, 10, step=1, splits=Some(4))\n+ * +- *Sort [k#57L ASC NULLS FIRST], false, 0\n+ *    +- ReusedExchange [k#57L], Exchange hashpartitioning(k#56L, 200)\n+ */\n+trait AliasAwareOutputPartitioning extends UnaryExecNode {\n+\n+  /**\n+   * `Seq` of `Expression`s which define the ouput of the node.\n+   */\n+  protected def outputExpressions: Seq[NamedExpression]\n+\n+  /**\n+   * Returns the valid `Partitioning`s for the node w.r.t its output and its expressions.\n+   */\n+  final override def outputPartitioning: Partitioning = {\n+    child.outputPartitioning match {\n+      case partitioning: Expression =>\n+        val exprToEquiv = partitioning.references.map { attr =>",
    "line": 73
  }],
  "prId": 22957
}]