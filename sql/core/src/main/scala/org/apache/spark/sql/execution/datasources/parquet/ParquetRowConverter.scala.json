[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can we inline this in the pattern match\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-05T23:52:33Z",
    "diffHunk": "@@ -482,13 +482,106 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n+\n+      def isStandardListLayout(t: GroupType): Boolean ="
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Done.\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-06T04:50:57Z",
    "diffHunk": "@@ -482,13 +482,106 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n+\n+      def isStandardListLayout(t: GroupType): Boolean ="
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "The below comment doesn't match this condition (`t.getName == \"array\"`)?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-06T09:05:10Z",
    "diffHunk": "@@ -482,13 +482,104 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Nice catch!\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-06T09:27:27Z",
    "diffHunk": "@@ -482,13 +482,104 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>"
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This few sentences seems can be improved to be more clear. Like: According to parquet-format spec, this schema can also be interpreted as `List<String>` if following standard 3-level list types as shown in above case branch. In order to avoid such ambiguous interpretation, we prefer standard 3-level list types and place this case after the above one. ...\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-06T09:37:03Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>\n+          // For legacy 2-level list types generated by parquet-avro (Parquet version < 1.6.0),\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group array {                  <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parent.getName + \"_tuple\" =>\n+          // For Parquet data generated by parquet-thrift, e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group my_list_tuple {          <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _)\n+            if parent.getOriginalType == LIST &&\n+              t.getFieldCount == 1 &&\n+              t.getName == \"list\" &&\n+              t.getFieldName(0) == \"element\" =>\n+          // For standard 3-level list types, e.g.:\n+          //\n+          //    // List<String> (list nullable, elements non-null)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary element (UTF8);\n+          //      }\n+          //    }\n+          //\n+          // This case branch must appear before the next one. See comments of the next case branch\n+          // for details.\n+          false\n+\n+        case (t: GroupType, StructType(fields)) =>\n+          // For legacy 2-level list types whose element type is a group type with a single field,\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          //\n+          // NOTE: This kind of schema is ambiguous. According to parquet-format spec, this schema"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Yea, the current comment is kinda contrived... Let me try again.\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-06T10:30:52Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>\n+          // For legacy 2-level list types generated by parquet-avro (Parquet version < 1.6.0),\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group array {                  <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parent.getName + \"_tuple\" =>\n+          // For Parquet data generated by parquet-thrift, e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group my_list_tuple {          <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _)\n+            if parent.getOriginalType == LIST &&\n+              t.getFieldCount == 1 &&\n+              t.getName == \"list\" &&\n+              t.getFieldName(0) == \"element\" =>\n+          // For standard 3-level list types, e.g.:\n+          //\n+          //    // List<String> (list nullable, elements non-null)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary element (UTF8);\n+          //      }\n+          //    }\n+          //\n+          // This case branch must appear before the next one. See comments of the next case branch\n+          // for details.\n+          false\n+\n+        case (t: GroupType, StructType(fields)) =>\n+          // For legacy 2-level list types whose element type is a group type with a single field,\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          //\n+          // NOTE: This kind of schema is ambiguous. According to parquet-format spec, this schema"
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "`<-- repeatedType` => `<-- parquetRepeatedType`?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:21:04Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Seems it is better to make the name match the variable name.\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:21:37Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType"
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Also mention that `t.getFieldCount` is 2 (including `str` and `num`) for this case?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:22:23Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;"
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "So, when we reach here, we have `t.getFieldCount==1`? Is it possible that `t.getFieldCount == 0`?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:28:21Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>\n+          // For legacy 2-level list types generated by parquet-avro (Parquet version < 1.6.0),\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group array {                  <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parent.getName + \"_tuple\" =>\n+          // For Parquet data generated by parquet-thrift, e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group my_list_tuple {          <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _)\n+            if parent.getOriginalType == LIST &&\n+              t.getFieldCount == 1 &&\n+              t.getName == \"list\" &&\n+              t.getFieldName(0) == \"element\" =>\n+          // For standard 3-level list types, e.g.:\n+          //\n+          //    // List<String> (list nullable, elements non-null)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary element (UTF8);\n+          //      }\n+          //    }\n+          //\n+          // This case branch must appear before the next one. See comments of the next case branch\n+          // for details.\n+          false\n+\n+        case (t: GroupType, StructType(fields)) =>"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Should we have a case to explicitly handle `t.getFieldCount == 0` (to make the code easier to follow)?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:28:55Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>\n+          // For legacy 2-level list types generated by parquet-avro (Parquet version < 1.6.0),\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group array {                  <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parent.getName + \"_tuple\" =>\n+          // For Parquet data generated by parquet-thrift, e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group my_list_tuple {          <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _)\n+            if parent.getOriginalType == LIST &&\n+              t.getFieldCount == 1 &&\n+              t.getName == \"list\" &&\n+              t.getFieldName(0) == \"element\" =>\n+          // For standard 3-level list types, e.g.:\n+          //\n+          //    // List<String> (list nullable, elements non-null)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary element (UTF8);\n+          //      }\n+          //    }\n+          //\n+          // This case branch must appear before the next one. See comments of the next case branch\n+          // for details.\n+          false\n+\n+        case (t: GroupType, StructType(fields)) =>"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Probably it is good to explain why we are explicitly matching `GroupType` with `StructType` (because we are trying to determine if `GroupType` represents a Struct or just a middle layer?).\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:31:57Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>\n+          // For legacy 2-level list types generated by parquet-avro (Parquet version < 1.6.0),\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group array {                  <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parent.getName + \"_tuple\" =>\n+          // For Parquet data generated by parquet-thrift, e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group my_list_tuple {          <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _)\n+            if parent.getOriginalType == LIST &&\n+              t.getFieldCount == 1 &&\n+              t.getName == \"list\" &&\n+              t.getFieldName(0) == \"element\" =>\n+          // For standard 3-level list types, e.g.:\n+          //\n+          //    // List<String> (list nullable, elements non-null)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary element (UTF8);\n+          //      }\n+          //    }\n+          //\n+          // This case branch must appear before the next one. See comments of the next case branch\n+          // for details.\n+          false\n+\n+        case (t: GroupType, StructType(fields)) =>"
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Also provide the Spark's corresponding StructType in this example?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-08T06:32:58Z",
    "diffHunk": "@@ -482,13 +482,105 @@ private[parquet] class ParquetRowConverter(\n      */\n     // scalastyle:on\n     private def isElementType(\n-        parquetRepeatedType: Type, catalystElementType: DataType, parentName: String): Boolean = {\n+        parquetRepeatedType: Type, catalystElementType: DataType, parent: GroupType): Boolean = {\n       (parquetRepeatedType, catalystElementType) match {\n-        case (t: PrimitiveType, _) => true\n-        case (t: GroupType, _) if t.getFieldCount > 1 => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" => true\n-        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parentName + \"_tuple\" => true\n-        case (t: GroupType, StructType(Array(f))) if f.name == t.getFieldName(0) => true\n+        case (t: PrimitiveType, _) =>\n+          // For legacy 2-level list types with primitive element type, e.g.:\n+          //\n+          //    // List<Integer> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated int32 element;                 <-- repeatedType\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount > 1 =>\n+          // For legacy 2-level list types whose element type is a group type with 2 or more fields,\n+          // e.g.:\n+          //\n+          //    // List<Tuple<String, Integer>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group element {                <-- repeatedType\n+          //        required binary str (UTF8);\n+          //        required int32 num;\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == \"array\" =>\n+          // For legacy 2-level list types generated by parquet-avro (Parquet version < 1.6.0),\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group array {                  <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _) if t.getFieldCount == 1 && t.getName == parent.getName + \"_tuple\" =>\n+          // For Parquet data generated by parquet-thrift, e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group my_list_tuple {          <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }\n+          true\n+\n+        case (t: GroupType, _)\n+            if parent.getOriginalType == LIST &&\n+              t.getFieldCount == 1 &&\n+              t.getName == \"list\" &&\n+              t.getFieldName(0) == \"element\" =>\n+          // For standard 3-level list types, e.g.:\n+          //\n+          //    // List<String> (list nullable, elements non-null)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary element (UTF8);\n+          //      }\n+          //    }\n+          //\n+          // This case branch must appear before the next one. See comments of the next case branch\n+          // for details.\n+          false\n+\n+        case (t: GroupType, StructType(fields)) =>\n+          // For legacy 2-level list types whose element type is a group type with a single field,\n+          // e.g.:\n+          //\n+          //    // List<OneTuple<String>> (nullable list, non-null elements)\n+          //    optional group my_list (LIST) {           <-- parent\n+          //      repeated group list {                   <-- repeatedType\n+          //        required binary str (UTF8);\n+          //      };\n+          //    }"
  }],
  "prId": 14014
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Can we add examples at here?\n",
    "commit": "516a99a32b415898423737946d5d01bc90f1241f",
    "createdAt": "2016-07-19T06:11:54Z",
    "diffHunk": "@@ -442,13 +445,23 @@ private[parquet] class ParquetRowConverter(\n     private val elementConverter: Converter = {\n       val repeatedType = parquetSchema.getType(0)\n       val elementType = catalystSchema.elementType\n-      val parentName = parquetSchema.getName\n \n-      if (isElementType(repeatedType, elementType, parentName)) {\n+      // At this stage, we're not sure whether the repeated field maps to the element type or is\n+      // just the syntactic repeated group of the 3-level standard LIST layout. Here we try to\n+      // convert the repeated field into a Catalyst type to see whether the converted type matches\n+      // the Catalyst array element type.\n+      val guessedElementType = schemaConverter.convertField(repeatedType)\n+\n+      if (DataType.equalsIgnoreCompatibleNullability(guessedElementType, elementType)) {\n+        // If the repeated field corresponds to the element type, creates a new converter using the\n+        // type of the repeated field.\n         newConverter(repeatedType, elementType, new ParentContainerUpdater {\n           override def set(value: Any): Unit = currentArray += value\n         })\n       } else {\n+        // If the repeated field corresponds to the syntactic group in the standard 3-level Parquet\n+        // LIST layout, creates a new converter using the only child field of the repeated field.\n+        assert(!repeatedType.isPrimitive && repeatedType.asGroupType().getFieldCount == 1)\n         new ElementConverter(repeatedType.asGroupType().getType(0), elementType)",
    "line": 84
  }],
  "prId": 14014
}]