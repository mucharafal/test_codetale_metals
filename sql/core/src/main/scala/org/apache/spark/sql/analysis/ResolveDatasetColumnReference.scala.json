[{
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "do we really need this column prefix? We use it only to avoid a scan, but we get it with a scan using `indexOf`, so I think we can get rid of it",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-23T14:16:35Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.{AnalysisException, Dataset}\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.{AttributeReference, Equality, EqualNullSafe, EqualTo}\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "when we resolve column reference, we have no idea what's the corresponding column even if we know the corresponding dataframe. That's why we need the col position info.",
    "commit": "e7bfcc8eb1cef025abd36913ec50b5221da4ad10",
    "createdAt": "2019-04-23T14:50:40Z",
    "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.analysis\n+\n+import scala.collection.mutable\n+import scala.util.Try\n+\n+import org.apache.spark.sql.{AnalysisException, Dataset}\n+import org.apache.spark.sql.catalyst.AliasIdentifier\n+import org.apache.spark.sql.catalyst.expressions.{AttributeReference, Equality, EqualNullSafe, EqualTo}\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, SubqueryAlias}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.MetadataBuilder\n+\n+/**\n+ * Resolves the Dataset column reference by traversing the query plan and finding the plan subtree\n+ * of the Dataset that the column reference belongs to.\n+ *\n+ * Dataset column reference is simply an [[AttributeReference]] that is returned by `Dataset#col`.\n+ * Most of time we don't need to do anything special, as [[AttributeReference]] can point to\n+ * the column precisely. However, in case of self-join, the analyzer generates\n+ * [[AttributeReference]] with new expr IDs for the right side plan of the join. If the Dataset\n+ * column reference points to a column in the right side plan of a self-join, we need to replace it\n+ * with the corresponding newly generated [[AttributeReference]].\n+ */\n+class ResolveDatasetColumnReference(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+  // Dataset column reference is an `AttributeReference` with 2 special metadata.\n+  private def isColumnReference(a: AttributeReference): Boolean = {\n+    a.metadata.contains(Dataset.ID_PREFIX) && a.metadata.contains(Dataset.COL_POS_PREFIX)\n+  }\n+\n+  private case class ColumnReference(datasetId: Long, colPos: Int)\n+\n+  private def toColumnReference(a: AttributeReference): ColumnReference = {\n+    ColumnReference(\n+      a.metadata.getLong(Dataset.ID_PREFIX),\n+      a.metadata.getLong(Dataset.COL_POS_PREFIX).toInt)"
  }],
  "prId": 24442
}]